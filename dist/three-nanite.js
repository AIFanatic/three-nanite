var __require = /* @__PURE__ */ ((x) => typeof require !== "undefined" ? require : typeof Proxy !== "undefined" ? new Proxy(x, {
  get: (a, b) => (typeof require !== "undefined" ? require : a)[b]
}) : x)(function(x) {
  if (typeof require !== "undefined")
    return require.apply(this, arguments);
  throw new Error('Dynamic require of "' + x + '" is not supported');
});

// node_modules/three/build/three.module.js
var REVISION = "143";
var MOUSE = { LEFT: 0, MIDDLE: 1, RIGHT: 2, ROTATE: 0, DOLLY: 1, PAN: 2 };
var TOUCH = { ROTATE: 0, PAN: 1, DOLLY_PAN: 2, DOLLY_ROTATE: 3 };
var CullFaceNone = 0;
var CullFaceBack = 1;
var CullFaceFront = 2;
var PCFShadowMap = 1;
var PCFSoftShadowMap = 2;
var VSMShadowMap = 3;
var FrontSide = 0;
var BackSide = 1;
var DoubleSide = 2;
var FlatShading = 1;
var NoBlending = 0;
var NormalBlending = 1;
var AdditiveBlending = 2;
var SubtractiveBlending = 3;
var MultiplyBlending = 4;
var CustomBlending = 5;
var AddEquation = 100;
var SubtractEquation = 101;
var ReverseSubtractEquation = 102;
var MinEquation = 103;
var MaxEquation = 104;
var ZeroFactor = 200;
var OneFactor = 201;
var SrcColorFactor = 202;
var OneMinusSrcColorFactor = 203;
var SrcAlphaFactor = 204;
var OneMinusSrcAlphaFactor = 205;
var DstAlphaFactor = 206;
var OneMinusDstAlphaFactor = 207;
var DstColorFactor = 208;
var OneMinusDstColorFactor = 209;
var SrcAlphaSaturateFactor = 210;
var NeverDepth = 0;
var AlwaysDepth = 1;
var LessDepth = 2;
var LessEqualDepth = 3;
var EqualDepth = 4;
var GreaterEqualDepth = 5;
var GreaterDepth = 6;
var NotEqualDepth = 7;
var MultiplyOperation = 0;
var MixOperation = 1;
var AddOperation = 2;
var NoToneMapping = 0;
var LinearToneMapping = 1;
var ReinhardToneMapping = 2;
var CineonToneMapping = 3;
var ACESFilmicToneMapping = 4;
var CustomToneMapping = 5;
var UVMapping = 300;
var CubeReflectionMapping = 301;
var CubeRefractionMapping = 302;
var EquirectangularReflectionMapping = 303;
var EquirectangularRefractionMapping = 304;
var CubeUVReflectionMapping = 306;
var RepeatWrapping = 1e3;
var ClampToEdgeWrapping = 1001;
var MirroredRepeatWrapping = 1002;
var NearestFilter = 1003;
var NearestMipmapNearestFilter = 1004;
var NearestMipmapLinearFilter = 1005;
var LinearFilter = 1006;
var LinearMipmapNearestFilter = 1007;
var LinearMipmapLinearFilter = 1008;
var UnsignedByteType = 1009;
var ByteType = 1010;
var ShortType = 1011;
var UnsignedShortType = 1012;
var IntType = 1013;
var UnsignedIntType = 1014;
var FloatType = 1015;
var HalfFloatType = 1016;
var UnsignedShort4444Type = 1017;
var UnsignedShort5551Type = 1018;
var UnsignedInt248Type = 1020;
var AlphaFormat = 1021;
var RGBFormat = 1022;
var RGBAFormat = 1023;
var LuminanceFormat = 1024;
var LuminanceAlphaFormat = 1025;
var DepthFormat = 1026;
var DepthStencilFormat = 1027;
var RedFormat = 1028;
var RedIntegerFormat = 1029;
var RGFormat = 1030;
var RGIntegerFormat = 1031;
var RGBAIntegerFormat = 1033;
var RGB_S3TC_DXT1_Format = 33776;
var RGBA_S3TC_DXT1_Format = 33777;
var RGBA_S3TC_DXT3_Format = 33778;
var RGBA_S3TC_DXT5_Format = 33779;
var RGB_PVRTC_4BPPV1_Format = 35840;
var RGB_PVRTC_2BPPV1_Format = 35841;
var RGBA_PVRTC_4BPPV1_Format = 35842;
var RGBA_PVRTC_2BPPV1_Format = 35843;
var RGB_ETC1_Format = 36196;
var RGB_ETC2_Format = 37492;
var RGBA_ETC2_EAC_Format = 37496;
var RGBA_ASTC_4x4_Format = 37808;
var RGBA_ASTC_5x4_Format = 37809;
var RGBA_ASTC_5x5_Format = 37810;
var RGBA_ASTC_6x5_Format = 37811;
var RGBA_ASTC_6x6_Format = 37812;
var RGBA_ASTC_8x5_Format = 37813;
var RGBA_ASTC_8x6_Format = 37814;
var RGBA_ASTC_8x8_Format = 37815;
var RGBA_ASTC_10x5_Format = 37816;
var RGBA_ASTC_10x6_Format = 37817;
var RGBA_ASTC_10x8_Format = 37818;
var RGBA_ASTC_10x10_Format = 37819;
var RGBA_ASTC_12x10_Format = 37820;
var RGBA_ASTC_12x12_Format = 37821;
var RGBA_BPTC_Format = 36492;
var InterpolateDiscrete = 2300;
var InterpolateLinear = 2301;
var InterpolateSmooth = 2302;
var ZeroCurvatureEnding = 2400;
var ZeroSlopeEnding = 2401;
var WrapAroundEnding = 2402;
var LinearEncoding = 3e3;
var sRGBEncoding = 3001;
var BasicDepthPacking = 3200;
var RGBADepthPacking = 3201;
var TangentSpaceNormalMap = 0;
var ObjectSpaceNormalMap = 1;
var SRGBColorSpace = "srgb";
var LinearSRGBColorSpace = "srgb-linear";
var KeepStencilOp = 7680;
var AlwaysStencilFunc = 519;
var StaticDrawUsage = 35044;
var GLSL3 = "300 es";
var _SRGBAFormat = 1035;
var EventDispatcher = class {
  addEventListener(type, listener) {
    if (this._listeners === void 0)
      this._listeners = {};
    const listeners = this._listeners;
    if (listeners[type] === void 0) {
      listeners[type] = [];
    }
    if (listeners[type].indexOf(listener) === -1) {
      listeners[type].push(listener);
    }
  }
  hasEventListener(type, listener) {
    if (this._listeners === void 0)
      return false;
    const listeners = this._listeners;
    return listeners[type] !== void 0 && listeners[type].indexOf(listener) !== -1;
  }
  removeEventListener(type, listener) {
    if (this._listeners === void 0)
      return;
    const listeners = this._listeners;
    const listenerArray = listeners[type];
    if (listenerArray !== void 0) {
      const index = listenerArray.indexOf(listener);
      if (index !== -1) {
        listenerArray.splice(index, 1);
      }
    }
  }
  dispatchEvent(event) {
    if (this._listeners === void 0)
      return;
    const listeners = this._listeners;
    const listenerArray = listeners[event.type];
    if (listenerArray !== void 0) {
      event.target = this;
      const array = listenerArray.slice(0);
      for (let i2 = 0, l = array.length; i2 < l; i2++) {
        array[i2].call(this, event);
      }
      event.target = null;
    }
  }
};
var _lut = ["00", "01", "02", "03", "04", "05", "06", "07", "08", "09", "0a", "0b", "0c", "0d", "0e", "0f", "10", "11", "12", "13", "14", "15", "16", "17", "18", "19", "1a", "1b", "1c", "1d", "1e", "1f", "20", "21", "22", "23", "24", "25", "26", "27", "28", "29", "2a", "2b", "2c", "2d", "2e", "2f", "30", "31", "32", "33", "34", "35", "36", "37", "38", "39", "3a", "3b", "3c", "3d", "3e", "3f", "40", "41", "42", "43", "44", "45", "46", "47", "48", "49", "4a", "4b", "4c", "4d", "4e", "4f", "50", "51", "52", "53", "54", "55", "56", "57", "58", "59", "5a", "5b", "5c", "5d", "5e", "5f", "60", "61", "62", "63", "64", "65", "66", "67", "68", "69", "6a", "6b", "6c", "6d", "6e", "6f", "70", "71", "72", "73", "74", "75", "76", "77", "78", "79", "7a", "7b", "7c", "7d", "7e", "7f", "80", "81", "82", "83", "84", "85", "86", "87", "88", "89", "8a", "8b", "8c", "8d", "8e", "8f", "90", "91", "92", "93", "94", "95", "96", "97", "98", "99", "9a", "9b", "9c", "9d", "9e", "9f", "a0", "a1", "a2", "a3", "a4", "a5", "a6", "a7", "a8", "a9", "aa", "ab", "ac", "ad", "ae", "af", "b0", "b1", "b2", "b3", "b4", "b5", "b6", "b7", "b8", "b9", "ba", "bb", "bc", "bd", "be", "bf", "c0", "c1", "c2", "c3", "c4", "c5", "c6", "c7", "c8", "c9", "ca", "cb", "cc", "cd", "ce", "cf", "d0", "d1", "d2", "d3", "d4", "d5", "d6", "d7", "d8", "d9", "da", "db", "dc", "dd", "de", "df", "e0", "e1", "e2", "e3", "e4", "e5", "e6", "e7", "e8", "e9", "ea", "eb", "ec", "ed", "ee", "ef", "f0", "f1", "f2", "f3", "f4", "f5", "f6", "f7", "f8", "f9", "fa", "fb", "fc", "fd", "fe", "ff"];
var DEG2RAD = Math.PI / 180;
var RAD2DEG = 180 / Math.PI;
function generateUUID() {
  const d0 = Math.random() * 4294967295 | 0;
  const d1 = Math.random() * 4294967295 | 0;
  const d2 = Math.random() * 4294967295 | 0;
  const d3 = Math.random() * 4294967295 | 0;
  const uuid = _lut[d0 & 255] + _lut[d0 >> 8 & 255] + _lut[d0 >> 16 & 255] + _lut[d0 >> 24 & 255] + "-" + _lut[d1 & 255] + _lut[d1 >> 8 & 255] + "-" + _lut[d1 >> 16 & 15 | 64] + _lut[d1 >> 24 & 255] + "-" + _lut[d2 & 63 | 128] + _lut[d2 >> 8 & 255] + "-" + _lut[d2 >> 16 & 255] + _lut[d2 >> 24 & 255] + _lut[d3 & 255] + _lut[d3 >> 8 & 255] + _lut[d3 >> 16 & 255] + _lut[d3 >> 24 & 255];
  return uuid.toLowerCase();
}
function clamp(value, min, max) {
  return Math.max(min, Math.min(max, value));
}
function euclideanModulo(n, m) {
  return (n % m + m) % m;
}
function lerp(x, y, t) {
  return (1 - t) * x + t * y;
}
function isPowerOfTwo(value) {
  return (value & value - 1) === 0 && value !== 0;
}
function floorPowerOfTwo(value) {
  return Math.pow(2, Math.floor(Math.log(value) / Math.LN2));
}
var Vector2 = class {
  constructor(x = 0, y = 0) {
    Vector2.prototype.isVector2 = true;
    this.x = x;
    this.y = y;
  }
  get width() {
    return this.x;
  }
  set width(value) {
    this.x = value;
  }
  get height() {
    return this.y;
  }
  set height(value) {
    this.y = value;
  }
  set(x, y) {
    this.x = x;
    this.y = y;
    return this;
  }
  setScalar(scalar) {
    this.x = scalar;
    this.y = scalar;
    return this;
  }
  setX(x) {
    this.x = x;
    return this;
  }
  setY(y) {
    this.y = y;
    return this;
  }
  setComponent(index, value) {
    switch (index) {
      case 0:
        this.x = value;
        break;
      case 1:
        this.y = value;
        break;
      default:
        throw new Error("index is out of range: " + index);
    }
    return this;
  }
  getComponent(index) {
    switch (index) {
      case 0:
        return this.x;
      case 1:
        return this.y;
      default:
        throw new Error("index is out of range: " + index);
    }
  }
  clone() {
    return new this.constructor(this.x, this.y);
  }
  copy(v) {
    this.x = v.x;
    this.y = v.y;
    return this;
  }
  add(v) {
    this.x += v.x;
    this.y += v.y;
    return this;
  }
  addScalar(s) {
    this.x += s;
    this.y += s;
    return this;
  }
  addVectors(a, b) {
    this.x = a.x + b.x;
    this.y = a.y + b.y;
    return this;
  }
  addScaledVector(v, s) {
    this.x += v.x * s;
    this.y += v.y * s;
    return this;
  }
  sub(v) {
    this.x -= v.x;
    this.y -= v.y;
    return this;
  }
  subScalar(s) {
    this.x -= s;
    this.y -= s;
    return this;
  }
  subVectors(a, b) {
    this.x = a.x - b.x;
    this.y = a.y - b.y;
    return this;
  }
  multiply(v) {
    this.x *= v.x;
    this.y *= v.y;
    return this;
  }
  multiplyScalar(scalar) {
    this.x *= scalar;
    this.y *= scalar;
    return this;
  }
  divide(v) {
    this.x /= v.x;
    this.y /= v.y;
    return this;
  }
  divideScalar(scalar) {
    return this.multiplyScalar(1 / scalar);
  }
  applyMatrix3(m) {
    const x = this.x, y = this.y;
    const e = m.elements;
    this.x = e[0] * x + e[3] * y + e[6];
    this.y = e[1] * x + e[4] * y + e[7];
    return this;
  }
  min(v) {
    this.x = Math.min(this.x, v.x);
    this.y = Math.min(this.y, v.y);
    return this;
  }
  max(v) {
    this.x = Math.max(this.x, v.x);
    this.y = Math.max(this.y, v.y);
    return this;
  }
  clamp(min, max) {
    this.x = Math.max(min.x, Math.min(max.x, this.x));
    this.y = Math.max(min.y, Math.min(max.y, this.y));
    return this;
  }
  clampScalar(minVal, maxVal) {
    this.x = Math.max(minVal, Math.min(maxVal, this.x));
    this.y = Math.max(minVal, Math.min(maxVal, this.y));
    return this;
  }
  clampLength(min, max) {
    const length = this.length();
    return this.divideScalar(length || 1).multiplyScalar(Math.max(min, Math.min(max, length)));
  }
  floor() {
    this.x = Math.floor(this.x);
    this.y = Math.floor(this.y);
    return this;
  }
  ceil() {
    this.x = Math.ceil(this.x);
    this.y = Math.ceil(this.y);
    return this;
  }
  round() {
    this.x = Math.round(this.x);
    this.y = Math.round(this.y);
    return this;
  }
  roundToZero() {
    this.x = this.x < 0 ? Math.ceil(this.x) : Math.floor(this.x);
    this.y = this.y < 0 ? Math.ceil(this.y) : Math.floor(this.y);
    return this;
  }
  negate() {
    this.x = -this.x;
    this.y = -this.y;
    return this;
  }
  dot(v) {
    return this.x * v.x + this.y * v.y;
  }
  cross(v) {
    return this.x * v.y - this.y * v.x;
  }
  lengthSq() {
    return this.x * this.x + this.y * this.y;
  }
  length() {
    return Math.sqrt(this.x * this.x + this.y * this.y);
  }
  manhattanLength() {
    return Math.abs(this.x) + Math.abs(this.y);
  }
  normalize() {
    return this.divideScalar(this.length() || 1);
  }
  angle() {
    const angle = Math.atan2(-this.y, -this.x) + Math.PI;
    return angle;
  }
  distanceTo(v) {
    return Math.sqrt(this.distanceToSquared(v));
  }
  distanceToSquared(v) {
    const dx = this.x - v.x, dy = this.y - v.y;
    return dx * dx + dy * dy;
  }
  manhattanDistanceTo(v) {
    return Math.abs(this.x - v.x) + Math.abs(this.y - v.y);
  }
  setLength(length) {
    return this.normalize().multiplyScalar(length);
  }
  lerp(v, alpha) {
    this.x += (v.x - this.x) * alpha;
    this.y += (v.y - this.y) * alpha;
    return this;
  }
  lerpVectors(v1, v2, alpha) {
    this.x = v1.x + (v2.x - v1.x) * alpha;
    this.y = v1.y + (v2.y - v1.y) * alpha;
    return this;
  }
  equals(v) {
    return v.x === this.x && v.y === this.y;
  }
  fromArray(array, offset = 0) {
    this.x = array[offset];
    this.y = array[offset + 1];
    return this;
  }
  toArray(array = [], offset = 0) {
    array[offset] = this.x;
    array[offset + 1] = this.y;
    return array;
  }
  fromBufferAttribute(attribute, index) {
    this.x = attribute.getX(index);
    this.y = attribute.getY(index);
    return this;
  }
  rotateAround(center, angle) {
    const c = Math.cos(angle), s = Math.sin(angle);
    const x = this.x - center.x;
    const y = this.y - center.y;
    this.x = x * c - y * s + center.x;
    this.y = x * s + y * c + center.y;
    return this;
  }
  random() {
    this.x = Math.random();
    this.y = Math.random();
    return this;
  }
  *[Symbol.iterator]() {
    yield this.x;
    yield this.y;
  }
};
var Matrix3 = class {
  constructor() {
    Matrix3.prototype.isMatrix3 = true;
    this.elements = [
      1,
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      1
    ];
  }
  set(n11, n12, n13, n21, n22, n23, n31, n32, n33) {
    const te = this.elements;
    te[0] = n11;
    te[1] = n21;
    te[2] = n31;
    te[3] = n12;
    te[4] = n22;
    te[5] = n32;
    te[6] = n13;
    te[7] = n23;
    te[8] = n33;
    return this;
  }
  identity() {
    this.set(
      1,
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      1
    );
    return this;
  }
  copy(m) {
    const te = this.elements;
    const me = m.elements;
    te[0] = me[0];
    te[1] = me[1];
    te[2] = me[2];
    te[3] = me[3];
    te[4] = me[4];
    te[5] = me[5];
    te[6] = me[6];
    te[7] = me[7];
    te[8] = me[8];
    return this;
  }
  extractBasis(xAxis, yAxis, zAxis) {
    xAxis.setFromMatrix3Column(this, 0);
    yAxis.setFromMatrix3Column(this, 1);
    zAxis.setFromMatrix3Column(this, 2);
    return this;
  }
  setFromMatrix4(m) {
    const me = m.elements;
    this.set(
      me[0],
      me[4],
      me[8],
      me[1],
      me[5],
      me[9],
      me[2],
      me[6],
      me[10]
    );
    return this;
  }
  multiply(m) {
    return this.multiplyMatrices(this, m);
  }
  premultiply(m) {
    return this.multiplyMatrices(m, this);
  }
  multiplyMatrices(a, b) {
    const ae = a.elements;
    const be = b.elements;
    const te = this.elements;
    const a11 = ae[0], a12 = ae[3], a13 = ae[6];
    const a21 = ae[1], a22 = ae[4], a23 = ae[7];
    const a31 = ae[2], a32 = ae[5], a33 = ae[8];
    const b11 = be[0], b12 = be[3], b13 = be[6];
    const b21 = be[1], b22 = be[4], b23 = be[7];
    const b31 = be[2], b32 = be[5], b33 = be[8];
    te[0] = a11 * b11 + a12 * b21 + a13 * b31;
    te[3] = a11 * b12 + a12 * b22 + a13 * b32;
    te[6] = a11 * b13 + a12 * b23 + a13 * b33;
    te[1] = a21 * b11 + a22 * b21 + a23 * b31;
    te[4] = a21 * b12 + a22 * b22 + a23 * b32;
    te[7] = a21 * b13 + a22 * b23 + a23 * b33;
    te[2] = a31 * b11 + a32 * b21 + a33 * b31;
    te[5] = a31 * b12 + a32 * b22 + a33 * b32;
    te[8] = a31 * b13 + a32 * b23 + a33 * b33;
    return this;
  }
  multiplyScalar(s) {
    const te = this.elements;
    te[0] *= s;
    te[3] *= s;
    te[6] *= s;
    te[1] *= s;
    te[4] *= s;
    te[7] *= s;
    te[2] *= s;
    te[5] *= s;
    te[8] *= s;
    return this;
  }
  determinant() {
    const te = this.elements;
    const a = te[0], b = te[1], c = te[2], d = te[3], e = te[4], f = te[5], g2 = te[6], h = te[7], i2 = te[8];
    return a * e * i2 - a * f * h - b * d * i2 + b * f * g2 + c * d * h - c * e * g2;
  }
  invert() {
    const te = this.elements, n11 = te[0], n21 = te[1], n31 = te[2], n12 = te[3], n22 = te[4], n32 = te[5], n13 = te[6], n23 = te[7], n33 = te[8], t11 = n33 * n22 - n32 * n23, t12 = n32 * n13 - n33 * n12, t13 = n23 * n12 - n22 * n13, det = n11 * t11 + n21 * t12 + n31 * t13;
    if (det === 0)
      return this.set(0, 0, 0, 0, 0, 0, 0, 0, 0);
    const detInv = 1 / det;
    te[0] = t11 * detInv;
    te[1] = (n31 * n23 - n33 * n21) * detInv;
    te[2] = (n32 * n21 - n31 * n22) * detInv;
    te[3] = t12 * detInv;
    te[4] = (n33 * n11 - n31 * n13) * detInv;
    te[5] = (n31 * n12 - n32 * n11) * detInv;
    te[6] = t13 * detInv;
    te[7] = (n21 * n13 - n23 * n11) * detInv;
    te[8] = (n22 * n11 - n21 * n12) * detInv;
    return this;
  }
  transpose() {
    let tmp;
    const m = this.elements;
    tmp = m[1];
    m[1] = m[3];
    m[3] = tmp;
    tmp = m[2];
    m[2] = m[6];
    m[6] = tmp;
    tmp = m[5];
    m[5] = m[7];
    m[7] = tmp;
    return this;
  }
  getNormalMatrix(matrix4) {
    return this.setFromMatrix4(matrix4).invert().transpose();
  }
  transposeIntoArray(r) {
    const m = this.elements;
    r[0] = m[0];
    r[1] = m[3];
    r[2] = m[6];
    r[3] = m[1];
    r[4] = m[4];
    r[5] = m[7];
    r[6] = m[2];
    r[7] = m[5];
    r[8] = m[8];
    return this;
  }
  setUvTransform(tx, ty, sx, sy, rotation, cx, cy) {
    const c = Math.cos(rotation);
    const s = Math.sin(rotation);
    this.set(
      sx * c,
      sx * s,
      -sx * (c * cx + s * cy) + cx + tx,
      -sy * s,
      sy * c,
      -sy * (-s * cx + c * cy) + cy + ty,
      0,
      0,
      1
    );
    return this;
  }
  scale(sx, sy) {
    const te = this.elements;
    te[0] *= sx;
    te[3] *= sx;
    te[6] *= sx;
    te[1] *= sy;
    te[4] *= sy;
    te[7] *= sy;
    return this;
  }
  rotate(theta) {
    const c = Math.cos(theta);
    const s = Math.sin(theta);
    const te = this.elements;
    const a11 = te[0], a12 = te[3], a13 = te[6];
    const a21 = te[1], a22 = te[4], a23 = te[7];
    te[0] = c * a11 + s * a21;
    te[3] = c * a12 + s * a22;
    te[6] = c * a13 + s * a23;
    te[1] = -s * a11 + c * a21;
    te[4] = -s * a12 + c * a22;
    te[7] = -s * a13 + c * a23;
    return this;
  }
  translate(tx, ty) {
    const te = this.elements;
    te[0] += tx * te[2];
    te[3] += tx * te[5];
    te[6] += tx * te[8];
    te[1] += ty * te[2];
    te[4] += ty * te[5];
    te[7] += ty * te[8];
    return this;
  }
  equals(matrix) {
    const te = this.elements;
    const me = matrix.elements;
    for (let i2 = 0; i2 < 9; i2++) {
      if (te[i2] !== me[i2])
        return false;
    }
    return true;
  }
  fromArray(array, offset = 0) {
    for (let i2 = 0; i2 < 9; i2++) {
      this.elements[i2] = array[i2 + offset];
    }
    return this;
  }
  toArray(array = [], offset = 0) {
    const te = this.elements;
    array[offset] = te[0];
    array[offset + 1] = te[1];
    array[offset + 2] = te[2];
    array[offset + 3] = te[3];
    array[offset + 4] = te[4];
    array[offset + 5] = te[5];
    array[offset + 6] = te[6];
    array[offset + 7] = te[7];
    array[offset + 8] = te[8];
    return array;
  }
  clone() {
    return new this.constructor().fromArray(this.elements);
  }
};
function arrayNeedsUint32(array) {
  for (let i2 = array.length - 1; i2 >= 0; --i2) {
    if (array[i2] > 65535)
      return true;
  }
  return false;
}
function createElementNS(name) {
  return document.createElementNS("http://www.w3.org/1999/xhtml", name);
}
function SRGBToLinear(c) {
  return c < 0.04045 ? c * 0.0773993808 : Math.pow(c * 0.9478672986 + 0.0521327014, 2.4);
}
function LinearToSRGB(c) {
  return c < 31308e-7 ? c * 12.92 : 1.055 * Math.pow(c, 0.41666) - 0.055;
}
var FN = {
  [SRGBColorSpace]: { [LinearSRGBColorSpace]: SRGBToLinear },
  [LinearSRGBColorSpace]: { [SRGBColorSpace]: LinearToSRGB }
};
var ColorManagement = {
  legacyMode: true,
  get workingColorSpace() {
    return LinearSRGBColorSpace;
  },
  set workingColorSpace(colorSpace) {
    console.warn("THREE.ColorManagement: .workingColorSpace is readonly.");
  },
  convert: function(color, sourceColorSpace, targetColorSpace) {
    if (this.legacyMode || sourceColorSpace === targetColorSpace || !sourceColorSpace || !targetColorSpace) {
      return color;
    }
    if (FN[sourceColorSpace] && FN[sourceColorSpace][targetColorSpace] !== void 0) {
      const fn = FN[sourceColorSpace][targetColorSpace];
      color.r = fn(color.r);
      color.g = fn(color.g);
      color.b = fn(color.b);
      return color;
    }
    throw new Error("Unsupported color space conversion.");
  },
  fromWorkingColorSpace: function(color, targetColorSpace) {
    return this.convert(color, this.workingColorSpace, targetColorSpace);
  },
  toWorkingColorSpace: function(color, sourceColorSpace) {
    return this.convert(color, sourceColorSpace, this.workingColorSpace);
  }
};
var _colorKeywords = {
  "aliceblue": 15792383,
  "antiquewhite": 16444375,
  "aqua": 65535,
  "aquamarine": 8388564,
  "azure": 15794175,
  "beige": 16119260,
  "bisque": 16770244,
  "black": 0,
  "blanchedalmond": 16772045,
  "blue": 255,
  "blueviolet": 9055202,
  "brown": 10824234,
  "burlywood": 14596231,
  "cadetblue": 6266528,
  "chartreuse": 8388352,
  "chocolate": 13789470,
  "coral": 16744272,
  "cornflowerblue": 6591981,
  "cornsilk": 16775388,
  "crimson": 14423100,
  "cyan": 65535,
  "darkblue": 139,
  "darkcyan": 35723,
  "darkgoldenrod": 12092939,
  "darkgray": 11119017,
  "darkgreen": 25600,
  "darkgrey": 11119017,
  "darkkhaki": 12433259,
  "darkmagenta": 9109643,
  "darkolivegreen": 5597999,
  "darkorange": 16747520,
  "darkorchid": 10040012,
  "darkred": 9109504,
  "darksalmon": 15308410,
  "darkseagreen": 9419919,
  "darkslateblue": 4734347,
  "darkslategray": 3100495,
  "darkslategrey": 3100495,
  "darkturquoise": 52945,
  "darkviolet": 9699539,
  "deeppink": 16716947,
  "deepskyblue": 49151,
  "dimgray": 6908265,
  "dimgrey": 6908265,
  "dodgerblue": 2003199,
  "firebrick": 11674146,
  "floralwhite": 16775920,
  "forestgreen": 2263842,
  "fuchsia": 16711935,
  "gainsboro": 14474460,
  "ghostwhite": 16316671,
  "gold": 16766720,
  "goldenrod": 14329120,
  "gray": 8421504,
  "green": 32768,
  "greenyellow": 11403055,
  "grey": 8421504,
  "honeydew": 15794160,
  "hotpink": 16738740,
  "indianred": 13458524,
  "indigo": 4915330,
  "ivory": 16777200,
  "khaki": 15787660,
  "lavender": 15132410,
  "lavenderblush": 16773365,
  "lawngreen": 8190976,
  "lemonchiffon": 16775885,
  "lightblue": 11393254,
  "lightcoral": 15761536,
  "lightcyan": 14745599,
  "lightgoldenrodyellow": 16448210,
  "lightgray": 13882323,
  "lightgreen": 9498256,
  "lightgrey": 13882323,
  "lightpink": 16758465,
  "lightsalmon": 16752762,
  "lightseagreen": 2142890,
  "lightskyblue": 8900346,
  "lightslategray": 7833753,
  "lightslategrey": 7833753,
  "lightsteelblue": 11584734,
  "lightyellow": 16777184,
  "lime": 65280,
  "limegreen": 3329330,
  "linen": 16445670,
  "magenta": 16711935,
  "maroon": 8388608,
  "mediumaquamarine": 6737322,
  "mediumblue": 205,
  "mediumorchid": 12211667,
  "mediumpurple": 9662683,
  "mediumseagreen": 3978097,
  "mediumslateblue": 8087790,
  "mediumspringgreen": 64154,
  "mediumturquoise": 4772300,
  "mediumvioletred": 13047173,
  "midnightblue": 1644912,
  "mintcream": 16121850,
  "mistyrose": 16770273,
  "moccasin": 16770229,
  "navajowhite": 16768685,
  "navy": 128,
  "oldlace": 16643558,
  "olive": 8421376,
  "olivedrab": 7048739,
  "orange": 16753920,
  "orangered": 16729344,
  "orchid": 14315734,
  "palegoldenrod": 15657130,
  "palegreen": 10025880,
  "paleturquoise": 11529966,
  "palevioletred": 14381203,
  "papayawhip": 16773077,
  "peachpuff": 16767673,
  "peru": 13468991,
  "pink": 16761035,
  "plum": 14524637,
  "powderblue": 11591910,
  "purple": 8388736,
  "rebeccapurple": 6697881,
  "red": 16711680,
  "rosybrown": 12357519,
  "royalblue": 4286945,
  "saddlebrown": 9127187,
  "salmon": 16416882,
  "sandybrown": 16032864,
  "seagreen": 3050327,
  "seashell": 16774638,
  "sienna": 10506797,
  "silver": 12632256,
  "skyblue": 8900331,
  "slateblue": 6970061,
  "slategray": 7372944,
  "slategrey": 7372944,
  "snow": 16775930,
  "springgreen": 65407,
  "steelblue": 4620980,
  "tan": 13808780,
  "teal": 32896,
  "thistle": 14204888,
  "tomato": 16737095,
  "turquoise": 4251856,
  "violet": 15631086,
  "wheat": 16113331,
  "white": 16777215,
  "whitesmoke": 16119285,
  "yellow": 16776960,
  "yellowgreen": 10145074
};
var _rgb = { r: 0, g: 0, b: 0 };
var _hslA = { h: 0, s: 0, l: 0 };
var _hslB = { h: 0, s: 0, l: 0 };
function hue2rgb(p, q, t) {
  if (t < 0)
    t += 1;
  if (t > 1)
    t -= 1;
  if (t < 1 / 6)
    return p + (q - p) * 6 * t;
  if (t < 1 / 2)
    return q;
  if (t < 2 / 3)
    return p + (q - p) * 6 * (2 / 3 - t);
  return p;
}
function toComponents(source, target) {
  target.r = source.r;
  target.g = source.g;
  target.b = source.b;
  return target;
}
var Color = class {
  constructor(r, g2, b) {
    this.isColor = true;
    this.r = 1;
    this.g = 1;
    this.b = 1;
    if (g2 === void 0 && b === void 0) {
      return this.set(r);
    }
    return this.setRGB(r, g2, b);
  }
  set(value) {
    if (value && value.isColor) {
      this.copy(value);
    } else if (typeof value === "number") {
      this.setHex(value);
    } else if (typeof value === "string") {
      this.setStyle(value);
    }
    return this;
  }
  setScalar(scalar) {
    this.r = scalar;
    this.g = scalar;
    this.b = scalar;
    return this;
  }
  setHex(hex, colorSpace = SRGBColorSpace) {
    hex = Math.floor(hex);
    this.r = (hex >> 16 & 255) / 255;
    this.g = (hex >> 8 & 255) / 255;
    this.b = (hex & 255) / 255;
    ColorManagement.toWorkingColorSpace(this, colorSpace);
    return this;
  }
  setRGB(r, g2, b, colorSpace = LinearSRGBColorSpace) {
    this.r = r;
    this.g = g2;
    this.b = b;
    ColorManagement.toWorkingColorSpace(this, colorSpace);
    return this;
  }
  setHSL(h, s, l, colorSpace = LinearSRGBColorSpace) {
    h = euclideanModulo(h, 1);
    s = clamp(s, 0, 1);
    l = clamp(l, 0, 1);
    if (s === 0) {
      this.r = this.g = this.b = l;
    } else {
      const p = l <= 0.5 ? l * (1 + s) : l + s - l * s;
      const q = 2 * l - p;
      this.r = hue2rgb(q, p, h + 1 / 3);
      this.g = hue2rgb(q, p, h);
      this.b = hue2rgb(q, p, h - 1 / 3);
    }
    ColorManagement.toWorkingColorSpace(this, colorSpace);
    return this;
  }
  setStyle(style, colorSpace = SRGBColorSpace) {
    function handleAlpha(string) {
      if (string === void 0)
        return;
      if (parseFloat(string) < 1) {
        console.warn("THREE.Color: Alpha component of " + style + " will be ignored.");
      }
    }
    let m;
    if (m = /^((?:rgb|hsl)a?)\(([^\)]*)\)/.exec(style)) {
      let color;
      const name = m[1];
      const components = m[2];
      switch (name) {
        case "rgb":
        case "rgba":
          if (color = /^\s*(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(components)) {
            this.r = Math.min(255, parseInt(color[1], 10)) / 255;
            this.g = Math.min(255, parseInt(color[2], 10)) / 255;
            this.b = Math.min(255, parseInt(color[3], 10)) / 255;
            ColorManagement.toWorkingColorSpace(this, colorSpace);
            handleAlpha(color[4]);
            return this;
          }
          if (color = /^\s*(\d+)\%\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(components)) {
            this.r = Math.min(100, parseInt(color[1], 10)) / 100;
            this.g = Math.min(100, parseInt(color[2], 10)) / 100;
            this.b = Math.min(100, parseInt(color[3], 10)) / 100;
            ColorManagement.toWorkingColorSpace(this, colorSpace);
            handleAlpha(color[4]);
            return this;
          }
          break;
        case "hsl":
        case "hsla":
          if (color = /^\s*(\d*\.?\d+)\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(components)) {
            const h = parseFloat(color[1]) / 360;
            const s = parseInt(color[2], 10) / 100;
            const l = parseInt(color[3], 10) / 100;
            handleAlpha(color[4]);
            return this.setHSL(h, s, l, colorSpace);
          }
          break;
      }
    } else if (m = /^\#([A-Fa-f\d]+)$/.exec(style)) {
      const hex = m[1];
      const size = hex.length;
      if (size === 3) {
        this.r = parseInt(hex.charAt(0) + hex.charAt(0), 16) / 255;
        this.g = parseInt(hex.charAt(1) + hex.charAt(1), 16) / 255;
        this.b = parseInt(hex.charAt(2) + hex.charAt(2), 16) / 255;
        ColorManagement.toWorkingColorSpace(this, colorSpace);
        return this;
      } else if (size === 6) {
        this.r = parseInt(hex.charAt(0) + hex.charAt(1), 16) / 255;
        this.g = parseInt(hex.charAt(2) + hex.charAt(3), 16) / 255;
        this.b = parseInt(hex.charAt(4) + hex.charAt(5), 16) / 255;
        ColorManagement.toWorkingColorSpace(this, colorSpace);
        return this;
      }
    }
    if (style && style.length > 0) {
      return this.setColorName(style, colorSpace);
    }
    return this;
  }
  setColorName(style, colorSpace = SRGBColorSpace) {
    const hex = _colorKeywords[style.toLowerCase()];
    if (hex !== void 0) {
      this.setHex(hex, colorSpace);
    } else {
      console.warn("THREE.Color: Unknown color " + style);
    }
    return this;
  }
  clone() {
    return new this.constructor(this.r, this.g, this.b);
  }
  copy(color) {
    this.r = color.r;
    this.g = color.g;
    this.b = color.b;
    return this;
  }
  copySRGBToLinear(color) {
    this.r = SRGBToLinear(color.r);
    this.g = SRGBToLinear(color.g);
    this.b = SRGBToLinear(color.b);
    return this;
  }
  copyLinearToSRGB(color) {
    this.r = LinearToSRGB(color.r);
    this.g = LinearToSRGB(color.g);
    this.b = LinearToSRGB(color.b);
    return this;
  }
  convertSRGBToLinear() {
    this.copySRGBToLinear(this);
    return this;
  }
  convertLinearToSRGB() {
    this.copyLinearToSRGB(this);
    return this;
  }
  getHex(colorSpace = SRGBColorSpace) {
    ColorManagement.fromWorkingColorSpace(toComponents(this, _rgb), colorSpace);
    return clamp(_rgb.r * 255, 0, 255) << 16 ^ clamp(_rgb.g * 255, 0, 255) << 8 ^ clamp(_rgb.b * 255, 0, 255) << 0;
  }
  getHexString(colorSpace = SRGBColorSpace) {
    return ("000000" + this.getHex(colorSpace).toString(16)).slice(-6);
  }
  getHSL(target, colorSpace = LinearSRGBColorSpace) {
    ColorManagement.fromWorkingColorSpace(toComponents(this, _rgb), colorSpace);
    const r = _rgb.r, g2 = _rgb.g, b = _rgb.b;
    const max = Math.max(r, g2, b);
    const min = Math.min(r, g2, b);
    let hue, saturation;
    const lightness = (min + max) / 2;
    if (min === max) {
      hue = 0;
      saturation = 0;
    } else {
      const delta = max - min;
      saturation = lightness <= 0.5 ? delta / (max + min) : delta / (2 - max - min);
      switch (max) {
        case r:
          hue = (g2 - b) / delta + (g2 < b ? 6 : 0);
          break;
        case g2:
          hue = (b - r) / delta + 2;
          break;
        case b:
          hue = (r - g2) / delta + 4;
          break;
      }
      hue /= 6;
    }
    target.h = hue;
    target.s = saturation;
    target.l = lightness;
    return target;
  }
  getRGB(target, colorSpace = LinearSRGBColorSpace) {
    ColorManagement.fromWorkingColorSpace(toComponents(this, _rgb), colorSpace);
    target.r = _rgb.r;
    target.g = _rgb.g;
    target.b = _rgb.b;
    return target;
  }
  getStyle(colorSpace = SRGBColorSpace) {
    ColorManagement.fromWorkingColorSpace(toComponents(this, _rgb), colorSpace);
    if (colorSpace !== SRGBColorSpace) {
      return `color(${colorSpace} ${_rgb.r} ${_rgb.g} ${_rgb.b})`;
    }
    return `rgb(${_rgb.r * 255 | 0},${_rgb.g * 255 | 0},${_rgb.b * 255 | 0})`;
  }
  offsetHSL(h, s, l) {
    this.getHSL(_hslA);
    _hslA.h += h;
    _hslA.s += s;
    _hslA.l += l;
    this.setHSL(_hslA.h, _hslA.s, _hslA.l);
    return this;
  }
  add(color) {
    this.r += color.r;
    this.g += color.g;
    this.b += color.b;
    return this;
  }
  addColors(color1, color2) {
    this.r = color1.r + color2.r;
    this.g = color1.g + color2.g;
    this.b = color1.b + color2.b;
    return this;
  }
  addScalar(s) {
    this.r += s;
    this.g += s;
    this.b += s;
    return this;
  }
  sub(color) {
    this.r = Math.max(0, this.r - color.r);
    this.g = Math.max(0, this.g - color.g);
    this.b = Math.max(0, this.b - color.b);
    return this;
  }
  multiply(color) {
    this.r *= color.r;
    this.g *= color.g;
    this.b *= color.b;
    return this;
  }
  multiplyScalar(s) {
    this.r *= s;
    this.g *= s;
    this.b *= s;
    return this;
  }
  lerp(color, alpha) {
    this.r += (color.r - this.r) * alpha;
    this.g += (color.g - this.g) * alpha;
    this.b += (color.b - this.b) * alpha;
    return this;
  }
  lerpColors(color1, color2, alpha) {
    this.r = color1.r + (color2.r - color1.r) * alpha;
    this.g = color1.g + (color2.g - color1.g) * alpha;
    this.b = color1.b + (color2.b - color1.b) * alpha;
    return this;
  }
  lerpHSL(color, alpha) {
    this.getHSL(_hslA);
    color.getHSL(_hslB);
    const h = lerp(_hslA.h, _hslB.h, alpha);
    const s = lerp(_hslA.s, _hslB.s, alpha);
    const l = lerp(_hslA.l, _hslB.l, alpha);
    this.setHSL(h, s, l);
    return this;
  }
  equals(c) {
    return c.r === this.r && c.g === this.g && c.b === this.b;
  }
  fromArray(array, offset = 0) {
    this.r = array[offset];
    this.g = array[offset + 1];
    this.b = array[offset + 2];
    return this;
  }
  toArray(array = [], offset = 0) {
    array[offset] = this.r;
    array[offset + 1] = this.g;
    array[offset + 2] = this.b;
    return array;
  }
  fromBufferAttribute(attribute, index) {
    this.r = attribute.getX(index);
    this.g = attribute.getY(index);
    this.b = attribute.getZ(index);
    if (attribute.normalized === true) {
      this.r /= 255;
      this.g /= 255;
      this.b /= 255;
    }
    return this;
  }
  toJSON() {
    return this.getHex();
  }
  *[Symbol.iterator]() {
    yield this.r;
    yield this.g;
    yield this.b;
  }
};
Color.NAMES = _colorKeywords;
var _canvas;
var ImageUtils = class {
  static getDataURL(image) {
    if (/^data:/i.test(image.src)) {
      return image.src;
    }
    if (typeof HTMLCanvasElement == "undefined") {
      return image.src;
    }
    let canvas;
    if (image instanceof HTMLCanvasElement) {
      canvas = image;
    } else {
      if (_canvas === void 0)
        _canvas = createElementNS("canvas");
      _canvas.width = image.width;
      _canvas.height = image.height;
      const context = _canvas.getContext("2d");
      if (image instanceof ImageData) {
        context.putImageData(image, 0, 0);
      } else {
        context.drawImage(image, 0, 0, image.width, image.height);
      }
      canvas = _canvas;
    }
    if (canvas.width > 2048 || canvas.height > 2048) {
      console.warn("THREE.ImageUtils.getDataURL: Image converted to jpg for performance reasons", image);
      return canvas.toDataURL("image/jpeg", 0.6);
    } else {
      return canvas.toDataURL("image/png");
    }
  }
  static sRGBToLinear(image) {
    if (typeof HTMLImageElement !== "undefined" && image instanceof HTMLImageElement || typeof HTMLCanvasElement !== "undefined" && image instanceof HTMLCanvasElement || typeof ImageBitmap !== "undefined" && image instanceof ImageBitmap) {
      const canvas = createElementNS("canvas");
      canvas.width = image.width;
      canvas.height = image.height;
      const context = canvas.getContext("2d");
      context.drawImage(image, 0, 0, image.width, image.height);
      const imageData = context.getImageData(0, 0, image.width, image.height);
      const data = imageData.data;
      for (let i2 = 0; i2 < data.length; i2++) {
        data[i2] = SRGBToLinear(data[i2] / 255) * 255;
      }
      context.putImageData(imageData, 0, 0);
      return canvas;
    } else if (image.data) {
      const data = image.data.slice(0);
      for (let i2 = 0; i2 < data.length; i2++) {
        if (data instanceof Uint8Array || data instanceof Uint8ClampedArray) {
          data[i2] = Math.floor(SRGBToLinear(data[i2] / 255) * 255);
        } else {
          data[i2] = SRGBToLinear(data[i2]);
        }
      }
      return {
        data,
        width: image.width,
        height: image.height
      };
    } else {
      console.warn("THREE.ImageUtils.sRGBToLinear(): Unsupported image type. No color space conversion applied.");
      return image;
    }
  }
};
var Source = class {
  constructor(data = null) {
    this.isSource = true;
    this.uuid = generateUUID();
    this.data = data;
    this.version = 0;
  }
  set needsUpdate(value) {
    if (value === true)
      this.version++;
  }
  toJSON(meta) {
    const isRootObject = meta === void 0 || typeof meta === "string";
    if (!isRootObject && meta.images[this.uuid] !== void 0) {
      return meta.images[this.uuid];
    }
    const output = {
      uuid: this.uuid,
      url: ""
    };
    const data = this.data;
    if (data !== null) {
      let url;
      if (Array.isArray(data)) {
        url = [];
        for (let i2 = 0, l = data.length; i2 < l; i2++) {
          if (data[i2].isDataTexture) {
            url.push(serializeImage(data[i2].image));
          } else {
            url.push(serializeImage(data[i2]));
          }
        }
      } else {
        url = serializeImage(data);
      }
      output.url = url;
    }
    if (!isRootObject) {
      meta.images[this.uuid] = output;
    }
    return output;
  }
};
function serializeImage(image) {
  if (typeof HTMLImageElement !== "undefined" && image instanceof HTMLImageElement || typeof HTMLCanvasElement !== "undefined" && image instanceof HTMLCanvasElement || typeof ImageBitmap !== "undefined" && image instanceof ImageBitmap) {
    return ImageUtils.getDataURL(image);
  } else {
    if (image.data) {
      return {
        data: Array.from(image.data),
        width: image.width,
        height: image.height,
        type: image.data.constructor.name
      };
    } else {
      console.warn("THREE.Texture: Unable to serialize Texture.");
      return {};
    }
  }
}
var textureId = 0;
var Texture = class extends EventDispatcher {
  constructor(image = Texture.DEFAULT_IMAGE, mapping = Texture.DEFAULT_MAPPING, wrapS = ClampToEdgeWrapping, wrapT = ClampToEdgeWrapping, magFilter = LinearFilter, minFilter = LinearMipmapLinearFilter, format = RGBAFormat, type = UnsignedByteType, anisotropy = 1, encoding = LinearEncoding) {
    super();
    this.isTexture = true;
    Object.defineProperty(this, "id", { value: textureId++ });
    this.uuid = generateUUID();
    this.name = "";
    this.source = new Source(image);
    this.mipmaps = [];
    this.mapping = mapping;
    this.wrapS = wrapS;
    this.wrapT = wrapT;
    this.magFilter = magFilter;
    this.minFilter = minFilter;
    this.anisotropy = anisotropy;
    this.format = format;
    this.internalFormat = null;
    this.type = type;
    this.offset = new Vector2(0, 0);
    this.repeat = new Vector2(1, 1);
    this.center = new Vector2(0, 0);
    this.rotation = 0;
    this.matrixAutoUpdate = true;
    this.matrix = new Matrix3();
    this.generateMipmaps = true;
    this.premultiplyAlpha = false;
    this.flipY = true;
    this.unpackAlignment = 4;
    this.encoding = encoding;
    this.userData = {};
    this.version = 0;
    this.onUpdate = null;
    this.isRenderTargetTexture = false;
    this.needsPMREMUpdate = false;
  }
  get image() {
    return this.source.data;
  }
  set image(value) {
    this.source.data = value;
  }
  updateMatrix() {
    this.matrix.setUvTransform(this.offset.x, this.offset.y, this.repeat.x, this.repeat.y, this.rotation, this.center.x, this.center.y);
  }
  clone() {
    return new this.constructor().copy(this);
  }
  copy(source) {
    this.name = source.name;
    this.source = source.source;
    this.mipmaps = source.mipmaps.slice(0);
    this.mapping = source.mapping;
    this.wrapS = source.wrapS;
    this.wrapT = source.wrapT;
    this.magFilter = source.magFilter;
    this.minFilter = source.minFilter;
    this.anisotropy = source.anisotropy;
    this.format = source.format;
    this.internalFormat = source.internalFormat;
    this.type = source.type;
    this.offset.copy(source.offset);
    this.repeat.copy(source.repeat);
    this.center.copy(source.center);
    this.rotation = source.rotation;
    this.matrixAutoUpdate = source.matrixAutoUpdate;
    this.matrix.copy(source.matrix);
    this.generateMipmaps = source.generateMipmaps;
    this.premultiplyAlpha = source.premultiplyAlpha;
    this.flipY = source.flipY;
    this.unpackAlignment = source.unpackAlignment;
    this.encoding = source.encoding;
    this.userData = JSON.parse(JSON.stringify(source.userData));
    this.needsUpdate = true;
    return this;
  }
  toJSON(meta) {
    const isRootObject = meta === void 0 || typeof meta === "string";
    if (!isRootObject && meta.textures[this.uuid] !== void 0) {
      return meta.textures[this.uuid];
    }
    const output = {
      metadata: {
        version: 4.5,
        type: "Texture",
        generator: "Texture.toJSON"
      },
      uuid: this.uuid,
      name: this.name,
      image: this.source.toJSON(meta).uuid,
      mapping: this.mapping,
      repeat: [this.repeat.x, this.repeat.y],
      offset: [this.offset.x, this.offset.y],
      center: [this.center.x, this.center.y],
      rotation: this.rotation,
      wrap: [this.wrapS, this.wrapT],
      format: this.format,
      type: this.type,
      encoding: this.encoding,
      minFilter: this.minFilter,
      magFilter: this.magFilter,
      anisotropy: this.anisotropy,
      flipY: this.flipY,
      premultiplyAlpha: this.premultiplyAlpha,
      unpackAlignment: this.unpackAlignment
    };
    if (JSON.stringify(this.userData) !== "{}")
      output.userData = this.userData;
    if (!isRootObject) {
      meta.textures[this.uuid] = output;
    }
    return output;
  }
  dispose() {
    this.dispatchEvent({ type: "dispose" });
  }
  transformUv(uv) {
    if (this.mapping !== UVMapping)
      return uv;
    uv.applyMatrix3(this.matrix);
    if (uv.x < 0 || uv.x > 1) {
      switch (this.wrapS) {
        case RepeatWrapping:
          uv.x = uv.x - Math.floor(uv.x);
          break;
        case ClampToEdgeWrapping:
          uv.x = uv.x < 0 ? 0 : 1;
          break;
        case MirroredRepeatWrapping:
          if (Math.abs(Math.floor(uv.x) % 2) === 1) {
            uv.x = Math.ceil(uv.x) - uv.x;
          } else {
            uv.x = uv.x - Math.floor(uv.x);
          }
          break;
      }
    }
    if (uv.y < 0 || uv.y > 1) {
      switch (this.wrapT) {
        case RepeatWrapping:
          uv.y = uv.y - Math.floor(uv.y);
          break;
        case ClampToEdgeWrapping:
          uv.y = uv.y < 0 ? 0 : 1;
          break;
        case MirroredRepeatWrapping:
          if (Math.abs(Math.floor(uv.y) % 2) === 1) {
            uv.y = Math.ceil(uv.y) - uv.y;
          } else {
            uv.y = uv.y - Math.floor(uv.y);
          }
          break;
      }
    }
    if (this.flipY) {
      uv.y = 1 - uv.y;
    }
    return uv;
  }
  set needsUpdate(value) {
    if (value === true) {
      this.version++;
      this.source.needsUpdate = true;
    }
  }
};
Texture.DEFAULT_IMAGE = null;
Texture.DEFAULT_MAPPING = UVMapping;
var Vector4 = class {
  constructor(x = 0, y = 0, z = 0, w2 = 1) {
    Vector4.prototype.isVector4 = true;
    this.x = x;
    this.y = y;
    this.z = z;
    this.w = w2;
  }
  get width() {
    return this.z;
  }
  set width(value) {
    this.z = value;
  }
  get height() {
    return this.w;
  }
  set height(value) {
    this.w = value;
  }
  set(x, y, z, w2) {
    this.x = x;
    this.y = y;
    this.z = z;
    this.w = w2;
    return this;
  }
  setScalar(scalar) {
    this.x = scalar;
    this.y = scalar;
    this.z = scalar;
    this.w = scalar;
    return this;
  }
  setX(x) {
    this.x = x;
    return this;
  }
  setY(y) {
    this.y = y;
    return this;
  }
  setZ(z) {
    this.z = z;
    return this;
  }
  setW(w2) {
    this.w = w2;
    return this;
  }
  setComponent(index, value) {
    switch (index) {
      case 0:
        this.x = value;
        break;
      case 1:
        this.y = value;
        break;
      case 2:
        this.z = value;
        break;
      case 3:
        this.w = value;
        break;
      default:
        throw new Error("index is out of range: " + index);
    }
    return this;
  }
  getComponent(index) {
    switch (index) {
      case 0:
        return this.x;
      case 1:
        return this.y;
      case 2:
        return this.z;
      case 3:
        return this.w;
      default:
        throw new Error("index is out of range: " + index);
    }
  }
  clone() {
    return new this.constructor(this.x, this.y, this.z, this.w);
  }
  copy(v) {
    this.x = v.x;
    this.y = v.y;
    this.z = v.z;
    this.w = v.w !== void 0 ? v.w : 1;
    return this;
  }
  add(v) {
    this.x += v.x;
    this.y += v.y;
    this.z += v.z;
    this.w += v.w;
    return this;
  }
  addScalar(s) {
    this.x += s;
    this.y += s;
    this.z += s;
    this.w += s;
    return this;
  }
  addVectors(a, b) {
    this.x = a.x + b.x;
    this.y = a.y + b.y;
    this.z = a.z + b.z;
    this.w = a.w + b.w;
    return this;
  }
  addScaledVector(v, s) {
    this.x += v.x * s;
    this.y += v.y * s;
    this.z += v.z * s;
    this.w += v.w * s;
    return this;
  }
  sub(v) {
    this.x -= v.x;
    this.y -= v.y;
    this.z -= v.z;
    this.w -= v.w;
    return this;
  }
  subScalar(s) {
    this.x -= s;
    this.y -= s;
    this.z -= s;
    this.w -= s;
    return this;
  }
  subVectors(a, b) {
    this.x = a.x - b.x;
    this.y = a.y - b.y;
    this.z = a.z - b.z;
    this.w = a.w - b.w;
    return this;
  }
  multiply(v) {
    this.x *= v.x;
    this.y *= v.y;
    this.z *= v.z;
    this.w *= v.w;
    return this;
  }
  multiplyScalar(scalar) {
    this.x *= scalar;
    this.y *= scalar;
    this.z *= scalar;
    this.w *= scalar;
    return this;
  }
  applyMatrix4(m) {
    const x = this.x, y = this.y, z = this.z, w2 = this.w;
    const e = m.elements;
    this.x = e[0] * x + e[4] * y + e[8] * z + e[12] * w2;
    this.y = e[1] * x + e[5] * y + e[9] * z + e[13] * w2;
    this.z = e[2] * x + e[6] * y + e[10] * z + e[14] * w2;
    this.w = e[3] * x + e[7] * y + e[11] * z + e[15] * w2;
    return this;
  }
  divideScalar(scalar) {
    return this.multiplyScalar(1 / scalar);
  }
  setAxisAngleFromQuaternion(q) {
    this.w = 2 * Math.acos(q.w);
    const s = Math.sqrt(1 - q.w * q.w);
    if (s < 1e-4) {
      this.x = 1;
      this.y = 0;
      this.z = 0;
    } else {
      this.x = q.x / s;
      this.y = q.y / s;
      this.z = q.z / s;
    }
    return this;
  }
  setAxisAngleFromRotationMatrix(m) {
    let angle, x, y, z;
    const epsilon = 0.01, epsilon2 = 0.1, te = m.elements, m11 = te[0], m12 = te[4], m13 = te[8], m21 = te[1], m22 = te[5], m23 = te[9], m31 = te[2], m32 = te[6], m33 = te[10];
    if (Math.abs(m12 - m21) < epsilon && Math.abs(m13 - m31) < epsilon && Math.abs(m23 - m32) < epsilon) {
      if (Math.abs(m12 + m21) < epsilon2 && Math.abs(m13 + m31) < epsilon2 && Math.abs(m23 + m32) < epsilon2 && Math.abs(m11 + m22 + m33 - 3) < epsilon2) {
        this.set(1, 0, 0, 0);
        return this;
      }
      angle = Math.PI;
      const xx = (m11 + 1) / 2;
      const yy = (m22 + 1) / 2;
      const zz = (m33 + 1) / 2;
      const xy = (m12 + m21) / 4;
      const xz = (m13 + m31) / 4;
      const yz = (m23 + m32) / 4;
      if (xx > yy && xx > zz) {
        if (xx < epsilon) {
          x = 0;
          y = 0.707106781;
          z = 0.707106781;
        } else {
          x = Math.sqrt(xx);
          y = xy / x;
          z = xz / x;
        }
      } else if (yy > zz) {
        if (yy < epsilon) {
          x = 0.707106781;
          y = 0;
          z = 0.707106781;
        } else {
          y = Math.sqrt(yy);
          x = xy / y;
          z = yz / y;
        }
      } else {
        if (zz < epsilon) {
          x = 0.707106781;
          y = 0.707106781;
          z = 0;
        } else {
          z = Math.sqrt(zz);
          x = xz / z;
          y = yz / z;
        }
      }
      this.set(x, y, z, angle);
      return this;
    }
    let s = Math.sqrt((m32 - m23) * (m32 - m23) + (m13 - m31) * (m13 - m31) + (m21 - m12) * (m21 - m12));
    if (Math.abs(s) < 1e-3)
      s = 1;
    this.x = (m32 - m23) / s;
    this.y = (m13 - m31) / s;
    this.z = (m21 - m12) / s;
    this.w = Math.acos((m11 + m22 + m33 - 1) / 2);
    return this;
  }
  min(v) {
    this.x = Math.min(this.x, v.x);
    this.y = Math.min(this.y, v.y);
    this.z = Math.min(this.z, v.z);
    this.w = Math.min(this.w, v.w);
    return this;
  }
  max(v) {
    this.x = Math.max(this.x, v.x);
    this.y = Math.max(this.y, v.y);
    this.z = Math.max(this.z, v.z);
    this.w = Math.max(this.w, v.w);
    return this;
  }
  clamp(min, max) {
    this.x = Math.max(min.x, Math.min(max.x, this.x));
    this.y = Math.max(min.y, Math.min(max.y, this.y));
    this.z = Math.max(min.z, Math.min(max.z, this.z));
    this.w = Math.max(min.w, Math.min(max.w, this.w));
    return this;
  }
  clampScalar(minVal, maxVal) {
    this.x = Math.max(minVal, Math.min(maxVal, this.x));
    this.y = Math.max(minVal, Math.min(maxVal, this.y));
    this.z = Math.max(minVal, Math.min(maxVal, this.z));
    this.w = Math.max(minVal, Math.min(maxVal, this.w));
    return this;
  }
  clampLength(min, max) {
    const length = this.length();
    return this.divideScalar(length || 1).multiplyScalar(Math.max(min, Math.min(max, length)));
  }
  floor() {
    this.x = Math.floor(this.x);
    this.y = Math.floor(this.y);
    this.z = Math.floor(this.z);
    this.w = Math.floor(this.w);
    return this;
  }
  ceil() {
    this.x = Math.ceil(this.x);
    this.y = Math.ceil(this.y);
    this.z = Math.ceil(this.z);
    this.w = Math.ceil(this.w);
    return this;
  }
  round() {
    this.x = Math.round(this.x);
    this.y = Math.round(this.y);
    this.z = Math.round(this.z);
    this.w = Math.round(this.w);
    return this;
  }
  roundToZero() {
    this.x = this.x < 0 ? Math.ceil(this.x) : Math.floor(this.x);
    this.y = this.y < 0 ? Math.ceil(this.y) : Math.floor(this.y);
    this.z = this.z < 0 ? Math.ceil(this.z) : Math.floor(this.z);
    this.w = this.w < 0 ? Math.ceil(this.w) : Math.floor(this.w);
    return this;
  }
  negate() {
    this.x = -this.x;
    this.y = -this.y;
    this.z = -this.z;
    this.w = -this.w;
    return this;
  }
  dot(v) {
    return this.x * v.x + this.y * v.y + this.z * v.z + this.w * v.w;
  }
  lengthSq() {
    return this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w;
  }
  length() {
    return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w);
  }
  manhattanLength() {
    return Math.abs(this.x) + Math.abs(this.y) + Math.abs(this.z) + Math.abs(this.w);
  }
  normalize() {
    return this.divideScalar(this.length() || 1);
  }
  setLength(length) {
    return this.normalize().multiplyScalar(length);
  }
  lerp(v, alpha) {
    this.x += (v.x - this.x) * alpha;
    this.y += (v.y - this.y) * alpha;
    this.z += (v.z - this.z) * alpha;
    this.w += (v.w - this.w) * alpha;
    return this;
  }
  lerpVectors(v1, v2, alpha) {
    this.x = v1.x + (v2.x - v1.x) * alpha;
    this.y = v1.y + (v2.y - v1.y) * alpha;
    this.z = v1.z + (v2.z - v1.z) * alpha;
    this.w = v1.w + (v2.w - v1.w) * alpha;
    return this;
  }
  equals(v) {
    return v.x === this.x && v.y === this.y && v.z === this.z && v.w === this.w;
  }
  fromArray(array, offset = 0) {
    this.x = array[offset];
    this.y = array[offset + 1];
    this.z = array[offset + 2];
    this.w = array[offset + 3];
    return this;
  }
  toArray(array = [], offset = 0) {
    array[offset] = this.x;
    array[offset + 1] = this.y;
    array[offset + 2] = this.z;
    array[offset + 3] = this.w;
    return array;
  }
  fromBufferAttribute(attribute, index) {
    this.x = attribute.getX(index);
    this.y = attribute.getY(index);
    this.z = attribute.getZ(index);
    this.w = attribute.getW(index);
    return this;
  }
  random() {
    this.x = Math.random();
    this.y = Math.random();
    this.z = Math.random();
    this.w = Math.random();
    return this;
  }
  *[Symbol.iterator]() {
    yield this.x;
    yield this.y;
    yield this.z;
    yield this.w;
  }
};
var WebGLRenderTarget = class extends EventDispatcher {
  constructor(width, height, options = {}) {
    super();
    this.isWebGLRenderTarget = true;
    this.width = width;
    this.height = height;
    this.depth = 1;
    this.scissor = new Vector4(0, 0, width, height);
    this.scissorTest = false;
    this.viewport = new Vector4(0, 0, width, height);
    const image = { width, height, depth: 1 };
    this.texture = new Texture(image, options.mapping, options.wrapS, options.wrapT, options.magFilter, options.minFilter, options.format, options.type, options.anisotropy, options.encoding);
    this.texture.isRenderTargetTexture = true;
    this.texture.flipY = false;
    this.texture.generateMipmaps = options.generateMipmaps !== void 0 ? options.generateMipmaps : false;
    this.texture.internalFormat = options.internalFormat !== void 0 ? options.internalFormat : null;
    this.texture.minFilter = options.minFilter !== void 0 ? options.minFilter : LinearFilter;
    this.depthBuffer = options.depthBuffer !== void 0 ? options.depthBuffer : true;
    this.stencilBuffer = options.stencilBuffer !== void 0 ? options.stencilBuffer : false;
    this.depthTexture = options.depthTexture !== void 0 ? options.depthTexture : null;
    this.samples = options.samples !== void 0 ? options.samples : 0;
  }
  setSize(width, height, depth = 1) {
    if (this.width !== width || this.height !== height || this.depth !== depth) {
      this.width = width;
      this.height = height;
      this.depth = depth;
      this.texture.image.width = width;
      this.texture.image.height = height;
      this.texture.image.depth = depth;
      this.dispose();
    }
    this.viewport.set(0, 0, width, height);
    this.scissor.set(0, 0, width, height);
  }
  clone() {
    return new this.constructor().copy(this);
  }
  copy(source) {
    this.width = source.width;
    this.height = source.height;
    this.depth = source.depth;
    this.viewport.copy(source.viewport);
    this.texture = source.texture.clone();
    this.texture.isRenderTargetTexture = true;
    const image = Object.assign({}, source.texture.image);
    this.texture.source = new Source(image);
    this.depthBuffer = source.depthBuffer;
    this.stencilBuffer = source.stencilBuffer;
    if (source.depthTexture !== null)
      this.depthTexture = source.depthTexture.clone();
    this.samples = source.samples;
    return this;
  }
  dispose() {
    this.dispatchEvent({ type: "dispose" });
  }
};
var DataArrayTexture = class extends Texture {
  constructor(data = null, width = 1, height = 1, depth = 1) {
    super(null);
    this.isDataArrayTexture = true;
    this.image = { data, width, height, depth };
    this.magFilter = NearestFilter;
    this.minFilter = NearestFilter;
    this.wrapR = ClampToEdgeWrapping;
    this.generateMipmaps = false;
    this.flipY = false;
    this.unpackAlignment = 1;
  }
};
var Data3DTexture = class extends Texture {
  constructor(data = null, width = 1, height = 1, depth = 1) {
    super(null);
    this.isData3DTexture = true;
    this.image = { data, width, height, depth };
    this.magFilter = NearestFilter;
    this.minFilter = NearestFilter;
    this.wrapR = ClampToEdgeWrapping;
    this.generateMipmaps = false;
    this.flipY = false;
    this.unpackAlignment = 1;
  }
};
var Quaternion = class {
  constructor(x = 0, y = 0, z = 0, w2 = 1) {
    this.isQuaternion = true;
    this._x = x;
    this._y = y;
    this._z = z;
    this._w = w2;
  }
  static slerpFlat(dst, dstOffset, src0, srcOffset0, src1, srcOffset1, t) {
    let x0 = src0[srcOffset0 + 0], y0 = src0[srcOffset0 + 1], z0 = src0[srcOffset0 + 2], w0 = src0[srcOffset0 + 3];
    const x1 = src1[srcOffset1 + 0], y1 = src1[srcOffset1 + 1], z1 = src1[srcOffset1 + 2], w1 = src1[srcOffset1 + 3];
    if (t === 0) {
      dst[dstOffset + 0] = x0;
      dst[dstOffset + 1] = y0;
      dst[dstOffset + 2] = z0;
      dst[dstOffset + 3] = w0;
      return;
    }
    if (t === 1) {
      dst[dstOffset + 0] = x1;
      dst[dstOffset + 1] = y1;
      dst[dstOffset + 2] = z1;
      dst[dstOffset + 3] = w1;
      return;
    }
    if (w0 !== w1 || x0 !== x1 || y0 !== y1 || z0 !== z1) {
      let s = 1 - t;
      const cos = x0 * x1 + y0 * y1 + z0 * z1 + w0 * w1, dir = cos >= 0 ? 1 : -1, sqrSin = 1 - cos * cos;
      if (sqrSin > Number.EPSILON) {
        const sin = Math.sqrt(sqrSin), len = Math.atan2(sin, cos * dir);
        s = Math.sin(s * len) / sin;
        t = Math.sin(t * len) / sin;
      }
      const tDir = t * dir;
      x0 = x0 * s + x1 * tDir;
      y0 = y0 * s + y1 * tDir;
      z0 = z0 * s + z1 * tDir;
      w0 = w0 * s + w1 * tDir;
      if (s === 1 - t) {
        const f = 1 / Math.sqrt(x0 * x0 + y0 * y0 + z0 * z0 + w0 * w0);
        x0 *= f;
        y0 *= f;
        z0 *= f;
        w0 *= f;
      }
    }
    dst[dstOffset] = x0;
    dst[dstOffset + 1] = y0;
    dst[dstOffset + 2] = z0;
    dst[dstOffset + 3] = w0;
  }
  static multiplyQuaternionsFlat(dst, dstOffset, src0, srcOffset0, src1, srcOffset1) {
    const x0 = src0[srcOffset0];
    const y0 = src0[srcOffset0 + 1];
    const z0 = src0[srcOffset0 + 2];
    const w0 = src0[srcOffset0 + 3];
    const x1 = src1[srcOffset1];
    const y1 = src1[srcOffset1 + 1];
    const z1 = src1[srcOffset1 + 2];
    const w1 = src1[srcOffset1 + 3];
    dst[dstOffset] = x0 * w1 + w0 * x1 + y0 * z1 - z0 * y1;
    dst[dstOffset + 1] = y0 * w1 + w0 * y1 + z0 * x1 - x0 * z1;
    dst[dstOffset + 2] = z0 * w1 + w0 * z1 + x0 * y1 - y0 * x1;
    dst[dstOffset + 3] = w0 * w1 - x0 * x1 - y0 * y1 - z0 * z1;
    return dst;
  }
  get x() {
    return this._x;
  }
  set x(value) {
    this._x = value;
    this._onChangeCallback();
  }
  get y() {
    return this._y;
  }
  set y(value) {
    this._y = value;
    this._onChangeCallback();
  }
  get z() {
    return this._z;
  }
  set z(value) {
    this._z = value;
    this._onChangeCallback();
  }
  get w() {
    return this._w;
  }
  set w(value) {
    this._w = value;
    this._onChangeCallback();
  }
  set(x, y, z, w2) {
    this._x = x;
    this._y = y;
    this._z = z;
    this._w = w2;
    this._onChangeCallback();
    return this;
  }
  clone() {
    return new this.constructor(this._x, this._y, this._z, this._w);
  }
  copy(quaternion) {
    this._x = quaternion.x;
    this._y = quaternion.y;
    this._z = quaternion.z;
    this._w = quaternion.w;
    this._onChangeCallback();
    return this;
  }
  setFromEuler(euler, update) {
    if (!(euler && euler.isEuler)) {
      throw new Error("THREE.Quaternion: .setFromEuler() now expects an Euler rotation rather than a Vector3 and order.");
    }
    const x = euler._x, y = euler._y, z = euler._z, order = euler._order;
    const cos = Math.cos;
    const sin = Math.sin;
    const c1 = cos(x / 2);
    const c2 = cos(y / 2);
    const c3 = cos(z / 2);
    const s1 = sin(x / 2);
    const s2 = sin(y / 2);
    const s3 = sin(z / 2);
    switch (order) {
      case "XYZ":
        this._x = s1 * c2 * c3 + c1 * s2 * s3;
        this._y = c1 * s2 * c3 - s1 * c2 * s3;
        this._z = c1 * c2 * s3 + s1 * s2 * c3;
        this._w = c1 * c2 * c3 - s1 * s2 * s3;
        break;
      case "YXZ":
        this._x = s1 * c2 * c3 + c1 * s2 * s3;
        this._y = c1 * s2 * c3 - s1 * c2 * s3;
        this._z = c1 * c2 * s3 - s1 * s2 * c3;
        this._w = c1 * c2 * c3 + s1 * s2 * s3;
        break;
      case "ZXY":
        this._x = s1 * c2 * c3 - c1 * s2 * s3;
        this._y = c1 * s2 * c3 + s1 * c2 * s3;
        this._z = c1 * c2 * s3 + s1 * s2 * c3;
        this._w = c1 * c2 * c3 - s1 * s2 * s3;
        break;
      case "ZYX":
        this._x = s1 * c2 * c3 - c1 * s2 * s3;
        this._y = c1 * s2 * c3 + s1 * c2 * s3;
        this._z = c1 * c2 * s3 - s1 * s2 * c3;
        this._w = c1 * c2 * c3 + s1 * s2 * s3;
        break;
      case "YZX":
        this._x = s1 * c2 * c3 + c1 * s2 * s3;
        this._y = c1 * s2 * c3 + s1 * c2 * s3;
        this._z = c1 * c2 * s3 - s1 * s2 * c3;
        this._w = c1 * c2 * c3 - s1 * s2 * s3;
        break;
      case "XZY":
        this._x = s1 * c2 * c3 - c1 * s2 * s3;
        this._y = c1 * s2 * c3 - s1 * c2 * s3;
        this._z = c1 * c2 * s3 + s1 * s2 * c3;
        this._w = c1 * c2 * c3 + s1 * s2 * s3;
        break;
      default:
        console.warn("THREE.Quaternion: .setFromEuler() encountered an unknown order: " + order);
    }
    if (update !== false)
      this._onChangeCallback();
    return this;
  }
  setFromAxisAngle(axis, angle) {
    const halfAngle = angle / 2, s = Math.sin(halfAngle);
    this._x = axis.x * s;
    this._y = axis.y * s;
    this._z = axis.z * s;
    this._w = Math.cos(halfAngle);
    this._onChangeCallback();
    return this;
  }
  setFromRotationMatrix(m) {
    const te = m.elements, m11 = te[0], m12 = te[4], m13 = te[8], m21 = te[1], m22 = te[5], m23 = te[9], m31 = te[2], m32 = te[6], m33 = te[10], trace = m11 + m22 + m33;
    if (trace > 0) {
      const s = 0.5 / Math.sqrt(trace + 1);
      this._w = 0.25 / s;
      this._x = (m32 - m23) * s;
      this._y = (m13 - m31) * s;
      this._z = (m21 - m12) * s;
    } else if (m11 > m22 && m11 > m33) {
      const s = 2 * Math.sqrt(1 + m11 - m22 - m33);
      this._w = (m32 - m23) / s;
      this._x = 0.25 * s;
      this._y = (m12 + m21) / s;
      this._z = (m13 + m31) / s;
    } else if (m22 > m33) {
      const s = 2 * Math.sqrt(1 + m22 - m11 - m33);
      this._w = (m13 - m31) / s;
      this._x = (m12 + m21) / s;
      this._y = 0.25 * s;
      this._z = (m23 + m32) / s;
    } else {
      const s = 2 * Math.sqrt(1 + m33 - m11 - m22);
      this._w = (m21 - m12) / s;
      this._x = (m13 + m31) / s;
      this._y = (m23 + m32) / s;
      this._z = 0.25 * s;
    }
    this._onChangeCallback();
    return this;
  }
  setFromUnitVectors(vFrom, vTo) {
    let r = vFrom.dot(vTo) + 1;
    if (r < Number.EPSILON) {
      r = 0;
      if (Math.abs(vFrom.x) > Math.abs(vFrom.z)) {
        this._x = -vFrom.y;
        this._y = vFrom.x;
        this._z = 0;
        this._w = r;
      } else {
        this._x = 0;
        this._y = -vFrom.z;
        this._z = vFrom.y;
        this._w = r;
      }
    } else {
      this._x = vFrom.y * vTo.z - vFrom.z * vTo.y;
      this._y = vFrom.z * vTo.x - vFrom.x * vTo.z;
      this._z = vFrom.x * vTo.y - vFrom.y * vTo.x;
      this._w = r;
    }
    return this.normalize();
  }
  angleTo(q) {
    return 2 * Math.acos(Math.abs(clamp(this.dot(q), -1, 1)));
  }
  rotateTowards(q, step) {
    const angle = this.angleTo(q);
    if (angle === 0)
      return this;
    const t = Math.min(1, step / angle);
    this.slerp(q, t);
    return this;
  }
  identity() {
    return this.set(0, 0, 0, 1);
  }
  invert() {
    return this.conjugate();
  }
  conjugate() {
    this._x *= -1;
    this._y *= -1;
    this._z *= -1;
    this._onChangeCallback();
    return this;
  }
  dot(v) {
    return this._x * v._x + this._y * v._y + this._z * v._z + this._w * v._w;
  }
  lengthSq() {
    return this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w;
  }
  length() {
    return Math.sqrt(this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w);
  }
  normalize() {
    let l = this.length();
    if (l === 0) {
      this._x = 0;
      this._y = 0;
      this._z = 0;
      this._w = 1;
    } else {
      l = 1 / l;
      this._x = this._x * l;
      this._y = this._y * l;
      this._z = this._z * l;
      this._w = this._w * l;
    }
    this._onChangeCallback();
    return this;
  }
  multiply(q) {
    return this.multiplyQuaternions(this, q);
  }
  premultiply(q) {
    return this.multiplyQuaternions(q, this);
  }
  multiplyQuaternions(a, b) {
    const qax = a._x, qay = a._y, qaz = a._z, qaw = a._w;
    const qbx = b._x, qby = b._y, qbz = b._z, qbw = b._w;
    this._x = qax * qbw + qaw * qbx + qay * qbz - qaz * qby;
    this._y = qay * qbw + qaw * qby + qaz * qbx - qax * qbz;
    this._z = qaz * qbw + qaw * qbz + qax * qby - qay * qbx;
    this._w = qaw * qbw - qax * qbx - qay * qby - qaz * qbz;
    this._onChangeCallback();
    return this;
  }
  slerp(qb, t) {
    if (t === 0)
      return this;
    if (t === 1)
      return this.copy(qb);
    const x = this._x, y = this._y, z = this._z, w2 = this._w;
    let cosHalfTheta = w2 * qb._w + x * qb._x + y * qb._y + z * qb._z;
    if (cosHalfTheta < 0) {
      this._w = -qb._w;
      this._x = -qb._x;
      this._y = -qb._y;
      this._z = -qb._z;
      cosHalfTheta = -cosHalfTheta;
    } else {
      this.copy(qb);
    }
    if (cosHalfTheta >= 1) {
      this._w = w2;
      this._x = x;
      this._y = y;
      this._z = z;
      return this;
    }
    const sqrSinHalfTheta = 1 - cosHalfTheta * cosHalfTheta;
    if (sqrSinHalfTheta <= Number.EPSILON) {
      const s = 1 - t;
      this._w = s * w2 + t * this._w;
      this._x = s * x + t * this._x;
      this._y = s * y + t * this._y;
      this._z = s * z + t * this._z;
      this.normalize();
      this._onChangeCallback();
      return this;
    }
    const sinHalfTheta = Math.sqrt(sqrSinHalfTheta);
    const halfTheta = Math.atan2(sinHalfTheta, cosHalfTheta);
    const ratioA = Math.sin((1 - t) * halfTheta) / sinHalfTheta, ratioB = Math.sin(t * halfTheta) / sinHalfTheta;
    this._w = w2 * ratioA + this._w * ratioB;
    this._x = x * ratioA + this._x * ratioB;
    this._y = y * ratioA + this._y * ratioB;
    this._z = z * ratioA + this._z * ratioB;
    this._onChangeCallback();
    return this;
  }
  slerpQuaternions(qa, qb, t) {
    return this.copy(qa).slerp(qb, t);
  }
  random() {
    const u1 = Math.random();
    const sqrt1u1 = Math.sqrt(1 - u1);
    const sqrtu1 = Math.sqrt(u1);
    const u2 = 2 * Math.PI * Math.random();
    const u3 = 2 * Math.PI * Math.random();
    return this.set(
      sqrt1u1 * Math.cos(u2),
      sqrtu1 * Math.sin(u3),
      sqrtu1 * Math.cos(u3),
      sqrt1u1 * Math.sin(u2)
    );
  }
  equals(quaternion) {
    return quaternion._x === this._x && quaternion._y === this._y && quaternion._z === this._z && quaternion._w === this._w;
  }
  fromArray(array, offset = 0) {
    this._x = array[offset];
    this._y = array[offset + 1];
    this._z = array[offset + 2];
    this._w = array[offset + 3];
    this._onChangeCallback();
    return this;
  }
  toArray(array = [], offset = 0) {
    array[offset] = this._x;
    array[offset + 1] = this._y;
    array[offset + 2] = this._z;
    array[offset + 3] = this._w;
    return array;
  }
  fromBufferAttribute(attribute, index) {
    this._x = attribute.getX(index);
    this._y = attribute.getY(index);
    this._z = attribute.getZ(index);
    this._w = attribute.getW(index);
    return this;
  }
  _onChange(callback) {
    this._onChangeCallback = callback;
    return this;
  }
  _onChangeCallback() {
  }
  *[Symbol.iterator]() {
    yield this._x;
    yield this._y;
    yield this._z;
    yield this._w;
  }
};
var Vector3 = class {
  constructor(x = 0, y = 0, z = 0) {
    Vector3.prototype.isVector3 = true;
    this.x = x;
    this.y = y;
    this.z = z;
  }
  set(x, y, z) {
    if (z === void 0)
      z = this.z;
    this.x = x;
    this.y = y;
    this.z = z;
    return this;
  }
  setScalar(scalar) {
    this.x = scalar;
    this.y = scalar;
    this.z = scalar;
    return this;
  }
  setX(x) {
    this.x = x;
    return this;
  }
  setY(y) {
    this.y = y;
    return this;
  }
  setZ(z) {
    this.z = z;
    return this;
  }
  setComponent(index, value) {
    switch (index) {
      case 0:
        this.x = value;
        break;
      case 1:
        this.y = value;
        break;
      case 2:
        this.z = value;
        break;
      default:
        throw new Error("index is out of range: " + index);
    }
    return this;
  }
  getComponent(index) {
    switch (index) {
      case 0:
        return this.x;
      case 1:
        return this.y;
      case 2:
        return this.z;
      default:
        throw new Error("index is out of range: " + index);
    }
  }
  clone() {
    return new this.constructor(this.x, this.y, this.z);
  }
  copy(v) {
    this.x = v.x;
    this.y = v.y;
    this.z = v.z;
    return this;
  }
  add(v) {
    this.x += v.x;
    this.y += v.y;
    this.z += v.z;
    return this;
  }
  addScalar(s) {
    this.x += s;
    this.y += s;
    this.z += s;
    return this;
  }
  addVectors(a, b) {
    this.x = a.x + b.x;
    this.y = a.y + b.y;
    this.z = a.z + b.z;
    return this;
  }
  addScaledVector(v, s) {
    this.x += v.x * s;
    this.y += v.y * s;
    this.z += v.z * s;
    return this;
  }
  sub(v) {
    this.x -= v.x;
    this.y -= v.y;
    this.z -= v.z;
    return this;
  }
  subScalar(s) {
    this.x -= s;
    this.y -= s;
    this.z -= s;
    return this;
  }
  subVectors(a, b) {
    this.x = a.x - b.x;
    this.y = a.y - b.y;
    this.z = a.z - b.z;
    return this;
  }
  multiply(v) {
    this.x *= v.x;
    this.y *= v.y;
    this.z *= v.z;
    return this;
  }
  multiplyScalar(scalar) {
    this.x *= scalar;
    this.y *= scalar;
    this.z *= scalar;
    return this;
  }
  multiplyVectors(a, b) {
    this.x = a.x * b.x;
    this.y = a.y * b.y;
    this.z = a.z * b.z;
    return this;
  }
  applyEuler(euler) {
    return this.applyQuaternion(_quaternion$4.setFromEuler(euler));
  }
  applyAxisAngle(axis, angle) {
    return this.applyQuaternion(_quaternion$4.setFromAxisAngle(axis, angle));
  }
  applyMatrix3(m) {
    const x = this.x, y = this.y, z = this.z;
    const e = m.elements;
    this.x = e[0] * x + e[3] * y + e[6] * z;
    this.y = e[1] * x + e[4] * y + e[7] * z;
    this.z = e[2] * x + e[5] * y + e[8] * z;
    return this;
  }
  applyNormalMatrix(m) {
    return this.applyMatrix3(m).normalize();
  }
  applyMatrix4(m) {
    const x = this.x, y = this.y, z = this.z;
    const e = m.elements;
    const w2 = 1 / (e[3] * x + e[7] * y + e[11] * z + e[15]);
    this.x = (e[0] * x + e[4] * y + e[8] * z + e[12]) * w2;
    this.y = (e[1] * x + e[5] * y + e[9] * z + e[13]) * w2;
    this.z = (e[2] * x + e[6] * y + e[10] * z + e[14]) * w2;
    return this;
  }
  applyQuaternion(q) {
    const x = this.x, y = this.y, z = this.z;
    const qx = q.x, qy = q.y, qz = q.z, qw = q.w;
    const ix = qw * x + qy * z - qz * y;
    const iy = qw * y + qz * x - qx * z;
    const iz = qw * z + qx * y - qy * x;
    const iw = -qx * x - qy * y - qz * z;
    this.x = ix * qw + iw * -qx + iy * -qz - iz * -qy;
    this.y = iy * qw + iw * -qy + iz * -qx - ix * -qz;
    this.z = iz * qw + iw * -qz + ix * -qy - iy * -qx;
    return this;
  }
  project(camera) {
    return this.applyMatrix4(camera.matrixWorldInverse).applyMatrix4(camera.projectionMatrix);
  }
  unproject(camera) {
    return this.applyMatrix4(camera.projectionMatrixInverse).applyMatrix4(camera.matrixWorld);
  }
  transformDirection(m) {
    const x = this.x, y = this.y, z = this.z;
    const e = m.elements;
    this.x = e[0] * x + e[4] * y + e[8] * z;
    this.y = e[1] * x + e[5] * y + e[9] * z;
    this.z = e[2] * x + e[6] * y + e[10] * z;
    return this.normalize();
  }
  divide(v) {
    this.x /= v.x;
    this.y /= v.y;
    this.z /= v.z;
    return this;
  }
  divideScalar(scalar) {
    return this.multiplyScalar(1 / scalar);
  }
  min(v) {
    this.x = Math.min(this.x, v.x);
    this.y = Math.min(this.y, v.y);
    this.z = Math.min(this.z, v.z);
    return this;
  }
  max(v) {
    this.x = Math.max(this.x, v.x);
    this.y = Math.max(this.y, v.y);
    this.z = Math.max(this.z, v.z);
    return this;
  }
  clamp(min, max) {
    this.x = Math.max(min.x, Math.min(max.x, this.x));
    this.y = Math.max(min.y, Math.min(max.y, this.y));
    this.z = Math.max(min.z, Math.min(max.z, this.z));
    return this;
  }
  clampScalar(minVal, maxVal) {
    this.x = Math.max(minVal, Math.min(maxVal, this.x));
    this.y = Math.max(minVal, Math.min(maxVal, this.y));
    this.z = Math.max(minVal, Math.min(maxVal, this.z));
    return this;
  }
  clampLength(min, max) {
    const length = this.length();
    return this.divideScalar(length || 1).multiplyScalar(Math.max(min, Math.min(max, length)));
  }
  floor() {
    this.x = Math.floor(this.x);
    this.y = Math.floor(this.y);
    this.z = Math.floor(this.z);
    return this;
  }
  ceil() {
    this.x = Math.ceil(this.x);
    this.y = Math.ceil(this.y);
    this.z = Math.ceil(this.z);
    return this;
  }
  round() {
    this.x = Math.round(this.x);
    this.y = Math.round(this.y);
    this.z = Math.round(this.z);
    return this;
  }
  roundToZero() {
    this.x = this.x < 0 ? Math.ceil(this.x) : Math.floor(this.x);
    this.y = this.y < 0 ? Math.ceil(this.y) : Math.floor(this.y);
    this.z = this.z < 0 ? Math.ceil(this.z) : Math.floor(this.z);
    return this;
  }
  negate() {
    this.x = -this.x;
    this.y = -this.y;
    this.z = -this.z;
    return this;
  }
  dot(v) {
    return this.x * v.x + this.y * v.y + this.z * v.z;
  }
  lengthSq() {
    return this.x * this.x + this.y * this.y + this.z * this.z;
  }
  length() {
    return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z);
  }
  manhattanLength() {
    return Math.abs(this.x) + Math.abs(this.y) + Math.abs(this.z);
  }
  normalize() {
    return this.divideScalar(this.length() || 1);
  }
  setLength(length) {
    return this.normalize().multiplyScalar(length);
  }
  lerp(v, alpha) {
    this.x += (v.x - this.x) * alpha;
    this.y += (v.y - this.y) * alpha;
    this.z += (v.z - this.z) * alpha;
    return this;
  }
  lerpVectors(v1, v2, alpha) {
    this.x = v1.x + (v2.x - v1.x) * alpha;
    this.y = v1.y + (v2.y - v1.y) * alpha;
    this.z = v1.z + (v2.z - v1.z) * alpha;
    return this;
  }
  cross(v) {
    return this.crossVectors(this, v);
  }
  crossVectors(a, b) {
    const ax = a.x, ay = a.y, az = a.z;
    const bx = b.x, by = b.y, bz = b.z;
    this.x = ay * bz - az * by;
    this.y = az * bx - ax * bz;
    this.z = ax * by - ay * bx;
    return this;
  }
  projectOnVector(v) {
    const denominator = v.lengthSq();
    if (denominator === 0)
      return this.set(0, 0, 0);
    const scalar = v.dot(this) / denominator;
    return this.copy(v).multiplyScalar(scalar);
  }
  projectOnPlane(planeNormal) {
    _vector$c.copy(this).projectOnVector(planeNormal);
    return this.sub(_vector$c);
  }
  reflect(normal) {
    return this.sub(_vector$c.copy(normal).multiplyScalar(2 * this.dot(normal)));
  }
  angleTo(v) {
    const denominator = Math.sqrt(this.lengthSq() * v.lengthSq());
    if (denominator === 0)
      return Math.PI / 2;
    const theta = this.dot(v) / denominator;
    return Math.acos(clamp(theta, -1, 1));
  }
  distanceTo(v) {
    return Math.sqrt(this.distanceToSquared(v));
  }
  distanceToSquared(v) {
    const dx = this.x - v.x, dy = this.y - v.y, dz = this.z - v.z;
    return dx * dx + dy * dy + dz * dz;
  }
  manhattanDistanceTo(v) {
    return Math.abs(this.x - v.x) + Math.abs(this.y - v.y) + Math.abs(this.z - v.z);
  }
  setFromSpherical(s) {
    return this.setFromSphericalCoords(s.radius, s.phi, s.theta);
  }
  setFromSphericalCoords(radius, phi, theta) {
    const sinPhiRadius = Math.sin(phi) * radius;
    this.x = sinPhiRadius * Math.sin(theta);
    this.y = Math.cos(phi) * radius;
    this.z = sinPhiRadius * Math.cos(theta);
    return this;
  }
  setFromCylindrical(c) {
    return this.setFromCylindricalCoords(c.radius, c.theta, c.y);
  }
  setFromCylindricalCoords(radius, theta, y) {
    this.x = radius * Math.sin(theta);
    this.y = y;
    this.z = radius * Math.cos(theta);
    return this;
  }
  setFromMatrixPosition(m) {
    const e = m.elements;
    this.x = e[12];
    this.y = e[13];
    this.z = e[14];
    return this;
  }
  setFromMatrixScale(m) {
    const sx = this.setFromMatrixColumn(m, 0).length();
    const sy = this.setFromMatrixColumn(m, 1).length();
    const sz = this.setFromMatrixColumn(m, 2).length();
    this.x = sx;
    this.y = sy;
    this.z = sz;
    return this;
  }
  setFromMatrixColumn(m, index) {
    return this.fromArray(m.elements, index * 4);
  }
  setFromMatrix3Column(m, index) {
    return this.fromArray(m.elements, index * 3);
  }
  setFromEuler(e) {
    this.x = e._x;
    this.y = e._y;
    this.z = e._z;
    return this;
  }
  equals(v) {
    return v.x === this.x && v.y === this.y && v.z === this.z;
  }
  fromArray(array, offset = 0) {
    this.x = array[offset];
    this.y = array[offset + 1];
    this.z = array[offset + 2];
    return this;
  }
  toArray(array = [], offset = 0) {
    array[offset] = this.x;
    array[offset + 1] = this.y;
    array[offset + 2] = this.z;
    return array;
  }
  fromBufferAttribute(attribute, index) {
    this.x = attribute.getX(index);
    this.y = attribute.getY(index);
    this.z = attribute.getZ(index);
    return this;
  }
  random() {
    this.x = Math.random();
    this.y = Math.random();
    this.z = Math.random();
    return this;
  }
  randomDirection() {
    const u = (Math.random() - 0.5) * 2;
    const t = Math.random() * Math.PI * 2;
    const f = Math.sqrt(1 - u ** 2);
    this.x = f * Math.cos(t);
    this.y = f * Math.sin(t);
    this.z = u;
    return this;
  }
  *[Symbol.iterator]() {
    yield this.x;
    yield this.y;
    yield this.z;
  }
};
var _vector$c = /* @__PURE__ */ new Vector3();
var _quaternion$4 = /* @__PURE__ */ new Quaternion();
var Box3 = class {
  constructor(min = new Vector3(Infinity, Infinity, Infinity), max = new Vector3(-Infinity, -Infinity, -Infinity)) {
    this.isBox3 = true;
    this.min = min;
    this.max = max;
  }
  set(min, max) {
    this.min.copy(min);
    this.max.copy(max);
    return this;
  }
  setFromArray(array) {
    let minX = Infinity;
    let minY = Infinity;
    let minZ = Infinity;
    let maxX = -Infinity;
    let maxY = -Infinity;
    let maxZ = -Infinity;
    for (let i2 = 0, l = array.length; i2 < l; i2 += 3) {
      const x = array[i2];
      const y = array[i2 + 1];
      const z = array[i2 + 2];
      if (x < minX)
        minX = x;
      if (y < minY)
        minY = y;
      if (z < minZ)
        minZ = z;
      if (x > maxX)
        maxX = x;
      if (y > maxY)
        maxY = y;
      if (z > maxZ)
        maxZ = z;
    }
    this.min.set(minX, minY, minZ);
    this.max.set(maxX, maxY, maxZ);
    return this;
  }
  setFromBufferAttribute(attribute) {
    let minX = Infinity;
    let minY = Infinity;
    let minZ = Infinity;
    let maxX = -Infinity;
    let maxY = -Infinity;
    let maxZ = -Infinity;
    for (let i2 = 0, l = attribute.count; i2 < l; i2++) {
      const x = attribute.getX(i2);
      const y = attribute.getY(i2);
      const z = attribute.getZ(i2);
      if (x < minX)
        minX = x;
      if (y < minY)
        minY = y;
      if (z < minZ)
        minZ = z;
      if (x > maxX)
        maxX = x;
      if (y > maxY)
        maxY = y;
      if (z > maxZ)
        maxZ = z;
    }
    this.min.set(minX, minY, minZ);
    this.max.set(maxX, maxY, maxZ);
    return this;
  }
  setFromPoints(points) {
    this.makeEmpty();
    for (let i2 = 0, il = points.length; i2 < il; i2++) {
      this.expandByPoint(points[i2]);
    }
    return this;
  }
  setFromCenterAndSize(center, size) {
    const halfSize = _vector$b.copy(size).multiplyScalar(0.5);
    this.min.copy(center).sub(halfSize);
    this.max.copy(center).add(halfSize);
    return this;
  }
  setFromObject(object, precise = false) {
    this.makeEmpty();
    return this.expandByObject(object, precise);
  }
  clone() {
    return new this.constructor().copy(this);
  }
  copy(box) {
    this.min.copy(box.min);
    this.max.copy(box.max);
    return this;
  }
  makeEmpty() {
    this.min.x = this.min.y = this.min.z = Infinity;
    this.max.x = this.max.y = this.max.z = -Infinity;
    return this;
  }
  isEmpty() {
    return this.max.x < this.min.x || this.max.y < this.min.y || this.max.z < this.min.z;
  }
  getCenter(target) {
    return this.isEmpty() ? target.set(0, 0, 0) : target.addVectors(this.min, this.max).multiplyScalar(0.5);
  }
  getSize(target) {
    return this.isEmpty() ? target.set(0, 0, 0) : target.subVectors(this.max, this.min);
  }
  expandByPoint(point) {
    this.min.min(point);
    this.max.max(point);
    return this;
  }
  expandByVector(vector) {
    this.min.sub(vector);
    this.max.add(vector);
    return this;
  }
  expandByScalar(scalar) {
    this.min.addScalar(-scalar);
    this.max.addScalar(scalar);
    return this;
  }
  expandByObject(object, precise = false) {
    object.updateWorldMatrix(false, false);
    const geometry = object.geometry;
    if (geometry !== void 0) {
      if (precise && geometry.attributes != void 0 && geometry.attributes.position !== void 0) {
        const position = geometry.attributes.position;
        for (let i2 = 0, l = position.count; i2 < l; i2++) {
          _vector$b.fromBufferAttribute(position, i2).applyMatrix4(object.matrixWorld);
          this.expandByPoint(_vector$b);
        }
      } else {
        if (geometry.boundingBox === null) {
          geometry.computeBoundingBox();
        }
        _box$3.copy(geometry.boundingBox);
        _box$3.applyMatrix4(object.matrixWorld);
        this.union(_box$3);
      }
    }
    const children = object.children;
    for (let i2 = 0, l = children.length; i2 < l; i2++) {
      this.expandByObject(children[i2], precise);
    }
    return this;
  }
  containsPoint(point) {
    return point.x < this.min.x || point.x > this.max.x || point.y < this.min.y || point.y > this.max.y || point.z < this.min.z || point.z > this.max.z ? false : true;
  }
  containsBox(box) {
    return this.min.x <= box.min.x && box.max.x <= this.max.x && this.min.y <= box.min.y && box.max.y <= this.max.y && this.min.z <= box.min.z && box.max.z <= this.max.z;
  }
  getParameter(point, target) {
    return target.set(
      (point.x - this.min.x) / (this.max.x - this.min.x),
      (point.y - this.min.y) / (this.max.y - this.min.y),
      (point.z - this.min.z) / (this.max.z - this.min.z)
    );
  }
  intersectsBox(box) {
    return box.max.x < this.min.x || box.min.x > this.max.x || box.max.y < this.min.y || box.min.y > this.max.y || box.max.z < this.min.z || box.min.z > this.max.z ? false : true;
  }
  intersectsSphere(sphere) {
    this.clampPoint(sphere.center, _vector$b);
    return _vector$b.distanceToSquared(sphere.center) <= sphere.radius * sphere.radius;
  }
  intersectsPlane(plane) {
    let min, max;
    if (plane.normal.x > 0) {
      min = plane.normal.x * this.min.x;
      max = plane.normal.x * this.max.x;
    } else {
      min = plane.normal.x * this.max.x;
      max = plane.normal.x * this.min.x;
    }
    if (plane.normal.y > 0) {
      min += plane.normal.y * this.min.y;
      max += plane.normal.y * this.max.y;
    } else {
      min += plane.normal.y * this.max.y;
      max += plane.normal.y * this.min.y;
    }
    if (plane.normal.z > 0) {
      min += plane.normal.z * this.min.z;
      max += plane.normal.z * this.max.z;
    } else {
      min += plane.normal.z * this.max.z;
      max += plane.normal.z * this.min.z;
    }
    return min <= -plane.constant && max >= -plane.constant;
  }
  intersectsTriangle(triangle) {
    if (this.isEmpty()) {
      return false;
    }
    this.getCenter(_center);
    _extents.subVectors(this.max, _center);
    _v0$2.subVectors(triangle.a, _center);
    _v1$7.subVectors(triangle.b, _center);
    _v2$3.subVectors(triangle.c, _center);
    _f0.subVectors(_v1$7, _v0$2);
    _f1.subVectors(_v2$3, _v1$7);
    _f2.subVectors(_v0$2, _v2$3);
    let axes = [
      0,
      -_f0.z,
      _f0.y,
      0,
      -_f1.z,
      _f1.y,
      0,
      -_f2.z,
      _f2.y,
      _f0.z,
      0,
      -_f0.x,
      _f1.z,
      0,
      -_f1.x,
      _f2.z,
      0,
      -_f2.x,
      -_f0.y,
      _f0.x,
      0,
      -_f1.y,
      _f1.x,
      0,
      -_f2.y,
      _f2.x,
      0
    ];
    if (!satForAxes(axes, _v0$2, _v1$7, _v2$3, _extents)) {
      return false;
    }
    axes = [1, 0, 0, 0, 1, 0, 0, 0, 1];
    if (!satForAxes(axes, _v0$2, _v1$7, _v2$3, _extents)) {
      return false;
    }
    _triangleNormal.crossVectors(_f0, _f1);
    axes = [_triangleNormal.x, _triangleNormal.y, _triangleNormal.z];
    return satForAxes(axes, _v0$2, _v1$7, _v2$3, _extents);
  }
  clampPoint(point, target) {
    return target.copy(point).clamp(this.min, this.max);
  }
  distanceToPoint(point) {
    const clampedPoint = _vector$b.copy(point).clamp(this.min, this.max);
    return clampedPoint.sub(point).length();
  }
  getBoundingSphere(target) {
    this.getCenter(target.center);
    target.radius = this.getSize(_vector$b).length() * 0.5;
    return target;
  }
  intersect(box) {
    this.min.max(box.min);
    this.max.min(box.max);
    if (this.isEmpty())
      this.makeEmpty();
    return this;
  }
  union(box) {
    this.min.min(box.min);
    this.max.max(box.max);
    return this;
  }
  applyMatrix4(matrix) {
    if (this.isEmpty())
      return this;
    _points[0].set(this.min.x, this.min.y, this.min.z).applyMatrix4(matrix);
    _points[1].set(this.min.x, this.min.y, this.max.z).applyMatrix4(matrix);
    _points[2].set(this.min.x, this.max.y, this.min.z).applyMatrix4(matrix);
    _points[3].set(this.min.x, this.max.y, this.max.z).applyMatrix4(matrix);
    _points[4].set(this.max.x, this.min.y, this.min.z).applyMatrix4(matrix);
    _points[5].set(this.max.x, this.min.y, this.max.z).applyMatrix4(matrix);
    _points[6].set(this.max.x, this.max.y, this.min.z).applyMatrix4(matrix);
    _points[7].set(this.max.x, this.max.y, this.max.z).applyMatrix4(matrix);
    this.setFromPoints(_points);
    return this;
  }
  translate(offset) {
    this.min.add(offset);
    this.max.add(offset);
    return this;
  }
  equals(box) {
    return box.min.equals(this.min) && box.max.equals(this.max);
  }
};
var _points = [
  /* @__PURE__ */ new Vector3(),
  /* @__PURE__ */ new Vector3(),
  /* @__PURE__ */ new Vector3(),
  /* @__PURE__ */ new Vector3(),
  /* @__PURE__ */ new Vector3(),
  /* @__PURE__ */ new Vector3(),
  /* @__PURE__ */ new Vector3(),
  /* @__PURE__ */ new Vector3()
];
var _vector$b = /* @__PURE__ */ new Vector3();
var _box$3 = /* @__PURE__ */ new Box3();
var _v0$2 = /* @__PURE__ */ new Vector3();
var _v1$7 = /* @__PURE__ */ new Vector3();
var _v2$3 = /* @__PURE__ */ new Vector3();
var _f0 = /* @__PURE__ */ new Vector3();
var _f1 = /* @__PURE__ */ new Vector3();
var _f2 = /* @__PURE__ */ new Vector3();
var _center = /* @__PURE__ */ new Vector3();
var _extents = /* @__PURE__ */ new Vector3();
var _triangleNormal = /* @__PURE__ */ new Vector3();
var _testAxis = /* @__PURE__ */ new Vector3();
function satForAxes(axes, v0, v1, v2, extents) {
  for (let i2 = 0, j = axes.length - 3; i2 <= j; i2 += 3) {
    _testAxis.fromArray(axes, i2);
    const r = extents.x * Math.abs(_testAxis.x) + extents.y * Math.abs(_testAxis.y) + extents.z * Math.abs(_testAxis.z);
    const p0 = v0.dot(_testAxis);
    const p1 = v1.dot(_testAxis);
    const p2 = v2.dot(_testAxis);
    if (Math.max(-Math.max(p0, p1, p2), Math.min(p0, p1, p2)) > r) {
      return false;
    }
  }
  return true;
}
var _box$2 = /* @__PURE__ */ new Box3();
var _v1$6 = /* @__PURE__ */ new Vector3();
var _toFarthestPoint = /* @__PURE__ */ new Vector3();
var _toPoint = /* @__PURE__ */ new Vector3();
var Sphere = class {
  constructor(center = new Vector3(), radius = -1) {
    this.center = center;
    this.radius = radius;
  }
  set(center, radius) {
    this.center.copy(center);
    this.radius = radius;
    return this;
  }
  setFromPoints(points, optionalCenter) {
    const center = this.center;
    if (optionalCenter !== void 0) {
      center.copy(optionalCenter);
    } else {
      _box$2.setFromPoints(points).getCenter(center);
    }
    let maxRadiusSq = 0;
    for (let i2 = 0, il = points.length; i2 < il; i2++) {
      maxRadiusSq = Math.max(maxRadiusSq, center.distanceToSquared(points[i2]));
    }
    this.radius = Math.sqrt(maxRadiusSq);
    return this;
  }
  copy(sphere) {
    this.center.copy(sphere.center);
    this.radius = sphere.radius;
    return this;
  }
  isEmpty() {
    return this.radius < 0;
  }
  makeEmpty() {
    this.center.set(0, 0, 0);
    this.radius = -1;
    return this;
  }
  containsPoint(point) {
    return point.distanceToSquared(this.center) <= this.radius * this.radius;
  }
  distanceToPoint(point) {
    return point.distanceTo(this.center) - this.radius;
  }
  intersectsSphere(sphere) {
    const radiusSum = this.radius + sphere.radius;
    return sphere.center.distanceToSquared(this.center) <= radiusSum * radiusSum;
  }
  intersectsBox(box) {
    return box.intersectsSphere(this);
  }
  intersectsPlane(plane) {
    return Math.abs(plane.distanceToPoint(this.center)) <= this.radius;
  }
  clampPoint(point, target) {
    const deltaLengthSq = this.center.distanceToSquared(point);
    target.copy(point);
    if (deltaLengthSq > this.radius * this.radius) {
      target.sub(this.center).normalize();
      target.multiplyScalar(this.radius).add(this.center);
    }
    return target;
  }
  getBoundingBox(target) {
    if (this.isEmpty()) {
      target.makeEmpty();
      return target;
    }
    target.set(this.center, this.center);
    target.expandByScalar(this.radius);
    return target;
  }
  applyMatrix4(matrix) {
    this.center.applyMatrix4(matrix);
    this.radius = this.radius * matrix.getMaxScaleOnAxis();
    return this;
  }
  translate(offset) {
    this.center.add(offset);
    return this;
  }
  expandByPoint(point) {
    _toPoint.subVectors(point, this.center);
    const lengthSq = _toPoint.lengthSq();
    if (lengthSq > this.radius * this.radius) {
      const length = Math.sqrt(lengthSq);
      const missingRadiusHalf = (length - this.radius) * 0.5;
      this.center.add(_toPoint.multiplyScalar(missingRadiusHalf / length));
      this.radius += missingRadiusHalf;
    }
    return this;
  }
  union(sphere) {
    if (this.center.equals(sphere.center) === true) {
      _toFarthestPoint.set(0, 0, 1).multiplyScalar(sphere.radius);
    } else {
      _toFarthestPoint.subVectors(sphere.center, this.center).normalize().multiplyScalar(sphere.radius);
    }
    this.expandByPoint(_v1$6.copy(sphere.center).add(_toFarthestPoint));
    this.expandByPoint(_v1$6.copy(sphere.center).sub(_toFarthestPoint));
    return this;
  }
  equals(sphere) {
    return sphere.center.equals(this.center) && sphere.radius === this.radius;
  }
  clone() {
    return new this.constructor().copy(this);
  }
};
var _vector$a = /* @__PURE__ */ new Vector3();
var _segCenter = /* @__PURE__ */ new Vector3();
var _segDir = /* @__PURE__ */ new Vector3();
var _diff = /* @__PURE__ */ new Vector3();
var _edge1 = /* @__PURE__ */ new Vector3();
var _edge2 = /* @__PURE__ */ new Vector3();
var _normal$1 = /* @__PURE__ */ new Vector3();
var Ray = class {
  constructor(origin = new Vector3(), direction = new Vector3(0, 0, -1)) {
    this.origin = origin;
    this.direction = direction;
  }
  set(origin, direction) {
    this.origin.copy(origin);
    this.direction.copy(direction);
    return this;
  }
  copy(ray) {
    this.origin.copy(ray.origin);
    this.direction.copy(ray.direction);
    return this;
  }
  at(t, target) {
    return target.copy(this.direction).multiplyScalar(t).add(this.origin);
  }
  lookAt(v) {
    this.direction.copy(v).sub(this.origin).normalize();
    return this;
  }
  recast(t) {
    this.origin.copy(this.at(t, _vector$a));
    return this;
  }
  closestPointToPoint(point, target) {
    target.subVectors(point, this.origin);
    const directionDistance = target.dot(this.direction);
    if (directionDistance < 0) {
      return target.copy(this.origin);
    }
    return target.copy(this.direction).multiplyScalar(directionDistance).add(this.origin);
  }
  distanceToPoint(point) {
    return Math.sqrt(this.distanceSqToPoint(point));
  }
  distanceSqToPoint(point) {
    const directionDistance = _vector$a.subVectors(point, this.origin).dot(this.direction);
    if (directionDistance < 0) {
      return this.origin.distanceToSquared(point);
    }
    _vector$a.copy(this.direction).multiplyScalar(directionDistance).add(this.origin);
    return _vector$a.distanceToSquared(point);
  }
  distanceSqToSegment(v0, v1, optionalPointOnRay, optionalPointOnSegment) {
    _segCenter.copy(v0).add(v1).multiplyScalar(0.5);
    _segDir.copy(v1).sub(v0).normalize();
    _diff.copy(this.origin).sub(_segCenter);
    const segExtent = v0.distanceTo(v1) * 0.5;
    const a01 = -this.direction.dot(_segDir);
    const b0 = _diff.dot(this.direction);
    const b1 = -_diff.dot(_segDir);
    const c = _diff.lengthSq();
    const det = Math.abs(1 - a01 * a01);
    let s0, s1, sqrDist, extDet;
    if (det > 0) {
      s0 = a01 * b1 - b0;
      s1 = a01 * b0 - b1;
      extDet = segExtent * det;
      if (s0 >= 0) {
        if (s1 >= -extDet) {
          if (s1 <= extDet) {
            const invDet = 1 / det;
            s0 *= invDet;
            s1 *= invDet;
            sqrDist = s0 * (s0 + a01 * s1 + 2 * b0) + s1 * (a01 * s0 + s1 + 2 * b1) + c;
          } else {
            s1 = segExtent;
            s0 = Math.max(0, -(a01 * s1 + b0));
            sqrDist = -s0 * s0 + s1 * (s1 + 2 * b1) + c;
          }
        } else {
          s1 = -segExtent;
          s0 = Math.max(0, -(a01 * s1 + b0));
          sqrDist = -s0 * s0 + s1 * (s1 + 2 * b1) + c;
        }
      } else {
        if (s1 <= -extDet) {
          s0 = Math.max(0, -(-a01 * segExtent + b0));
          s1 = s0 > 0 ? -segExtent : Math.min(Math.max(-segExtent, -b1), segExtent);
          sqrDist = -s0 * s0 + s1 * (s1 + 2 * b1) + c;
        } else if (s1 <= extDet) {
          s0 = 0;
          s1 = Math.min(Math.max(-segExtent, -b1), segExtent);
          sqrDist = s1 * (s1 + 2 * b1) + c;
        } else {
          s0 = Math.max(0, -(a01 * segExtent + b0));
          s1 = s0 > 0 ? segExtent : Math.min(Math.max(-segExtent, -b1), segExtent);
          sqrDist = -s0 * s0 + s1 * (s1 + 2 * b1) + c;
        }
      }
    } else {
      s1 = a01 > 0 ? -segExtent : segExtent;
      s0 = Math.max(0, -(a01 * s1 + b0));
      sqrDist = -s0 * s0 + s1 * (s1 + 2 * b1) + c;
    }
    if (optionalPointOnRay) {
      optionalPointOnRay.copy(this.direction).multiplyScalar(s0).add(this.origin);
    }
    if (optionalPointOnSegment) {
      optionalPointOnSegment.copy(_segDir).multiplyScalar(s1).add(_segCenter);
    }
    return sqrDist;
  }
  intersectSphere(sphere, target) {
    _vector$a.subVectors(sphere.center, this.origin);
    const tca = _vector$a.dot(this.direction);
    const d2 = _vector$a.dot(_vector$a) - tca * tca;
    const radius2 = sphere.radius * sphere.radius;
    if (d2 > radius2)
      return null;
    const thc = Math.sqrt(radius2 - d2);
    const t0 = tca - thc;
    const t1 = tca + thc;
    if (t0 < 0 && t1 < 0)
      return null;
    if (t0 < 0)
      return this.at(t1, target);
    return this.at(t0, target);
  }
  intersectsSphere(sphere) {
    return this.distanceSqToPoint(sphere.center) <= sphere.radius * sphere.radius;
  }
  distanceToPlane(plane) {
    const denominator = plane.normal.dot(this.direction);
    if (denominator === 0) {
      if (plane.distanceToPoint(this.origin) === 0) {
        return 0;
      }
      return null;
    }
    const t = -(this.origin.dot(plane.normal) + plane.constant) / denominator;
    return t >= 0 ? t : null;
  }
  intersectPlane(plane, target) {
    const t = this.distanceToPlane(plane);
    if (t === null) {
      return null;
    }
    return this.at(t, target);
  }
  intersectsPlane(plane) {
    const distToPoint = plane.distanceToPoint(this.origin);
    if (distToPoint === 0) {
      return true;
    }
    const denominator = plane.normal.dot(this.direction);
    if (denominator * distToPoint < 0) {
      return true;
    }
    return false;
  }
  intersectBox(box, target) {
    let tmin, tmax, tymin, tymax, tzmin, tzmax;
    const invdirx = 1 / this.direction.x, invdiry = 1 / this.direction.y, invdirz = 1 / this.direction.z;
    const origin = this.origin;
    if (invdirx >= 0) {
      tmin = (box.min.x - origin.x) * invdirx;
      tmax = (box.max.x - origin.x) * invdirx;
    } else {
      tmin = (box.max.x - origin.x) * invdirx;
      tmax = (box.min.x - origin.x) * invdirx;
    }
    if (invdiry >= 0) {
      tymin = (box.min.y - origin.y) * invdiry;
      tymax = (box.max.y - origin.y) * invdiry;
    } else {
      tymin = (box.max.y - origin.y) * invdiry;
      tymax = (box.min.y - origin.y) * invdiry;
    }
    if (tmin > tymax || tymin > tmax)
      return null;
    if (tymin > tmin || tmin !== tmin)
      tmin = tymin;
    if (tymax < tmax || tmax !== tmax)
      tmax = tymax;
    if (invdirz >= 0) {
      tzmin = (box.min.z - origin.z) * invdirz;
      tzmax = (box.max.z - origin.z) * invdirz;
    } else {
      tzmin = (box.max.z - origin.z) * invdirz;
      tzmax = (box.min.z - origin.z) * invdirz;
    }
    if (tmin > tzmax || tzmin > tmax)
      return null;
    if (tzmin > tmin || tmin !== tmin)
      tmin = tzmin;
    if (tzmax < tmax || tmax !== tmax)
      tmax = tzmax;
    if (tmax < 0)
      return null;
    return this.at(tmin >= 0 ? tmin : tmax, target);
  }
  intersectsBox(box) {
    return this.intersectBox(box, _vector$a) !== null;
  }
  intersectTriangle(a, b, c, backfaceCulling, target) {
    _edge1.subVectors(b, a);
    _edge2.subVectors(c, a);
    _normal$1.crossVectors(_edge1, _edge2);
    let DdN = this.direction.dot(_normal$1);
    let sign;
    if (DdN > 0) {
      if (backfaceCulling)
        return null;
      sign = 1;
    } else if (DdN < 0) {
      sign = -1;
      DdN = -DdN;
    } else {
      return null;
    }
    _diff.subVectors(this.origin, a);
    const DdQxE2 = sign * this.direction.dot(_edge2.crossVectors(_diff, _edge2));
    if (DdQxE2 < 0) {
      return null;
    }
    const DdE1xQ = sign * this.direction.dot(_edge1.cross(_diff));
    if (DdE1xQ < 0) {
      return null;
    }
    if (DdQxE2 + DdE1xQ > DdN) {
      return null;
    }
    const QdN = -sign * _diff.dot(_normal$1);
    if (QdN < 0) {
      return null;
    }
    return this.at(QdN / DdN, target);
  }
  applyMatrix4(matrix4) {
    this.origin.applyMatrix4(matrix4);
    this.direction.transformDirection(matrix4);
    return this;
  }
  equals(ray) {
    return ray.origin.equals(this.origin) && ray.direction.equals(this.direction);
  }
  clone() {
    return new this.constructor().copy(this);
  }
};
var Matrix4 = class {
  constructor() {
    Matrix4.prototype.isMatrix4 = true;
    this.elements = [
      1,
      0,
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      0,
      1
    ];
  }
  set(n11, n12, n13, n14, n21, n22, n23, n24, n31, n32, n33, n34, n41, n42, n43, n44) {
    const te = this.elements;
    te[0] = n11;
    te[4] = n12;
    te[8] = n13;
    te[12] = n14;
    te[1] = n21;
    te[5] = n22;
    te[9] = n23;
    te[13] = n24;
    te[2] = n31;
    te[6] = n32;
    te[10] = n33;
    te[14] = n34;
    te[3] = n41;
    te[7] = n42;
    te[11] = n43;
    te[15] = n44;
    return this;
  }
  identity() {
    this.set(
      1,
      0,
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      0,
      1
    );
    return this;
  }
  clone() {
    return new Matrix4().fromArray(this.elements);
  }
  copy(m) {
    const te = this.elements;
    const me = m.elements;
    te[0] = me[0];
    te[1] = me[1];
    te[2] = me[2];
    te[3] = me[3];
    te[4] = me[4];
    te[5] = me[5];
    te[6] = me[6];
    te[7] = me[7];
    te[8] = me[8];
    te[9] = me[9];
    te[10] = me[10];
    te[11] = me[11];
    te[12] = me[12];
    te[13] = me[13];
    te[14] = me[14];
    te[15] = me[15];
    return this;
  }
  copyPosition(m) {
    const te = this.elements, me = m.elements;
    te[12] = me[12];
    te[13] = me[13];
    te[14] = me[14];
    return this;
  }
  setFromMatrix3(m) {
    const me = m.elements;
    this.set(
      me[0],
      me[3],
      me[6],
      0,
      me[1],
      me[4],
      me[7],
      0,
      me[2],
      me[5],
      me[8],
      0,
      0,
      0,
      0,
      1
    );
    return this;
  }
  extractBasis(xAxis, yAxis, zAxis) {
    xAxis.setFromMatrixColumn(this, 0);
    yAxis.setFromMatrixColumn(this, 1);
    zAxis.setFromMatrixColumn(this, 2);
    return this;
  }
  makeBasis(xAxis, yAxis, zAxis) {
    this.set(
      xAxis.x,
      yAxis.x,
      zAxis.x,
      0,
      xAxis.y,
      yAxis.y,
      zAxis.y,
      0,
      xAxis.z,
      yAxis.z,
      zAxis.z,
      0,
      0,
      0,
      0,
      1
    );
    return this;
  }
  extractRotation(m) {
    const te = this.elements;
    const me = m.elements;
    const scaleX = 1 / _v1$5.setFromMatrixColumn(m, 0).length();
    const scaleY = 1 / _v1$5.setFromMatrixColumn(m, 1).length();
    const scaleZ = 1 / _v1$5.setFromMatrixColumn(m, 2).length();
    te[0] = me[0] * scaleX;
    te[1] = me[1] * scaleX;
    te[2] = me[2] * scaleX;
    te[3] = 0;
    te[4] = me[4] * scaleY;
    te[5] = me[5] * scaleY;
    te[6] = me[6] * scaleY;
    te[7] = 0;
    te[8] = me[8] * scaleZ;
    te[9] = me[9] * scaleZ;
    te[10] = me[10] * scaleZ;
    te[11] = 0;
    te[12] = 0;
    te[13] = 0;
    te[14] = 0;
    te[15] = 1;
    return this;
  }
  makeRotationFromEuler(euler) {
    const te = this.elements;
    const x = euler.x, y = euler.y, z = euler.z;
    const a = Math.cos(x), b = Math.sin(x);
    const c = Math.cos(y), d = Math.sin(y);
    const e = Math.cos(z), f = Math.sin(z);
    if (euler.order === "XYZ") {
      const ae = a * e, af = a * f, be = b * e, bf = b * f;
      te[0] = c * e;
      te[4] = -c * f;
      te[8] = d;
      te[1] = af + be * d;
      te[5] = ae - bf * d;
      te[9] = -b * c;
      te[2] = bf - ae * d;
      te[6] = be + af * d;
      te[10] = a * c;
    } else if (euler.order === "YXZ") {
      const ce = c * e, cf = c * f, de = d * e, df = d * f;
      te[0] = ce + df * b;
      te[4] = de * b - cf;
      te[8] = a * d;
      te[1] = a * f;
      te[5] = a * e;
      te[9] = -b;
      te[2] = cf * b - de;
      te[6] = df + ce * b;
      te[10] = a * c;
    } else if (euler.order === "ZXY") {
      const ce = c * e, cf = c * f, de = d * e, df = d * f;
      te[0] = ce - df * b;
      te[4] = -a * f;
      te[8] = de + cf * b;
      te[1] = cf + de * b;
      te[5] = a * e;
      te[9] = df - ce * b;
      te[2] = -a * d;
      te[6] = b;
      te[10] = a * c;
    } else if (euler.order === "ZYX") {
      const ae = a * e, af = a * f, be = b * e, bf = b * f;
      te[0] = c * e;
      te[4] = be * d - af;
      te[8] = ae * d + bf;
      te[1] = c * f;
      te[5] = bf * d + ae;
      te[9] = af * d - be;
      te[2] = -d;
      te[6] = b * c;
      te[10] = a * c;
    } else if (euler.order === "YZX") {
      const ac = a * c, ad = a * d, bc = b * c, bd = b * d;
      te[0] = c * e;
      te[4] = bd - ac * f;
      te[8] = bc * f + ad;
      te[1] = f;
      te[5] = a * e;
      te[9] = -b * e;
      te[2] = -d * e;
      te[6] = ad * f + bc;
      te[10] = ac - bd * f;
    } else if (euler.order === "XZY") {
      const ac = a * c, ad = a * d, bc = b * c, bd = b * d;
      te[0] = c * e;
      te[4] = -f;
      te[8] = d * e;
      te[1] = ac * f + bd;
      te[5] = a * e;
      te[9] = ad * f - bc;
      te[2] = bc * f - ad;
      te[6] = b * e;
      te[10] = bd * f + ac;
    }
    te[3] = 0;
    te[7] = 0;
    te[11] = 0;
    te[12] = 0;
    te[13] = 0;
    te[14] = 0;
    te[15] = 1;
    return this;
  }
  makeRotationFromQuaternion(q) {
    return this.compose(_zero, q, _one);
  }
  lookAt(eye, target, up) {
    const te = this.elements;
    _z.subVectors(eye, target);
    if (_z.lengthSq() === 0) {
      _z.z = 1;
    }
    _z.normalize();
    _x.crossVectors(up, _z);
    if (_x.lengthSq() === 0) {
      if (Math.abs(up.z) === 1) {
        _z.x += 1e-4;
      } else {
        _z.z += 1e-4;
      }
      _z.normalize();
      _x.crossVectors(up, _z);
    }
    _x.normalize();
    _y.crossVectors(_z, _x);
    te[0] = _x.x;
    te[4] = _y.x;
    te[8] = _z.x;
    te[1] = _x.y;
    te[5] = _y.y;
    te[9] = _z.y;
    te[2] = _x.z;
    te[6] = _y.z;
    te[10] = _z.z;
    return this;
  }
  multiply(m) {
    return this.multiplyMatrices(this, m);
  }
  premultiply(m) {
    return this.multiplyMatrices(m, this);
  }
  multiplyMatrices(a, b) {
    const ae = a.elements;
    const be = b.elements;
    const te = this.elements;
    const a11 = ae[0], a12 = ae[4], a13 = ae[8], a14 = ae[12];
    const a21 = ae[1], a22 = ae[5], a23 = ae[9], a24 = ae[13];
    const a31 = ae[2], a32 = ae[6], a33 = ae[10], a34 = ae[14];
    const a41 = ae[3], a42 = ae[7], a43 = ae[11], a44 = ae[15];
    const b11 = be[0], b12 = be[4], b13 = be[8], b14 = be[12];
    const b21 = be[1], b22 = be[5], b23 = be[9], b24 = be[13];
    const b31 = be[2], b32 = be[6], b33 = be[10], b34 = be[14];
    const b41 = be[3], b42 = be[7], b43 = be[11], b44 = be[15];
    te[0] = a11 * b11 + a12 * b21 + a13 * b31 + a14 * b41;
    te[4] = a11 * b12 + a12 * b22 + a13 * b32 + a14 * b42;
    te[8] = a11 * b13 + a12 * b23 + a13 * b33 + a14 * b43;
    te[12] = a11 * b14 + a12 * b24 + a13 * b34 + a14 * b44;
    te[1] = a21 * b11 + a22 * b21 + a23 * b31 + a24 * b41;
    te[5] = a21 * b12 + a22 * b22 + a23 * b32 + a24 * b42;
    te[9] = a21 * b13 + a22 * b23 + a23 * b33 + a24 * b43;
    te[13] = a21 * b14 + a22 * b24 + a23 * b34 + a24 * b44;
    te[2] = a31 * b11 + a32 * b21 + a33 * b31 + a34 * b41;
    te[6] = a31 * b12 + a32 * b22 + a33 * b32 + a34 * b42;
    te[10] = a31 * b13 + a32 * b23 + a33 * b33 + a34 * b43;
    te[14] = a31 * b14 + a32 * b24 + a33 * b34 + a34 * b44;
    te[3] = a41 * b11 + a42 * b21 + a43 * b31 + a44 * b41;
    te[7] = a41 * b12 + a42 * b22 + a43 * b32 + a44 * b42;
    te[11] = a41 * b13 + a42 * b23 + a43 * b33 + a44 * b43;
    te[15] = a41 * b14 + a42 * b24 + a43 * b34 + a44 * b44;
    return this;
  }
  multiplyScalar(s) {
    const te = this.elements;
    te[0] *= s;
    te[4] *= s;
    te[8] *= s;
    te[12] *= s;
    te[1] *= s;
    te[5] *= s;
    te[9] *= s;
    te[13] *= s;
    te[2] *= s;
    te[6] *= s;
    te[10] *= s;
    te[14] *= s;
    te[3] *= s;
    te[7] *= s;
    te[11] *= s;
    te[15] *= s;
    return this;
  }
  determinant() {
    const te = this.elements;
    const n11 = te[0], n12 = te[4], n13 = te[8], n14 = te[12];
    const n21 = te[1], n22 = te[5], n23 = te[9], n24 = te[13];
    const n31 = te[2], n32 = te[6], n33 = te[10], n34 = te[14];
    const n41 = te[3], n42 = te[7], n43 = te[11], n44 = te[15];
    return n41 * (+n14 * n23 * n32 - n13 * n24 * n32 - n14 * n22 * n33 + n12 * n24 * n33 + n13 * n22 * n34 - n12 * n23 * n34) + n42 * (+n11 * n23 * n34 - n11 * n24 * n33 + n14 * n21 * n33 - n13 * n21 * n34 + n13 * n24 * n31 - n14 * n23 * n31) + n43 * (+n11 * n24 * n32 - n11 * n22 * n34 - n14 * n21 * n32 + n12 * n21 * n34 + n14 * n22 * n31 - n12 * n24 * n31) + n44 * (-n13 * n22 * n31 - n11 * n23 * n32 + n11 * n22 * n33 + n13 * n21 * n32 - n12 * n21 * n33 + n12 * n23 * n31);
  }
  transpose() {
    const te = this.elements;
    let tmp;
    tmp = te[1];
    te[1] = te[4];
    te[4] = tmp;
    tmp = te[2];
    te[2] = te[8];
    te[8] = tmp;
    tmp = te[6];
    te[6] = te[9];
    te[9] = tmp;
    tmp = te[3];
    te[3] = te[12];
    te[12] = tmp;
    tmp = te[7];
    te[7] = te[13];
    te[13] = tmp;
    tmp = te[11];
    te[11] = te[14];
    te[14] = tmp;
    return this;
  }
  setPosition(x, y, z) {
    const te = this.elements;
    if (x.isVector3) {
      te[12] = x.x;
      te[13] = x.y;
      te[14] = x.z;
    } else {
      te[12] = x;
      te[13] = y;
      te[14] = z;
    }
    return this;
  }
  invert() {
    const te = this.elements, n11 = te[0], n21 = te[1], n31 = te[2], n41 = te[3], n12 = te[4], n22 = te[5], n32 = te[6], n42 = te[7], n13 = te[8], n23 = te[9], n33 = te[10], n43 = te[11], n14 = te[12], n24 = te[13], n34 = te[14], n44 = te[15], t11 = n23 * n34 * n42 - n24 * n33 * n42 + n24 * n32 * n43 - n22 * n34 * n43 - n23 * n32 * n44 + n22 * n33 * n44, t12 = n14 * n33 * n42 - n13 * n34 * n42 - n14 * n32 * n43 + n12 * n34 * n43 + n13 * n32 * n44 - n12 * n33 * n44, t13 = n13 * n24 * n42 - n14 * n23 * n42 + n14 * n22 * n43 - n12 * n24 * n43 - n13 * n22 * n44 + n12 * n23 * n44, t14 = n14 * n23 * n32 - n13 * n24 * n32 - n14 * n22 * n33 + n12 * n24 * n33 + n13 * n22 * n34 - n12 * n23 * n34;
    const det = n11 * t11 + n21 * t12 + n31 * t13 + n41 * t14;
    if (det === 0)
      return this.set(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);
    const detInv = 1 / det;
    te[0] = t11 * detInv;
    te[1] = (n24 * n33 * n41 - n23 * n34 * n41 - n24 * n31 * n43 + n21 * n34 * n43 + n23 * n31 * n44 - n21 * n33 * n44) * detInv;
    te[2] = (n22 * n34 * n41 - n24 * n32 * n41 + n24 * n31 * n42 - n21 * n34 * n42 - n22 * n31 * n44 + n21 * n32 * n44) * detInv;
    te[3] = (n23 * n32 * n41 - n22 * n33 * n41 - n23 * n31 * n42 + n21 * n33 * n42 + n22 * n31 * n43 - n21 * n32 * n43) * detInv;
    te[4] = t12 * detInv;
    te[5] = (n13 * n34 * n41 - n14 * n33 * n41 + n14 * n31 * n43 - n11 * n34 * n43 - n13 * n31 * n44 + n11 * n33 * n44) * detInv;
    te[6] = (n14 * n32 * n41 - n12 * n34 * n41 - n14 * n31 * n42 + n11 * n34 * n42 + n12 * n31 * n44 - n11 * n32 * n44) * detInv;
    te[7] = (n12 * n33 * n41 - n13 * n32 * n41 + n13 * n31 * n42 - n11 * n33 * n42 - n12 * n31 * n43 + n11 * n32 * n43) * detInv;
    te[8] = t13 * detInv;
    te[9] = (n14 * n23 * n41 - n13 * n24 * n41 - n14 * n21 * n43 + n11 * n24 * n43 + n13 * n21 * n44 - n11 * n23 * n44) * detInv;
    te[10] = (n12 * n24 * n41 - n14 * n22 * n41 + n14 * n21 * n42 - n11 * n24 * n42 - n12 * n21 * n44 + n11 * n22 * n44) * detInv;
    te[11] = (n13 * n22 * n41 - n12 * n23 * n41 - n13 * n21 * n42 + n11 * n23 * n42 + n12 * n21 * n43 - n11 * n22 * n43) * detInv;
    te[12] = t14 * detInv;
    te[13] = (n13 * n24 * n31 - n14 * n23 * n31 + n14 * n21 * n33 - n11 * n24 * n33 - n13 * n21 * n34 + n11 * n23 * n34) * detInv;
    te[14] = (n14 * n22 * n31 - n12 * n24 * n31 - n14 * n21 * n32 + n11 * n24 * n32 + n12 * n21 * n34 - n11 * n22 * n34) * detInv;
    te[15] = (n12 * n23 * n31 - n13 * n22 * n31 + n13 * n21 * n32 - n11 * n23 * n32 - n12 * n21 * n33 + n11 * n22 * n33) * detInv;
    return this;
  }
  scale(v) {
    const te = this.elements;
    const x = v.x, y = v.y, z = v.z;
    te[0] *= x;
    te[4] *= y;
    te[8] *= z;
    te[1] *= x;
    te[5] *= y;
    te[9] *= z;
    te[2] *= x;
    te[6] *= y;
    te[10] *= z;
    te[3] *= x;
    te[7] *= y;
    te[11] *= z;
    return this;
  }
  getMaxScaleOnAxis() {
    const te = this.elements;
    const scaleXSq = te[0] * te[0] + te[1] * te[1] + te[2] * te[2];
    const scaleYSq = te[4] * te[4] + te[5] * te[5] + te[6] * te[6];
    const scaleZSq = te[8] * te[8] + te[9] * te[9] + te[10] * te[10];
    return Math.sqrt(Math.max(scaleXSq, scaleYSq, scaleZSq));
  }
  makeTranslation(x, y, z) {
    this.set(
      1,
      0,
      0,
      x,
      0,
      1,
      0,
      y,
      0,
      0,
      1,
      z,
      0,
      0,
      0,
      1
    );
    return this;
  }
  makeRotationX(theta) {
    const c = Math.cos(theta), s = Math.sin(theta);
    this.set(
      1,
      0,
      0,
      0,
      0,
      c,
      -s,
      0,
      0,
      s,
      c,
      0,
      0,
      0,
      0,
      1
    );
    return this;
  }
  makeRotationY(theta) {
    const c = Math.cos(theta), s = Math.sin(theta);
    this.set(
      c,
      0,
      s,
      0,
      0,
      1,
      0,
      0,
      -s,
      0,
      c,
      0,
      0,
      0,
      0,
      1
    );
    return this;
  }
  makeRotationZ(theta) {
    const c = Math.cos(theta), s = Math.sin(theta);
    this.set(
      c,
      -s,
      0,
      0,
      s,
      c,
      0,
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      0,
      1
    );
    return this;
  }
  makeRotationAxis(axis, angle) {
    const c = Math.cos(angle);
    const s = Math.sin(angle);
    const t = 1 - c;
    const x = axis.x, y = axis.y, z = axis.z;
    const tx = t * x, ty = t * y;
    this.set(
      tx * x + c,
      tx * y - s * z,
      tx * z + s * y,
      0,
      tx * y + s * z,
      ty * y + c,
      ty * z - s * x,
      0,
      tx * z - s * y,
      ty * z + s * x,
      t * z * z + c,
      0,
      0,
      0,
      0,
      1
    );
    return this;
  }
  makeScale(x, y, z) {
    this.set(
      x,
      0,
      0,
      0,
      0,
      y,
      0,
      0,
      0,
      0,
      z,
      0,
      0,
      0,
      0,
      1
    );
    return this;
  }
  makeShear(xy, xz, yx, yz, zx, zy) {
    this.set(
      1,
      yx,
      zx,
      0,
      xy,
      1,
      zy,
      0,
      xz,
      yz,
      1,
      0,
      0,
      0,
      0,
      1
    );
    return this;
  }
  compose(position, quaternion, scale) {
    const te = this.elements;
    const x = quaternion._x, y = quaternion._y, z = quaternion._z, w2 = quaternion._w;
    const x2 = x + x, y2 = y + y, z2 = z + z;
    const xx = x * x2, xy = x * y2, xz = x * z2;
    const yy = y * y2, yz = y * z2, zz = z * z2;
    const wx = w2 * x2, wy = w2 * y2, wz = w2 * z2;
    const sx = scale.x, sy = scale.y, sz = scale.z;
    te[0] = (1 - (yy + zz)) * sx;
    te[1] = (xy + wz) * sx;
    te[2] = (xz - wy) * sx;
    te[3] = 0;
    te[4] = (xy - wz) * sy;
    te[5] = (1 - (xx + zz)) * sy;
    te[6] = (yz + wx) * sy;
    te[7] = 0;
    te[8] = (xz + wy) * sz;
    te[9] = (yz - wx) * sz;
    te[10] = (1 - (xx + yy)) * sz;
    te[11] = 0;
    te[12] = position.x;
    te[13] = position.y;
    te[14] = position.z;
    te[15] = 1;
    return this;
  }
  decompose(position, quaternion, scale) {
    const te = this.elements;
    let sx = _v1$5.set(te[0], te[1], te[2]).length();
    const sy = _v1$5.set(te[4], te[5], te[6]).length();
    const sz = _v1$5.set(te[8], te[9], te[10]).length();
    const det = this.determinant();
    if (det < 0)
      sx = -sx;
    position.x = te[12];
    position.y = te[13];
    position.z = te[14];
    _m1$2.copy(this);
    const invSX = 1 / sx;
    const invSY = 1 / sy;
    const invSZ = 1 / sz;
    _m1$2.elements[0] *= invSX;
    _m1$2.elements[1] *= invSX;
    _m1$2.elements[2] *= invSX;
    _m1$2.elements[4] *= invSY;
    _m1$2.elements[5] *= invSY;
    _m1$2.elements[6] *= invSY;
    _m1$2.elements[8] *= invSZ;
    _m1$2.elements[9] *= invSZ;
    _m1$2.elements[10] *= invSZ;
    quaternion.setFromRotationMatrix(_m1$2);
    scale.x = sx;
    scale.y = sy;
    scale.z = sz;
    return this;
  }
  makePerspective(left, right, top, bottom, near, far) {
    const te = this.elements;
    const x = 2 * near / (right - left);
    const y = 2 * near / (top - bottom);
    const a = (right + left) / (right - left);
    const b = (top + bottom) / (top - bottom);
    const c = -(far + near) / (far - near);
    const d = -2 * far * near / (far - near);
    te[0] = x;
    te[4] = 0;
    te[8] = a;
    te[12] = 0;
    te[1] = 0;
    te[5] = y;
    te[9] = b;
    te[13] = 0;
    te[2] = 0;
    te[6] = 0;
    te[10] = c;
    te[14] = d;
    te[3] = 0;
    te[7] = 0;
    te[11] = -1;
    te[15] = 0;
    return this;
  }
  makeOrthographic(left, right, top, bottom, near, far) {
    const te = this.elements;
    const w2 = 1 / (right - left);
    const h = 1 / (top - bottom);
    const p = 1 / (far - near);
    const x = (right + left) * w2;
    const y = (top + bottom) * h;
    const z = (far + near) * p;
    te[0] = 2 * w2;
    te[4] = 0;
    te[8] = 0;
    te[12] = -x;
    te[1] = 0;
    te[5] = 2 * h;
    te[9] = 0;
    te[13] = -y;
    te[2] = 0;
    te[6] = 0;
    te[10] = -2 * p;
    te[14] = -z;
    te[3] = 0;
    te[7] = 0;
    te[11] = 0;
    te[15] = 1;
    return this;
  }
  equals(matrix) {
    const te = this.elements;
    const me = matrix.elements;
    for (let i2 = 0; i2 < 16; i2++) {
      if (te[i2] !== me[i2])
        return false;
    }
    return true;
  }
  fromArray(array, offset = 0) {
    for (let i2 = 0; i2 < 16; i2++) {
      this.elements[i2] = array[i2 + offset];
    }
    return this;
  }
  toArray(array = [], offset = 0) {
    const te = this.elements;
    array[offset] = te[0];
    array[offset + 1] = te[1];
    array[offset + 2] = te[2];
    array[offset + 3] = te[3];
    array[offset + 4] = te[4];
    array[offset + 5] = te[5];
    array[offset + 6] = te[6];
    array[offset + 7] = te[7];
    array[offset + 8] = te[8];
    array[offset + 9] = te[9];
    array[offset + 10] = te[10];
    array[offset + 11] = te[11];
    array[offset + 12] = te[12];
    array[offset + 13] = te[13];
    array[offset + 14] = te[14];
    array[offset + 15] = te[15];
    return array;
  }
};
var _v1$5 = /* @__PURE__ */ new Vector3();
var _m1$2 = /* @__PURE__ */ new Matrix4();
var _zero = /* @__PURE__ */ new Vector3(0, 0, 0);
var _one = /* @__PURE__ */ new Vector3(1, 1, 1);
var _x = /* @__PURE__ */ new Vector3();
var _y = /* @__PURE__ */ new Vector3();
var _z = /* @__PURE__ */ new Vector3();
var _matrix$1 = /* @__PURE__ */ new Matrix4();
var _quaternion$3 = /* @__PURE__ */ new Quaternion();
var Euler = class {
  constructor(x = 0, y = 0, z = 0, order = Euler.DefaultOrder) {
    this.isEuler = true;
    this._x = x;
    this._y = y;
    this._z = z;
    this._order = order;
  }
  get x() {
    return this._x;
  }
  set x(value) {
    this._x = value;
    this._onChangeCallback();
  }
  get y() {
    return this._y;
  }
  set y(value) {
    this._y = value;
    this._onChangeCallback();
  }
  get z() {
    return this._z;
  }
  set z(value) {
    this._z = value;
    this._onChangeCallback();
  }
  get order() {
    return this._order;
  }
  set order(value) {
    this._order = value;
    this._onChangeCallback();
  }
  set(x, y, z, order = this._order) {
    this._x = x;
    this._y = y;
    this._z = z;
    this._order = order;
    this._onChangeCallback();
    return this;
  }
  clone() {
    return new this.constructor(this._x, this._y, this._z, this._order);
  }
  copy(euler) {
    this._x = euler._x;
    this._y = euler._y;
    this._z = euler._z;
    this._order = euler._order;
    this._onChangeCallback();
    return this;
  }
  setFromRotationMatrix(m, order = this._order, update = true) {
    const te = m.elements;
    const m11 = te[0], m12 = te[4], m13 = te[8];
    const m21 = te[1], m22 = te[5], m23 = te[9];
    const m31 = te[2], m32 = te[6], m33 = te[10];
    switch (order) {
      case "XYZ":
        this._y = Math.asin(clamp(m13, -1, 1));
        if (Math.abs(m13) < 0.9999999) {
          this._x = Math.atan2(-m23, m33);
          this._z = Math.atan2(-m12, m11);
        } else {
          this._x = Math.atan2(m32, m22);
          this._z = 0;
        }
        break;
      case "YXZ":
        this._x = Math.asin(-clamp(m23, -1, 1));
        if (Math.abs(m23) < 0.9999999) {
          this._y = Math.atan2(m13, m33);
          this._z = Math.atan2(m21, m22);
        } else {
          this._y = Math.atan2(-m31, m11);
          this._z = 0;
        }
        break;
      case "ZXY":
        this._x = Math.asin(clamp(m32, -1, 1));
        if (Math.abs(m32) < 0.9999999) {
          this._y = Math.atan2(-m31, m33);
          this._z = Math.atan2(-m12, m22);
        } else {
          this._y = 0;
          this._z = Math.atan2(m21, m11);
        }
        break;
      case "ZYX":
        this._y = Math.asin(-clamp(m31, -1, 1));
        if (Math.abs(m31) < 0.9999999) {
          this._x = Math.atan2(m32, m33);
          this._z = Math.atan2(m21, m11);
        } else {
          this._x = 0;
          this._z = Math.atan2(-m12, m22);
        }
        break;
      case "YZX":
        this._z = Math.asin(clamp(m21, -1, 1));
        if (Math.abs(m21) < 0.9999999) {
          this._x = Math.atan2(-m23, m22);
          this._y = Math.atan2(-m31, m11);
        } else {
          this._x = 0;
          this._y = Math.atan2(m13, m33);
        }
        break;
      case "XZY":
        this._z = Math.asin(-clamp(m12, -1, 1));
        if (Math.abs(m12) < 0.9999999) {
          this._x = Math.atan2(m32, m22);
          this._y = Math.atan2(m13, m11);
        } else {
          this._x = Math.atan2(-m23, m33);
          this._y = 0;
        }
        break;
      default:
        console.warn("THREE.Euler: .setFromRotationMatrix() encountered an unknown order: " + order);
    }
    this._order = order;
    if (update === true)
      this._onChangeCallback();
    return this;
  }
  setFromQuaternion(q, order, update) {
    _matrix$1.makeRotationFromQuaternion(q);
    return this.setFromRotationMatrix(_matrix$1, order, update);
  }
  setFromVector3(v, order = this._order) {
    return this.set(v.x, v.y, v.z, order);
  }
  reorder(newOrder) {
    _quaternion$3.setFromEuler(this);
    return this.setFromQuaternion(_quaternion$3, newOrder);
  }
  equals(euler) {
    return euler._x === this._x && euler._y === this._y && euler._z === this._z && euler._order === this._order;
  }
  fromArray(array) {
    this._x = array[0];
    this._y = array[1];
    this._z = array[2];
    if (array[3] !== void 0)
      this._order = array[3];
    this._onChangeCallback();
    return this;
  }
  toArray(array = [], offset = 0) {
    array[offset] = this._x;
    array[offset + 1] = this._y;
    array[offset + 2] = this._z;
    array[offset + 3] = this._order;
    return array;
  }
  _onChange(callback) {
    this._onChangeCallback = callback;
    return this;
  }
  _onChangeCallback() {
  }
  *[Symbol.iterator]() {
    yield this._x;
    yield this._y;
    yield this._z;
    yield this._order;
  }
  toVector3() {
    console.error("THREE.Euler: .toVector3() has been removed. Use Vector3.setFromEuler() instead");
  }
};
Euler.DefaultOrder = "XYZ";
Euler.RotationOrders = ["XYZ", "YZX", "ZXY", "XZY", "YXZ", "ZYX"];
var Layers = class {
  constructor() {
    this.mask = 1 | 0;
  }
  set(channel) {
    this.mask = (1 << channel | 0) >>> 0;
  }
  enable(channel) {
    this.mask |= 1 << channel | 0;
  }
  enableAll() {
    this.mask = 4294967295 | 0;
  }
  toggle(channel) {
    this.mask ^= 1 << channel | 0;
  }
  disable(channel) {
    this.mask &= ~(1 << channel | 0);
  }
  disableAll() {
    this.mask = 0;
  }
  test(layers) {
    return (this.mask & layers.mask) !== 0;
  }
  isEnabled(channel) {
    return (this.mask & (1 << channel | 0)) !== 0;
  }
};
var _object3DId = 0;
var _v1$4 = /* @__PURE__ */ new Vector3();
var _q1 = /* @__PURE__ */ new Quaternion();
var _m1$1 = /* @__PURE__ */ new Matrix4();
var _target = /* @__PURE__ */ new Vector3();
var _position$3 = /* @__PURE__ */ new Vector3();
var _scale$2 = /* @__PURE__ */ new Vector3();
var _quaternion$2 = /* @__PURE__ */ new Quaternion();
var _xAxis = /* @__PURE__ */ new Vector3(1, 0, 0);
var _yAxis = /* @__PURE__ */ new Vector3(0, 1, 0);
var _zAxis = /* @__PURE__ */ new Vector3(0, 0, 1);
var _addedEvent = { type: "added" };
var _removedEvent = { type: "removed" };
var Object3D = class extends EventDispatcher {
  constructor() {
    super();
    this.isObject3D = true;
    Object.defineProperty(this, "id", { value: _object3DId++ });
    this.uuid = generateUUID();
    this.name = "";
    this.type = "Object3D";
    this.parent = null;
    this.children = [];
    this.up = Object3D.DefaultUp.clone();
    const position = new Vector3();
    const rotation = new Euler();
    const quaternion = new Quaternion();
    const scale = new Vector3(1, 1, 1);
    function onRotationChange() {
      quaternion.setFromEuler(rotation, false);
    }
    function onQuaternionChange() {
      rotation.setFromQuaternion(quaternion, void 0, false);
    }
    rotation._onChange(onRotationChange);
    quaternion._onChange(onQuaternionChange);
    Object.defineProperties(this, {
      position: {
        configurable: true,
        enumerable: true,
        value: position
      },
      rotation: {
        configurable: true,
        enumerable: true,
        value: rotation
      },
      quaternion: {
        configurable: true,
        enumerable: true,
        value: quaternion
      },
      scale: {
        configurable: true,
        enumerable: true,
        value: scale
      },
      modelViewMatrix: {
        value: new Matrix4()
      },
      normalMatrix: {
        value: new Matrix3()
      }
    });
    this.matrix = new Matrix4();
    this.matrixWorld = new Matrix4();
    this.matrixAutoUpdate = Object3D.DefaultMatrixAutoUpdate;
    this.matrixWorldNeedsUpdate = false;
    this.layers = new Layers();
    this.visible = true;
    this.castShadow = false;
    this.receiveShadow = false;
    this.frustumCulled = true;
    this.renderOrder = 0;
    this.animations = [];
    this.userData = {};
  }
  onBeforeRender() {
  }
  onAfterRender() {
  }
  applyMatrix4(matrix) {
    if (this.matrixAutoUpdate)
      this.updateMatrix();
    this.matrix.premultiply(matrix);
    this.matrix.decompose(this.position, this.quaternion, this.scale);
  }
  applyQuaternion(q) {
    this.quaternion.premultiply(q);
    return this;
  }
  setRotationFromAxisAngle(axis, angle) {
    this.quaternion.setFromAxisAngle(axis, angle);
  }
  setRotationFromEuler(euler) {
    this.quaternion.setFromEuler(euler, true);
  }
  setRotationFromMatrix(m) {
    this.quaternion.setFromRotationMatrix(m);
  }
  setRotationFromQuaternion(q) {
    this.quaternion.copy(q);
  }
  rotateOnAxis(axis, angle) {
    _q1.setFromAxisAngle(axis, angle);
    this.quaternion.multiply(_q1);
    return this;
  }
  rotateOnWorldAxis(axis, angle) {
    _q1.setFromAxisAngle(axis, angle);
    this.quaternion.premultiply(_q1);
    return this;
  }
  rotateX(angle) {
    return this.rotateOnAxis(_xAxis, angle);
  }
  rotateY(angle) {
    return this.rotateOnAxis(_yAxis, angle);
  }
  rotateZ(angle) {
    return this.rotateOnAxis(_zAxis, angle);
  }
  translateOnAxis(axis, distance) {
    _v1$4.copy(axis).applyQuaternion(this.quaternion);
    this.position.add(_v1$4.multiplyScalar(distance));
    return this;
  }
  translateX(distance) {
    return this.translateOnAxis(_xAxis, distance);
  }
  translateY(distance) {
    return this.translateOnAxis(_yAxis, distance);
  }
  translateZ(distance) {
    return this.translateOnAxis(_zAxis, distance);
  }
  localToWorld(vector) {
    return vector.applyMatrix4(this.matrixWorld);
  }
  worldToLocal(vector) {
    return vector.applyMatrix4(_m1$1.copy(this.matrixWorld).invert());
  }
  lookAt(x, y, z) {
    if (x.isVector3) {
      _target.copy(x);
    } else {
      _target.set(x, y, z);
    }
    const parent = this.parent;
    this.updateWorldMatrix(true, false);
    _position$3.setFromMatrixPosition(this.matrixWorld);
    if (this.isCamera || this.isLight) {
      _m1$1.lookAt(_position$3, _target, this.up);
    } else {
      _m1$1.lookAt(_target, _position$3, this.up);
    }
    this.quaternion.setFromRotationMatrix(_m1$1);
    if (parent) {
      _m1$1.extractRotation(parent.matrixWorld);
      _q1.setFromRotationMatrix(_m1$1);
      this.quaternion.premultiply(_q1.invert());
    }
  }
  add(object) {
    if (arguments.length > 1) {
      for (let i2 = 0; i2 < arguments.length; i2++) {
        this.add(arguments[i2]);
      }
      return this;
    }
    if (object === this) {
      console.error("THREE.Object3D.add: object can't be added as a child of itself.", object);
      return this;
    }
    if (object && object.isObject3D) {
      if (object.parent !== null) {
        object.parent.remove(object);
      }
      object.parent = this;
      this.children.push(object);
      object.dispatchEvent(_addedEvent);
    } else {
      console.error("THREE.Object3D.add: object not an instance of THREE.Object3D.", object);
    }
    return this;
  }
  remove(object) {
    if (arguments.length > 1) {
      for (let i2 = 0; i2 < arguments.length; i2++) {
        this.remove(arguments[i2]);
      }
      return this;
    }
    const index = this.children.indexOf(object);
    if (index !== -1) {
      object.parent = null;
      this.children.splice(index, 1);
      object.dispatchEvent(_removedEvent);
    }
    return this;
  }
  removeFromParent() {
    const parent = this.parent;
    if (parent !== null) {
      parent.remove(this);
    }
    return this;
  }
  clear() {
    for (let i2 = 0; i2 < this.children.length; i2++) {
      const object = this.children[i2];
      object.parent = null;
      object.dispatchEvent(_removedEvent);
    }
    this.children.length = 0;
    return this;
  }
  attach(object) {
    this.updateWorldMatrix(true, false);
    _m1$1.copy(this.matrixWorld).invert();
    if (object.parent !== null) {
      object.parent.updateWorldMatrix(true, false);
      _m1$1.multiply(object.parent.matrixWorld);
    }
    object.applyMatrix4(_m1$1);
    this.add(object);
    object.updateWorldMatrix(false, true);
    return this;
  }
  getObjectById(id) {
    return this.getObjectByProperty("id", id);
  }
  getObjectByName(name) {
    return this.getObjectByProperty("name", name);
  }
  getObjectByProperty(name, value) {
    if (this[name] === value)
      return this;
    for (let i2 = 0, l = this.children.length; i2 < l; i2++) {
      const child = this.children[i2];
      const object = child.getObjectByProperty(name, value);
      if (object !== void 0) {
        return object;
      }
    }
    return void 0;
  }
  getWorldPosition(target) {
    this.updateWorldMatrix(true, false);
    return target.setFromMatrixPosition(this.matrixWorld);
  }
  getWorldQuaternion(target) {
    this.updateWorldMatrix(true, false);
    this.matrixWorld.decompose(_position$3, target, _scale$2);
    return target;
  }
  getWorldScale(target) {
    this.updateWorldMatrix(true, false);
    this.matrixWorld.decompose(_position$3, _quaternion$2, target);
    return target;
  }
  getWorldDirection(target) {
    this.updateWorldMatrix(true, false);
    const e = this.matrixWorld.elements;
    return target.set(e[8], e[9], e[10]).normalize();
  }
  raycast() {
  }
  traverse(callback) {
    callback(this);
    const children = this.children;
    for (let i2 = 0, l = children.length; i2 < l; i2++) {
      children[i2].traverse(callback);
    }
  }
  traverseVisible(callback) {
    if (this.visible === false)
      return;
    callback(this);
    const children = this.children;
    for (let i2 = 0, l = children.length; i2 < l; i2++) {
      children[i2].traverseVisible(callback);
    }
  }
  traverseAncestors(callback) {
    const parent = this.parent;
    if (parent !== null) {
      callback(parent);
      parent.traverseAncestors(callback);
    }
  }
  updateMatrix() {
    this.matrix.compose(this.position, this.quaternion, this.scale);
    this.matrixWorldNeedsUpdate = true;
  }
  updateMatrixWorld(force) {
    if (this.matrixAutoUpdate)
      this.updateMatrix();
    if (this.matrixWorldNeedsUpdate || force) {
      if (this.parent === null) {
        this.matrixWorld.copy(this.matrix);
      } else {
        this.matrixWorld.multiplyMatrices(this.parent.matrixWorld, this.matrix);
      }
      this.matrixWorldNeedsUpdate = false;
      force = true;
    }
    const children = this.children;
    for (let i2 = 0, l = children.length; i2 < l; i2++) {
      children[i2].updateMatrixWorld(force);
    }
  }
  updateWorldMatrix(updateParents, updateChildren) {
    const parent = this.parent;
    if (updateParents === true && parent !== null) {
      parent.updateWorldMatrix(true, false);
    }
    if (this.matrixAutoUpdate)
      this.updateMatrix();
    if (this.parent === null) {
      this.matrixWorld.copy(this.matrix);
    } else {
      this.matrixWorld.multiplyMatrices(this.parent.matrixWorld, this.matrix);
    }
    if (updateChildren === true) {
      const children = this.children;
      for (let i2 = 0, l = children.length; i2 < l; i2++) {
        children[i2].updateWorldMatrix(false, true);
      }
    }
  }
  toJSON(meta) {
    const isRootObject = meta === void 0 || typeof meta === "string";
    const output = {};
    if (isRootObject) {
      meta = {
        geometries: {},
        materials: {},
        textures: {},
        images: {},
        shapes: {},
        skeletons: {},
        animations: {},
        nodes: {}
      };
      output.metadata = {
        version: 4.5,
        type: "Object",
        generator: "Object3D.toJSON"
      };
    }
    const object = {};
    object.uuid = this.uuid;
    object.type = this.type;
    if (this.name !== "")
      object.name = this.name;
    if (this.castShadow === true)
      object.castShadow = true;
    if (this.receiveShadow === true)
      object.receiveShadow = true;
    if (this.visible === false)
      object.visible = false;
    if (this.frustumCulled === false)
      object.frustumCulled = false;
    if (this.renderOrder !== 0)
      object.renderOrder = this.renderOrder;
    if (JSON.stringify(this.userData) !== "{}")
      object.userData = this.userData;
    object.layers = this.layers.mask;
    object.matrix = this.matrix.toArray();
    if (this.matrixAutoUpdate === false)
      object.matrixAutoUpdate = false;
    if (this.isInstancedMesh) {
      object.type = "InstancedMesh";
      object.count = this.count;
      object.instanceMatrix = this.instanceMatrix.toJSON();
      if (this.instanceColor !== null)
        object.instanceColor = this.instanceColor.toJSON();
    }
    function serialize(library, element) {
      if (library[element.uuid] === void 0) {
        library[element.uuid] = element.toJSON(meta);
      }
      return element.uuid;
    }
    if (this.isScene) {
      if (this.background) {
        if (this.background.isColor) {
          object.background = this.background.toJSON();
        } else if (this.background.isTexture) {
          object.background = this.background.toJSON(meta).uuid;
        }
      }
      if (this.environment && this.environment.isTexture && this.environment.isRenderTargetTexture !== true) {
        object.environment = this.environment.toJSON(meta).uuid;
      }
    } else if (this.isMesh || this.isLine || this.isPoints) {
      object.geometry = serialize(meta.geometries, this.geometry);
      const parameters = this.geometry.parameters;
      if (parameters !== void 0 && parameters.shapes !== void 0) {
        const shapes = parameters.shapes;
        if (Array.isArray(shapes)) {
          for (let i2 = 0, l = shapes.length; i2 < l; i2++) {
            const shape = shapes[i2];
            serialize(meta.shapes, shape);
          }
        } else {
          serialize(meta.shapes, shapes);
        }
      }
    }
    if (this.isSkinnedMesh) {
      object.bindMode = this.bindMode;
      object.bindMatrix = this.bindMatrix.toArray();
      if (this.skeleton !== void 0) {
        serialize(meta.skeletons, this.skeleton);
        object.skeleton = this.skeleton.uuid;
      }
    }
    if (this.material !== void 0) {
      if (Array.isArray(this.material)) {
        const uuids = [];
        for (let i2 = 0, l = this.material.length; i2 < l; i2++) {
          uuids.push(serialize(meta.materials, this.material[i2]));
        }
        object.material = uuids;
      } else {
        object.material = serialize(meta.materials, this.material);
      }
    }
    if (this.children.length > 0) {
      object.children = [];
      for (let i2 = 0; i2 < this.children.length; i2++) {
        object.children.push(this.children[i2].toJSON(meta).object);
      }
    }
    if (this.animations.length > 0) {
      object.animations = [];
      for (let i2 = 0; i2 < this.animations.length; i2++) {
        const animation = this.animations[i2];
        object.animations.push(serialize(meta.animations, animation));
      }
    }
    if (isRootObject) {
      const geometries = extractFromCache(meta.geometries);
      const materials = extractFromCache(meta.materials);
      const textures = extractFromCache(meta.textures);
      const images = extractFromCache(meta.images);
      const shapes = extractFromCache(meta.shapes);
      const skeletons = extractFromCache(meta.skeletons);
      const animations = extractFromCache(meta.animations);
      const nodes = extractFromCache(meta.nodes);
      if (geometries.length > 0)
        output.geometries = geometries;
      if (materials.length > 0)
        output.materials = materials;
      if (textures.length > 0)
        output.textures = textures;
      if (images.length > 0)
        output.images = images;
      if (shapes.length > 0)
        output.shapes = shapes;
      if (skeletons.length > 0)
        output.skeletons = skeletons;
      if (animations.length > 0)
        output.animations = animations;
      if (nodes.length > 0)
        output.nodes = nodes;
    }
    output.object = object;
    return output;
    function extractFromCache(cache) {
      const values = [];
      for (const key in cache) {
        const data = cache[key];
        delete data.metadata;
        values.push(data);
      }
      return values;
    }
  }
  clone(recursive) {
    return new this.constructor().copy(this, recursive);
  }
  copy(source, recursive = true) {
    this.name = source.name;
    this.up.copy(source.up);
    this.position.copy(source.position);
    this.rotation.order = source.rotation.order;
    this.quaternion.copy(source.quaternion);
    this.scale.copy(source.scale);
    this.matrix.copy(source.matrix);
    this.matrixWorld.copy(source.matrixWorld);
    this.matrixAutoUpdate = source.matrixAutoUpdate;
    this.matrixWorldNeedsUpdate = source.matrixWorldNeedsUpdate;
    this.layers.mask = source.layers.mask;
    this.visible = source.visible;
    this.castShadow = source.castShadow;
    this.receiveShadow = source.receiveShadow;
    this.frustumCulled = source.frustumCulled;
    this.renderOrder = source.renderOrder;
    this.userData = JSON.parse(JSON.stringify(source.userData));
    if (recursive === true) {
      for (let i2 = 0; i2 < source.children.length; i2++) {
        const child = source.children[i2];
        this.add(child.clone());
      }
    }
    return this;
  }
};
Object3D.DefaultUp = /* @__PURE__ */ new Vector3(0, 1, 0);
Object3D.DefaultMatrixAutoUpdate = true;
var _v0$1 = /* @__PURE__ */ new Vector3();
var _v1$3 = /* @__PURE__ */ new Vector3();
var _v2$2 = /* @__PURE__ */ new Vector3();
var _v3$1 = /* @__PURE__ */ new Vector3();
var _vab = /* @__PURE__ */ new Vector3();
var _vac = /* @__PURE__ */ new Vector3();
var _vbc = /* @__PURE__ */ new Vector3();
var _vap = /* @__PURE__ */ new Vector3();
var _vbp = /* @__PURE__ */ new Vector3();
var _vcp = /* @__PURE__ */ new Vector3();
var Triangle = class {
  constructor(a = new Vector3(), b = new Vector3(), c = new Vector3()) {
    this.a = a;
    this.b = b;
    this.c = c;
  }
  static getNormal(a, b, c, target) {
    target.subVectors(c, b);
    _v0$1.subVectors(a, b);
    target.cross(_v0$1);
    const targetLengthSq = target.lengthSq();
    if (targetLengthSq > 0) {
      return target.multiplyScalar(1 / Math.sqrt(targetLengthSq));
    }
    return target.set(0, 0, 0);
  }
  static getBarycoord(point, a, b, c, target) {
    _v0$1.subVectors(c, a);
    _v1$3.subVectors(b, a);
    _v2$2.subVectors(point, a);
    const dot00 = _v0$1.dot(_v0$1);
    const dot01 = _v0$1.dot(_v1$3);
    const dot02 = _v0$1.dot(_v2$2);
    const dot11 = _v1$3.dot(_v1$3);
    const dot12 = _v1$3.dot(_v2$2);
    const denom = dot00 * dot11 - dot01 * dot01;
    if (denom === 0) {
      return target.set(-2, -1, -1);
    }
    const invDenom = 1 / denom;
    const u = (dot11 * dot02 - dot01 * dot12) * invDenom;
    const v = (dot00 * dot12 - dot01 * dot02) * invDenom;
    return target.set(1 - u - v, v, u);
  }
  static containsPoint(point, a, b, c) {
    this.getBarycoord(point, a, b, c, _v3$1);
    return _v3$1.x >= 0 && _v3$1.y >= 0 && _v3$1.x + _v3$1.y <= 1;
  }
  static getUV(point, p1, p2, p3, uv1, uv2, uv3, target) {
    this.getBarycoord(point, p1, p2, p3, _v3$1);
    target.set(0, 0);
    target.addScaledVector(uv1, _v3$1.x);
    target.addScaledVector(uv2, _v3$1.y);
    target.addScaledVector(uv3, _v3$1.z);
    return target;
  }
  static isFrontFacing(a, b, c, direction) {
    _v0$1.subVectors(c, b);
    _v1$3.subVectors(a, b);
    return _v0$1.cross(_v1$3).dot(direction) < 0 ? true : false;
  }
  set(a, b, c) {
    this.a.copy(a);
    this.b.copy(b);
    this.c.copy(c);
    return this;
  }
  setFromPointsAndIndices(points, i0, i1, i2) {
    this.a.copy(points[i0]);
    this.b.copy(points[i1]);
    this.c.copy(points[i2]);
    return this;
  }
  setFromAttributeAndIndices(attribute, i0, i1, i2) {
    this.a.fromBufferAttribute(attribute, i0);
    this.b.fromBufferAttribute(attribute, i1);
    this.c.fromBufferAttribute(attribute, i2);
    return this;
  }
  clone() {
    return new this.constructor().copy(this);
  }
  copy(triangle) {
    this.a.copy(triangle.a);
    this.b.copy(triangle.b);
    this.c.copy(triangle.c);
    return this;
  }
  getArea() {
    _v0$1.subVectors(this.c, this.b);
    _v1$3.subVectors(this.a, this.b);
    return _v0$1.cross(_v1$3).length() * 0.5;
  }
  getMidpoint(target) {
    return target.addVectors(this.a, this.b).add(this.c).multiplyScalar(1 / 3);
  }
  getNormal(target) {
    return Triangle.getNormal(this.a, this.b, this.c, target);
  }
  getPlane(target) {
    return target.setFromCoplanarPoints(this.a, this.b, this.c);
  }
  getBarycoord(point, target) {
    return Triangle.getBarycoord(point, this.a, this.b, this.c, target);
  }
  getUV(point, uv1, uv2, uv3, target) {
    return Triangle.getUV(point, this.a, this.b, this.c, uv1, uv2, uv3, target);
  }
  containsPoint(point) {
    return Triangle.containsPoint(point, this.a, this.b, this.c);
  }
  isFrontFacing(direction) {
    return Triangle.isFrontFacing(this.a, this.b, this.c, direction);
  }
  intersectsBox(box) {
    return box.intersectsTriangle(this);
  }
  closestPointToPoint(p, target) {
    const a = this.a, b = this.b, c = this.c;
    let v, w2;
    _vab.subVectors(b, a);
    _vac.subVectors(c, a);
    _vap.subVectors(p, a);
    const d1 = _vab.dot(_vap);
    const d2 = _vac.dot(_vap);
    if (d1 <= 0 && d2 <= 0) {
      return target.copy(a);
    }
    _vbp.subVectors(p, b);
    const d3 = _vab.dot(_vbp);
    const d4 = _vac.dot(_vbp);
    if (d3 >= 0 && d4 <= d3) {
      return target.copy(b);
    }
    const vc = d1 * d4 - d3 * d2;
    if (vc <= 0 && d1 >= 0 && d3 <= 0) {
      v = d1 / (d1 - d3);
      return target.copy(a).addScaledVector(_vab, v);
    }
    _vcp.subVectors(p, c);
    const d5 = _vab.dot(_vcp);
    const d6 = _vac.dot(_vcp);
    if (d6 >= 0 && d5 <= d6) {
      return target.copy(c);
    }
    const vb = d5 * d2 - d1 * d6;
    if (vb <= 0 && d2 >= 0 && d6 <= 0) {
      w2 = d2 / (d2 - d6);
      return target.copy(a).addScaledVector(_vac, w2);
    }
    const va = d3 * d6 - d5 * d4;
    if (va <= 0 && d4 - d3 >= 0 && d5 - d6 >= 0) {
      _vbc.subVectors(c, b);
      w2 = (d4 - d3) / (d4 - d3 + (d5 - d6));
      return target.copy(b).addScaledVector(_vbc, w2);
    }
    const denom = 1 / (va + vb + vc);
    v = vb * denom;
    w2 = vc * denom;
    return target.copy(a).addScaledVector(_vab, v).addScaledVector(_vac, w2);
  }
  equals(triangle) {
    return triangle.a.equals(this.a) && triangle.b.equals(this.b) && triangle.c.equals(this.c);
  }
};
var materialId = 0;
var Material = class extends EventDispatcher {
  constructor() {
    super();
    this.isMaterial = true;
    Object.defineProperty(this, "id", { value: materialId++ });
    this.uuid = generateUUID();
    this.name = "";
    this.type = "Material";
    this.blending = NormalBlending;
    this.side = FrontSide;
    this.vertexColors = false;
    this.opacity = 1;
    this.transparent = false;
    this.blendSrc = SrcAlphaFactor;
    this.blendDst = OneMinusSrcAlphaFactor;
    this.blendEquation = AddEquation;
    this.blendSrcAlpha = null;
    this.blendDstAlpha = null;
    this.blendEquationAlpha = null;
    this.depthFunc = LessEqualDepth;
    this.depthTest = true;
    this.depthWrite = true;
    this.stencilWriteMask = 255;
    this.stencilFunc = AlwaysStencilFunc;
    this.stencilRef = 0;
    this.stencilFuncMask = 255;
    this.stencilFail = KeepStencilOp;
    this.stencilZFail = KeepStencilOp;
    this.stencilZPass = KeepStencilOp;
    this.stencilWrite = false;
    this.clippingPlanes = null;
    this.clipIntersection = false;
    this.clipShadows = false;
    this.shadowSide = null;
    this.colorWrite = true;
    this.precision = null;
    this.polygonOffset = false;
    this.polygonOffsetFactor = 0;
    this.polygonOffsetUnits = 0;
    this.dithering = false;
    this.alphaToCoverage = false;
    this.premultipliedAlpha = false;
    this.visible = true;
    this.toneMapped = true;
    this.userData = {};
    this.version = 0;
    this._alphaTest = 0;
  }
  get alphaTest() {
    return this._alphaTest;
  }
  set alphaTest(value) {
    if (this._alphaTest > 0 !== value > 0) {
      this.version++;
    }
    this._alphaTest = value;
  }
  onBuild() {
  }
  onBeforeRender() {
  }
  onBeforeCompile() {
  }
  customProgramCacheKey() {
    return this.onBeforeCompile.toString();
  }
  setValues(values) {
    if (values === void 0)
      return;
    for (const key in values) {
      const newValue = values[key];
      if (newValue === void 0) {
        console.warn("THREE.Material: '" + key + "' parameter is undefined.");
        continue;
      }
      if (key === "shading") {
        console.warn("THREE." + this.type + ": .shading has been removed. Use the boolean .flatShading instead.");
        this.flatShading = newValue === FlatShading ? true : false;
        continue;
      }
      const currentValue = this[key];
      if (currentValue === void 0) {
        console.warn("THREE." + this.type + ": '" + key + "' is not a property of this material.");
        continue;
      }
      if (currentValue && currentValue.isColor) {
        currentValue.set(newValue);
      } else if (currentValue && currentValue.isVector3 && (newValue && newValue.isVector3)) {
        currentValue.copy(newValue);
      } else {
        this[key] = newValue;
      }
    }
  }
  toJSON(meta) {
    const isRootObject = meta === void 0 || typeof meta === "string";
    if (isRootObject) {
      meta = {
        textures: {},
        images: {}
      };
    }
    const data = {
      metadata: {
        version: 4.5,
        type: "Material",
        generator: "Material.toJSON"
      }
    };
    data.uuid = this.uuid;
    data.type = this.type;
    if (this.name !== "")
      data.name = this.name;
    if (this.color && this.color.isColor)
      data.color = this.color.getHex();
    if (this.roughness !== void 0)
      data.roughness = this.roughness;
    if (this.metalness !== void 0)
      data.metalness = this.metalness;
    if (this.sheen !== void 0)
      data.sheen = this.sheen;
    if (this.sheenColor && this.sheenColor.isColor)
      data.sheenColor = this.sheenColor.getHex();
    if (this.sheenRoughness !== void 0)
      data.sheenRoughness = this.sheenRoughness;
    if (this.emissive && this.emissive.isColor)
      data.emissive = this.emissive.getHex();
    if (this.emissiveIntensity && this.emissiveIntensity !== 1)
      data.emissiveIntensity = this.emissiveIntensity;
    if (this.specular && this.specular.isColor)
      data.specular = this.specular.getHex();
    if (this.specularIntensity !== void 0)
      data.specularIntensity = this.specularIntensity;
    if (this.specularColor && this.specularColor.isColor)
      data.specularColor = this.specularColor.getHex();
    if (this.shininess !== void 0)
      data.shininess = this.shininess;
    if (this.clearcoat !== void 0)
      data.clearcoat = this.clearcoat;
    if (this.clearcoatRoughness !== void 0)
      data.clearcoatRoughness = this.clearcoatRoughness;
    if (this.clearcoatMap && this.clearcoatMap.isTexture) {
      data.clearcoatMap = this.clearcoatMap.toJSON(meta).uuid;
    }
    if (this.clearcoatRoughnessMap && this.clearcoatRoughnessMap.isTexture) {
      data.clearcoatRoughnessMap = this.clearcoatRoughnessMap.toJSON(meta).uuid;
    }
    if (this.clearcoatNormalMap && this.clearcoatNormalMap.isTexture) {
      data.clearcoatNormalMap = this.clearcoatNormalMap.toJSON(meta).uuid;
      data.clearcoatNormalScale = this.clearcoatNormalScale.toArray();
    }
    if (this.iridescence !== void 0)
      data.iridescence = this.iridescence;
    if (this.iridescenceIOR !== void 0)
      data.iridescenceIOR = this.iridescenceIOR;
    if (this.iridescenceThicknessRange !== void 0)
      data.iridescenceThicknessRange = this.iridescenceThicknessRange;
    if (this.iridescenceMap && this.iridescenceMap.isTexture) {
      data.iridescenceMap = this.iridescenceMap.toJSON(meta).uuid;
    }
    if (this.iridescenceThicknessMap && this.iridescenceThicknessMap.isTexture) {
      data.iridescenceThicknessMap = this.iridescenceThicknessMap.toJSON(meta).uuid;
    }
    if (this.map && this.map.isTexture)
      data.map = this.map.toJSON(meta).uuid;
    if (this.matcap && this.matcap.isTexture)
      data.matcap = this.matcap.toJSON(meta).uuid;
    if (this.alphaMap && this.alphaMap.isTexture)
      data.alphaMap = this.alphaMap.toJSON(meta).uuid;
    if (this.lightMap && this.lightMap.isTexture) {
      data.lightMap = this.lightMap.toJSON(meta).uuid;
      data.lightMapIntensity = this.lightMapIntensity;
    }
    if (this.aoMap && this.aoMap.isTexture) {
      data.aoMap = this.aoMap.toJSON(meta).uuid;
      data.aoMapIntensity = this.aoMapIntensity;
    }
    if (this.bumpMap && this.bumpMap.isTexture) {
      data.bumpMap = this.bumpMap.toJSON(meta).uuid;
      data.bumpScale = this.bumpScale;
    }
    if (this.normalMap && this.normalMap.isTexture) {
      data.normalMap = this.normalMap.toJSON(meta).uuid;
      data.normalMapType = this.normalMapType;
      data.normalScale = this.normalScale.toArray();
    }
    if (this.displacementMap && this.displacementMap.isTexture) {
      data.displacementMap = this.displacementMap.toJSON(meta).uuid;
      data.displacementScale = this.displacementScale;
      data.displacementBias = this.displacementBias;
    }
    if (this.roughnessMap && this.roughnessMap.isTexture)
      data.roughnessMap = this.roughnessMap.toJSON(meta).uuid;
    if (this.metalnessMap && this.metalnessMap.isTexture)
      data.metalnessMap = this.metalnessMap.toJSON(meta).uuid;
    if (this.emissiveMap && this.emissiveMap.isTexture)
      data.emissiveMap = this.emissiveMap.toJSON(meta).uuid;
    if (this.specularMap && this.specularMap.isTexture)
      data.specularMap = this.specularMap.toJSON(meta).uuid;
    if (this.specularIntensityMap && this.specularIntensityMap.isTexture)
      data.specularIntensityMap = this.specularIntensityMap.toJSON(meta).uuid;
    if (this.specularColorMap && this.specularColorMap.isTexture)
      data.specularColorMap = this.specularColorMap.toJSON(meta).uuid;
    if (this.envMap && this.envMap.isTexture) {
      data.envMap = this.envMap.toJSON(meta).uuid;
      if (this.combine !== void 0)
        data.combine = this.combine;
    }
    if (this.envMapIntensity !== void 0)
      data.envMapIntensity = this.envMapIntensity;
    if (this.reflectivity !== void 0)
      data.reflectivity = this.reflectivity;
    if (this.refractionRatio !== void 0)
      data.refractionRatio = this.refractionRatio;
    if (this.gradientMap && this.gradientMap.isTexture) {
      data.gradientMap = this.gradientMap.toJSON(meta).uuid;
    }
    if (this.transmission !== void 0)
      data.transmission = this.transmission;
    if (this.transmissionMap && this.transmissionMap.isTexture)
      data.transmissionMap = this.transmissionMap.toJSON(meta).uuid;
    if (this.thickness !== void 0)
      data.thickness = this.thickness;
    if (this.thicknessMap && this.thicknessMap.isTexture)
      data.thicknessMap = this.thicknessMap.toJSON(meta).uuid;
    if (this.attenuationDistance !== void 0)
      data.attenuationDistance = this.attenuationDistance;
    if (this.attenuationColor !== void 0)
      data.attenuationColor = this.attenuationColor.getHex();
    if (this.size !== void 0)
      data.size = this.size;
    if (this.shadowSide !== null)
      data.shadowSide = this.shadowSide;
    if (this.sizeAttenuation !== void 0)
      data.sizeAttenuation = this.sizeAttenuation;
    if (this.blending !== NormalBlending)
      data.blending = this.blending;
    if (this.side !== FrontSide)
      data.side = this.side;
    if (this.vertexColors)
      data.vertexColors = true;
    if (this.opacity < 1)
      data.opacity = this.opacity;
    if (this.transparent === true)
      data.transparent = this.transparent;
    data.depthFunc = this.depthFunc;
    data.depthTest = this.depthTest;
    data.depthWrite = this.depthWrite;
    data.colorWrite = this.colorWrite;
    data.stencilWrite = this.stencilWrite;
    data.stencilWriteMask = this.stencilWriteMask;
    data.stencilFunc = this.stencilFunc;
    data.stencilRef = this.stencilRef;
    data.stencilFuncMask = this.stencilFuncMask;
    data.stencilFail = this.stencilFail;
    data.stencilZFail = this.stencilZFail;
    data.stencilZPass = this.stencilZPass;
    if (this.rotation !== void 0 && this.rotation !== 0)
      data.rotation = this.rotation;
    if (this.polygonOffset === true)
      data.polygonOffset = true;
    if (this.polygonOffsetFactor !== 0)
      data.polygonOffsetFactor = this.polygonOffsetFactor;
    if (this.polygonOffsetUnits !== 0)
      data.polygonOffsetUnits = this.polygonOffsetUnits;
    if (this.linewidth !== void 0 && this.linewidth !== 1)
      data.linewidth = this.linewidth;
    if (this.dashSize !== void 0)
      data.dashSize = this.dashSize;
    if (this.gapSize !== void 0)
      data.gapSize = this.gapSize;
    if (this.scale !== void 0)
      data.scale = this.scale;
    if (this.dithering === true)
      data.dithering = true;
    if (this.alphaTest > 0)
      data.alphaTest = this.alphaTest;
    if (this.alphaToCoverage === true)
      data.alphaToCoverage = this.alphaToCoverage;
    if (this.premultipliedAlpha === true)
      data.premultipliedAlpha = this.premultipliedAlpha;
    if (this.wireframe === true)
      data.wireframe = this.wireframe;
    if (this.wireframeLinewidth > 1)
      data.wireframeLinewidth = this.wireframeLinewidth;
    if (this.wireframeLinecap !== "round")
      data.wireframeLinecap = this.wireframeLinecap;
    if (this.wireframeLinejoin !== "round")
      data.wireframeLinejoin = this.wireframeLinejoin;
    if (this.flatShading === true)
      data.flatShading = this.flatShading;
    if (this.visible === false)
      data.visible = false;
    if (this.toneMapped === false)
      data.toneMapped = false;
    if (this.fog === false)
      data.fog = false;
    if (JSON.stringify(this.userData) !== "{}")
      data.userData = this.userData;
    function extractFromCache(cache) {
      const values = [];
      for (const key in cache) {
        const data2 = cache[key];
        delete data2.metadata;
        values.push(data2);
      }
      return values;
    }
    if (isRootObject) {
      const textures = extractFromCache(meta.textures);
      const images = extractFromCache(meta.images);
      if (textures.length > 0)
        data.textures = textures;
      if (images.length > 0)
        data.images = images;
    }
    return data;
  }
  clone() {
    return new this.constructor().copy(this);
  }
  copy(source) {
    this.name = source.name;
    this.blending = source.blending;
    this.side = source.side;
    this.vertexColors = source.vertexColors;
    this.opacity = source.opacity;
    this.transparent = source.transparent;
    this.blendSrc = source.blendSrc;
    this.blendDst = source.blendDst;
    this.blendEquation = source.blendEquation;
    this.blendSrcAlpha = source.blendSrcAlpha;
    this.blendDstAlpha = source.blendDstAlpha;
    this.blendEquationAlpha = source.blendEquationAlpha;
    this.depthFunc = source.depthFunc;
    this.depthTest = source.depthTest;
    this.depthWrite = source.depthWrite;
    this.stencilWriteMask = source.stencilWriteMask;
    this.stencilFunc = source.stencilFunc;
    this.stencilRef = source.stencilRef;
    this.stencilFuncMask = source.stencilFuncMask;
    this.stencilFail = source.stencilFail;
    this.stencilZFail = source.stencilZFail;
    this.stencilZPass = source.stencilZPass;
    this.stencilWrite = source.stencilWrite;
    const srcPlanes = source.clippingPlanes;
    let dstPlanes = null;
    if (srcPlanes !== null) {
      const n = srcPlanes.length;
      dstPlanes = new Array(n);
      for (let i2 = 0; i2 !== n; ++i2) {
        dstPlanes[i2] = srcPlanes[i2].clone();
      }
    }
    this.clippingPlanes = dstPlanes;
    this.clipIntersection = source.clipIntersection;
    this.clipShadows = source.clipShadows;
    this.shadowSide = source.shadowSide;
    this.colorWrite = source.colorWrite;
    this.precision = source.precision;
    this.polygonOffset = source.polygonOffset;
    this.polygonOffsetFactor = source.polygonOffsetFactor;
    this.polygonOffsetUnits = source.polygonOffsetUnits;
    this.dithering = source.dithering;
    this.alphaTest = source.alphaTest;
    this.alphaToCoverage = source.alphaToCoverage;
    this.premultipliedAlpha = source.premultipliedAlpha;
    this.visible = source.visible;
    this.toneMapped = source.toneMapped;
    this.userData = JSON.parse(JSON.stringify(source.userData));
    return this;
  }
  dispose() {
    this.dispatchEvent({ type: "dispose" });
  }
  set needsUpdate(value) {
    if (value === true)
      this.version++;
  }
};
var MeshBasicMaterial = class extends Material {
  constructor(parameters) {
    super();
    this.isMeshBasicMaterial = true;
    this.type = "MeshBasicMaterial";
    this.color = new Color(16777215);
    this.map = null;
    this.lightMap = null;
    this.lightMapIntensity = 1;
    this.aoMap = null;
    this.aoMapIntensity = 1;
    this.specularMap = null;
    this.alphaMap = null;
    this.envMap = null;
    this.combine = MultiplyOperation;
    this.reflectivity = 1;
    this.refractionRatio = 0.98;
    this.wireframe = false;
    this.wireframeLinewidth = 1;
    this.wireframeLinecap = "round";
    this.wireframeLinejoin = "round";
    this.fog = true;
    this.setValues(parameters);
  }
  copy(source) {
    super.copy(source);
    this.color.copy(source.color);
    this.map = source.map;
    this.lightMap = source.lightMap;
    this.lightMapIntensity = source.lightMapIntensity;
    this.aoMap = source.aoMap;
    this.aoMapIntensity = source.aoMapIntensity;
    this.specularMap = source.specularMap;
    this.alphaMap = source.alphaMap;
    this.envMap = source.envMap;
    this.combine = source.combine;
    this.reflectivity = source.reflectivity;
    this.refractionRatio = source.refractionRatio;
    this.wireframe = source.wireframe;
    this.wireframeLinewidth = source.wireframeLinewidth;
    this.wireframeLinecap = source.wireframeLinecap;
    this.wireframeLinejoin = source.wireframeLinejoin;
    this.fog = source.fog;
    return this;
  }
};
var _vector$9 = /* @__PURE__ */ new Vector3();
var _vector2$1 = /* @__PURE__ */ new Vector2();
var BufferAttribute = class {
  constructor(array, itemSize, normalized) {
    if (Array.isArray(array)) {
      throw new TypeError("THREE.BufferAttribute: array should be a Typed Array.");
    }
    this.isBufferAttribute = true;
    this.name = "";
    this.array = array;
    this.itemSize = itemSize;
    this.count = array !== void 0 ? array.length / itemSize : 0;
    this.normalized = normalized === true;
    this.usage = StaticDrawUsage;
    this.updateRange = { offset: 0, count: -1 };
    this.version = 0;
  }
  onUploadCallback() {
  }
  set needsUpdate(value) {
    if (value === true)
      this.version++;
  }
  setUsage(value) {
    this.usage = value;
    return this;
  }
  copy(source) {
    this.name = source.name;
    this.array = new source.array.constructor(source.array);
    this.itemSize = source.itemSize;
    this.count = source.count;
    this.normalized = source.normalized;
    this.usage = source.usage;
    return this;
  }
  copyAt(index1, attribute, index2) {
    index1 *= this.itemSize;
    index2 *= attribute.itemSize;
    for (let i2 = 0, l = this.itemSize; i2 < l; i2++) {
      this.array[index1 + i2] = attribute.array[index2 + i2];
    }
    return this;
  }
  copyArray(array) {
    this.array.set(array);
    return this;
  }
  copyColorsArray(colors) {
    const array = this.array;
    let offset = 0;
    for (let i2 = 0, l = colors.length; i2 < l; i2++) {
      let color = colors[i2];
      if (color === void 0) {
        console.warn("THREE.BufferAttribute.copyColorsArray(): color is undefined", i2);
        color = new Color();
      }
      array[offset++] = color.r;
      array[offset++] = color.g;
      array[offset++] = color.b;
    }
    return this;
  }
  copyVector2sArray(vectors) {
    const array = this.array;
    let offset = 0;
    for (let i2 = 0, l = vectors.length; i2 < l; i2++) {
      let vector = vectors[i2];
      if (vector === void 0) {
        console.warn("THREE.BufferAttribute.copyVector2sArray(): vector is undefined", i2);
        vector = new Vector2();
      }
      array[offset++] = vector.x;
      array[offset++] = vector.y;
    }
    return this;
  }
  copyVector3sArray(vectors) {
    const array = this.array;
    let offset = 0;
    for (let i2 = 0, l = vectors.length; i2 < l; i2++) {
      let vector = vectors[i2];
      if (vector === void 0) {
        console.warn("THREE.BufferAttribute.copyVector3sArray(): vector is undefined", i2);
        vector = new Vector3();
      }
      array[offset++] = vector.x;
      array[offset++] = vector.y;
      array[offset++] = vector.z;
    }
    return this;
  }
  copyVector4sArray(vectors) {
    const array = this.array;
    let offset = 0;
    for (let i2 = 0, l = vectors.length; i2 < l; i2++) {
      let vector = vectors[i2];
      if (vector === void 0) {
        console.warn("THREE.BufferAttribute.copyVector4sArray(): vector is undefined", i2);
        vector = new Vector4();
      }
      array[offset++] = vector.x;
      array[offset++] = vector.y;
      array[offset++] = vector.z;
      array[offset++] = vector.w;
    }
    return this;
  }
  applyMatrix3(m) {
    if (this.itemSize === 2) {
      for (let i2 = 0, l = this.count; i2 < l; i2++) {
        _vector2$1.fromBufferAttribute(this, i2);
        _vector2$1.applyMatrix3(m);
        this.setXY(i2, _vector2$1.x, _vector2$1.y);
      }
    } else if (this.itemSize === 3) {
      for (let i2 = 0, l = this.count; i2 < l; i2++) {
        _vector$9.fromBufferAttribute(this, i2);
        _vector$9.applyMatrix3(m);
        this.setXYZ(i2, _vector$9.x, _vector$9.y, _vector$9.z);
      }
    }
    return this;
  }
  applyMatrix4(m) {
    for (let i2 = 0, l = this.count; i2 < l; i2++) {
      _vector$9.fromBufferAttribute(this, i2);
      _vector$9.applyMatrix4(m);
      this.setXYZ(i2, _vector$9.x, _vector$9.y, _vector$9.z);
    }
    return this;
  }
  applyNormalMatrix(m) {
    for (let i2 = 0, l = this.count; i2 < l; i2++) {
      _vector$9.fromBufferAttribute(this, i2);
      _vector$9.applyNormalMatrix(m);
      this.setXYZ(i2, _vector$9.x, _vector$9.y, _vector$9.z);
    }
    return this;
  }
  transformDirection(m) {
    for (let i2 = 0, l = this.count; i2 < l; i2++) {
      _vector$9.fromBufferAttribute(this, i2);
      _vector$9.transformDirection(m);
      this.setXYZ(i2, _vector$9.x, _vector$9.y, _vector$9.z);
    }
    return this;
  }
  set(value, offset = 0) {
    this.array.set(value, offset);
    return this;
  }
  getX(index) {
    return this.array[index * this.itemSize];
  }
  setX(index, x) {
    this.array[index * this.itemSize] = x;
    return this;
  }
  getY(index) {
    return this.array[index * this.itemSize + 1];
  }
  setY(index, y) {
    this.array[index * this.itemSize + 1] = y;
    return this;
  }
  getZ(index) {
    return this.array[index * this.itemSize + 2];
  }
  setZ(index, z) {
    this.array[index * this.itemSize + 2] = z;
    return this;
  }
  getW(index) {
    return this.array[index * this.itemSize + 3];
  }
  setW(index, w2) {
    this.array[index * this.itemSize + 3] = w2;
    return this;
  }
  setXY(index, x, y) {
    index *= this.itemSize;
    this.array[index + 0] = x;
    this.array[index + 1] = y;
    return this;
  }
  setXYZ(index, x, y, z) {
    index *= this.itemSize;
    this.array[index + 0] = x;
    this.array[index + 1] = y;
    this.array[index + 2] = z;
    return this;
  }
  setXYZW(index, x, y, z, w2) {
    index *= this.itemSize;
    this.array[index + 0] = x;
    this.array[index + 1] = y;
    this.array[index + 2] = z;
    this.array[index + 3] = w2;
    return this;
  }
  onUpload(callback) {
    this.onUploadCallback = callback;
    return this;
  }
  clone() {
    return new this.constructor(this.array, this.itemSize).copy(this);
  }
  toJSON() {
    const data = {
      itemSize: this.itemSize,
      type: this.array.constructor.name,
      array: Array.from(this.array),
      normalized: this.normalized
    };
    if (this.name !== "")
      data.name = this.name;
    if (this.usage !== StaticDrawUsage)
      data.usage = this.usage;
    if (this.updateRange.offset !== 0 || this.updateRange.count !== -1)
      data.updateRange = this.updateRange;
    return data;
  }
};
var Uint16BufferAttribute = class extends BufferAttribute {
  constructor(array, itemSize, normalized) {
    super(new Uint16Array(array), itemSize, normalized);
  }
};
var Uint32BufferAttribute = class extends BufferAttribute {
  constructor(array, itemSize, normalized) {
    super(new Uint32Array(array), itemSize, normalized);
  }
};
var Float32BufferAttribute = class extends BufferAttribute {
  constructor(array, itemSize, normalized) {
    super(new Float32Array(array), itemSize, normalized);
  }
};
var _id$1 = 0;
var _m1 = /* @__PURE__ */ new Matrix4();
var _obj = /* @__PURE__ */ new Object3D();
var _offset = /* @__PURE__ */ new Vector3();
var _box$1 = /* @__PURE__ */ new Box3();
var _boxMorphTargets = /* @__PURE__ */ new Box3();
var _vector$8 = /* @__PURE__ */ new Vector3();
var BufferGeometry = class extends EventDispatcher {
  constructor() {
    super();
    this.isBufferGeometry = true;
    Object.defineProperty(this, "id", { value: _id$1++ });
    this.uuid = generateUUID();
    this.name = "";
    this.type = "BufferGeometry";
    this.index = null;
    this.attributes = {};
    this.morphAttributes = {};
    this.morphTargetsRelative = false;
    this.groups = [];
    this.boundingBox = null;
    this.boundingSphere = null;
    this.drawRange = { start: 0, count: Infinity };
    this.userData = {};
  }
  getIndex() {
    return this.index;
  }
  setIndex(index) {
    if (Array.isArray(index)) {
      this.index = new (arrayNeedsUint32(index) ? Uint32BufferAttribute : Uint16BufferAttribute)(index, 1);
    } else {
      this.index = index;
    }
    return this;
  }
  getAttribute(name) {
    return this.attributes[name];
  }
  setAttribute(name, attribute) {
    this.attributes[name] = attribute;
    return this;
  }
  deleteAttribute(name) {
    delete this.attributes[name];
    return this;
  }
  hasAttribute(name) {
    return this.attributes[name] !== void 0;
  }
  addGroup(start, count, materialIndex = 0) {
    this.groups.push({
      start,
      count,
      materialIndex
    });
  }
  clearGroups() {
    this.groups = [];
  }
  setDrawRange(start, count) {
    this.drawRange.start = start;
    this.drawRange.count = count;
  }
  applyMatrix4(matrix) {
    const position = this.attributes.position;
    if (position !== void 0) {
      position.applyMatrix4(matrix);
      position.needsUpdate = true;
    }
    const normal = this.attributes.normal;
    if (normal !== void 0) {
      const normalMatrix = new Matrix3().getNormalMatrix(matrix);
      normal.applyNormalMatrix(normalMatrix);
      normal.needsUpdate = true;
    }
    const tangent = this.attributes.tangent;
    if (tangent !== void 0) {
      tangent.transformDirection(matrix);
      tangent.needsUpdate = true;
    }
    if (this.boundingBox !== null) {
      this.computeBoundingBox();
    }
    if (this.boundingSphere !== null) {
      this.computeBoundingSphere();
    }
    return this;
  }
  applyQuaternion(q) {
    _m1.makeRotationFromQuaternion(q);
    this.applyMatrix4(_m1);
    return this;
  }
  rotateX(angle) {
    _m1.makeRotationX(angle);
    this.applyMatrix4(_m1);
    return this;
  }
  rotateY(angle) {
    _m1.makeRotationY(angle);
    this.applyMatrix4(_m1);
    return this;
  }
  rotateZ(angle) {
    _m1.makeRotationZ(angle);
    this.applyMatrix4(_m1);
    return this;
  }
  translate(x, y, z) {
    _m1.makeTranslation(x, y, z);
    this.applyMatrix4(_m1);
    return this;
  }
  scale(x, y, z) {
    _m1.makeScale(x, y, z);
    this.applyMatrix4(_m1);
    return this;
  }
  lookAt(vector) {
    _obj.lookAt(vector);
    _obj.updateMatrix();
    this.applyMatrix4(_obj.matrix);
    return this;
  }
  center() {
    this.computeBoundingBox();
    this.boundingBox.getCenter(_offset).negate();
    this.translate(_offset.x, _offset.y, _offset.z);
    return this;
  }
  setFromPoints(points) {
    const position = [];
    for (let i2 = 0, l = points.length; i2 < l; i2++) {
      const point = points[i2];
      position.push(point.x, point.y, point.z || 0);
    }
    this.setAttribute("position", new Float32BufferAttribute(position, 3));
    return this;
  }
  computeBoundingBox() {
    if (this.boundingBox === null) {
      this.boundingBox = new Box3();
    }
    const position = this.attributes.position;
    const morphAttributesPosition = this.morphAttributes.position;
    if (position && position.isGLBufferAttribute) {
      console.error('THREE.BufferGeometry.computeBoundingBox(): GLBufferAttribute requires a manual bounding box. Alternatively set "mesh.frustumCulled" to "false".', this);
      this.boundingBox.set(
        new Vector3(-Infinity, -Infinity, -Infinity),
        new Vector3(Infinity, Infinity, Infinity)
      );
      return;
    }
    if (position !== void 0) {
      this.boundingBox.setFromBufferAttribute(position);
      if (morphAttributesPosition) {
        for (let i2 = 0, il = morphAttributesPosition.length; i2 < il; i2++) {
          const morphAttribute = morphAttributesPosition[i2];
          _box$1.setFromBufferAttribute(morphAttribute);
          if (this.morphTargetsRelative) {
            _vector$8.addVectors(this.boundingBox.min, _box$1.min);
            this.boundingBox.expandByPoint(_vector$8);
            _vector$8.addVectors(this.boundingBox.max, _box$1.max);
            this.boundingBox.expandByPoint(_vector$8);
          } else {
            this.boundingBox.expandByPoint(_box$1.min);
            this.boundingBox.expandByPoint(_box$1.max);
          }
        }
      }
    } else {
      this.boundingBox.makeEmpty();
    }
    if (isNaN(this.boundingBox.min.x) || isNaN(this.boundingBox.min.y) || isNaN(this.boundingBox.min.z)) {
      console.error('THREE.BufferGeometry.computeBoundingBox(): Computed min/max have NaN values. The "position" attribute is likely to have NaN values.', this);
    }
  }
  computeBoundingSphere() {
    if (this.boundingSphere === null) {
      this.boundingSphere = new Sphere();
    }
    const position = this.attributes.position;
    const morphAttributesPosition = this.morphAttributes.position;
    if (position && position.isGLBufferAttribute) {
      console.error('THREE.BufferGeometry.computeBoundingSphere(): GLBufferAttribute requires a manual bounding sphere. Alternatively set "mesh.frustumCulled" to "false".', this);
      this.boundingSphere.set(new Vector3(), Infinity);
      return;
    }
    if (position) {
      const center = this.boundingSphere.center;
      _box$1.setFromBufferAttribute(position);
      if (morphAttributesPosition) {
        for (let i2 = 0, il = morphAttributesPosition.length; i2 < il; i2++) {
          const morphAttribute = morphAttributesPosition[i2];
          _boxMorphTargets.setFromBufferAttribute(morphAttribute);
          if (this.morphTargetsRelative) {
            _vector$8.addVectors(_box$1.min, _boxMorphTargets.min);
            _box$1.expandByPoint(_vector$8);
            _vector$8.addVectors(_box$1.max, _boxMorphTargets.max);
            _box$1.expandByPoint(_vector$8);
          } else {
            _box$1.expandByPoint(_boxMorphTargets.min);
            _box$1.expandByPoint(_boxMorphTargets.max);
          }
        }
      }
      _box$1.getCenter(center);
      let maxRadiusSq = 0;
      for (let i2 = 0, il = position.count; i2 < il; i2++) {
        _vector$8.fromBufferAttribute(position, i2);
        maxRadiusSq = Math.max(maxRadiusSq, center.distanceToSquared(_vector$8));
      }
      if (morphAttributesPosition) {
        for (let i2 = 0, il = morphAttributesPosition.length; i2 < il; i2++) {
          const morphAttribute = morphAttributesPosition[i2];
          const morphTargetsRelative = this.morphTargetsRelative;
          for (let j = 0, jl = morphAttribute.count; j < jl; j++) {
            _vector$8.fromBufferAttribute(morphAttribute, j);
            if (morphTargetsRelative) {
              _offset.fromBufferAttribute(position, j);
              _vector$8.add(_offset);
            }
            maxRadiusSq = Math.max(maxRadiusSq, center.distanceToSquared(_vector$8));
          }
        }
      }
      this.boundingSphere.radius = Math.sqrt(maxRadiusSq);
      if (isNaN(this.boundingSphere.radius)) {
        console.error('THREE.BufferGeometry.computeBoundingSphere(): Computed radius is NaN. The "position" attribute is likely to have NaN values.', this);
      }
    }
  }
  computeTangents() {
    const index = this.index;
    const attributes = this.attributes;
    if (index === null || attributes.position === void 0 || attributes.normal === void 0 || attributes.uv === void 0) {
      console.error("THREE.BufferGeometry: .computeTangents() failed. Missing required attributes (index, position, normal or uv)");
      return;
    }
    const indices = index.array;
    const positions = attributes.position.array;
    const normals = attributes.normal.array;
    const uvs = attributes.uv.array;
    const nVertices = positions.length / 3;
    if (this.hasAttribute("tangent") === false) {
      this.setAttribute("tangent", new BufferAttribute(new Float32Array(4 * nVertices), 4));
    }
    const tangents = this.getAttribute("tangent").array;
    const tan1 = [], tan2 = [];
    for (let i2 = 0; i2 < nVertices; i2++) {
      tan1[i2] = new Vector3();
      tan2[i2] = new Vector3();
    }
    const vA = new Vector3(), vB = new Vector3(), vC = new Vector3(), uvA = new Vector2(), uvB = new Vector2(), uvC = new Vector2(), sdir = new Vector3(), tdir = new Vector3();
    function handleTriangle(a, b, c) {
      vA.fromArray(positions, a * 3);
      vB.fromArray(positions, b * 3);
      vC.fromArray(positions, c * 3);
      uvA.fromArray(uvs, a * 2);
      uvB.fromArray(uvs, b * 2);
      uvC.fromArray(uvs, c * 2);
      vB.sub(vA);
      vC.sub(vA);
      uvB.sub(uvA);
      uvC.sub(uvA);
      const r = 1 / (uvB.x * uvC.y - uvC.x * uvB.y);
      if (!isFinite(r))
        return;
      sdir.copy(vB).multiplyScalar(uvC.y).addScaledVector(vC, -uvB.y).multiplyScalar(r);
      tdir.copy(vC).multiplyScalar(uvB.x).addScaledVector(vB, -uvC.x).multiplyScalar(r);
      tan1[a].add(sdir);
      tan1[b].add(sdir);
      tan1[c].add(sdir);
      tan2[a].add(tdir);
      tan2[b].add(tdir);
      tan2[c].add(tdir);
    }
    let groups = this.groups;
    if (groups.length === 0) {
      groups = [{
        start: 0,
        count: indices.length
      }];
    }
    for (let i2 = 0, il = groups.length; i2 < il; ++i2) {
      const group = groups[i2];
      const start = group.start;
      const count = group.count;
      for (let j = start, jl = start + count; j < jl; j += 3) {
        handleTriangle(
          indices[j + 0],
          indices[j + 1],
          indices[j + 2]
        );
      }
    }
    const tmp = new Vector3(), tmp2 = new Vector3();
    const n = new Vector3(), n2 = new Vector3();
    function handleVertex(v) {
      n.fromArray(normals, v * 3);
      n2.copy(n);
      const t = tan1[v];
      tmp.copy(t);
      tmp.sub(n.multiplyScalar(n.dot(t))).normalize();
      tmp2.crossVectors(n2, t);
      const test = tmp2.dot(tan2[v]);
      const w2 = test < 0 ? -1 : 1;
      tangents[v * 4] = tmp.x;
      tangents[v * 4 + 1] = tmp.y;
      tangents[v * 4 + 2] = tmp.z;
      tangents[v * 4 + 3] = w2;
    }
    for (let i2 = 0, il = groups.length; i2 < il; ++i2) {
      const group = groups[i2];
      const start = group.start;
      const count = group.count;
      for (let j = start, jl = start + count; j < jl; j += 3) {
        handleVertex(indices[j + 0]);
        handleVertex(indices[j + 1]);
        handleVertex(indices[j + 2]);
      }
    }
  }
  computeVertexNormals() {
    const index = this.index;
    const positionAttribute = this.getAttribute("position");
    if (positionAttribute !== void 0) {
      let normalAttribute = this.getAttribute("normal");
      if (normalAttribute === void 0) {
        normalAttribute = new BufferAttribute(new Float32Array(positionAttribute.count * 3), 3);
        this.setAttribute("normal", normalAttribute);
      } else {
        for (let i2 = 0, il = normalAttribute.count; i2 < il; i2++) {
          normalAttribute.setXYZ(i2, 0, 0, 0);
        }
      }
      const pA = new Vector3(), pB = new Vector3(), pC = new Vector3();
      const nA = new Vector3(), nB = new Vector3(), nC = new Vector3();
      const cb = new Vector3(), ab = new Vector3();
      if (index) {
        for (let i2 = 0, il = index.count; i2 < il; i2 += 3) {
          const vA = index.getX(i2 + 0);
          const vB = index.getX(i2 + 1);
          const vC = index.getX(i2 + 2);
          pA.fromBufferAttribute(positionAttribute, vA);
          pB.fromBufferAttribute(positionAttribute, vB);
          pC.fromBufferAttribute(positionAttribute, vC);
          cb.subVectors(pC, pB);
          ab.subVectors(pA, pB);
          cb.cross(ab);
          nA.fromBufferAttribute(normalAttribute, vA);
          nB.fromBufferAttribute(normalAttribute, vB);
          nC.fromBufferAttribute(normalAttribute, vC);
          nA.add(cb);
          nB.add(cb);
          nC.add(cb);
          normalAttribute.setXYZ(vA, nA.x, nA.y, nA.z);
          normalAttribute.setXYZ(vB, nB.x, nB.y, nB.z);
          normalAttribute.setXYZ(vC, nC.x, nC.y, nC.z);
        }
      } else {
        for (let i2 = 0, il = positionAttribute.count; i2 < il; i2 += 3) {
          pA.fromBufferAttribute(positionAttribute, i2 + 0);
          pB.fromBufferAttribute(positionAttribute, i2 + 1);
          pC.fromBufferAttribute(positionAttribute, i2 + 2);
          cb.subVectors(pC, pB);
          ab.subVectors(pA, pB);
          cb.cross(ab);
          normalAttribute.setXYZ(i2 + 0, cb.x, cb.y, cb.z);
          normalAttribute.setXYZ(i2 + 1, cb.x, cb.y, cb.z);
          normalAttribute.setXYZ(i2 + 2, cb.x, cb.y, cb.z);
        }
      }
      this.normalizeNormals();
      normalAttribute.needsUpdate = true;
    }
  }
  merge(geometry, offset) {
    if (!(geometry && geometry.isBufferGeometry)) {
      console.error("THREE.BufferGeometry.merge(): geometry not an instance of THREE.BufferGeometry.", geometry);
      return;
    }
    if (offset === void 0) {
      offset = 0;
      console.warn(
        "THREE.BufferGeometry.merge(): Overwriting original geometry, starting at offset=0. Use BufferGeometryUtils.mergeBufferGeometries() for lossless merge."
      );
    }
    const attributes = this.attributes;
    for (const key in attributes) {
      if (geometry.attributes[key] === void 0)
        continue;
      const attribute1 = attributes[key];
      const attributeArray1 = attribute1.array;
      const attribute2 = geometry.attributes[key];
      const attributeArray2 = attribute2.array;
      const attributeOffset = attribute2.itemSize * offset;
      const length = Math.min(attributeArray2.length, attributeArray1.length - attributeOffset);
      for (let i2 = 0, j = attributeOffset; i2 < length; i2++, j++) {
        attributeArray1[j] = attributeArray2[i2];
      }
    }
    return this;
  }
  normalizeNormals() {
    const normals = this.attributes.normal;
    for (let i2 = 0, il = normals.count; i2 < il; i2++) {
      _vector$8.fromBufferAttribute(normals, i2);
      _vector$8.normalize();
      normals.setXYZ(i2, _vector$8.x, _vector$8.y, _vector$8.z);
    }
  }
  toNonIndexed() {
    function convertBufferAttribute(attribute, indices2) {
      const array = attribute.array;
      const itemSize = attribute.itemSize;
      const normalized = attribute.normalized;
      const array2 = new array.constructor(indices2.length * itemSize);
      let index = 0, index2 = 0;
      for (let i2 = 0, l = indices2.length; i2 < l; i2++) {
        if (attribute.isInterleavedBufferAttribute) {
          index = indices2[i2] * attribute.data.stride + attribute.offset;
        } else {
          index = indices2[i2] * itemSize;
        }
        for (let j = 0; j < itemSize; j++) {
          array2[index2++] = array[index++];
        }
      }
      return new BufferAttribute(array2, itemSize, normalized);
    }
    if (this.index === null) {
      console.warn("THREE.BufferGeometry.toNonIndexed(): BufferGeometry is already non-indexed.");
      return this;
    }
    const geometry2 = new BufferGeometry();
    const indices = this.index.array;
    const attributes = this.attributes;
    for (const name in attributes) {
      const attribute = attributes[name];
      const newAttribute = convertBufferAttribute(attribute, indices);
      geometry2.setAttribute(name, newAttribute);
    }
    const morphAttributes = this.morphAttributes;
    for (const name in morphAttributes) {
      const morphArray = [];
      const morphAttribute = morphAttributes[name];
      for (let i2 = 0, il = morphAttribute.length; i2 < il; i2++) {
        const attribute = morphAttribute[i2];
        const newAttribute = convertBufferAttribute(attribute, indices);
        morphArray.push(newAttribute);
      }
      geometry2.morphAttributes[name] = morphArray;
    }
    geometry2.morphTargetsRelative = this.morphTargetsRelative;
    const groups = this.groups;
    for (let i2 = 0, l = groups.length; i2 < l; i2++) {
      const group = groups[i2];
      geometry2.addGroup(group.start, group.count, group.materialIndex);
    }
    return geometry2;
  }
  toJSON() {
    const data = {
      metadata: {
        version: 4.5,
        type: "BufferGeometry",
        generator: "BufferGeometry.toJSON"
      }
    };
    data.uuid = this.uuid;
    data.type = this.type;
    if (this.name !== "")
      data.name = this.name;
    if (Object.keys(this.userData).length > 0)
      data.userData = this.userData;
    if (this.parameters !== void 0) {
      const parameters = this.parameters;
      for (const key in parameters) {
        if (parameters[key] !== void 0)
          data[key] = parameters[key];
      }
      return data;
    }
    data.data = { attributes: {} };
    const index = this.index;
    if (index !== null) {
      data.data.index = {
        type: index.array.constructor.name,
        array: Array.prototype.slice.call(index.array)
      };
    }
    const attributes = this.attributes;
    for (const key in attributes) {
      const attribute = attributes[key];
      data.data.attributes[key] = attribute.toJSON(data.data);
    }
    const morphAttributes = {};
    let hasMorphAttributes = false;
    for (const key in this.morphAttributes) {
      const attributeArray = this.morphAttributes[key];
      const array = [];
      for (let i2 = 0, il = attributeArray.length; i2 < il; i2++) {
        const attribute = attributeArray[i2];
        array.push(attribute.toJSON(data.data));
      }
      if (array.length > 0) {
        morphAttributes[key] = array;
        hasMorphAttributes = true;
      }
    }
    if (hasMorphAttributes) {
      data.data.morphAttributes = morphAttributes;
      data.data.morphTargetsRelative = this.morphTargetsRelative;
    }
    const groups = this.groups;
    if (groups.length > 0) {
      data.data.groups = JSON.parse(JSON.stringify(groups));
    }
    const boundingSphere = this.boundingSphere;
    if (boundingSphere !== null) {
      data.data.boundingSphere = {
        center: boundingSphere.center.toArray(),
        radius: boundingSphere.radius
      };
    }
    return data;
  }
  clone() {
    return new this.constructor().copy(this);
  }
  copy(source) {
    this.index = null;
    this.attributes = {};
    this.morphAttributes = {};
    this.groups = [];
    this.boundingBox = null;
    this.boundingSphere = null;
    const data = {};
    this.name = source.name;
    const index = source.index;
    if (index !== null) {
      this.setIndex(index.clone(data));
    }
    const attributes = source.attributes;
    for (const name in attributes) {
      const attribute = attributes[name];
      this.setAttribute(name, attribute.clone(data));
    }
    const morphAttributes = source.morphAttributes;
    for (const name in morphAttributes) {
      const array = [];
      const morphAttribute = morphAttributes[name];
      for (let i2 = 0, l = morphAttribute.length; i2 < l; i2++) {
        array.push(morphAttribute[i2].clone(data));
      }
      this.morphAttributes[name] = array;
    }
    this.morphTargetsRelative = source.morphTargetsRelative;
    const groups = source.groups;
    for (let i2 = 0, l = groups.length; i2 < l; i2++) {
      const group = groups[i2];
      this.addGroup(group.start, group.count, group.materialIndex);
    }
    const boundingBox = source.boundingBox;
    if (boundingBox !== null) {
      this.boundingBox = boundingBox.clone();
    }
    const boundingSphere = source.boundingSphere;
    if (boundingSphere !== null) {
      this.boundingSphere = boundingSphere.clone();
    }
    this.drawRange.start = source.drawRange.start;
    this.drawRange.count = source.drawRange.count;
    this.userData = source.userData;
    if (source.parameters !== void 0)
      this.parameters = Object.assign({}, source.parameters);
    return this;
  }
  dispose() {
    this.dispatchEvent({ type: "dispose" });
  }
};
var _inverseMatrix$2 = /* @__PURE__ */ new Matrix4();
var _ray$2 = /* @__PURE__ */ new Ray();
var _sphere$3 = /* @__PURE__ */ new Sphere();
var _vA$1 = /* @__PURE__ */ new Vector3();
var _vB$1 = /* @__PURE__ */ new Vector3();
var _vC$1 = /* @__PURE__ */ new Vector3();
var _tempA = /* @__PURE__ */ new Vector3();
var _tempB = /* @__PURE__ */ new Vector3();
var _tempC = /* @__PURE__ */ new Vector3();
var _morphA = /* @__PURE__ */ new Vector3();
var _morphB = /* @__PURE__ */ new Vector3();
var _morphC = /* @__PURE__ */ new Vector3();
var _uvA$1 = /* @__PURE__ */ new Vector2();
var _uvB$1 = /* @__PURE__ */ new Vector2();
var _uvC$1 = /* @__PURE__ */ new Vector2();
var _intersectionPoint = /* @__PURE__ */ new Vector3();
var _intersectionPointWorld = /* @__PURE__ */ new Vector3();
var Mesh = class extends Object3D {
  constructor(geometry = new BufferGeometry(), material = new MeshBasicMaterial()) {
    super();
    this.isMesh = true;
    this.type = "Mesh";
    this.geometry = geometry;
    this.material = material;
    this.updateMorphTargets();
  }
  copy(source, recursive) {
    super.copy(source, recursive);
    if (source.morphTargetInfluences !== void 0) {
      this.morphTargetInfluences = source.morphTargetInfluences.slice();
    }
    if (source.morphTargetDictionary !== void 0) {
      this.morphTargetDictionary = Object.assign({}, source.morphTargetDictionary);
    }
    this.material = source.material;
    this.geometry = source.geometry;
    return this;
  }
  updateMorphTargets() {
    const geometry = this.geometry;
    const morphAttributes = geometry.morphAttributes;
    const keys = Object.keys(morphAttributes);
    if (keys.length > 0) {
      const morphAttribute = morphAttributes[keys[0]];
      if (morphAttribute !== void 0) {
        this.morphTargetInfluences = [];
        this.morphTargetDictionary = {};
        for (let m = 0, ml = morphAttribute.length; m < ml; m++) {
          const name = morphAttribute[m].name || String(m);
          this.morphTargetInfluences.push(0);
          this.morphTargetDictionary[name] = m;
        }
      }
    }
  }
  raycast(raycaster, intersects) {
    const geometry = this.geometry;
    const material = this.material;
    const matrixWorld = this.matrixWorld;
    if (material === void 0)
      return;
    if (geometry.boundingSphere === null)
      geometry.computeBoundingSphere();
    _sphere$3.copy(geometry.boundingSphere);
    _sphere$3.applyMatrix4(matrixWorld);
    if (raycaster.ray.intersectsSphere(_sphere$3) === false)
      return;
    _inverseMatrix$2.copy(matrixWorld).invert();
    _ray$2.copy(raycaster.ray).applyMatrix4(_inverseMatrix$2);
    if (geometry.boundingBox !== null) {
      if (_ray$2.intersectsBox(geometry.boundingBox) === false)
        return;
    }
    let intersection;
    const index = geometry.index;
    const position = geometry.attributes.position;
    const morphPosition = geometry.morphAttributes.position;
    const morphTargetsRelative = geometry.morphTargetsRelative;
    const uv = geometry.attributes.uv;
    const uv2 = geometry.attributes.uv2;
    const groups = geometry.groups;
    const drawRange = geometry.drawRange;
    if (index !== null) {
      if (Array.isArray(material)) {
        for (let i2 = 0, il = groups.length; i2 < il; i2++) {
          const group = groups[i2];
          const groupMaterial = material[group.materialIndex];
          const start = Math.max(group.start, drawRange.start);
          const end = Math.min(index.count, Math.min(group.start + group.count, drawRange.start + drawRange.count));
          for (let j = start, jl = end; j < jl; j += 3) {
            const a = index.getX(j);
            const b = index.getX(j + 1);
            const c = index.getX(j + 2);
            intersection = checkBufferGeometryIntersection(this, groupMaterial, raycaster, _ray$2, position, morphPosition, morphTargetsRelative, uv, uv2, a, b, c);
            if (intersection) {
              intersection.faceIndex = Math.floor(j / 3);
              intersection.face.materialIndex = group.materialIndex;
              intersects.push(intersection);
            }
          }
        }
      } else {
        const start = Math.max(0, drawRange.start);
        const end = Math.min(index.count, drawRange.start + drawRange.count);
        for (let i2 = start, il = end; i2 < il; i2 += 3) {
          const a = index.getX(i2);
          const b = index.getX(i2 + 1);
          const c = index.getX(i2 + 2);
          intersection = checkBufferGeometryIntersection(this, material, raycaster, _ray$2, position, morphPosition, morphTargetsRelative, uv, uv2, a, b, c);
          if (intersection) {
            intersection.faceIndex = Math.floor(i2 / 3);
            intersects.push(intersection);
          }
        }
      }
    } else if (position !== void 0) {
      if (Array.isArray(material)) {
        for (let i2 = 0, il = groups.length; i2 < il; i2++) {
          const group = groups[i2];
          const groupMaterial = material[group.materialIndex];
          const start = Math.max(group.start, drawRange.start);
          const end = Math.min(position.count, Math.min(group.start + group.count, drawRange.start + drawRange.count));
          for (let j = start, jl = end; j < jl; j += 3) {
            const a = j;
            const b = j + 1;
            const c = j + 2;
            intersection = checkBufferGeometryIntersection(this, groupMaterial, raycaster, _ray$2, position, morphPosition, morphTargetsRelative, uv, uv2, a, b, c);
            if (intersection) {
              intersection.faceIndex = Math.floor(j / 3);
              intersection.face.materialIndex = group.materialIndex;
              intersects.push(intersection);
            }
          }
        }
      } else {
        const start = Math.max(0, drawRange.start);
        const end = Math.min(position.count, drawRange.start + drawRange.count);
        for (let i2 = start, il = end; i2 < il; i2 += 3) {
          const a = i2;
          const b = i2 + 1;
          const c = i2 + 2;
          intersection = checkBufferGeometryIntersection(this, material, raycaster, _ray$2, position, morphPosition, morphTargetsRelative, uv, uv2, a, b, c);
          if (intersection) {
            intersection.faceIndex = Math.floor(i2 / 3);
            intersects.push(intersection);
          }
        }
      }
    }
  }
};
function checkIntersection(object, material, raycaster, ray, pA, pB, pC, point) {
  let intersect;
  if (material.side === BackSide) {
    intersect = ray.intersectTriangle(pC, pB, pA, true, point);
  } else {
    intersect = ray.intersectTriangle(pA, pB, pC, material.side !== DoubleSide, point);
  }
  if (intersect === null)
    return null;
  _intersectionPointWorld.copy(point);
  _intersectionPointWorld.applyMatrix4(object.matrixWorld);
  const distance = raycaster.ray.origin.distanceTo(_intersectionPointWorld);
  if (distance < raycaster.near || distance > raycaster.far)
    return null;
  return {
    distance,
    point: _intersectionPointWorld.clone(),
    object
  };
}
function checkBufferGeometryIntersection(object, material, raycaster, ray, position, morphPosition, morphTargetsRelative, uv, uv2, a, b, c) {
  _vA$1.fromBufferAttribute(position, a);
  _vB$1.fromBufferAttribute(position, b);
  _vC$1.fromBufferAttribute(position, c);
  const morphInfluences = object.morphTargetInfluences;
  if (morphPosition && morphInfluences) {
    _morphA.set(0, 0, 0);
    _morphB.set(0, 0, 0);
    _morphC.set(0, 0, 0);
    for (let i2 = 0, il = morphPosition.length; i2 < il; i2++) {
      const influence = morphInfluences[i2];
      const morphAttribute = morphPosition[i2];
      if (influence === 0)
        continue;
      _tempA.fromBufferAttribute(morphAttribute, a);
      _tempB.fromBufferAttribute(morphAttribute, b);
      _tempC.fromBufferAttribute(morphAttribute, c);
      if (morphTargetsRelative) {
        _morphA.addScaledVector(_tempA, influence);
        _morphB.addScaledVector(_tempB, influence);
        _morphC.addScaledVector(_tempC, influence);
      } else {
        _morphA.addScaledVector(_tempA.sub(_vA$1), influence);
        _morphB.addScaledVector(_tempB.sub(_vB$1), influence);
        _morphC.addScaledVector(_tempC.sub(_vC$1), influence);
      }
    }
    _vA$1.add(_morphA);
    _vB$1.add(_morphB);
    _vC$1.add(_morphC);
  }
  if (object.isSkinnedMesh) {
    object.boneTransform(a, _vA$1);
    object.boneTransform(b, _vB$1);
    object.boneTransform(c, _vC$1);
  }
  const intersection = checkIntersection(object, material, raycaster, ray, _vA$1, _vB$1, _vC$1, _intersectionPoint);
  if (intersection) {
    if (uv) {
      _uvA$1.fromBufferAttribute(uv, a);
      _uvB$1.fromBufferAttribute(uv, b);
      _uvC$1.fromBufferAttribute(uv, c);
      intersection.uv = Triangle.getUV(_intersectionPoint, _vA$1, _vB$1, _vC$1, _uvA$1, _uvB$1, _uvC$1, new Vector2());
    }
    if (uv2) {
      _uvA$1.fromBufferAttribute(uv2, a);
      _uvB$1.fromBufferAttribute(uv2, b);
      _uvC$1.fromBufferAttribute(uv2, c);
      intersection.uv2 = Triangle.getUV(_intersectionPoint, _vA$1, _vB$1, _vC$1, _uvA$1, _uvB$1, _uvC$1, new Vector2());
    }
    const face = {
      a,
      b,
      c,
      normal: new Vector3(),
      materialIndex: 0
    };
    Triangle.getNormal(_vA$1, _vB$1, _vC$1, face.normal);
    intersection.face = face;
  }
  return intersection;
}
var BoxGeometry = class extends BufferGeometry {
  constructor(width = 1, height = 1, depth = 1, widthSegments = 1, heightSegments = 1, depthSegments = 1) {
    super();
    this.type = "BoxGeometry";
    this.parameters = {
      width,
      height,
      depth,
      widthSegments,
      heightSegments,
      depthSegments
    };
    const scope = this;
    widthSegments = Math.floor(widthSegments);
    heightSegments = Math.floor(heightSegments);
    depthSegments = Math.floor(depthSegments);
    const indices = [];
    const vertices = [];
    const normals = [];
    const uvs = [];
    let numberOfVertices = 0;
    let groupStart = 0;
    buildPlane("z", "y", "x", -1, -1, depth, height, width, depthSegments, heightSegments, 0);
    buildPlane("z", "y", "x", 1, -1, depth, height, -width, depthSegments, heightSegments, 1);
    buildPlane("x", "z", "y", 1, 1, width, depth, height, widthSegments, depthSegments, 2);
    buildPlane("x", "z", "y", 1, -1, width, depth, -height, widthSegments, depthSegments, 3);
    buildPlane("x", "y", "z", 1, -1, width, height, depth, widthSegments, heightSegments, 4);
    buildPlane("x", "y", "z", -1, -1, width, height, -depth, widthSegments, heightSegments, 5);
    this.setIndex(indices);
    this.setAttribute("position", new Float32BufferAttribute(vertices, 3));
    this.setAttribute("normal", new Float32BufferAttribute(normals, 3));
    this.setAttribute("uv", new Float32BufferAttribute(uvs, 2));
    function buildPlane(u, v, w2, udir, vdir, width2, height2, depth2, gridX, gridY, materialIndex) {
      const segmentWidth = width2 / gridX;
      const segmentHeight = height2 / gridY;
      const widthHalf = width2 / 2;
      const heightHalf = height2 / 2;
      const depthHalf = depth2 / 2;
      const gridX1 = gridX + 1;
      const gridY1 = gridY + 1;
      let vertexCounter = 0;
      let groupCount = 0;
      const vector = new Vector3();
      for (let iy = 0; iy < gridY1; iy++) {
        const y = iy * segmentHeight - heightHalf;
        for (let ix = 0; ix < gridX1; ix++) {
          const x = ix * segmentWidth - widthHalf;
          vector[u] = x * udir;
          vector[v] = y * vdir;
          vector[w2] = depthHalf;
          vertices.push(vector.x, vector.y, vector.z);
          vector[u] = 0;
          vector[v] = 0;
          vector[w2] = depth2 > 0 ? 1 : -1;
          normals.push(vector.x, vector.y, vector.z);
          uvs.push(ix / gridX);
          uvs.push(1 - iy / gridY);
          vertexCounter += 1;
        }
      }
      for (let iy = 0; iy < gridY; iy++) {
        for (let ix = 0; ix < gridX; ix++) {
          const a = numberOfVertices + ix + gridX1 * iy;
          const b = numberOfVertices + ix + gridX1 * (iy + 1);
          const c = numberOfVertices + (ix + 1) + gridX1 * (iy + 1);
          const d = numberOfVertices + (ix + 1) + gridX1 * iy;
          indices.push(a, b, d);
          indices.push(b, c, d);
          groupCount += 6;
        }
      }
      scope.addGroup(groupStart, groupCount, materialIndex);
      groupStart += groupCount;
      numberOfVertices += vertexCounter;
    }
  }
  static fromJSON(data) {
    return new BoxGeometry(data.width, data.height, data.depth, data.widthSegments, data.heightSegments, data.depthSegments);
  }
};
function cloneUniforms(src) {
  const dst = {};
  for (const u in src) {
    dst[u] = {};
    for (const p in src[u]) {
      const property = src[u][p];
      if (property && (property.isColor || property.isMatrix3 || property.isMatrix4 || property.isVector2 || property.isVector3 || property.isVector4 || property.isTexture || property.isQuaternion)) {
        dst[u][p] = property.clone();
      } else if (Array.isArray(property)) {
        dst[u][p] = property.slice();
      } else {
        dst[u][p] = property;
      }
    }
  }
  return dst;
}
function mergeUniforms(uniforms) {
  const merged = {};
  for (let u = 0; u < uniforms.length; u++) {
    const tmp = cloneUniforms(uniforms[u]);
    for (const p in tmp) {
      merged[p] = tmp[p];
    }
  }
  return merged;
}
function cloneUniformsGroups(src) {
  const dst = [];
  for (let u = 0; u < src.length; u++) {
    dst.push(src[u].clone());
  }
  return dst;
}
var UniformsUtils = { clone: cloneUniforms, merge: mergeUniforms };
var default_vertex = "void main() {\n	gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n}";
var default_fragment = "void main() {\n	gl_FragColor = vec4( 1.0, 0.0, 0.0, 1.0 );\n}";
var ShaderMaterial = class extends Material {
  constructor(parameters) {
    super();
    this.isShaderMaterial = true;
    this.type = "ShaderMaterial";
    this.defines = {};
    this.uniforms = {};
    this.uniformsGroups = [];
    this.vertexShader = default_vertex;
    this.fragmentShader = default_fragment;
    this.linewidth = 1;
    this.wireframe = false;
    this.wireframeLinewidth = 1;
    this.fog = false;
    this.lights = false;
    this.clipping = false;
    this.extensions = {
      derivatives: false,
      fragDepth: false,
      drawBuffers: false,
      shaderTextureLOD: false
    };
    this.defaultAttributeValues = {
      "color": [1, 1, 1],
      "uv": [0, 0],
      "uv2": [0, 0]
    };
    this.index0AttributeName = void 0;
    this.uniformsNeedUpdate = false;
    this.glslVersion = null;
    if (parameters !== void 0) {
      if (parameters.attributes !== void 0) {
        console.error("THREE.ShaderMaterial: attributes should now be defined in THREE.BufferGeometry instead.");
      }
      this.setValues(parameters);
    }
  }
  copy(source) {
    super.copy(source);
    this.fragmentShader = source.fragmentShader;
    this.vertexShader = source.vertexShader;
    this.uniforms = cloneUniforms(source.uniforms);
    this.uniformsGroups = cloneUniformsGroups(source.uniformsGroups);
    this.defines = Object.assign({}, source.defines);
    this.wireframe = source.wireframe;
    this.wireframeLinewidth = source.wireframeLinewidth;
    this.fog = source.fog;
    this.lights = source.lights;
    this.clipping = source.clipping;
    this.extensions = Object.assign({}, source.extensions);
    this.glslVersion = source.glslVersion;
    return this;
  }
  toJSON(meta) {
    const data = super.toJSON(meta);
    data.glslVersion = this.glslVersion;
    data.uniforms = {};
    for (const name in this.uniforms) {
      const uniform = this.uniforms[name];
      const value = uniform.value;
      if (value && value.isTexture) {
        data.uniforms[name] = {
          type: "t",
          value: value.toJSON(meta).uuid
        };
      } else if (value && value.isColor) {
        data.uniforms[name] = {
          type: "c",
          value: value.getHex()
        };
      } else if (value && value.isVector2) {
        data.uniforms[name] = {
          type: "v2",
          value: value.toArray()
        };
      } else if (value && value.isVector3) {
        data.uniforms[name] = {
          type: "v3",
          value: value.toArray()
        };
      } else if (value && value.isVector4) {
        data.uniforms[name] = {
          type: "v4",
          value: value.toArray()
        };
      } else if (value && value.isMatrix3) {
        data.uniforms[name] = {
          type: "m3",
          value: value.toArray()
        };
      } else if (value && value.isMatrix4) {
        data.uniforms[name] = {
          type: "m4",
          value: value.toArray()
        };
      } else {
        data.uniforms[name] = {
          value
        };
      }
    }
    if (Object.keys(this.defines).length > 0)
      data.defines = this.defines;
    data.vertexShader = this.vertexShader;
    data.fragmentShader = this.fragmentShader;
    const extensions = {};
    for (const key in this.extensions) {
      if (this.extensions[key] === true)
        extensions[key] = true;
    }
    if (Object.keys(extensions).length > 0)
      data.extensions = extensions;
    return data;
  }
};
var Camera = class extends Object3D {
  constructor() {
    super();
    this.isCamera = true;
    this.type = "Camera";
    this.matrixWorldInverse = new Matrix4();
    this.projectionMatrix = new Matrix4();
    this.projectionMatrixInverse = new Matrix4();
  }
  copy(source, recursive) {
    super.copy(source, recursive);
    this.matrixWorldInverse.copy(source.matrixWorldInverse);
    this.projectionMatrix.copy(source.projectionMatrix);
    this.projectionMatrixInverse.copy(source.projectionMatrixInverse);
    return this;
  }
  getWorldDirection(target) {
    this.updateWorldMatrix(true, false);
    const e = this.matrixWorld.elements;
    return target.set(-e[8], -e[9], -e[10]).normalize();
  }
  updateMatrixWorld(force) {
    super.updateMatrixWorld(force);
    this.matrixWorldInverse.copy(this.matrixWorld).invert();
  }
  updateWorldMatrix(updateParents, updateChildren) {
    super.updateWorldMatrix(updateParents, updateChildren);
    this.matrixWorldInverse.copy(this.matrixWorld).invert();
  }
  clone() {
    return new this.constructor().copy(this);
  }
};
var PerspectiveCamera = class extends Camera {
  constructor(fov2 = 50, aspect2 = 1, near = 0.1, far = 2e3) {
    super();
    this.isPerspectiveCamera = true;
    this.type = "PerspectiveCamera";
    this.fov = fov2;
    this.zoom = 1;
    this.near = near;
    this.far = far;
    this.focus = 10;
    this.aspect = aspect2;
    this.view = null;
    this.filmGauge = 35;
    this.filmOffset = 0;
    this.updateProjectionMatrix();
  }
  copy(source, recursive) {
    super.copy(source, recursive);
    this.fov = source.fov;
    this.zoom = source.zoom;
    this.near = source.near;
    this.far = source.far;
    this.focus = source.focus;
    this.aspect = source.aspect;
    this.view = source.view === null ? null : Object.assign({}, source.view);
    this.filmGauge = source.filmGauge;
    this.filmOffset = source.filmOffset;
    return this;
  }
  setFocalLength(focalLength) {
    const vExtentSlope = 0.5 * this.getFilmHeight() / focalLength;
    this.fov = RAD2DEG * 2 * Math.atan(vExtentSlope);
    this.updateProjectionMatrix();
  }
  getFocalLength() {
    const vExtentSlope = Math.tan(DEG2RAD * 0.5 * this.fov);
    return 0.5 * this.getFilmHeight() / vExtentSlope;
  }
  getEffectiveFOV() {
    return RAD2DEG * 2 * Math.atan(
      Math.tan(DEG2RAD * 0.5 * this.fov) / this.zoom
    );
  }
  getFilmWidth() {
    return this.filmGauge * Math.min(this.aspect, 1);
  }
  getFilmHeight() {
    return this.filmGauge / Math.max(this.aspect, 1);
  }
  setViewOffset(fullWidth, fullHeight, x, y, width, height) {
    this.aspect = fullWidth / fullHeight;
    if (this.view === null) {
      this.view = {
        enabled: true,
        fullWidth: 1,
        fullHeight: 1,
        offsetX: 0,
        offsetY: 0,
        width: 1,
        height: 1
      };
    }
    this.view.enabled = true;
    this.view.fullWidth = fullWidth;
    this.view.fullHeight = fullHeight;
    this.view.offsetX = x;
    this.view.offsetY = y;
    this.view.width = width;
    this.view.height = height;
    this.updateProjectionMatrix();
  }
  clearViewOffset() {
    if (this.view !== null) {
      this.view.enabled = false;
    }
    this.updateProjectionMatrix();
  }
  updateProjectionMatrix() {
    const near = this.near;
    let top = near * Math.tan(DEG2RAD * 0.5 * this.fov) / this.zoom;
    let height = 2 * top;
    let width = this.aspect * height;
    let left = -0.5 * width;
    const view = this.view;
    if (this.view !== null && this.view.enabled) {
      const fullWidth = view.fullWidth, fullHeight = view.fullHeight;
      left += view.offsetX * width / fullWidth;
      top -= view.offsetY * height / fullHeight;
      width *= view.width / fullWidth;
      height *= view.height / fullHeight;
    }
    const skew = this.filmOffset;
    if (skew !== 0)
      left += near * skew / this.getFilmWidth();
    this.projectionMatrix.makePerspective(left, left + width, top, top - height, near, this.far);
    this.projectionMatrixInverse.copy(this.projectionMatrix).invert();
  }
  toJSON(meta) {
    const data = super.toJSON(meta);
    data.object.fov = this.fov;
    data.object.zoom = this.zoom;
    data.object.near = this.near;
    data.object.far = this.far;
    data.object.focus = this.focus;
    data.object.aspect = this.aspect;
    if (this.view !== null)
      data.object.view = Object.assign({}, this.view);
    data.object.filmGauge = this.filmGauge;
    data.object.filmOffset = this.filmOffset;
    return data;
  }
};
var fov = 90;
var aspect = 1;
var CubeCamera = class extends Object3D {
  constructor(near, far, renderTarget) {
    super();
    this.type = "CubeCamera";
    if (renderTarget.isWebGLCubeRenderTarget !== true) {
      console.error("THREE.CubeCamera: The constructor now expects an instance of WebGLCubeRenderTarget as third parameter.");
      return;
    }
    this.renderTarget = renderTarget;
    const cameraPX = new PerspectiveCamera(fov, aspect, near, far);
    cameraPX.layers = this.layers;
    cameraPX.up.set(0, -1, 0);
    cameraPX.lookAt(new Vector3(1, 0, 0));
    this.add(cameraPX);
    const cameraNX = new PerspectiveCamera(fov, aspect, near, far);
    cameraNX.layers = this.layers;
    cameraNX.up.set(0, -1, 0);
    cameraNX.lookAt(new Vector3(-1, 0, 0));
    this.add(cameraNX);
    const cameraPY = new PerspectiveCamera(fov, aspect, near, far);
    cameraPY.layers = this.layers;
    cameraPY.up.set(0, 0, 1);
    cameraPY.lookAt(new Vector3(0, 1, 0));
    this.add(cameraPY);
    const cameraNY = new PerspectiveCamera(fov, aspect, near, far);
    cameraNY.layers = this.layers;
    cameraNY.up.set(0, 0, -1);
    cameraNY.lookAt(new Vector3(0, -1, 0));
    this.add(cameraNY);
    const cameraPZ = new PerspectiveCamera(fov, aspect, near, far);
    cameraPZ.layers = this.layers;
    cameraPZ.up.set(0, -1, 0);
    cameraPZ.lookAt(new Vector3(0, 0, 1));
    this.add(cameraPZ);
    const cameraNZ = new PerspectiveCamera(fov, aspect, near, far);
    cameraNZ.layers = this.layers;
    cameraNZ.up.set(0, -1, 0);
    cameraNZ.lookAt(new Vector3(0, 0, -1));
    this.add(cameraNZ);
  }
  update(renderer, scene) {
    if (this.parent === null)
      this.updateMatrixWorld();
    const renderTarget = this.renderTarget;
    const [cameraPX, cameraNX, cameraPY, cameraNY, cameraPZ, cameraNZ] = this.children;
    const currentRenderTarget = renderer.getRenderTarget();
    const currentToneMapping = renderer.toneMapping;
    const currentXrEnabled = renderer.xr.enabled;
    renderer.toneMapping = NoToneMapping;
    renderer.xr.enabled = false;
    const generateMipmaps = renderTarget.texture.generateMipmaps;
    renderTarget.texture.generateMipmaps = false;
    renderer.setRenderTarget(renderTarget, 0);
    renderer.render(scene, cameraPX);
    renderer.setRenderTarget(renderTarget, 1);
    renderer.render(scene, cameraNX);
    renderer.setRenderTarget(renderTarget, 2);
    renderer.render(scene, cameraPY);
    renderer.setRenderTarget(renderTarget, 3);
    renderer.render(scene, cameraNY);
    renderer.setRenderTarget(renderTarget, 4);
    renderer.render(scene, cameraPZ);
    renderTarget.texture.generateMipmaps = generateMipmaps;
    renderer.setRenderTarget(renderTarget, 5);
    renderer.render(scene, cameraNZ);
    renderer.setRenderTarget(currentRenderTarget);
    renderer.toneMapping = currentToneMapping;
    renderer.xr.enabled = currentXrEnabled;
    renderTarget.texture.needsPMREMUpdate = true;
  }
};
var CubeTexture = class extends Texture {
  constructor(images, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy, encoding) {
    images = images !== void 0 ? images : [];
    mapping = mapping !== void 0 ? mapping : CubeReflectionMapping;
    super(images, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy, encoding);
    this.isCubeTexture = true;
    this.flipY = false;
  }
  get images() {
    return this.image;
  }
  set images(value) {
    this.image = value;
  }
};
var WebGLCubeRenderTarget = class extends WebGLRenderTarget {
  constructor(size, options = {}) {
    super(size, size, options);
    this.isWebGLCubeRenderTarget = true;
    const image = { width: size, height: size, depth: 1 };
    const images = [image, image, image, image, image, image];
    this.texture = new CubeTexture(images, options.mapping, options.wrapS, options.wrapT, options.magFilter, options.minFilter, options.format, options.type, options.anisotropy, options.encoding);
    this.texture.isRenderTargetTexture = true;
    this.texture.generateMipmaps = options.generateMipmaps !== void 0 ? options.generateMipmaps : false;
    this.texture.minFilter = options.minFilter !== void 0 ? options.minFilter : LinearFilter;
  }
  fromEquirectangularTexture(renderer, texture) {
    this.texture.type = texture.type;
    this.texture.encoding = texture.encoding;
    this.texture.generateMipmaps = texture.generateMipmaps;
    this.texture.minFilter = texture.minFilter;
    this.texture.magFilter = texture.magFilter;
    const shader = {
      uniforms: {
        tEquirect: { value: null }
      },
      vertexShader: `

				varying vec3 vWorldDirection;

				vec3 transformDirection( in vec3 dir, in mat4 matrix ) {

					return normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );

				}

				void main() {

					vWorldDirection = transformDirection( position, modelMatrix );

					#include <begin_vertex>
					#include <project_vertex>

				}
			`,
      fragmentShader: `

				uniform sampler2D tEquirect;

				varying vec3 vWorldDirection;

				#include <common>

				void main() {

					vec3 direction = normalize( vWorldDirection );

					vec2 sampleUV = equirectUv( direction );

					gl_FragColor = texture2D( tEquirect, sampleUV );

				}
			`
    };
    const geometry = new BoxGeometry(5, 5, 5);
    const material = new ShaderMaterial({
      name: "CubemapFromEquirect",
      uniforms: cloneUniforms(shader.uniforms),
      vertexShader: shader.vertexShader,
      fragmentShader: shader.fragmentShader,
      side: BackSide,
      blending: NoBlending
    });
    material.uniforms.tEquirect.value = texture;
    const mesh = new Mesh(geometry, material);
    const currentMinFilter = texture.minFilter;
    if (texture.minFilter === LinearMipmapLinearFilter)
      texture.minFilter = LinearFilter;
    const camera = new CubeCamera(1, 10, this);
    camera.update(renderer, mesh);
    texture.minFilter = currentMinFilter;
    mesh.geometry.dispose();
    mesh.material.dispose();
    return this;
  }
  clear(renderer, color, depth, stencil) {
    const currentRenderTarget = renderer.getRenderTarget();
    for (let i2 = 0; i2 < 6; i2++) {
      renderer.setRenderTarget(this, i2);
      renderer.clear(color, depth, stencil);
    }
    renderer.setRenderTarget(currentRenderTarget);
  }
};
var _vector1 = /* @__PURE__ */ new Vector3();
var _vector2 = /* @__PURE__ */ new Vector3();
var _normalMatrix = /* @__PURE__ */ new Matrix3();
var Plane = class {
  constructor(normal = new Vector3(1, 0, 0), constant = 0) {
    this.isPlane = true;
    this.normal = normal;
    this.constant = constant;
  }
  set(normal, constant) {
    this.normal.copy(normal);
    this.constant = constant;
    return this;
  }
  setComponents(x, y, z, w2) {
    this.normal.set(x, y, z);
    this.constant = w2;
    return this;
  }
  setFromNormalAndCoplanarPoint(normal, point) {
    this.normal.copy(normal);
    this.constant = -point.dot(this.normal);
    return this;
  }
  setFromCoplanarPoints(a, b, c) {
    const normal = _vector1.subVectors(c, b).cross(_vector2.subVectors(a, b)).normalize();
    this.setFromNormalAndCoplanarPoint(normal, a);
    return this;
  }
  copy(plane) {
    this.normal.copy(plane.normal);
    this.constant = plane.constant;
    return this;
  }
  normalize() {
    const inverseNormalLength = 1 / this.normal.length();
    this.normal.multiplyScalar(inverseNormalLength);
    this.constant *= inverseNormalLength;
    return this;
  }
  negate() {
    this.constant *= -1;
    this.normal.negate();
    return this;
  }
  distanceToPoint(point) {
    return this.normal.dot(point) + this.constant;
  }
  distanceToSphere(sphere) {
    return this.distanceToPoint(sphere.center) - sphere.radius;
  }
  projectPoint(point, target) {
    return target.copy(this.normal).multiplyScalar(-this.distanceToPoint(point)).add(point);
  }
  intersectLine(line, target) {
    const direction = line.delta(_vector1);
    const denominator = this.normal.dot(direction);
    if (denominator === 0) {
      if (this.distanceToPoint(line.start) === 0) {
        return target.copy(line.start);
      }
      return null;
    }
    const t = -(line.start.dot(this.normal) + this.constant) / denominator;
    if (t < 0 || t > 1) {
      return null;
    }
    return target.copy(direction).multiplyScalar(t).add(line.start);
  }
  intersectsLine(line) {
    const startSign = this.distanceToPoint(line.start);
    const endSign = this.distanceToPoint(line.end);
    return startSign < 0 && endSign > 0 || endSign < 0 && startSign > 0;
  }
  intersectsBox(box) {
    return box.intersectsPlane(this);
  }
  intersectsSphere(sphere) {
    return sphere.intersectsPlane(this);
  }
  coplanarPoint(target) {
    return target.copy(this.normal).multiplyScalar(-this.constant);
  }
  applyMatrix4(matrix, optionalNormalMatrix) {
    const normalMatrix = optionalNormalMatrix || _normalMatrix.getNormalMatrix(matrix);
    const referencePoint = this.coplanarPoint(_vector1).applyMatrix4(matrix);
    const normal = this.normal.applyMatrix3(normalMatrix).normalize();
    this.constant = -referencePoint.dot(normal);
    return this;
  }
  translate(offset) {
    this.constant -= offset.dot(this.normal);
    return this;
  }
  equals(plane) {
    return plane.normal.equals(this.normal) && plane.constant === this.constant;
  }
  clone() {
    return new this.constructor().copy(this);
  }
};
var _sphere$2 = /* @__PURE__ */ new Sphere();
var _vector$7 = /* @__PURE__ */ new Vector3();
var Frustum = class {
  constructor(p0 = new Plane(), p1 = new Plane(), p2 = new Plane(), p3 = new Plane(), p4 = new Plane(), p5 = new Plane()) {
    this.planes = [p0, p1, p2, p3, p4, p5];
  }
  set(p0, p1, p2, p3, p4, p5) {
    const planes = this.planes;
    planes[0].copy(p0);
    planes[1].copy(p1);
    planes[2].copy(p2);
    planes[3].copy(p3);
    planes[4].copy(p4);
    planes[5].copy(p5);
    return this;
  }
  copy(frustum) {
    const planes = this.planes;
    for (let i2 = 0; i2 < 6; i2++) {
      planes[i2].copy(frustum.planes[i2]);
    }
    return this;
  }
  setFromProjectionMatrix(m) {
    const planes = this.planes;
    const me = m.elements;
    const me0 = me[0], me1 = me[1], me2 = me[2], me3 = me[3];
    const me4 = me[4], me5 = me[5], me6 = me[6], me7 = me[7];
    const me8 = me[8], me9 = me[9], me10 = me[10], me11 = me[11];
    const me12 = me[12], me13 = me[13], me14 = me[14], me15 = me[15];
    planes[0].setComponents(me3 - me0, me7 - me4, me11 - me8, me15 - me12).normalize();
    planes[1].setComponents(me3 + me0, me7 + me4, me11 + me8, me15 + me12).normalize();
    planes[2].setComponents(me3 + me1, me7 + me5, me11 + me9, me15 + me13).normalize();
    planes[3].setComponents(me3 - me1, me7 - me5, me11 - me9, me15 - me13).normalize();
    planes[4].setComponents(me3 - me2, me7 - me6, me11 - me10, me15 - me14).normalize();
    planes[5].setComponents(me3 + me2, me7 + me6, me11 + me10, me15 + me14).normalize();
    return this;
  }
  intersectsObject(object) {
    const geometry = object.geometry;
    if (geometry.boundingSphere === null)
      geometry.computeBoundingSphere();
    _sphere$2.copy(geometry.boundingSphere).applyMatrix4(object.matrixWorld);
    return this.intersectsSphere(_sphere$2);
  }
  intersectsSprite(sprite) {
    _sphere$2.center.set(0, 0, 0);
    _sphere$2.radius = 0.7071067811865476;
    _sphere$2.applyMatrix4(sprite.matrixWorld);
    return this.intersectsSphere(_sphere$2);
  }
  intersectsSphere(sphere) {
    const planes = this.planes;
    const center = sphere.center;
    const negRadius = -sphere.radius;
    for (let i2 = 0; i2 < 6; i2++) {
      const distance = planes[i2].distanceToPoint(center);
      if (distance < negRadius) {
        return false;
      }
    }
    return true;
  }
  intersectsBox(box) {
    const planes = this.planes;
    for (let i2 = 0; i2 < 6; i2++) {
      const plane = planes[i2];
      _vector$7.x = plane.normal.x > 0 ? box.max.x : box.min.x;
      _vector$7.y = plane.normal.y > 0 ? box.max.y : box.min.y;
      _vector$7.z = plane.normal.z > 0 ? box.max.z : box.min.z;
      if (plane.distanceToPoint(_vector$7) < 0) {
        return false;
      }
    }
    return true;
  }
  containsPoint(point) {
    const planes = this.planes;
    for (let i2 = 0; i2 < 6; i2++) {
      if (planes[i2].distanceToPoint(point) < 0) {
        return false;
      }
    }
    return true;
  }
  clone() {
    return new this.constructor().copy(this);
  }
};
function WebGLAnimation() {
  let context = null;
  let isAnimating = false;
  let animationLoop = null;
  let requestId = null;
  function onAnimationFrame(time, frame) {
    animationLoop(time, frame);
    requestId = context.requestAnimationFrame(onAnimationFrame);
  }
  return {
    start: function() {
      if (isAnimating === true)
        return;
      if (animationLoop === null)
        return;
      requestId = context.requestAnimationFrame(onAnimationFrame);
      isAnimating = true;
    },
    stop: function() {
      context.cancelAnimationFrame(requestId);
      isAnimating = false;
    },
    setAnimationLoop: function(callback) {
      animationLoop = callback;
    },
    setContext: function(value) {
      context = value;
    }
  };
}
function WebGLAttributes(gl, capabilities) {
  const isWebGL2 = capabilities.isWebGL2;
  const buffers = /* @__PURE__ */ new WeakMap();
  function createBuffer(attribute, bufferType) {
    const array = attribute.array;
    const usage = attribute.usage;
    const buffer = gl.createBuffer();
    gl.bindBuffer(bufferType, buffer);
    gl.bufferData(bufferType, array, usage);
    attribute.onUploadCallback();
    let type;
    if (array instanceof Float32Array) {
      type = 5126;
    } else if (array instanceof Uint16Array) {
      if (attribute.isFloat16BufferAttribute) {
        if (isWebGL2) {
          type = 5131;
        } else {
          throw new Error("THREE.WebGLAttributes: Usage of Float16BufferAttribute requires WebGL2.");
        }
      } else {
        type = 5123;
      }
    } else if (array instanceof Int16Array) {
      type = 5122;
    } else if (array instanceof Uint32Array) {
      type = 5125;
    } else if (array instanceof Int32Array) {
      type = 5124;
    } else if (array instanceof Int8Array) {
      type = 5120;
    } else if (array instanceof Uint8Array) {
      type = 5121;
    } else if (array instanceof Uint8ClampedArray) {
      type = 5121;
    } else {
      throw new Error("THREE.WebGLAttributes: Unsupported buffer data format: " + array);
    }
    return {
      buffer,
      type,
      bytesPerElement: array.BYTES_PER_ELEMENT,
      version: attribute.version
    };
  }
  function updateBuffer(buffer, attribute, bufferType) {
    const array = attribute.array;
    const updateRange = attribute.updateRange;
    gl.bindBuffer(bufferType, buffer);
    if (updateRange.count === -1) {
      gl.bufferSubData(bufferType, 0, array);
    } else {
      if (isWebGL2) {
        gl.bufferSubData(
          bufferType,
          updateRange.offset * array.BYTES_PER_ELEMENT,
          array,
          updateRange.offset,
          updateRange.count
        );
      } else {
        gl.bufferSubData(
          bufferType,
          updateRange.offset * array.BYTES_PER_ELEMENT,
          array.subarray(updateRange.offset, updateRange.offset + updateRange.count)
        );
      }
      updateRange.count = -1;
    }
  }
  function get(attribute) {
    if (attribute.isInterleavedBufferAttribute)
      attribute = attribute.data;
    return buffers.get(attribute);
  }
  function remove(attribute) {
    if (attribute.isInterleavedBufferAttribute)
      attribute = attribute.data;
    const data = buffers.get(attribute);
    if (data) {
      gl.deleteBuffer(data.buffer);
      buffers.delete(attribute);
    }
  }
  function update(attribute, bufferType) {
    if (attribute.isGLBufferAttribute) {
      const cached = buffers.get(attribute);
      if (!cached || cached.version < attribute.version) {
        buffers.set(attribute, {
          buffer: attribute.buffer,
          type: attribute.type,
          bytesPerElement: attribute.elementSize,
          version: attribute.version
        });
      }
      return;
    }
    if (attribute.isInterleavedBufferAttribute)
      attribute = attribute.data;
    const data = buffers.get(attribute);
    if (data === void 0) {
      buffers.set(attribute, createBuffer(attribute, bufferType));
    } else if (data.version < attribute.version) {
      updateBuffer(data.buffer, attribute, bufferType);
      data.version = attribute.version;
    }
  }
  return {
    get,
    remove,
    update
  };
}
var PlaneGeometry = class extends BufferGeometry {
  constructor(width = 1, height = 1, widthSegments = 1, heightSegments = 1) {
    super();
    this.type = "PlaneGeometry";
    this.parameters = {
      width,
      height,
      widthSegments,
      heightSegments
    };
    const width_half = width / 2;
    const height_half = height / 2;
    const gridX = Math.floor(widthSegments);
    const gridY = Math.floor(heightSegments);
    const gridX1 = gridX + 1;
    const gridY1 = gridY + 1;
    const segment_width = width / gridX;
    const segment_height = height / gridY;
    const indices = [];
    const vertices = [];
    const normals = [];
    const uvs = [];
    for (let iy = 0; iy < gridY1; iy++) {
      const y = iy * segment_height - height_half;
      for (let ix = 0; ix < gridX1; ix++) {
        const x = ix * segment_width - width_half;
        vertices.push(x, -y, 0);
        normals.push(0, 0, 1);
        uvs.push(ix / gridX);
        uvs.push(1 - iy / gridY);
      }
    }
    for (let iy = 0; iy < gridY; iy++) {
      for (let ix = 0; ix < gridX; ix++) {
        const a = ix + gridX1 * iy;
        const b = ix + gridX1 * (iy + 1);
        const c = ix + 1 + gridX1 * (iy + 1);
        const d = ix + 1 + gridX1 * iy;
        indices.push(a, b, d);
        indices.push(b, c, d);
      }
    }
    this.setIndex(indices);
    this.setAttribute("position", new Float32BufferAttribute(vertices, 3));
    this.setAttribute("normal", new Float32BufferAttribute(normals, 3));
    this.setAttribute("uv", new Float32BufferAttribute(uvs, 2));
  }
  static fromJSON(data) {
    return new PlaneGeometry(data.width, data.height, data.widthSegments, data.heightSegments);
  }
};
var alphamap_fragment = "#ifdef USE_ALPHAMAP\n	diffuseColor.a *= texture2D( alphaMap, vUv ).g;\n#endif";
var alphamap_pars_fragment = "#ifdef USE_ALPHAMAP\n	uniform sampler2D alphaMap;\n#endif";
var alphatest_fragment = "#ifdef USE_ALPHATEST\n	if ( diffuseColor.a < alphaTest ) discard;\n#endif";
var alphatest_pars_fragment = "#ifdef USE_ALPHATEST\n	uniform float alphaTest;\n#endif";
var aomap_fragment = "#ifdef USE_AOMAP\n	float ambientOcclusion = ( texture2D( aoMap, vUv2 ).r - 1.0 ) * aoMapIntensity + 1.0;\n	reflectedLight.indirectDiffuse *= ambientOcclusion;\n	#if defined( USE_ENVMAP ) && defined( STANDARD )\n		float dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );\n		reflectedLight.indirectSpecular *= computeSpecularOcclusion( dotNV, ambientOcclusion, material.roughness );\n	#endif\n#endif";
var aomap_pars_fragment = "#ifdef USE_AOMAP\n	uniform sampler2D aoMap;\n	uniform float aoMapIntensity;\n#endif";
var begin_vertex = "vec3 transformed = vec3( position );";
var beginnormal_vertex = "vec3 objectNormal = vec3( normal );\n#ifdef USE_TANGENT\n	vec3 objectTangent = vec3( tangent.xyz );\n#endif";
var bsdfs = "vec3 BRDF_Lambert( const in vec3 diffuseColor ) {\n	return RECIPROCAL_PI * diffuseColor;\n}\nvec3 F_Schlick( const in vec3 f0, const in float f90, const in float dotVH ) {\n	float fresnel = exp2( ( - 5.55473 * dotVH - 6.98316 ) * dotVH );\n	return f0 * ( 1.0 - fresnel ) + ( f90 * fresnel );\n}\nfloat F_Schlick( const in float f0, const in float f90, const in float dotVH ) {\n	float fresnel = exp2( ( - 5.55473 * dotVH - 6.98316 ) * dotVH );\n	return f0 * ( 1.0 - fresnel ) + ( f90 * fresnel );\n}\nvec3 Schlick_to_F0( const in vec3 f, const in float f90, const in float dotVH ) {\n    float x = clamp( 1.0 - dotVH, 0.0, 1.0 );\n    float x2 = x * x;\n    float x5 = clamp( x * x2 * x2, 0.0, 0.9999 );\n    return ( f - vec3( f90 ) * x5 ) / ( 1.0 - x5 );\n}\nfloat V_GGX_SmithCorrelated( const in float alpha, const in float dotNL, const in float dotNV ) {\n	float a2 = pow2( alpha );\n	float gv = dotNL * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNV ) );\n	float gl = dotNV * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNL ) );\n	return 0.5 / max( gv + gl, EPSILON );\n}\nfloat D_GGX( const in float alpha, const in float dotNH ) {\n	float a2 = pow2( alpha );\n	float denom = pow2( dotNH ) * ( a2 - 1.0 ) + 1.0;\n	return RECIPROCAL_PI * a2 / pow2( denom );\n}\nvec3 BRDF_GGX( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in vec3 f0, const in float f90, const in float roughness ) {\n	float alpha = pow2( roughness );\n	vec3 halfDir = normalize( lightDir + viewDir );\n	float dotNL = saturate( dot( normal, lightDir ) );\n	float dotNV = saturate( dot( normal, viewDir ) );\n	float dotNH = saturate( dot( normal, halfDir ) );\n	float dotVH = saturate( dot( viewDir, halfDir ) );\n	vec3 F = F_Schlick( f0, f90, dotVH );\n	float V = V_GGX_SmithCorrelated( alpha, dotNL, dotNV );\n	float D = D_GGX( alpha, dotNH );\n	return F * ( V * D );\n}\n#ifdef USE_IRIDESCENCE\n	vec3 BRDF_GGX_Iridescence( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in vec3 f0, const in float f90, const in float iridescence, const in vec3 iridescenceFresnel, const in float roughness ) {\n		float alpha = pow2( roughness );\n		vec3 halfDir = normalize( lightDir + viewDir );\n		float dotNL = saturate( dot( normal, lightDir ) );\n		float dotNV = saturate( dot( normal, viewDir ) );\n		float dotNH = saturate( dot( normal, halfDir ) );\n		float dotVH = saturate( dot( viewDir, halfDir ) );\n		vec3 F = mix( F_Schlick( f0, f90, dotVH ), iridescenceFresnel, iridescence );\n		float V = V_GGX_SmithCorrelated( alpha, dotNL, dotNV );\n		float D = D_GGX( alpha, dotNH );\n		return F * ( V * D );\n	}\n#endif\nvec2 LTC_Uv( const in vec3 N, const in vec3 V, const in float roughness ) {\n	const float LUT_SIZE = 64.0;\n	const float LUT_SCALE = ( LUT_SIZE - 1.0 ) / LUT_SIZE;\n	const float LUT_BIAS = 0.5 / LUT_SIZE;\n	float dotNV = saturate( dot( N, V ) );\n	vec2 uv = vec2( roughness, sqrt( 1.0 - dotNV ) );\n	uv = uv * LUT_SCALE + LUT_BIAS;\n	return uv;\n}\nfloat LTC_ClippedSphereFormFactor( const in vec3 f ) {\n	float l = length( f );\n	return max( ( l * l + f.z ) / ( l + 1.0 ), 0.0 );\n}\nvec3 LTC_EdgeVectorFormFactor( const in vec3 v1, const in vec3 v2 ) {\n	float x = dot( v1, v2 );\n	float y = abs( x );\n	float a = 0.8543985 + ( 0.4965155 + 0.0145206 * y ) * y;\n	float b = 3.4175940 + ( 4.1616724 + y ) * y;\n	float v = a / b;\n	float theta_sintheta = ( x > 0.0 ) ? v : 0.5 * inversesqrt( max( 1.0 - x * x, 1e-7 ) ) - v;\n	return cross( v1, v2 ) * theta_sintheta;\n}\nvec3 LTC_Evaluate( const in vec3 N, const in vec3 V, const in vec3 P, const in mat3 mInv, const in vec3 rectCoords[ 4 ] ) {\n	vec3 v1 = rectCoords[ 1 ] - rectCoords[ 0 ];\n	vec3 v2 = rectCoords[ 3 ] - rectCoords[ 0 ];\n	vec3 lightNormal = cross( v1, v2 );\n	if( dot( lightNormal, P - rectCoords[ 0 ] ) < 0.0 ) return vec3( 0.0 );\n	vec3 T1, T2;\n	T1 = normalize( V - N * dot( V, N ) );\n	T2 = - cross( N, T1 );\n	mat3 mat = mInv * transposeMat3( mat3( T1, T2, N ) );\n	vec3 coords[ 4 ];\n	coords[ 0 ] = mat * ( rectCoords[ 0 ] - P );\n	coords[ 1 ] = mat * ( rectCoords[ 1 ] - P );\n	coords[ 2 ] = mat * ( rectCoords[ 2 ] - P );\n	coords[ 3 ] = mat * ( rectCoords[ 3 ] - P );\n	coords[ 0 ] = normalize( coords[ 0 ] );\n	coords[ 1 ] = normalize( coords[ 1 ] );\n	coords[ 2 ] = normalize( coords[ 2 ] );\n	coords[ 3 ] = normalize( coords[ 3 ] );\n	vec3 vectorFormFactor = vec3( 0.0 );\n	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 0 ], coords[ 1 ] );\n	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 1 ], coords[ 2 ] );\n	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 2 ], coords[ 3 ] );\n	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 3 ], coords[ 0 ] );\n	float result = LTC_ClippedSphereFormFactor( vectorFormFactor );\n	return vec3( result );\n}\nfloat G_BlinnPhong_Implicit( ) {\n	return 0.25;\n}\nfloat D_BlinnPhong( const in float shininess, const in float dotNH ) {\n	return RECIPROCAL_PI * ( shininess * 0.5 + 1.0 ) * pow( dotNH, shininess );\n}\nvec3 BRDF_BlinnPhong( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in vec3 specularColor, const in float shininess ) {\n	vec3 halfDir = normalize( lightDir + viewDir );\n	float dotNH = saturate( dot( normal, halfDir ) );\n	float dotVH = saturate( dot( viewDir, halfDir ) );\n	vec3 F = F_Schlick( specularColor, 1.0, dotVH );\n	float G = G_BlinnPhong_Implicit( );\n	float D = D_BlinnPhong( shininess, dotNH );\n	return F * ( G * D );\n}\n#if defined( USE_SHEEN )\nfloat D_Charlie( float roughness, float dotNH ) {\n	float alpha = pow2( roughness );\n	float invAlpha = 1.0 / alpha;\n	float cos2h = dotNH * dotNH;\n	float sin2h = max( 1.0 - cos2h, 0.0078125 );\n	return ( 2.0 + invAlpha ) * pow( sin2h, invAlpha * 0.5 ) / ( 2.0 * PI );\n}\nfloat V_Neubelt( float dotNV, float dotNL ) {\n	return saturate( 1.0 / ( 4.0 * ( dotNL + dotNV - dotNL * dotNV ) ) );\n}\nvec3 BRDF_Sheen( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, vec3 sheenColor, const in float sheenRoughness ) {\n	vec3 halfDir = normalize( lightDir + viewDir );\n	float dotNL = saturate( dot( normal, lightDir ) );\n	float dotNV = saturate( dot( normal, viewDir ) );\n	float dotNH = saturate( dot( normal, halfDir ) );\n	float D = D_Charlie( sheenRoughness, dotNH );\n	float V = V_Neubelt( dotNV, dotNL );\n	return sheenColor * ( D * V );\n}\n#endif";
var iridescence_fragment = "#ifdef USE_IRIDESCENCE\n	const mat3 XYZ_TO_REC709 = mat3(\n		 3.2404542, -0.9692660,  0.0556434,\n		-1.5371385,  1.8760108, -0.2040259,\n		-0.4985314,  0.0415560,  1.0572252\n	);\n	vec3 Fresnel0ToIor( vec3 fresnel0 ) {\n		vec3 sqrtF0 = sqrt( fresnel0 );\n		return ( vec3( 1.0 ) + sqrtF0 ) / ( vec3( 1.0 ) - sqrtF0 );\n	}\n	vec3 IorToFresnel0( vec3 transmittedIor, float incidentIor ) {\n		return pow2( ( transmittedIor - vec3( incidentIor ) ) / ( transmittedIor + vec3( incidentIor ) ) );\n	}\n	float IorToFresnel0( float transmittedIor, float incidentIor ) {\n		return pow2( ( transmittedIor - incidentIor ) / ( transmittedIor + incidentIor ));\n	}\n	vec3 evalSensitivity( float OPD, vec3 shift ) {\n		float phase = 2.0 * PI * OPD * 1.0e-9;\n		vec3 val = vec3( 5.4856e-13, 4.4201e-13, 5.2481e-13 );\n		vec3 pos = vec3( 1.6810e+06, 1.7953e+06, 2.2084e+06 );\n		vec3 var = vec3( 4.3278e+09, 9.3046e+09, 6.6121e+09 );\n		vec3 xyz = val * sqrt( 2.0 * PI * var ) * cos( pos * phase + shift ) * exp( - pow2( phase ) * var );\n		xyz.x += 9.7470e-14 * sqrt( 2.0 * PI * 4.5282e+09 ) * cos( 2.2399e+06 * phase + shift[ 0 ] ) * exp( - 4.5282e+09 * pow2( phase ) );\n		xyz /= 1.0685e-7;\n		vec3 rgb = XYZ_TO_REC709 * xyz;\n		return rgb;\n	}\n	vec3 evalIridescence( float outsideIOR, float eta2, float cosTheta1, float thinFilmThickness, vec3 baseF0 ) {\n		vec3 I;\n		float iridescenceIOR = mix( outsideIOR, eta2, smoothstep( 0.0, 0.03, thinFilmThickness ) );\n		float sinTheta2Sq = pow2( outsideIOR / iridescenceIOR ) * ( 1.0 - pow2( cosTheta1 ) );\n		float cosTheta2Sq = 1.0 - sinTheta2Sq;\n		if ( cosTheta2Sq < 0.0 ) {\n			 return vec3( 1.0 );\n		}\n		float cosTheta2 = sqrt( cosTheta2Sq );\n		float R0 = IorToFresnel0( iridescenceIOR, outsideIOR );\n		float R12 = F_Schlick( R0, 1.0, cosTheta1 );\n		float R21 = R12;\n		float T121 = 1.0 - R12;\n		float phi12 = 0.0;\n		if ( iridescenceIOR < outsideIOR ) phi12 = PI;\n		float phi21 = PI - phi12;\n		vec3 baseIOR = Fresnel0ToIor( clamp( baseF0, 0.0, 0.9999 ) );		vec3 R1 = IorToFresnel0( baseIOR, iridescenceIOR );\n		vec3 R23 = F_Schlick( R1, 1.0, cosTheta2 );\n		vec3 phi23 = vec3( 0.0 );\n		if ( baseIOR[ 0 ] < iridescenceIOR ) phi23[ 0 ] = PI;\n		if ( baseIOR[ 1 ] < iridescenceIOR ) phi23[ 1 ] = PI;\n		if ( baseIOR[ 2 ] < iridescenceIOR ) phi23[ 2 ] = PI;\n		float OPD = 2.0 * iridescenceIOR * thinFilmThickness * cosTheta2;\n		vec3 phi = vec3( phi21 ) + phi23;\n		vec3 R123 = clamp( R12 * R23, 1e-5, 0.9999 );\n		vec3 r123 = sqrt( R123 );\n		vec3 Rs = pow2( T121 ) * R23 / ( vec3( 1.0 ) - R123 );\n		vec3 C0 = R12 + Rs;\n		I = C0;\n		vec3 Cm = Rs - T121;\n		for ( int m = 1; m <= 2; ++ m ) {\n			Cm *= r123;\n			vec3 Sm = 2.0 * evalSensitivity( float( m ) * OPD, float( m ) * phi );\n			I += Cm * Sm;\n		}\n		return max( I, vec3( 0.0 ) );\n	}\n#endif";
var bumpmap_pars_fragment = "#ifdef USE_BUMPMAP\n	uniform sampler2D bumpMap;\n	uniform float bumpScale;\n	vec2 dHdxy_fwd() {\n		vec2 dSTdx = dFdx( vUv );\n		vec2 dSTdy = dFdy( vUv );\n		float Hll = bumpScale * texture2D( bumpMap, vUv ).x;\n		float dBx = bumpScale * texture2D( bumpMap, vUv + dSTdx ).x - Hll;\n		float dBy = bumpScale * texture2D( bumpMap, vUv + dSTdy ).x - Hll;\n		return vec2( dBx, dBy );\n	}\n	vec3 perturbNormalArb( vec3 surf_pos, vec3 surf_norm, vec2 dHdxy, float faceDirection ) {\n		vec3 vSigmaX = dFdx( surf_pos.xyz );\n		vec3 vSigmaY = dFdy( surf_pos.xyz );\n		vec3 vN = surf_norm;\n		vec3 R1 = cross( vSigmaY, vN );\n		vec3 R2 = cross( vN, vSigmaX );\n		float fDet = dot( vSigmaX, R1 ) * faceDirection;\n		vec3 vGrad = sign( fDet ) * ( dHdxy.x * R1 + dHdxy.y * R2 );\n		return normalize( abs( fDet ) * surf_norm - vGrad );\n	}\n#endif";
var clipping_planes_fragment = "#if NUM_CLIPPING_PLANES > 0\n	vec4 plane;\n	#pragma unroll_loop_start\n	for ( int i = 0; i < UNION_CLIPPING_PLANES; i ++ ) {\n		plane = clippingPlanes[ i ];\n		if ( dot( vClipPosition, plane.xyz ) > plane.w ) discard;\n	}\n	#pragma unroll_loop_end\n	#if UNION_CLIPPING_PLANES < NUM_CLIPPING_PLANES\n		bool clipped = true;\n		#pragma unroll_loop_start\n		for ( int i = UNION_CLIPPING_PLANES; i < NUM_CLIPPING_PLANES; i ++ ) {\n			plane = clippingPlanes[ i ];\n			clipped = ( dot( vClipPosition, plane.xyz ) > plane.w ) && clipped;\n		}\n		#pragma unroll_loop_end\n		if ( clipped ) discard;\n	#endif\n#endif";
var clipping_planes_pars_fragment = "#if NUM_CLIPPING_PLANES > 0\n	varying vec3 vClipPosition;\n	uniform vec4 clippingPlanes[ NUM_CLIPPING_PLANES ];\n#endif";
var clipping_planes_pars_vertex = "#if NUM_CLIPPING_PLANES > 0\n	varying vec3 vClipPosition;\n#endif";
var clipping_planes_vertex = "#if NUM_CLIPPING_PLANES > 0\n	vClipPosition = - mvPosition.xyz;\n#endif";
var color_fragment = "#if defined( USE_COLOR_ALPHA )\n	diffuseColor *= vColor;\n#elif defined( USE_COLOR )\n	diffuseColor.rgb *= vColor;\n#endif";
var color_pars_fragment = "#if defined( USE_COLOR_ALPHA )\n	varying vec4 vColor;\n#elif defined( USE_COLOR )\n	varying vec3 vColor;\n#endif";
var color_pars_vertex = "#if defined( USE_COLOR_ALPHA )\n	varying vec4 vColor;\n#elif defined( USE_COLOR ) || defined( USE_INSTANCING_COLOR )\n	varying vec3 vColor;\n#endif";
var color_vertex = "#if defined( USE_COLOR_ALPHA )\n	vColor = vec4( 1.0 );\n#elif defined( USE_COLOR ) || defined( USE_INSTANCING_COLOR )\n	vColor = vec3( 1.0 );\n#endif\n#ifdef USE_COLOR\n	vColor *= color;\n#endif\n#ifdef USE_INSTANCING_COLOR\n	vColor.xyz *= instanceColor.xyz;\n#endif";
var common = "#define PI 3.141592653589793\n#define PI2 6.283185307179586\n#define PI_HALF 1.5707963267948966\n#define RECIPROCAL_PI 0.3183098861837907\n#define RECIPROCAL_PI2 0.15915494309189535\n#define EPSILON 1e-6\n#ifndef saturate\n#define saturate( a ) clamp( a, 0.0, 1.0 )\n#endif\n#define whiteComplement( a ) ( 1.0 - saturate( a ) )\nfloat pow2( const in float x ) { return x*x; }\nvec3 pow2( const in vec3 x ) { return x*x; }\nfloat pow3( const in float x ) { return x*x*x; }\nfloat pow4( const in float x ) { float x2 = x*x; return x2*x2; }\nfloat max3( const in vec3 v ) { return max( max( v.x, v.y ), v.z ); }\nfloat average( const in vec3 v ) { return dot( v, vec3( 0.3333333 ) ); }\nhighp float rand( const in vec2 uv ) {\n	const highp float a = 12.9898, b = 78.233, c = 43758.5453;\n	highp float dt = dot( uv.xy, vec2( a,b ) ), sn = mod( dt, PI );\n	return fract( sin( sn ) * c );\n}\n#ifdef HIGH_PRECISION\n	float precisionSafeLength( vec3 v ) { return length( v ); }\n#else\n	float precisionSafeLength( vec3 v ) {\n		float maxComponent = max3( abs( v ) );\n		return length( v / maxComponent ) * maxComponent;\n	}\n#endif\nstruct IncidentLight {\n	vec3 color;\n	vec3 direction;\n	bool visible;\n};\nstruct ReflectedLight {\n	vec3 directDiffuse;\n	vec3 directSpecular;\n	vec3 indirectDiffuse;\n	vec3 indirectSpecular;\n};\nstruct GeometricContext {\n	vec3 position;\n	vec3 normal;\n	vec3 viewDir;\n#ifdef USE_CLEARCOAT\n	vec3 clearcoatNormal;\n#endif\n};\nvec3 transformDirection( in vec3 dir, in mat4 matrix ) {\n	return normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );\n}\nvec3 inverseTransformDirection( in vec3 dir, in mat4 matrix ) {\n	return normalize( ( vec4( dir, 0.0 ) * matrix ).xyz );\n}\nmat3 transposeMat3( const in mat3 m ) {\n	mat3 tmp;\n	tmp[ 0 ] = vec3( m[ 0 ].x, m[ 1 ].x, m[ 2 ].x );\n	tmp[ 1 ] = vec3( m[ 0 ].y, m[ 1 ].y, m[ 2 ].y );\n	tmp[ 2 ] = vec3( m[ 0 ].z, m[ 1 ].z, m[ 2 ].z );\n	return tmp;\n}\nfloat luminance( const in vec3 rgb ) {\n	const vec3 weights = vec3( 0.2126729, 0.7151522, 0.0721750 );\n	return dot( weights, rgb );\n}\nbool isPerspectiveMatrix( mat4 m ) {\n	return m[ 2 ][ 3 ] == - 1.0;\n}\nvec2 equirectUv( in vec3 dir ) {\n	float u = atan( dir.z, dir.x ) * RECIPROCAL_PI2 + 0.5;\n	float v = asin( clamp( dir.y, - 1.0, 1.0 ) ) * RECIPROCAL_PI + 0.5;\n	return vec2( u, v );\n}";
var cube_uv_reflection_fragment = "#ifdef ENVMAP_TYPE_CUBE_UV\n	#define cubeUV_minMipLevel 4.0\n	#define cubeUV_minTileSize 16.0\n	float getFace( vec3 direction ) {\n		vec3 absDirection = abs( direction );\n		float face = - 1.0;\n		if ( absDirection.x > absDirection.z ) {\n			if ( absDirection.x > absDirection.y )\n				face = direction.x > 0.0 ? 0.0 : 3.0;\n			else\n				face = direction.y > 0.0 ? 1.0 : 4.0;\n		} else {\n			if ( absDirection.z > absDirection.y )\n				face = direction.z > 0.0 ? 2.0 : 5.0;\n			else\n				face = direction.y > 0.0 ? 1.0 : 4.0;\n		}\n		return face;\n	}\n	vec2 getUV( vec3 direction, float face ) {\n		vec2 uv;\n		if ( face == 0.0 ) {\n			uv = vec2( direction.z, direction.y ) / abs( direction.x );\n		} else if ( face == 1.0 ) {\n			uv = vec2( - direction.x, - direction.z ) / abs( direction.y );\n		} else if ( face == 2.0 ) {\n			uv = vec2( - direction.x, direction.y ) / abs( direction.z );\n		} else if ( face == 3.0 ) {\n			uv = vec2( - direction.z, direction.y ) / abs( direction.x );\n		} else if ( face == 4.0 ) {\n			uv = vec2( - direction.x, direction.z ) / abs( direction.y );\n		} else {\n			uv = vec2( direction.x, direction.y ) / abs( direction.z );\n		}\n		return 0.5 * ( uv + 1.0 );\n	}\n	vec3 bilinearCubeUV( sampler2D envMap, vec3 direction, float mipInt ) {\n		float face = getFace( direction );\n		float filterInt = max( cubeUV_minMipLevel - mipInt, 0.0 );\n		mipInt = max( mipInt, cubeUV_minMipLevel );\n		float faceSize = exp2( mipInt );\n		vec2 uv = getUV( direction, face ) * ( faceSize - 2.0 ) + 1.0;\n		if ( face > 2.0 ) {\n			uv.y += faceSize;\n			face -= 3.0;\n		}\n		uv.x += face * faceSize;\n		uv.x += filterInt * 3.0 * cubeUV_minTileSize;\n		uv.y += 4.0 * ( exp2( CUBEUV_MAX_MIP ) - faceSize );\n		uv.x *= CUBEUV_TEXEL_WIDTH;\n		uv.y *= CUBEUV_TEXEL_HEIGHT;\n		#ifdef texture2DGradEXT\n			return texture2DGradEXT( envMap, uv, vec2( 0.0 ), vec2( 0.0 ) ).rgb;\n		#else\n			return texture2D( envMap, uv ).rgb;\n		#endif\n	}\n	#define r0 1.0\n	#define v0 0.339\n	#define m0 - 2.0\n	#define r1 0.8\n	#define v1 0.276\n	#define m1 - 1.0\n	#define r4 0.4\n	#define v4 0.046\n	#define m4 2.0\n	#define r5 0.305\n	#define v5 0.016\n	#define m5 3.0\n	#define r6 0.21\n	#define v6 0.0038\n	#define m6 4.0\n	float roughnessToMip( float roughness ) {\n		float mip = 0.0;\n		if ( roughness >= r1 ) {\n			mip = ( r0 - roughness ) * ( m1 - m0 ) / ( r0 - r1 ) + m0;\n		} else if ( roughness >= r4 ) {\n			mip = ( r1 - roughness ) * ( m4 - m1 ) / ( r1 - r4 ) + m1;\n		} else if ( roughness >= r5 ) {\n			mip = ( r4 - roughness ) * ( m5 - m4 ) / ( r4 - r5 ) + m4;\n		} else if ( roughness >= r6 ) {\n			mip = ( r5 - roughness ) * ( m6 - m5 ) / ( r5 - r6 ) + m5;\n		} else {\n			mip = - 2.0 * log2( 1.16 * roughness );		}\n		return mip;\n	}\n	vec4 textureCubeUV( sampler2D envMap, vec3 sampleDir, float roughness ) {\n		float mip = clamp( roughnessToMip( roughness ), m0, CUBEUV_MAX_MIP );\n		float mipF = fract( mip );\n		float mipInt = floor( mip );\n		vec3 color0 = bilinearCubeUV( envMap, sampleDir, mipInt );\n		if ( mipF == 0.0 ) {\n			return vec4( color0, 1.0 );\n		} else {\n			vec3 color1 = bilinearCubeUV( envMap, sampleDir, mipInt + 1.0 );\n			return vec4( mix( color0, color1, mipF ), 1.0 );\n		}\n	}\n#endif";
var defaultnormal_vertex = "vec3 transformedNormal = objectNormal;\n#ifdef USE_INSTANCING\n	mat3 m = mat3( instanceMatrix );\n	transformedNormal /= vec3( dot( m[ 0 ], m[ 0 ] ), dot( m[ 1 ], m[ 1 ] ), dot( m[ 2 ], m[ 2 ] ) );\n	transformedNormal = m * transformedNormal;\n#endif\ntransformedNormal = normalMatrix * transformedNormal;\n#ifdef FLIP_SIDED\n	transformedNormal = - transformedNormal;\n#endif\n#ifdef USE_TANGENT\n	vec3 transformedTangent = ( modelViewMatrix * vec4( objectTangent, 0.0 ) ).xyz;\n	#ifdef FLIP_SIDED\n		transformedTangent = - transformedTangent;\n	#endif\n#endif";
var displacementmap_pars_vertex = "#ifdef USE_DISPLACEMENTMAP\n	uniform sampler2D displacementMap;\n	uniform float displacementScale;\n	uniform float displacementBias;\n#endif";
var displacementmap_vertex = "#ifdef USE_DISPLACEMENTMAP\n	transformed += normalize( objectNormal ) * ( texture2D( displacementMap, vUv ).x * displacementScale + displacementBias );\n#endif";
var emissivemap_fragment = "#ifdef USE_EMISSIVEMAP\n	vec4 emissiveColor = texture2D( emissiveMap, vUv );\n	totalEmissiveRadiance *= emissiveColor.rgb;\n#endif";
var emissivemap_pars_fragment = "#ifdef USE_EMISSIVEMAP\n	uniform sampler2D emissiveMap;\n#endif";
var encodings_fragment = "gl_FragColor = linearToOutputTexel( gl_FragColor );";
var encodings_pars_fragment = "vec4 LinearToLinear( in vec4 value ) {\n	return value;\n}\nvec4 LinearTosRGB( in vec4 value ) {\n	return vec4( mix( pow( value.rgb, vec3( 0.41666 ) ) * 1.055 - vec3( 0.055 ), value.rgb * 12.92, vec3( lessThanEqual( value.rgb, vec3( 0.0031308 ) ) ) ), value.a );\n}";
var envmap_fragment = "#ifdef USE_ENVMAP\n	#ifdef ENV_WORLDPOS\n		vec3 cameraToFrag;\n		if ( isOrthographic ) {\n			cameraToFrag = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );\n		} else {\n			cameraToFrag = normalize( vWorldPosition - cameraPosition );\n		}\n		vec3 worldNormal = inverseTransformDirection( normal, viewMatrix );\n		#ifdef ENVMAP_MODE_REFLECTION\n			vec3 reflectVec = reflect( cameraToFrag, worldNormal );\n		#else\n			vec3 reflectVec = refract( cameraToFrag, worldNormal, refractionRatio );\n		#endif\n	#else\n		vec3 reflectVec = vReflect;\n	#endif\n	#ifdef ENVMAP_TYPE_CUBE\n		vec4 envColor = textureCube( envMap, vec3( flipEnvMap * reflectVec.x, reflectVec.yz ) );\n	#elif defined( ENVMAP_TYPE_CUBE_UV )\n		vec4 envColor = textureCubeUV( envMap, reflectVec, 0.0 );\n	#else\n		vec4 envColor = vec4( 0.0 );\n	#endif\n	#ifdef ENVMAP_BLENDING_MULTIPLY\n		outgoingLight = mix( outgoingLight, outgoingLight * envColor.xyz, specularStrength * reflectivity );\n	#elif defined( ENVMAP_BLENDING_MIX )\n		outgoingLight = mix( outgoingLight, envColor.xyz, specularStrength * reflectivity );\n	#elif defined( ENVMAP_BLENDING_ADD )\n		outgoingLight += envColor.xyz * specularStrength * reflectivity;\n	#endif\n#endif";
var envmap_common_pars_fragment = "#ifdef USE_ENVMAP\n	uniform float envMapIntensity;\n	uniform float flipEnvMap;\n	#ifdef ENVMAP_TYPE_CUBE\n		uniform samplerCube envMap;\n	#else\n		uniform sampler2D envMap;\n	#endif\n	\n#endif";
var envmap_pars_fragment = "#ifdef USE_ENVMAP\n	uniform float reflectivity;\n	#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG )\n		#define ENV_WORLDPOS\n	#endif\n	#ifdef ENV_WORLDPOS\n		varying vec3 vWorldPosition;\n		uniform float refractionRatio;\n	#else\n		varying vec3 vReflect;\n	#endif\n#endif";
var envmap_pars_vertex = "#ifdef USE_ENVMAP\n	#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) ||defined( PHONG )\n		#define ENV_WORLDPOS\n	#endif\n	#ifdef ENV_WORLDPOS\n		\n		varying vec3 vWorldPosition;\n	#else\n		varying vec3 vReflect;\n		uniform float refractionRatio;\n	#endif\n#endif";
var envmap_vertex = "#ifdef USE_ENVMAP\n	#ifdef ENV_WORLDPOS\n		vWorldPosition = worldPosition.xyz;\n	#else\n		vec3 cameraToVertex;\n		if ( isOrthographic ) {\n			cameraToVertex = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );\n		} else {\n			cameraToVertex = normalize( worldPosition.xyz - cameraPosition );\n		}\n		vec3 worldNormal = inverseTransformDirection( transformedNormal, viewMatrix );\n		#ifdef ENVMAP_MODE_REFLECTION\n			vReflect = reflect( cameraToVertex, worldNormal );\n		#else\n			vReflect = refract( cameraToVertex, worldNormal, refractionRatio );\n		#endif\n	#endif\n#endif";
var fog_vertex = "#ifdef USE_FOG\n	vFogDepth = - mvPosition.z;\n#endif";
var fog_pars_vertex = "#ifdef USE_FOG\n	varying float vFogDepth;\n#endif";
var fog_fragment = "#ifdef USE_FOG\n	#ifdef FOG_EXP2\n		float fogFactor = 1.0 - exp( - fogDensity * fogDensity * vFogDepth * vFogDepth );\n	#else\n		float fogFactor = smoothstep( fogNear, fogFar, vFogDepth );\n	#endif\n	gl_FragColor.rgb = mix( gl_FragColor.rgb, fogColor, fogFactor );\n#endif";
var fog_pars_fragment = "#ifdef USE_FOG\n	uniform vec3 fogColor;\n	varying float vFogDepth;\n	#ifdef FOG_EXP2\n		uniform float fogDensity;\n	#else\n		uniform float fogNear;\n		uniform float fogFar;\n	#endif\n#endif";
var gradientmap_pars_fragment = "#ifdef USE_GRADIENTMAP\n	uniform sampler2D gradientMap;\n#endif\nvec3 getGradientIrradiance( vec3 normal, vec3 lightDirection ) {\n	float dotNL = dot( normal, lightDirection );\n	vec2 coord = vec2( dotNL * 0.5 + 0.5, 0.0 );\n	#ifdef USE_GRADIENTMAP\n		return vec3( texture2D( gradientMap, coord ).r );\n	#else\n		return ( coord.x < 0.7 ) ? vec3( 0.7 ) : vec3( 1.0 );\n	#endif\n}";
var lightmap_fragment = "#ifdef USE_LIGHTMAP\n	vec4 lightMapTexel = texture2D( lightMap, vUv2 );\n	vec3 lightMapIrradiance = lightMapTexel.rgb * lightMapIntensity;\n	reflectedLight.indirectDiffuse += lightMapIrradiance;\n#endif";
var lightmap_pars_fragment = "#ifdef USE_LIGHTMAP\n	uniform sampler2D lightMap;\n	uniform float lightMapIntensity;\n#endif";
var lights_lambert_vertex = "vec3 diffuse = vec3( 1.0 );\nGeometricContext geometry;\ngeometry.position = mvPosition.xyz;\ngeometry.normal = normalize( transformedNormal );\ngeometry.viewDir = ( isOrthographic ) ? vec3( 0, 0, 1 ) : normalize( -mvPosition.xyz );\nGeometricContext backGeometry;\nbackGeometry.position = geometry.position;\nbackGeometry.normal = -geometry.normal;\nbackGeometry.viewDir = geometry.viewDir;\nvLightFront = vec3( 0.0 );\nvIndirectFront = vec3( 0.0 );\n#ifdef DOUBLE_SIDED\n	vLightBack = vec3( 0.0 );\n	vIndirectBack = vec3( 0.0 );\n#endif\nIncidentLight directLight;\nfloat dotNL;\nvec3 directLightColor_Diffuse;\nvIndirectFront += getAmbientLightIrradiance( ambientLightColor );\nvIndirectFront += getLightProbeIrradiance( lightProbe, geometry.normal );\n#ifdef DOUBLE_SIDED\n	vIndirectBack += getAmbientLightIrradiance( ambientLightColor );\n	vIndirectBack += getLightProbeIrradiance( lightProbe, backGeometry.normal );\n#endif\n#if NUM_POINT_LIGHTS > 0\n	#pragma unroll_loop_start\n	for ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\n		getPointLightInfo( pointLights[ i ], geometry, directLight );\n		dotNL = dot( geometry.normal, directLight.direction );\n		directLightColor_Diffuse = directLight.color;\n		vLightFront += saturate( dotNL ) * directLightColor_Diffuse;\n		#ifdef DOUBLE_SIDED\n			vLightBack += saturate( - dotNL ) * directLightColor_Diffuse;\n		#endif\n	}\n	#pragma unroll_loop_end\n#endif\n#if NUM_SPOT_LIGHTS > 0\n	#pragma unroll_loop_start\n	for ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\n		getSpotLightInfo( spotLights[ i ], geometry, directLight );\n		dotNL = dot( geometry.normal, directLight.direction );\n		directLightColor_Diffuse = directLight.color;\n		vLightFront += saturate( dotNL ) * directLightColor_Diffuse;\n		#ifdef DOUBLE_SIDED\n			vLightBack += saturate( - dotNL ) * directLightColor_Diffuse;\n		#endif\n	}\n	#pragma unroll_loop_end\n#endif\n#if NUM_DIR_LIGHTS > 0\n	#pragma unroll_loop_start\n	for ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\n		getDirectionalLightInfo( directionalLights[ i ], geometry, directLight );\n		dotNL = dot( geometry.normal, directLight.direction );\n		directLightColor_Diffuse = directLight.color;\n		vLightFront += saturate( dotNL ) * directLightColor_Diffuse;\n		#ifdef DOUBLE_SIDED\n			vLightBack += saturate( - dotNL ) * directLightColor_Diffuse;\n		#endif\n	}\n	#pragma unroll_loop_end\n#endif\n#if NUM_HEMI_LIGHTS > 0\n	#pragma unroll_loop_start\n	for ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {\n		vIndirectFront += getHemisphereLightIrradiance( hemisphereLights[ i ], geometry.normal );\n		#ifdef DOUBLE_SIDED\n			vIndirectBack += getHemisphereLightIrradiance( hemisphereLights[ i ], backGeometry.normal );\n		#endif\n	}\n	#pragma unroll_loop_end\n#endif";
var lights_pars_begin = "uniform bool receiveShadow;\nuniform vec3 ambientLightColor;\nuniform vec3 lightProbe[ 9 ];\nvec3 shGetIrradianceAt( in vec3 normal, in vec3 shCoefficients[ 9 ] ) {\n	float x = normal.x, y = normal.y, z = normal.z;\n	vec3 result = shCoefficients[ 0 ] * 0.886227;\n	result += shCoefficients[ 1 ] * 2.0 * 0.511664 * y;\n	result += shCoefficients[ 2 ] * 2.0 * 0.511664 * z;\n	result += shCoefficients[ 3 ] * 2.0 * 0.511664 * x;\n	result += shCoefficients[ 4 ] * 2.0 * 0.429043 * x * y;\n	result += shCoefficients[ 5 ] * 2.0 * 0.429043 * y * z;\n	result += shCoefficients[ 6 ] * ( 0.743125 * z * z - 0.247708 );\n	result += shCoefficients[ 7 ] * 2.0 * 0.429043 * x * z;\n	result += shCoefficients[ 8 ] * 0.429043 * ( x * x - y * y );\n	return result;\n}\nvec3 getLightProbeIrradiance( const in vec3 lightProbe[ 9 ], const in vec3 normal ) {\n	vec3 worldNormal = inverseTransformDirection( normal, viewMatrix );\n	vec3 irradiance = shGetIrradianceAt( worldNormal, lightProbe );\n	return irradiance;\n}\nvec3 getAmbientLightIrradiance( const in vec3 ambientLightColor ) {\n	vec3 irradiance = ambientLightColor;\n	return irradiance;\n}\nfloat getDistanceAttenuation( const in float lightDistance, const in float cutoffDistance, const in float decayExponent ) {\n	#if defined ( PHYSICALLY_CORRECT_LIGHTS )\n		float distanceFalloff = 1.0 / max( pow( lightDistance, decayExponent ), 0.01 );\n		if ( cutoffDistance > 0.0 ) {\n			distanceFalloff *= pow2( saturate( 1.0 - pow4( lightDistance / cutoffDistance ) ) );\n		}\n		return distanceFalloff;\n	#else\n		if ( cutoffDistance > 0.0 && decayExponent > 0.0 ) {\n			return pow( saturate( - lightDistance / cutoffDistance + 1.0 ), decayExponent );\n		}\n		return 1.0;\n	#endif\n}\nfloat getSpotAttenuation( const in float coneCosine, const in float penumbraCosine, const in float angleCosine ) {\n	return smoothstep( coneCosine, penumbraCosine, angleCosine );\n}\n#if NUM_DIR_LIGHTS > 0\n	struct DirectionalLight {\n		vec3 direction;\n		vec3 color;\n	};\n	uniform DirectionalLight directionalLights[ NUM_DIR_LIGHTS ];\n	void getDirectionalLightInfo( const in DirectionalLight directionalLight, const in GeometricContext geometry, out IncidentLight light ) {\n		light.color = directionalLight.color;\n		light.direction = directionalLight.direction;\n		light.visible = true;\n	}\n#endif\n#if NUM_POINT_LIGHTS > 0\n	struct PointLight {\n		vec3 position;\n		vec3 color;\n		float distance;\n		float decay;\n	};\n	uniform PointLight pointLights[ NUM_POINT_LIGHTS ];\n	void getPointLightInfo( const in PointLight pointLight, const in GeometricContext geometry, out IncidentLight light ) {\n		vec3 lVector = pointLight.position - geometry.position;\n		light.direction = normalize( lVector );\n		float lightDistance = length( lVector );\n		light.color = pointLight.color;\n		light.color *= getDistanceAttenuation( lightDistance, pointLight.distance, pointLight.decay );\n		light.visible = ( light.color != vec3( 0.0 ) );\n	}\n#endif\n#if NUM_SPOT_LIGHTS > 0\n	struct SpotLight {\n		vec3 position;\n		vec3 direction;\n		vec3 color;\n		float distance;\n		float decay;\n		float coneCos;\n		float penumbraCos;\n	};\n	uniform SpotLight spotLights[ NUM_SPOT_LIGHTS ];\n	void getSpotLightInfo( const in SpotLight spotLight, const in GeometricContext geometry, out IncidentLight light ) {\n		vec3 lVector = spotLight.position - geometry.position;\n		light.direction = normalize( lVector );\n		float angleCos = dot( light.direction, spotLight.direction );\n		float spotAttenuation = getSpotAttenuation( spotLight.coneCos, spotLight.penumbraCos, angleCos );\n		if ( spotAttenuation > 0.0 ) {\n			float lightDistance = length( lVector );\n			light.color = spotLight.color * spotAttenuation;\n			light.color *= getDistanceAttenuation( lightDistance, spotLight.distance, spotLight.decay );\n			light.visible = ( light.color != vec3( 0.0 ) );\n		} else {\n			light.color = vec3( 0.0 );\n			light.visible = false;\n		}\n	}\n#endif\n#if NUM_RECT_AREA_LIGHTS > 0\n	struct RectAreaLight {\n		vec3 color;\n		vec3 position;\n		vec3 halfWidth;\n		vec3 halfHeight;\n	};\n	uniform sampler2D ltc_1;	uniform sampler2D ltc_2;\n	uniform RectAreaLight rectAreaLights[ NUM_RECT_AREA_LIGHTS ];\n#endif\n#if NUM_HEMI_LIGHTS > 0\n	struct HemisphereLight {\n		vec3 direction;\n		vec3 skyColor;\n		vec3 groundColor;\n	};\n	uniform HemisphereLight hemisphereLights[ NUM_HEMI_LIGHTS ];\n	vec3 getHemisphereLightIrradiance( const in HemisphereLight hemiLight, const in vec3 normal ) {\n		float dotNL = dot( normal, hemiLight.direction );\n		float hemiDiffuseWeight = 0.5 * dotNL + 0.5;\n		vec3 irradiance = mix( hemiLight.groundColor, hemiLight.skyColor, hemiDiffuseWeight );\n		return irradiance;\n	}\n#endif";
var envmap_physical_pars_fragment = "#if defined( USE_ENVMAP )\n	vec3 getIBLIrradiance( const in vec3 normal ) {\n		#if defined( ENVMAP_TYPE_CUBE_UV )\n			vec3 worldNormal = inverseTransformDirection( normal, viewMatrix );\n			vec4 envMapColor = textureCubeUV( envMap, worldNormal, 1.0 );\n			return PI * envMapColor.rgb * envMapIntensity;\n		#else\n			return vec3( 0.0 );\n		#endif\n	}\n	vec3 getIBLRadiance( const in vec3 viewDir, const in vec3 normal, const in float roughness ) {\n		#if defined( ENVMAP_TYPE_CUBE_UV )\n			vec3 reflectVec = reflect( - viewDir, normal );\n			reflectVec = normalize( mix( reflectVec, normal, roughness * roughness) );\n			reflectVec = inverseTransformDirection( reflectVec, viewMatrix );\n			vec4 envMapColor = textureCubeUV( envMap, reflectVec, roughness );\n			return envMapColor.rgb * envMapIntensity;\n		#else\n			return vec3( 0.0 );\n		#endif\n	}\n#endif";
var lights_toon_fragment = "ToonMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb;";
var lights_toon_pars_fragment = "varying vec3 vViewPosition;\nstruct ToonMaterial {\n	vec3 diffuseColor;\n};\nvoid RE_Direct_Toon( const in IncidentLight directLight, const in GeometricContext geometry, const in ToonMaterial material, inout ReflectedLight reflectedLight ) {\n	vec3 irradiance = getGradientIrradiance( geometry.normal, directLight.direction ) * directLight.color;\n	reflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n}\nvoid RE_IndirectDiffuse_Toon( const in vec3 irradiance, const in GeometricContext geometry, const in ToonMaterial material, inout ReflectedLight reflectedLight ) {\n	reflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n}\n#define RE_Direct				RE_Direct_Toon\n#define RE_IndirectDiffuse		RE_IndirectDiffuse_Toon\n#define Material_LightProbeLOD( material )	(0)";
var lights_phong_fragment = "BlinnPhongMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb;\nmaterial.specularColor = specular;\nmaterial.specularShininess = shininess;\nmaterial.specularStrength = specularStrength;";
var lights_phong_pars_fragment = "varying vec3 vViewPosition;\nstruct BlinnPhongMaterial {\n	vec3 diffuseColor;\n	vec3 specularColor;\n	float specularShininess;\n	float specularStrength;\n};\nvoid RE_Direct_BlinnPhong( const in IncidentLight directLight, const in GeometricContext geometry, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {\n	float dotNL = saturate( dot( geometry.normal, directLight.direction ) );\n	vec3 irradiance = dotNL * directLight.color;\n	reflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n	reflectedLight.directSpecular += irradiance * BRDF_BlinnPhong( directLight.direction, geometry.viewDir, geometry.normal, material.specularColor, material.specularShininess ) * material.specularStrength;\n}\nvoid RE_IndirectDiffuse_BlinnPhong( const in vec3 irradiance, const in GeometricContext geometry, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {\n	reflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n}\n#define RE_Direct				RE_Direct_BlinnPhong\n#define RE_IndirectDiffuse		RE_IndirectDiffuse_BlinnPhong\n#define Material_LightProbeLOD( material )	(0)";
var lights_physical_fragment = "PhysicalMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb * ( 1.0 - metalnessFactor );\nvec3 dxy = max( abs( dFdx( geometryNormal ) ), abs( dFdy( geometryNormal ) ) );\nfloat geometryRoughness = max( max( dxy.x, dxy.y ), dxy.z );\nmaterial.roughness = max( roughnessFactor, 0.0525 );material.roughness += geometryRoughness;\nmaterial.roughness = min( material.roughness, 1.0 );\n#ifdef IOR\n	#ifdef SPECULAR\n		float specularIntensityFactor = specularIntensity;\n		vec3 specularColorFactor = specularColor;\n		#ifdef USE_SPECULARINTENSITYMAP\n			specularIntensityFactor *= texture2D( specularIntensityMap, vUv ).a;\n		#endif\n		#ifdef USE_SPECULARCOLORMAP\n			specularColorFactor *= texture2D( specularColorMap, vUv ).rgb;\n		#endif\n		material.specularF90 = mix( specularIntensityFactor, 1.0, metalnessFactor );\n	#else\n		float specularIntensityFactor = 1.0;\n		vec3 specularColorFactor = vec3( 1.0 );\n		material.specularF90 = 1.0;\n	#endif\n	material.specularColor = mix( min( pow2( ( ior - 1.0 ) / ( ior + 1.0 ) ) * specularColorFactor, vec3( 1.0 ) ) * specularIntensityFactor, diffuseColor.rgb, metalnessFactor );\n#else\n	material.specularColor = mix( vec3( 0.04 ), diffuseColor.rgb, metalnessFactor );\n	material.specularF90 = 1.0;\n#endif\n#ifdef USE_CLEARCOAT\n	material.clearcoat = clearcoat;\n	material.clearcoatRoughness = clearcoatRoughness;\n	material.clearcoatF0 = vec3( 0.04 );\n	material.clearcoatF90 = 1.0;\n	#ifdef USE_CLEARCOATMAP\n		material.clearcoat *= texture2D( clearcoatMap, vUv ).x;\n	#endif\n	#ifdef USE_CLEARCOAT_ROUGHNESSMAP\n		material.clearcoatRoughness *= texture2D( clearcoatRoughnessMap, vUv ).y;\n	#endif\n	material.clearcoat = saturate( material.clearcoat );	material.clearcoatRoughness = max( material.clearcoatRoughness, 0.0525 );\n	material.clearcoatRoughness += geometryRoughness;\n	material.clearcoatRoughness = min( material.clearcoatRoughness, 1.0 );\n#endif\n#ifdef USE_IRIDESCENCE\n	material.iridescence = iridescence;\n	material.iridescenceIOR = iridescenceIOR;\n	#ifdef USE_IRIDESCENCEMAP\n		material.iridescence *= texture2D( iridescenceMap, vUv ).r;\n	#endif\n	#ifdef USE_IRIDESCENCE_THICKNESSMAP\n		material.iridescenceThickness = (iridescenceThicknessMaximum - iridescenceThicknessMinimum) * texture2D( iridescenceThicknessMap, vUv ).g + iridescenceThicknessMinimum;\n	#else\n		material.iridescenceThickness = iridescenceThicknessMaximum;\n	#endif\n#endif\n#ifdef USE_SHEEN\n	material.sheenColor = sheenColor;\n	#ifdef USE_SHEENCOLORMAP\n		material.sheenColor *= texture2D( sheenColorMap, vUv ).rgb;\n	#endif\n	material.sheenRoughness = clamp( sheenRoughness, 0.07, 1.0 );\n	#ifdef USE_SHEENROUGHNESSMAP\n		material.sheenRoughness *= texture2D( sheenRoughnessMap, vUv ).a;\n	#endif\n#endif";
var lights_physical_pars_fragment = "struct PhysicalMaterial {\n	vec3 diffuseColor;\n	float roughness;\n	vec3 specularColor;\n	float specularF90;\n	#ifdef USE_CLEARCOAT\n		float clearcoat;\n		float clearcoatRoughness;\n		vec3 clearcoatF0;\n		float clearcoatF90;\n	#endif\n	#ifdef USE_IRIDESCENCE\n		float iridescence;\n		float iridescenceIOR;\n		float iridescenceThickness;\n		vec3 iridescenceFresnel;\n		vec3 iridescenceF0;\n	#endif\n	#ifdef USE_SHEEN\n		vec3 sheenColor;\n		float sheenRoughness;\n	#endif\n};\nvec3 clearcoatSpecular = vec3( 0.0 );\nvec3 sheenSpecular = vec3( 0.0 );\nfloat IBLSheenBRDF( const in vec3 normal, const in vec3 viewDir, const in float roughness) {\n	float dotNV = saturate( dot( normal, viewDir ) );\n	float r2 = roughness * roughness;\n	float a = roughness < 0.25 ? -339.2 * r2 + 161.4 * roughness - 25.9 : -8.48 * r2 + 14.3 * roughness - 9.95;\n	float b = roughness < 0.25 ? 44.0 * r2 - 23.7 * roughness + 3.26 : 1.97 * r2 - 3.27 * roughness + 0.72;\n	float DG = exp( a * dotNV + b ) + ( roughness < 0.25 ? 0.0 : 0.1 * ( roughness - 0.25 ) );\n	return saturate( DG * RECIPROCAL_PI );\n}\nvec2 DFGApprox( const in vec3 normal, const in vec3 viewDir, const in float roughness ) {\n	float dotNV = saturate( dot( normal, viewDir ) );\n	const vec4 c0 = vec4( - 1, - 0.0275, - 0.572, 0.022 );\n	const vec4 c1 = vec4( 1, 0.0425, 1.04, - 0.04 );\n	vec4 r = roughness * c0 + c1;\n	float a004 = min( r.x * r.x, exp2( - 9.28 * dotNV ) ) * r.x + r.y;\n	vec2 fab = vec2( - 1.04, 1.04 ) * a004 + r.zw;\n	return fab;\n}\nvec3 EnvironmentBRDF( const in vec3 normal, const in vec3 viewDir, const in vec3 specularColor, const in float specularF90, const in float roughness ) {\n	vec2 fab = DFGApprox( normal, viewDir, roughness );\n	return specularColor * fab.x + specularF90 * fab.y;\n}\n#ifdef USE_IRIDESCENCE\nvoid computeMultiscatteringIridescence( const in vec3 normal, const in vec3 viewDir, const in vec3 specularColor, const in float specularF90, const in float iridescence, const in vec3 iridescenceF0, const in float roughness, inout vec3 singleScatter, inout vec3 multiScatter ) {\n#else\nvoid computeMultiscattering( const in vec3 normal, const in vec3 viewDir, const in vec3 specularColor, const in float specularF90, const in float roughness, inout vec3 singleScatter, inout vec3 multiScatter ) {\n#endif\n	vec2 fab = DFGApprox( normal, viewDir, roughness );\n	#ifdef USE_IRIDESCENCE\n		vec3 Fr = mix( specularColor, iridescenceF0, iridescence );\n	#else\n		vec3 Fr = specularColor;\n	#endif\n	vec3 FssEss = Fr * fab.x + specularF90 * fab.y;\n	float Ess = fab.x + fab.y;\n	float Ems = 1.0 - Ess;\n	vec3 Favg = Fr + ( 1.0 - Fr ) * 0.047619;	vec3 Fms = FssEss * Favg / ( 1.0 - Ems * Favg );\n	singleScatter += FssEss;\n	multiScatter += Fms * Ems;\n}\n#if NUM_RECT_AREA_LIGHTS > 0\n	void RE_Direct_RectArea_Physical( const in RectAreaLight rectAreaLight, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n		vec3 normal = geometry.normal;\n		vec3 viewDir = geometry.viewDir;\n		vec3 position = geometry.position;\n		vec3 lightPos = rectAreaLight.position;\n		vec3 halfWidth = rectAreaLight.halfWidth;\n		vec3 halfHeight = rectAreaLight.halfHeight;\n		vec3 lightColor = rectAreaLight.color;\n		float roughness = material.roughness;\n		vec3 rectCoords[ 4 ];\n		rectCoords[ 0 ] = lightPos + halfWidth - halfHeight;		rectCoords[ 1 ] = lightPos - halfWidth - halfHeight;\n		rectCoords[ 2 ] = lightPos - halfWidth + halfHeight;\n		rectCoords[ 3 ] = lightPos + halfWidth + halfHeight;\n		vec2 uv = LTC_Uv( normal, viewDir, roughness );\n		vec4 t1 = texture2D( ltc_1, uv );\n		vec4 t2 = texture2D( ltc_2, uv );\n		mat3 mInv = mat3(\n			vec3( t1.x, 0, t1.y ),\n			vec3(    0, 1,    0 ),\n			vec3( t1.z, 0, t1.w )\n		);\n		vec3 fresnel = ( material.specularColor * t2.x + ( vec3( 1.0 ) - material.specularColor ) * t2.y );\n		reflectedLight.directSpecular += lightColor * fresnel * LTC_Evaluate( normal, viewDir, position, mInv, rectCoords );\n		reflectedLight.directDiffuse += lightColor * material.diffuseColor * LTC_Evaluate( normal, viewDir, position, mat3( 1.0 ), rectCoords );\n	}\n#endif\nvoid RE_Direct_Physical( const in IncidentLight directLight, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n	float dotNL = saturate( dot( geometry.normal, directLight.direction ) );\n	vec3 irradiance = dotNL * directLight.color;\n	#ifdef USE_CLEARCOAT\n		float dotNLcc = saturate( dot( geometry.clearcoatNormal, directLight.direction ) );\n		vec3 ccIrradiance = dotNLcc * directLight.color;\n		clearcoatSpecular += ccIrradiance * BRDF_GGX( directLight.direction, geometry.viewDir, geometry.clearcoatNormal, material.clearcoatF0, material.clearcoatF90, material.clearcoatRoughness );\n	#endif\n	#ifdef USE_SHEEN\n		sheenSpecular += irradiance * BRDF_Sheen( directLight.direction, geometry.viewDir, geometry.normal, material.sheenColor, material.sheenRoughness );\n	#endif\n	#ifdef USE_IRIDESCENCE\n		reflectedLight.directSpecular += irradiance * BRDF_GGX_Iridescence( directLight.direction, geometry.viewDir, geometry.normal, material.specularColor, material.specularF90, material.iridescence, material.iridescenceFresnel, material.roughness );\n	#else\n		reflectedLight.directSpecular += irradiance * BRDF_GGX( directLight.direction, geometry.viewDir, geometry.normal, material.specularColor, material.specularF90, material.roughness );\n	#endif\n	reflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n}\nvoid RE_IndirectDiffuse_Physical( const in vec3 irradiance, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n	reflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n}\nvoid RE_IndirectSpecular_Physical( const in vec3 radiance, const in vec3 irradiance, const in vec3 clearcoatRadiance, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight) {\n	#ifdef USE_CLEARCOAT\n		clearcoatSpecular += clearcoatRadiance * EnvironmentBRDF( geometry.clearcoatNormal, geometry.viewDir, material.clearcoatF0, material.clearcoatF90, material.clearcoatRoughness );\n	#endif\n	#ifdef USE_SHEEN\n		sheenSpecular += irradiance * material.sheenColor * IBLSheenBRDF( geometry.normal, geometry.viewDir, material.sheenRoughness );\n	#endif\n	vec3 singleScattering = vec3( 0.0 );\n	vec3 multiScattering = vec3( 0.0 );\n	vec3 cosineWeightedIrradiance = irradiance * RECIPROCAL_PI;\n	#ifdef USE_IRIDESCENCE\n		computeMultiscatteringIridescence( geometry.normal, geometry.viewDir, material.specularColor, material.specularF90, material.iridescence, material.iridescenceFresnel, material.roughness, singleScattering, multiScattering );\n	#else\n		computeMultiscattering( geometry.normal, geometry.viewDir, material.specularColor, material.specularF90, material.roughness, singleScattering, multiScattering );\n	#endif\n	vec3 totalScattering = singleScattering + multiScattering;\n	vec3 diffuse = material.diffuseColor * ( 1.0 - max( max( totalScattering.r, totalScattering.g ), totalScattering.b ) );\n	reflectedLight.indirectSpecular += radiance * singleScattering;\n	reflectedLight.indirectSpecular += multiScattering * cosineWeightedIrradiance;\n	reflectedLight.indirectDiffuse += diffuse * cosineWeightedIrradiance;\n}\n#define RE_Direct				RE_Direct_Physical\n#define RE_Direct_RectArea		RE_Direct_RectArea_Physical\n#define RE_IndirectDiffuse		RE_IndirectDiffuse_Physical\n#define RE_IndirectSpecular		RE_IndirectSpecular_Physical\nfloat computeSpecularOcclusion( const in float dotNV, const in float ambientOcclusion, const in float roughness ) {\n	return saturate( pow( dotNV + ambientOcclusion, exp2( - 16.0 * roughness - 1.0 ) ) - 1.0 + ambientOcclusion );\n}";
var lights_fragment_begin = "\nGeometricContext geometry;\ngeometry.position = - vViewPosition;\ngeometry.normal = normal;\ngeometry.viewDir = ( isOrthographic ) ? vec3( 0, 0, 1 ) : normalize( vViewPosition );\n#ifdef USE_CLEARCOAT\n	geometry.clearcoatNormal = clearcoatNormal;\n#endif\n#ifdef USE_IRIDESCENCE\n	float dotNVi = saturate( dot( normal, geometry.viewDir ) );\n	if ( material.iridescenceThickness == 0.0 ) {\n		material.iridescence = 0.0;\n	} else {\n		material.iridescence = saturate( material.iridescence );\n	}\n	if ( material.iridescence > 0.0 ) {\n		material.iridescenceFresnel = evalIridescence( 1.0, material.iridescenceIOR, dotNVi, material.iridescenceThickness, material.specularColor );\n		material.iridescenceF0 = Schlick_to_F0( material.iridescenceFresnel, 1.0, dotNVi );\n	}\n#endif\nIncidentLight directLight;\n#if ( NUM_POINT_LIGHTS > 0 ) && defined( RE_Direct )\n	PointLight pointLight;\n	#if defined( USE_SHADOWMAP ) && NUM_POINT_LIGHT_SHADOWS > 0\n	PointLightShadow pointLightShadow;\n	#endif\n	#pragma unroll_loop_start\n	for ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\n		pointLight = pointLights[ i ];\n		getPointLightInfo( pointLight, geometry, directLight );\n		#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_POINT_LIGHT_SHADOWS )\n		pointLightShadow = pointLightShadows[ i ];\n		directLight.color *= all( bvec2( directLight.visible, receiveShadow ) ) ? getPointShadow( pointShadowMap[ i ], pointLightShadow.shadowMapSize, pointLightShadow.shadowBias, pointLightShadow.shadowRadius, vPointShadowCoord[ i ], pointLightShadow.shadowCameraNear, pointLightShadow.shadowCameraFar ) : 1.0;\n		#endif\n		RE_Direct( directLight, geometry, material, reflectedLight );\n	}\n	#pragma unroll_loop_end\n#endif\n#if ( NUM_SPOT_LIGHTS > 0 ) && defined( RE_Direct )\n	SpotLight spotLight;\n	#if defined( USE_SHADOWMAP ) && NUM_SPOT_LIGHT_SHADOWS > 0\n	SpotLightShadow spotLightShadow;\n	#endif\n	#pragma unroll_loop_start\n	for ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\n		spotLight = spotLights[ i ];\n		getSpotLightInfo( spotLight, geometry, directLight );\n		#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )\n		spotLightShadow = spotLightShadows[ i ];\n		directLight.color *= all( bvec2( directLight.visible, receiveShadow ) ) ? getShadow( spotShadowMap[ i ], spotLightShadow.shadowMapSize, spotLightShadow.shadowBias, spotLightShadow.shadowRadius, vSpotShadowCoord[ i ] ) : 1.0;\n		#endif\n		RE_Direct( directLight, geometry, material, reflectedLight );\n	}\n	#pragma unroll_loop_end\n#endif\n#if ( NUM_DIR_LIGHTS > 0 ) && defined( RE_Direct )\n	DirectionalLight directionalLight;\n	#if defined( USE_SHADOWMAP ) && NUM_DIR_LIGHT_SHADOWS > 0\n	DirectionalLightShadow directionalLightShadow;\n	#endif\n	#pragma unroll_loop_start\n	for ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\n		directionalLight = directionalLights[ i ];\n		getDirectionalLightInfo( directionalLight, geometry, directLight );\n		#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_DIR_LIGHT_SHADOWS )\n		directionalLightShadow = directionalLightShadows[ i ];\n		directLight.color *= all( bvec2( directLight.visible, receiveShadow ) ) ? getShadow( directionalShadowMap[ i ], directionalLightShadow.shadowMapSize, directionalLightShadow.shadowBias, directionalLightShadow.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;\n		#endif\n		RE_Direct( directLight, geometry, material, reflectedLight );\n	}\n	#pragma unroll_loop_end\n#endif\n#if ( NUM_RECT_AREA_LIGHTS > 0 ) && defined( RE_Direct_RectArea )\n	RectAreaLight rectAreaLight;\n	#pragma unroll_loop_start\n	for ( int i = 0; i < NUM_RECT_AREA_LIGHTS; i ++ ) {\n		rectAreaLight = rectAreaLights[ i ];\n		RE_Direct_RectArea( rectAreaLight, geometry, material, reflectedLight );\n	}\n	#pragma unroll_loop_end\n#endif\n#if defined( RE_IndirectDiffuse )\n	vec3 iblIrradiance = vec3( 0.0 );\n	vec3 irradiance = getAmbientLightIrradiance( ambientLightColor );\n	irradiance += getLightProbeIrradiance( lightProbe, geometry.normal );\n	#if ( NUM_HEMI_LIGHTS > 0 )\n		#pragma unroll_loop_start\n		for ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {\n			irradiance += getHemisphereLightIrradiance( hemisphereLights[ i ], geometry.normal );\n		}\n		#pragma unroll_loop_end\n	#endif\n#endif\n#if defined( RE_IndirectSpecular )\n	vec3 radiance = vec3( 0.0 );\n	vec3 clearcoatRadiance = vec3( 0.0 );\n#endif";
var lights_fragment_maps = "#if defined( RE_IndirectDiffuse )\n	#ifdef USE_LIGHTMAP\n		vec4 lightMapTexel = texture2D( lightMap, vUv2 );\n		vec3 lightMapIrradiance = lightMapTexel.rgb * lightMapIntensity;\n		irradiance += lightMapIrradiance;\n	#endif\n	#if defined( USE_ENVMAP ) && defined( STANDARD ) && defined( ENVMAP_TYPE_CUBE_UV )\n		iblIrradiance += getIBLIrradiance( geometry.normal );\n	#endif\n#endif\n#if defined( USE_ENVMAP ) && defined( RE_IndirectSpecular )\n	radiance += getIBLRadiance( geometry.viewDir, geometry.normal, material.roughness );\n	#ifdef USE_CLEARCOAT\n		clearcoatRadiance += getIBLRadiance( geometry.viewDir, geometry.clearcoatNormal, material.clearcoatRoughness );\n	#endif\n#endif";
var lights_fragment_end = "#if defined( RE_IndirectDiffuse )\n	RE_IndirectDiffuse( irradiance, geometry, material, reflectedLight );\n#endif\n#if defined( RE_IndirectSpecular )\n	RE_IndirectSpecular( radiance, iblIrradiance, clearcoatRadiance, geometry, material, reflectedLight );\n#endif";
var logdepthbuf_fragment = "#if defined( USE_LOGDEPTHBUF ) && defined( USE_LOGDEPTHBUF_EXT )\n	gl_FragDepthEXT = vIsPerspective == 0.0 ? gl_FragCoord.z : log2( vFragDepth ) * logDepthBufFC * 0.5;\n#endif";
var logdepthbuf_pars_fragment = "#if defined( USE_LOGDEPTHBUF ) && defined( USE_LOGDEPTHBUF_EXT )\n	uniform float logDepthBufFC;\n	varying float vFragDepth;\n	varying float vIsPerspective;\n#endif";
var logdepthbuf_pars_vertex = "#ifdef USE_LOGDEPTHBUF\n	#ifdef USE_LOGDEPTHBUF_EXT\n		varying float vFragDepth;\n		varying float vIsPerspective;\n	#else\n		uniform float logDepthBufFC;\n	#endif\n#endif";
var logdepthbuf_vertex = "#ifdef USE_LOGDEPTHBUF\n	#ifdef USE_LOGDEPTHBUF_EXT\n		vFragDepth = 1.0 + gl_Position.w;\n		vIsPerspective = float( isPerspectiveMatrix( projectionMatrix ) );\n	#else\n		if ( isPerspectiveMatrix( projectionMatrix ) ) {\n			gl_Position.z = log2( max( EPSILON, gl_Position.w + 1.0 ) ) * logDepthBufFC - 1.0;\n			gl_Position.z *= gl_Position.w;\n		}\n	#endif\n#endif";
var map_fragment = "#ifdef USE_MAP\n	vec4 sampledDiffuseColor = texture2D( map, vUv );\n	#ifdef DECODE_VIDEO_TEXTURE\n		sampledDiffuseColor = vec4( mix( pow( sampledDiffuseColor.rgb * 0.9478672986 + vec3( 0.0521327014 ), vec3( 2.4 ) ), sampledDiffuseColor.rgb * 0.0773993808, vec3( lessThanEqual( sampledDiffuseColor.rgb, vec3( 0.04045 ) ) ) ), sampledDiffuseColor.w );\n	#endif\n	diffuseColor *= sampledDiffuseColor;\n#endif";
var map_pars_fragment = "#ifdef USE_MAP\n	uniform sampler2D map;\n#endif";
var map_particle_fragment = "#if defined( USE_MAP ) || defined( USE_ALPHAMAP )\n	vec2 uv = ( uvTransform * vec3( gl_PointCoord.x, 1.0 - gl_PointCoord.y, 1 ) ).xy;\n#endif\n#ifdef USE_MAP\n	diffuseColor *= texture2D( map, uv );\n#endif\n#ifdef USE_ALPHAMAP\n	diffuseColor.a *= texture2D( alphaMap, uv ).g;\n#endif";
var map_particle_pars_fragment = "#if defined( USE_MAP ) || defined( USE_ALPHAMAP )\n	uniform mat3 uvTransform;\n#endif\n#ifdef USE_MAP\n	uniform sampler2D map;\n#endif\n#ifdef USE_ALPHAMAP\n	uniform sampler2D alphaMap;\n#endif";
var metalnessmap_fragment = "float metalnessFactor = metalness;\n#ifdef USE_METALNESSMAP\n	vec4 texelMetalness = texture2D( metalnessMap, vUv );\n	metalnessFactor *= texelMetalness.b;\n#endif";
var metalnessmap_pars_fragment = "#ifdef USE_METALNESSMAP\n	uniform sampler2D metalnessMap;\n#endif";
var morphcolor_vertex = "#if defined( USE_MORPHCOLORS ) && defined( MORPHTARGETS_TEXTURE )\n	vColor *= morphTargetBaseInfluence;\n	for ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {\n		#if defined( USE_COLOR_ALPHA )\n			if ( morphTargetInfluences[ i ] != 0.0 ) vColor += getMorph( gl_VertexID, i, 2 ) * morphTargetInfluences[ i ];\n		#elif defined( USE_COLOR )\n			if ( morphTargetInfluences[ i ] != 0.0 ) vColor += getMorph( gl_VertexID, i, 2 ).rgb * morphTargetInfluences[ i ];\n		#endif\n	}\n#endif";
var morphnormal_vertex = "#ifdef USE_MORPHNORMALS\n	objectNormal *= morphTargetBaseInfluence;\n	#ifdef MORPHTARGETS_TEXTURE\n		for ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {\n			if ( morphTargetInfluences[ i ] != 0.0 ) objectNormal += getMorph( gl_VertexID, i, 1 ).xyz * morphTargetInfluences[ i ];\n		}\n	#else\n		objectNormal += morphNormal0 * morphTargetInfluences[ 0 ];\n		objectNormal += morphNormal1 * morphTargetInfluences[ 1 ];\n		objectNormal += morphNormal2 * morphTargetInfluences[ 2 ];\n		objectNormal += morphNormal3 * morphTargetInfluences[ 3 ];\n	#endif\n#endif";
var morphtarget_pars_vertex = "#ifdef USE_MORPHTARGETS\n	uniform float morphTargetBaseInfluence;\n	#ifdef MORPHTARGETS_TEXTURE\n		uniform float morphTargetInfluences[ MORPHTARGETS_COUNT ];\n		uniform sampler2DArray morphTargetsTexture;\n		uniform ivec2 morphTargetsTextureSize;\n		vec4 getMorph( const in int vertexIndex, const in int morphTargetIndex, const in int offset ) {\n			int texelIndex = vertexIndex * MORPHTARGETS_TEXTURE_STRIDE + offset;\n			int y = texelIndex / morphTargetsTextureSize.x;\n			int x = texelIndex - y * morphTargetsTextureSize.x;\n			ivec3 morphUV = ivec3( x, y, morphTargetIndex );\n			return texelFetch( morphTargetsTexture, morphUV, 0 );\n		}\n	#else\n		#ifndef USE_MORPHNORMALS\n			uniform float morphTargetInfluences[ 8 ];\n		#else\n			uniform float morphTargetInfluences[ 4 ];\n		#endif\n	#endif\n#endif";
var morphtarget_vertex = "#ifdef USE_MORPHTARGETS\n	transformed *= morphTargetBaseInfluence;\n	#ifdef MORPHTARGETS_TEXTURE\n		for ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {\n			if ( morphTargetInfluences[ i ] != 0.0 ) transformed += getMorph( gl_VertexID, i, 0 ).xyz * morphTargetInfluences[ i ];\n		}\n	#else\n		transformed += morphTarget0 * morphTargetInfluences[ 0 ];\n		transformed += morphTarget1 * morphTargetInfluences[ 1 ];\n		transformed += morphTarget2 * morphTargetInfluences[ 2 ];\n		transformed += morphTarget3 * morphTargetInfluences[ 3 ];\n		#ifndef USE_MORPHNORMALS\n			transformed += morphTarget4 * morphTargetInfluences[ 4 ];\n			transformed += morphTarget5 * morphTargetInfluences[ 5 ];\n			transformed += morphTarget6 * morphTargetInfluences[ 6 ];\n			transformed += morphTarget7 * morphTargetInfluences[ 7 ];\n		#endif\n	#endif\n#endif";
var normal_fragment_begin = "float faceDirection = gl_FrontFacing ? 1.0 : - 1.0;\n#ifdef FLAT_SHADED\n	vec3 fdx = vec3( dFdx( vViewPosition.x ), dFdx( vViewPosition.y ), dFdx( vViewPosition.z ) );\n	vec3 fdy = vec3( dFdy( vViewPosition.x ), dFdy( vViewPosition.y ), dFdy( vViewPosition.z ) );\n	vec3 normal = normalize( cross( fdx, fdy ) );\n#else\n	vec3 normal = normalize( vNormal );\n	#ifdef DOUBLE_SIDED\n		normal = normal * faceDirection;\n	#endif\n	#ifdef USE_TANGENT\n		vec3 tangent = normalize( vTangent );\n		vec3 bitangent = normalize( vBitangent );\n		#ifdef DOUBLE_SIDED\n			tangent = tangent * faceDirection;\n			bitangent = bitangent * faceDirection;\n		#endif\n		#if defined( TANGENTSPACE_NORMALMAP ) || defined( USE_CLEARCOAT_NORMALMAP )\n			mat3 vTBN = mat3( tangent, bitangent, normal );\n		#endif\n	#endif\n#endif\nvec3 geometryNormal = normal;";
var normal_fragment_maps = "#ifdef OBJECTSPACE_NORMALMAP\n	normal = texture2D( normalMap, vUv ).xyz * 2.0 - 1.0;\n	#ifdef FLIP_SIDED\n		normal = - normal;\n	#endif\n	#ifdef DOUBLE_SIDED\n		normal = normal * faceDirection;\n	#endif\n	normal = normalize( normalMatrix * normal );\n#elif defined( TANGENTSPACE_NORMALMAP )\n	vec3 mapN = texture2D( normalMap, vUv ).xyz * 2.0 - 1.0;\n	mapN.xy *= normalScale;\n	#ifdef USE_TANGENT\n		normal = normalize( vTBN * mapN );\n	#else\n		normal = perturbNormal2Arb( - vViewPosition, normal, mapN, faceDirection );\n	#endif\n#elif defined( USE_BUMPMAP )\n	normal = perturbNormalArb( - vViewPosition, normal, dHdxy_fwd(), faceDirection );\n#endif";
var normal_pars_fragment = "#ifndef FLAT_SHADED\n	varying vec3 vNormal;\n	#ifdef USE_TANGENT\n		varying vec3 vTangent;\n		varying vec3 vBitangent;\n	#endif\n#endif";
var normal_pars_vertex = "#ifndef FLAT_SHADED\n	varying vec3 vNormal;\n	#ifdef USE_TANGENT\n		varying vec3 vTangent;\n		varying vec3 vBitangent;\n	#endif\n#endif";
var normal_vertex = "#ifndef FLAT_SHADED\n	vNormal = normalize( transformedNormal );\n	#ifdef USE_TANGENT\n		vTangent = normalize( transformedTangent );\n		vBitangent = normalize( cross( vNormal, vTangent ) * tangent.w );\n	#endif\n#endif";
var normalmap_pars_fragment = "#ifdef USE_NORMALMAP\n	uniform sampler2D normalMap;\n	uniform vec2 normalScale;\n#endif\n#ifdef OBJECTSPACE_NORMALMAP\n	uniform mat3 normalMatrix;\n#endif\n#if ! defined ( USE_TANGENT ) && ( defined ( TANGENTSPACE_NORMALMAP ) || defined ( USE_CLEARCOAT_NORMALMAP ) )\n	vec3 perturbNormal2Arb( vec3 eye_pos, vec3 surf_norm, vec3 mapN, float faceDirection ) {\n		vec3 q0 = dFdx( eye_pos.xyz );\n		vec3 q1 = dFdy( eye_pos.xyz );\n		vec2 st0 = dFdx( vUv.st );\n		vec2 st1 = dFdy( vUv.st );\n		vec3 N = surf_norm;\n		vec3 q1perp = cross( q1, N );\n		vec3 q0perp = cross( N, q0 );\n		vec3 T = q1perp * st0.x + q0perp * st1.x;\n		vec3 B = q1perp * st0.y + q0perp * st1.y;\n		float det = max( dot( T, T ), dot( B, B ) );\n		float scale = ( det == 0.0 ) ? 0.0 : faceDirection * inversesqrt( det );\n		return normalize( T * ( mapN.x * scale ) + B * ( mapN.y * scale ) + N * mapN.z );\n	}\n#endif";
var clearcoat_normal_fragment_begin = "#ifdef USE_CLEARCOAT\n	vec3 clearcoatNormal = geometryNormal;\n#endif";
var clearcoat_normal_fragment_maps = "#ifdef USE_CLEARCOAT_NORMALMAP\n	vec3 clearcoatMapN = texture2D( clearcoatNormalMap, vUv ).xyz * 2.0 - 1.0;\n	clearcoatMapN.xy *= clearcoatNormalScale;\n	#ifdef USE_TANGENT\n		clearcoatNormal = normalize( vTBN * clearcoatMapN );\n	#else\n		clearcoatNormal = perturbNormal2Arb( - vViewPosition, clearcoatNormal, clearcoatMapN, faceDirection );\n	#endif\n#endif";
var clearcoat_pars_fragment = "#ifdef USE_CLEARCOATMAP\n	uniform sampler2D clearcoatMap;\n#endif\n#ifdef USE_CLEARCOAT_ROUGHNESSMAP\n	uniform sampler2D clearcoatRoughnessMap;\n#endif\n#ifdef USE_CLEARCOAT_NORMALMAP\n	uniform sampler2D clearcoatNormalMap;\n	uniform vec2 clearcoatNormalScale;\n#endif";
var iridescence_pars_fragment = "#ifdef USE_IRIDESCENCEMAP\n	uniform sampler2D iridescenceMap;\n#endif\n#ifdef USE_IRIDESCENCE_THICKNESSMAP\n	uniform sampler2D iridescenceThicknessMap;\n#endif";
var output_fragment = "#ifdef OPAQUE\ndiffuseColor.a = 1.0;\n#endif\n#ifdef USE_TRANSMISSION\ndiffuseColor.a *= transmissionAlpha + 0.1;\n#endif\ngl_FragColor = vec4( outgoingLight, diffuseColor.a );";
var packing = "vec3 packNormalToRGB( const in vec3 normal ) {\n	return normalize( normal ) * 0.5 + 0.5;\n}\nvec3 unpackRGBToNormal( const in vec3 rgb ) {\n	return 2.0 * rgb.xyz - 1.0;\n}\nconst float PackUpscale = 256. / 255.;const float UnpackDownscale = 255. / 256.;\nconst vec3 PackFactors = vec3( 256. * 256. * 256., 256. * 256., 256. );\nconst vec4 UnpackFactors = UnpackDownscale / vec4( PackFactors, 1. );\nconst float ShiftRight8 = 1. / 256.;\nvec4 packDepthToRGBA( const in float v ) {\n	vec4 r = vec4( fract( v * PackFactors ), v );\n	r.yzw -= r.xyz * ShiftRight8;	return r * PackUpscale;\n}\nfloat unpackRGBAToDepth( const in vec4 v ) {\n	return dot( v, UnpackFactors );\n}\nvec4 pack2HalfToRGBA( vec2 v ) {\n	vec4 r = vec4( v.x, fract( v.x * 255.0 ), v.y, fract( v.y * 255.0 ) );\n	return vec4( r.x - r.y / 255.0, r.y, r.z - r.w / 255.0, r.w );\n}\nvec2 unpackRGBATo2Half( vec4 v ) {\n	return vec2( v.x + ( v.y / 255.0 ), v.z + ( v.w / 255.0 ) );\n}\nfloat viewZToOrthographicDepth( const in float viewZ, const in float near, const in float far ) {\n	return ( viewZ + near ) / ( near - far );\n}\nfloat orthographicDepthToViewZ( const in float linearClipZ, const in float near, const in float far ) {\n	return linearClipZ * ( near - far ) - near;\n}\nfloat viewZToPerspectiveDepth( const in float viewZ, const in float near, const in float far ) {\n	return ( ( near + viewZ ) * far ) / ( ( far - near ) * viewZ );\n}\nfloat perspectiveDepthToViewZ( const in float invClipZ, const in float near, const in float far ) {\n	return ( near * far ) / ( ( far - near ) * invClipZ - far );\n}";
var premultiplied_alpha_fragment = "#ifdef PREMULTIPLIED_ALPHA\n	gl_FragColor.rgb *= gl_FragColor.a;\n#endif";
var project_vertex = "vec4 mvPosition = vec4( transformed, 1.0 );\n#ifdef USE_INSTANCING\n	mvPosition = instanceMatrix * mvPosition;\n#endif\nmvPosition = modelViewMatrix * mvPosition;\ngl_Position = projectionMatrix * mvPosition;";
var dithering_fragment = "#ifdef DITHERING\n	gl_FragColor.rgb = dithering( gl_FragColor.rgb );\n#endif";
var dithering_pars_fragment = "#ifdef DITHERING\n	vec3 dithering( vec3 color ) {\n		float grid_position = rand( gl_FragCoord.xy );\n		vec3 dither_shift_RGB = vec3( 0.25 / 255.0, -0.25 / 255.0, 0.25 / 255.0 );\n		dither_shift_RGB = mix( 2.0 * dither_shift_RGB, -2.0 * dither_shift_RGB, grid_position );\n		return color + dither_shift_RGB;\n	}\n#endif";
var roughnessmap_fragment = "float roughnessFactor = roughness;\n#ifdef USE_ROUGHNESSMAP\n	vec4 texelRoughness = texture2D( roughnessMap, vUv );\n	roughnessFactor *= texelRoughness.g;\n#endif";
var roughnessmap_pars_fragment = "#ifdef USE_ROUGHNESSMAP\n	uniform sampler2D roughnessMap;\n#endif";
var shadowmap_pars_fragment = "#ifdef USE_SHADOWMAP\n	#if NUM_DIR_LIGHT_SHADOWS > 0\n		uniform sampler2D directionalShadowMap[ NUM_DIR_LIGHT_SHADOWS ];\n		varying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHT_SHADOWS ];\n		struct DirectionalLightShadow {\n			float shadowBias;\n			float shadowNormalBias;\n			float shadowRadius;\n			vec2 shadowMapSize;\n		};\n		uniform DirectionalLightShadow directionalLightShadows[ NUM_DIR_LIGHT_SHADOWS ];\n	#endif\n	#if NUM_SPOT_LIGHT_SHADOWS > 0\n		uniform sampler2D spotShadowMap[ NUM_SPOT_LIGHT_SHADOWS ];\n		varying vec4 vSpotShadowCoord[ NUM_SPOT_LIGHT_SHADOWS ];\n		struct SpotLightShadow {\n			float shadowBias;\n			float shadowNormalBias;\n			float shadowRadius;\n			vec2 shadowMapSize;\n		};\n		uniform SpotLightShadow spotLightShadows[ NUM_SPOT_LIGHT_SHADOWS ];\n	#endif\n	#if NUM_POINT_LIGHT_SHADOWS > 0\n		uniform sampler2D pointShadowMap[ NUM_POINT_LIGHT_SHADOWS ];\n		varying vec4 vPointShadowCoord[ NUM_POINT_LIGHT_SHADOWS ];\n		struct PointLightShadow {\n			float shadowBias;\n			float shadowNormalBias;\n			float shadowRadius;\n			vec2 shadowMapSize;\n			float shadowCameraNear;\n			float shadowCameraFar;\n		};\n		uniform PointLightShadow pointLightShadows[ NUM_POINT_LIGHT_SHADOWS ];\n	#endif\n	float texture2DCompare( sampler2D depths, vec2 uv, float compare ) {\n		return step( compare, unpackRGBAToDepth( texture2D( depths, uv ) ) );\n	}\n	vec2 texture2DDistribution( sampler2D shadow, vec2 uv ) {\n		return unpackRGBATo2Half( texture2D( shadow, uv ) );\n	}\n	float VSMShadow (sampler2D shadow, vec2 uv, float compare ){\n		float occlusion = 1.0;\n		vec2 distribution = texture2DDistribution( shadow, uv );\n		float hard_shadow = step( compare , distribution.x );\n		if (hard_shadow != 1.0 ) {\n			float distance = compare - distribution.x ;\n			float variance = max( 0.00000, distribution.y * distribution.y );\n			float softness_probability = variance / (variance + distance * distance );			softness_probability = clamp( ( softness_probability - 0.3 ) / ( 0.95 - 0.3 ), 0.0, 1.0 );			occlusion = clamp( max( hard_shadow, softness_probability ), 0.0, 1.0 );\n		}\n		return occlusion;\n	}\n	float getShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord ) {\n		float shadow = 1.0;\n		shadowCoord.xyz /= shadowCoord.w;\n		shadowCoord.z += shadowBias;\n		bvec4 inFrustumVec = bvec4 ( shadowCoord.x >= 0.0, shadowCoord.x <= 1.0, shadowCoord.y >= 0.0, shadowCoord.y <= 1.0 );\n		bool inFrustum = all( inFrustumVec );\n		bvec2 frustumTestVec = bvec2( inFrustum, shadowCoord.z <= 1.0 );\n		bool frustumTest = all( frustumTestVec );\n		if ( frustumTest ) {\n		#if defined( SHADOWMAP_TYPE_PCF )\n			vec2 texelSize = vec2( 1.0 ) / shadowMapSize;\n			float dx0 = - texelSize.x * shadowRadius;\n			float dy0 = - texelSize.y * shadowRadius;\n			float dx1 = + texelSize.x * shadowRadius;\n			float dy1 = + texelSize.y * shadowRadius;\n			float dx2 = dx0 / 2.0;\n			float dy2 = dy0 / 2.0;\n			float dx3 = dx1 / 2.0;\n			float dy3 = dy1 / 2.0;\n			shadow = (\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, dy2 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy2 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, dy2 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, 0.0 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, 0.0 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, dy3 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy3 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, dy3 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )\n			) * ( 1.0 / 17.0 );\n		#elif defined( SHADOWMAP_TYPE_PCF_SOFT )\n			vec2 texelSize = vec2( 1.0 ) / shadowMapSize;\n			float dx = texelSize.x;\n			float dy = texelSize.y;\n			vec2 uv = shadowCoord.xy;\n			vec2 f = fract( uv * shadowMapSize + 0.5 );\n			uv -= f * texelSize;\n			shadow = (\n				texture2DCompare( shadowMap, uv, shadowCoord.z ) +\n				texture2DCompare( shadowMap, uv + vec2( dx, 0.0 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, uv + vec2( 0.0, dy ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, uv + texelSize, shadowCoord.z ) +\n				mix( texture2DCompare( shadowMap, uv + vec2( -dx, 0.0 ), shadowCoord.z ), \n					 texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, 0.0 ), shadowCoord.z ),\n					 f.x ) +\n				mix( texture2DCompare( shadowMap, uv + vec2( -dx, dy ), shadowCoord.z ), \n					 texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, dy ), shadowCoord.z ),\n					 f.x ) +\n				mix( texture2DCompare( shadowMap, uv + vec2( 0.0, -dy ), shadowCoord.z ), \n					 texture2DCompare( shadowMap, uv + vec2( 0.0, 2.0 * dy ), shadowCoord.z ),\n					 f.y ) +\n				mix( texture2DCompare( shadowMap, uv + vec2( dx, -dy ), shadowCoord.z ), \n					 texture2DCompare( shadowMap, uv + vec2( dx, 2.0 * dy ), shadowCoord.z ),\n					 f.y ) +\n				mix( mix( texture2DCompare( shadowMap, uv + vec2( -dx, -dy ), shadowCoord.z ), \n						  texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, -dy ), shadowCoord.z ),\n						  f.x ),\n					 mix( texture2DCompare( shadowMap, uv + vec2( -dx, 2.0 * dy ), shadowCoord.z ), \n						  texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, 2.0 * dy ), shadowCoord.z ),\n						  f.x ),\n					 f.y )\n			) * ( 1.0 / 9.0 );\n		#elif defined( SHADOWMAP_TYPE_VSM )\n			shadow = VSMShadow( shadowMap, shadowCoord.xy, shadowCoord.z );\n		#else\n			shadow = texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z );\n		#endif\n		}\n		return shadow;\n	}\n	vec2 cubeToUV( vec3 v, float texelSizeY ) {\n		vec3 absV = abs( v );\n		float scaleToCube = 1.0 / max( absV.x, max( absV.y, absV.z ) );\n		absV *= scaleToCube;\n		v *= scaleToCube * ( 1.0 - 2.0 * texelSizeY );\n		vec2 planar = v.xy;\n		float almostATexel = 1.5 * texelSizeY;\n		float almostOne = 1.0 - almostATexel;\n		if ( absV.z >= almostOne ) {\n			if ( v.z > 0.0 )\n				planar.x = 4.0 - v.x;\n		} else if ( absV.x >= almostOne ) {\n			float signX = sign( v.x );\n			planar.x = v.z * signX + 2.0 * signX;\n		} else if ( absV.y >= almostOne ) {\n			float signY = sign( v.y );\n			planar.x = v.x + 2.0 * signY + 2.0;\n			planar.y = v.z * signY - 2.0;\n		}\n		return vec2( 0.125, 0.25 ) * planar + vec2( 0.375, 0.75 );\n	}\n	float getPointShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord, float shadowCameraNear, float shadowCameraFar ) {\n		vec2 texelSize = vec2( 1.0 ) / ( shadowMapSize * vec2( 4.0, 2.0 ) );\n		vec3 lightToPosition = shadowCoord.xyz;\n		float dp = ( length( lightToPosition ) - shadowCameraNear ) / ( shadowCameraFar - shadowCameraNear );		dp += shadowBias;\n		vec3 bd3D = normalize( lightToPosition );\n		#if defined( SHADOWMAP_TYPE_PCF ) || defined( SHADOWMAP_TYPE_PCF_SOFT ) || defined( SHADOWMAP_TYPE_VSM )\n			vec2 offset = vec2( - 1, 1 ) * shadowRadius * texelSize.y;\n			return (\n				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyy, texelSize.y ), dp ) +\n				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyy, texelSize.y ), dp ) +\n				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyx, texelSize.y ), dp ) +\n				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyx, texelSize.y ), dp ) +\n				texture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp ) +\n				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxy, texelSize.y ), dp ) +\n				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxy, texelSize.y ), dp ) +\n				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxx, texelSize.y ), dp ) +\n				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxx, texelSize.y ), dp )\n			) * ( 1.0 / 9.0 );\n		#else\n			return texture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp );\n		#endif\n	}\n#endif";
var shadowmap_pars_vertex = "#ifdef USE_SHADOWMAP\n	#if NUM_DIR_LIGHT_SHADOWS > 0\n		uniform mat4 directionalShadowMatrix[ NUM_DIR_LIGHT_SHADOWS ];\n		varying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHT_SHADOWS ];\n		struct DirectionalLightShadow {\n			float shadowBias;\n			float shadowNormalBias;\n			float shadowRadius;\n			vec2 shadowMapSize;\n		};\n		uniform DirectionalLightShadow directionalLightShadows[ NUM_DIR_LIGHT_SHADOWS ];\n	#endif\n	#if NUM_SPOT_LIGHT_SHADOWS > 0\n		uniform mat4 spotShadowMatrix[ NUM_SPOT_LIGHT_SHADOWS ];\n		varying vec4 vSpotShadowCoord[ NUM_SPOT_LIGHT_SHADOWS ];\n		struct SpotLightShadow {\n			float shadowBias;\n			float shadowNormalBias;\n			float shadowRadius;\n			vec2 shadowMapSize;\n		};\n		uniform SpotLightShadow spotLightShadows[ NUM_SPOT_LIGHT_SHADOWS ];\n	#endif\n	#if NUM_POINT_LIGHT_SHADOWS > 0\n		uniform mat4 pointShadowMatrix[ NUM_POINT_LIGHT_SHADOWS ];\n		varying vec4 vPointShadowCoord[ NUM_POINT_LIGHT_SHADOWS ];\n		struct PointLightShadow {\n			float shadowBias;\n			float shadowNormalBias;\n			float shadowRadius;\n			vec2 shadowMapSize;\n			float shadowCameraNear;\n			float shadowCameraFar;\n		};\n		uniform PointLightShadow pointLightShadows[ NUM_POINT_LIGHT_SHADOWS ];\n	#endif\n#endif";
var shadowmap_vertex = "#ifdef USE_SHADOWMAP\n	#if NUM_DIR_LIGHT_SHADOWS > 0 || NUM_SPOT_LIGHT_SHADOWS > 0 || NUM_POINT_LIGHT_SHADOWS > 0\n		vec3 shadowWorldNormal = inverseTransformDirection( transformedNormal, viewMatrix );\n		vec4 shadowWorldPosition;\n	#endif\n	#if NUM_DIR_LIGHT_SHADOWS > 0\n	#pragma unroll_loop_start\n	for ( int i = 0; i < NUM_DIR_LIGHT_SHADOWS; i ++ ) {\n		shadowWorldPosition = worldPosition + vec4( shadowWorldNormal * directionalLightShadows[ i ].shadowNormalBias, 0 );\n		vDirectionalShadowCoord[ i ] = directionalShadowMatrix[ i ] * shadowWorldPosition;\n	}\n	#pragma unroll_loop_end\n	#endif\n	#if NUM_SPOT_LIGHT_SHADOWS > 0\n	#pragma unroll_loop_start\n	for ( int i = 0; i < NUM_SPOT_LIGHT_SHADOWS; i ++ ) {\n		shadowWorldPosition = worldPosition + vec4( shadowWorldNormal * spotLightShadows[ i ].shadowNormalBias, 0 );\n		vSpotShadowCoord[ i ] = spotShadowMatrix[ i ] * shadowWorldPosition;\n	}\n	#pragma unroll_loop_end\n	#endif\n	#if NUM_POINT_LIGHT_SHADOWS > 0\n	#pragma unroll_loop_start\n	for ( int i = 0; i < NUM_POINT_LIGHT_SHADOWS; i ++ ) {\n		shadowWorldPosition = worldPosition + vec4( shadowWorldNormal * pointLightShadows[ i ].shadowNormalBias, 0 );\n		vPointShadowCoord[ i ] = pointShadowMatrix[ i ] * shadowWorldPosition;\n	}\n	#pragma unroll_loop_end\n	#endif\n#endif";
var shadowmask_pars_fragment = "float getShadowMask() {\n	float shadow = 1.0;\n	#ifdef USE_SHADOWMAP\n	#if NUM_DIR_LIGHT_SHADOWS > 0\n	DirectionalLightShadow directionalLight;\n	#pragma unroll_loop_start\n	for ( int i = 0; i < NUM_DIR_LIGHT_SHADOWS; i ++ ) {\n		directionalLight = directionalLightShadows[ i ];\n		shadow *= receiveShadow ? getShadow( directionalShadowMap[ i ], directionalLight.shadowMapSize, directionalLight.shadowBias, directionalLight.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;\n	}\n	#pragma unroll_loop_end\n	#endif\n	#if NUM_SPOT_LIGHT_SHADOWS > 0\n	SpotLightShadow spotLight;\n	#pragma unroll_loop_start\n	for ( int i = 0; i < NUM_SPOT_LIGHT_SHADOWS; i ++ ) {\n		spotLight = spotLightShadows[ i ];\n		shadow *= receiveShadow ? getShadow( spotShadowMap[ i ], spotLight.shadowMapSize, spotLight.shadowBias, spotLight.shadowRadius, vSpotShadowCoord[ i ] ) : 1.0;\n	}\n	#pragma unroll_loop_end\n	#endif\n	#if NUM_POINT_LIGHT_SHADOWS > 0\n	PointLightShadow pointLight;\n	#pragma unroll_loop_start\n	for ( int i = 0; i < NUM_POINT_LIGHT_SHADOWS; i ++ ) {\n		pointLight = pointLightShadows[ i ];\n		shadow *= receiveShadow ? getPointShadow( pointShadowMap[ i ], pointLight.shadowMapSize, pointLight.shadowBias, pointLight.shadowRadius, vPointShadowCoord[ i ], pointLight.shadowCameraNear, pointLight.shadowCameraFar ) : 1.0;\n	}\n	#pragma unroll_loop_end\n	#endif\n	#endif\n	return shadow;\n}";
var skinbase_vertex = "#ifdef USE_SKINNING\n	mat4 boneMatX = getBoneMatrix( skinIndex.x );\n	mat4 boneMatY = getBoneMatrix( skinIndex.y );\n	mat4 boneMatZ = getBoneMatrix( skinIndex.z );\n	mat4 boneMatW = getBoneMatrix( skinIndex.w );\n#endif";
var skinning_pars_vertex = "#ifdef USE_SKINNING\n	uniform mat4 bindMatrix;\n	uniform mat4 bindMatrixInverse;\n	uniform highp sampler2D boneTexture;\n	uniform int boneTextureSize;\n	mat4 getBoneMatrix( const in float i ) {\n		float j = i * 4.0;\n		float x = mod( j, float( boneTextureSize ) );\n		float y = floor( j / float( boneTextureSize ) );\n		float dx = 1.0 / float( boneTextureSize );\n		float dy = 1.0 / float( boneTextureSize );\n		y = dy * ( y + 0.5 );\n		vec4 v1 = texture2D( boneTexture, vec2( dx * ( x + 0.5 ), y ) );\n		vec4 v2 = texture2D( boneTexture, vec2( dx * ( x + 1.5 ), y ) );\n		vec4 v3 = texture2D( boneTexture, vec2( dx * ( x + 2.5 ), y ) );\n		vec4 v4 = texture2D( boneTexture, vec2( dx * ( x + 3.5 ), y ) );\n		mat4 bone = mat4( v1, v2, v3, v4 );\n		return bone;\n	}\n#endif";
var skinning_vertex = "#ifdef USE_SKINNING\n	vec4 skinVertex = bindMatrix * vec4( transformed, 1.0 );\n	vec4 skinned = vec4( 0.0 );\n	skinned += boneMatX * skinVertex * skinWeight.x;\n	skinned += boneMatY * skinVertex * skinWeight.y;\n	skinned += boneMatZ * skinVertex * skinWeight.z;\n	skinned += boneMatW * skinVertex * skinWeight.w;\n	transformed = ( bindMatrixInverse * skinned ).xyz;\n#endif";
var skinnormal_vertex = "#ifdef USE_SKINNING\n	mat4 skinMatrix = mat4( 0.0 );\n	skinMatrix += skinWeight.x * boneMatX;\n	skinMatrix += skinWeight.y * boneMatY;\n	skinMatrix += skinWeight.z * boneMatZ;\n	skinMatrix += skinWeight.w * boneMatW;\n	skinMatrix = bindMatrixInverse * skinMatrix * bindMatrix;\n	objectNormal = vec4( skinMatrix * vec4( objectNormal, 0.0 ) ).xyz;\n	#ifdef USE_TANGENT\n		objectTangent = vec4( skinMatrix * vec4( objectTangent, 0.0 ) ).xyz;\n	#endif\n#endif";
var specularmap_fragment = "float specularStrength;\n#ifdef USE_SPECULARMAP\n	vec4 texelSpecular = texture2D( specularMap, vUv );\n	specularStrength = texelSpecular.r;\n#else\n	specularStrength = 1.0;\n#endif";
var specularmap_pars_fragment = "#ifdef USE_SPECULARMAP\n	uniform sampler2D specularMap;\n#endif";
var tonemapping_fragment = "#if defined( TONE_MAPPING )\n	gl_FragColor.rgb = toneMapping( gl_FragColor.rgb );\n#endif";
var tonemapping_pars_fragment = "#ifndef saturate\n#define saturate( a ) clamp( a, 0.0, 1.0 )\n#endif\nuniform float toneMappingExposure;\nvec3 LinearToneMapping( vec3 color ) {\n	return toneMappingExposure * color;\n}\nvec3 ReinhardToneMapping( vec3 color ) {\n	color *= toneMappingExposure;\n	return saturate( color / ( vec3( 1.0 ) + color ) );\n}\nvec3 OptimizedCineonToneMapping( vec3 color ) {\n	color *= toneMappingExposure;\n	color = max( vec3( 0.0 ), color - 0.004 );\n	return pow( ( color * ( 6.2 * color + 0.5 ) ) / ( color * ( 6.2 * color + 1.7 ) + 0.06 ), vec3( 2.2 ) );\n}\nvec3 RRTAndODTFit( vec3 v ) {\n	vec3 a = v * ( v + 0.0245786 ) - 0.000090537;\n	vec3 b = v * ( 0.983729 * v + 0.4329510 ) + 0.238081;\n	return a / b;\n}\nvec3 ACESFilmicToneMapping( vec3 color ) {\n	const mat3 ACESInputMat = mat3(\n		vec3( 0.59719, 0.07600, 0.02840 ),		vec3( 0.35458, 0.90834, 0.13383 ),\n		vec3( 0.04823, 0.01566, 0.83777 )\n	);\n	const mat3 ACESOutputMat = mat3(\n		vec3(  1.60475, -0.10208, -0.00327 ),		vec3( -0.53108,  1.10813, -0.07276 ),\n		vec3( -0.07367, -0.00605,  1.07602 )\n	);\n	color *= toneMappingExposure / 0.6;\n	color = ACESInputMat * color;\n	color = RRTAndODTFit( color );\n	color = ACESOutputMat * color;\n	return saturate( color );\n}\nvec3 CustomToneMapping( vec3 color ) { return color; }";
var transmission_fragment = "#ifdef USE_TRANSMISSION\n	float transmissionAlpha = 1.0;\n	float transmissionFactor = transmission;\n	float thicknessFactor = thickness;\n	#ifdef USE_TRANSMISSIONMAP\n		transmissionFactor *= texture2D( transmissionMap, vUv ).r;\n	#endif\n	#ifdef USE_THICKNESSMAP\n		thicknessFactor *= texture2D( thicknessMap, vUv ).g;\n	#endif\n	vec3 pos = vWorldPosition;\n	vec3 v = normalize( cameraPosition - pos );\n	vec3 n = inverseTransformDirection( normal, viewMatrix );\n	vec4 transmission = getIBLVolumeRefraction(\n		n, v, roughnessFactor, material.diffuseColor, material.specularColor, material.specularF90,\n		pos, modelMatrix, viewMatrix, projectionMatrix, ior, thicknessFactor,\n		attenuationColor, attenuationDistance );\n	totalDiffuse = mix( totalDiffuse, transmission.rgb, transmissionFactor );\n	transmissionAlpha = mix( transmissionAlpha, transmission.a, transmissionFactor );\n#endif";
var transmission_pars_fragment = "#ifdef USE_TRANSMISSION\n	uniform float transmission;\n	uniform float thickness;\n	uniform float attenuationDistance;\n	uniform vec3 attenuationColor;\n	#ifdef USE_TRANSMISSIONMAP\n		uniform sampler2D transmissionMap;\n	#endif\n	#ifdef USE_THICKNESSMAP\n		uniform sampler2D thicknessMap;\n	#endif\n	uniform vec2 transmissionSamplerSize;\n	uniform sampler2D transmissionSamplerMap;\n	uniform mat4 modelMatrix;\n	uniform mat4 projectionMatrix;\n	varying vec3 vWorldPosition;\n	vec3 getVolumeTransmissionRay( const in vec3 n, const in vec3 v, const in float thickness, const in float ior, const in mat4 modelMatrix ) {\n		vec3 refractionVector = refract( - v, normalize( n ), 1.0 / ior );\n		vec3 modelScale;\n		modelScale.x = length( vec3( modelMatrix[ 0 ].xyz ) );\n		modelScale.y = length( vec3( modelMatrix[ 1 ].xyz ) );\n		modelScale.z = length( vec3( modelMatrix[ 2 ].xyz ) );\n		return normalize( refractionVector ) * thickness * modelScale;\n	}\n	float applyIorToRoughness( const in float roughness, const in float ior ) {\n		return roughness * clamp( ior * 2.0 - 2.0, 0.0, 1.0 );\n	}\n	vec4 getTransmissionSample( const in vec2 fragCoord, const in float roughness, const in float ior ) {\n		float framebufferLod = log2( transmissionSamplerSize.x ) * applyIorToRoughness( roughness, ior );\n		#ifdef texture2DLodEXT\n			return texture2DLodEXT( transmissionSamplerMap, fragCoord.xy, framebufferLod );\n		#else\n			return texture2D( transmissionSamplerMap, fragCoord.xy, framebufferLod );\n		#endif\n	}\n	vec3 applyVolumeAttenuation( const in vec3 radiance, const in float transmissionDistance, const in vec3 attenuationColor, const in float attenuationDistance ) {\n		if ( attenuationDistance == 0.0 ) {\n			return radiance;\n		} else {\n			vec3 attenuationCoefficient = -log( attenuationColor ) / attenuationDistance;\n			vec3 transmittance = exp( - attenuationCoefficient * transmissionDistance );			return transmittance * radiance;\n		}\n	}\n	vec4 getIBLVolumeRefraction( const in vec3 n, const in vec3 v, const in float roughness, const in vec3 diffuseColor,\n		const in vec3 specularColor, const in float specularF90, const in vec3 position, const in mat4 modelMatrix,\n		const in mat4 viewMatrix, const in mat4 projMatrix, const in float ior, const in float thickness,\n		const in vec3 attenuationColor, const in float attenuationDistance ) {\n		vec3 transmissionRay = getVolumeTransmissionRay( n, v, thickness, ior, modelMatrix );\n		vec3 refractedRayExit = position + transmissionRay;\n		vec4 ndcPos = projMatrix * viewMatrix * vec4( refractedRayExit, 1.0 );\n		vec2 refractionCoords = ndcPos.xy / ndcPos.w;\n		refractionCoords += 1.0;\n		refractionCoords /= 2.0;\n		vec4 transmittedLight = getTransmissionSample( refractionCoords, roughness, ior );\n		vec3 attenuatedColor = applyVolumeAttenuation( transmittedLight.rgb, length( transmissionRay ), attenuationColor, attenuationDistance );\n		vec3 F = EnvironmentBRDF( n, v, specularColor, specularF90, roughness );\n		return vec4( ( 1.0 - F ) * attenuatedColor * diffuseColor, transmittedLight.a );\n	}\n#endif";
var uv_pars_fragment = "#if ( defined( USE_UV ) && ! defined( UVS_VERTEX_ONLY ) )\n	varying vec2 vUv;\n#endif";
var uv_pars_vertex = "#ifdef USE_UV\n	#ifdef UVS_VERTEX_ONLY\n		vec2 vUv;\n	#else\n		varying vec2 vUv;\n	#endif\n	uniform mat3 uvTransform;\n#endif";
var uv_vertex = "#ifdef USE_UV\n	vUv = ( uvTransform * vec3( uv, 1 ) ).xy;\n#endif";
var uv2_pars_fragment = "#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n	varying vec2 vUv2;\n#endif";
var uv2_pars_vertex = "#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n	attribute vec2 uv2;\n	varying vec2 vUv2;\n	uniform mat3 uv2Transform;\n#endif";
var uv2_vertex = "#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n	vUv2 = ( uv2Transform * vec3( uv2, 1 ) ).xy;\n#endif";
var worldpos_vertex = "#if defined( USE_ENVMAP ) || defined( DISTANCE ) || defined ( USE_SHADOWMAP ) || defined ( USE_TRANSMISSION )\n	vec4 worldPosition = vec4( transformed, 1.0 );\n	#ifdef USE_INSTANCING\n		worldPosition = instanceMatrix * worldPosition;\n	#endif\n	worldPosition = modelMatrix * worldPosition;\n#endif";
var vertex$g = "varying vec2 vUv;\nuniform mat3 uvTransform;\nvoid main() {\n	vUv = ( uvTransform * vec3( uv, 1 ) ).xy;\n	gl_Position = vec4( position.xy, 1.0, 1.0 );\n}";
var fragment$g = "uniform sampler2D t2D;\nvarying vec2 vUv;\nvoid main() {\n	gl_FragColor = texture2D( t2D, vUv );\n	#ifdef DECODE_VIDEO_TEXTURE\n		gl_FragColor = vec4( mix( pow( gl_FragColor.rgb * 0.9478672986 + vec3( 0.0521327014 ), vec3( 2.4 ) ), gl_FragColor.rgb * 0.0773993808, vec3( lessThanEqual( gl_FragColor.rgb, vec3( 0.04045 ) ) ) ), gl_FragColor.w );\n	#endif\n	#include <tonemapping_fragment>\n	#include <encodings_fragment>\n}";
var vertex$f = "varying vec3 vWorldDirection;\n#include <common>\nvoid main() {\n	vWorldDirection = transformDirection( position, modelMatrix );\n	#include <begin_vertex>\n	#include <project_vertex>\n	gl_Position.z = gl_Position.w;\n}";
var fragment$f = "#include <envmap_common_pars_fragment>\nuniform float opacity;\nvarying vec3 vWorldDirection;\n#include <cube_uv_reflection_fragment>\nvoid main() {\n	vec3 vReflect = vWorldDirection;\n	#include <envmap_fragment>\n	gl_FragColor = envColor;\n	gl_FragColor.a *= opacity;\n	#include <tonemapping_fragment>\n	#include <encodings_fragment>\n}";
var vertex$e = "#include <common>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvarying vec2 vHighPrecisionZW;\nvoid main() {\n	#include <uv_vertex>\n	#include <skinbase_vertex>\n	#ifdef USE_DISPLACEMENTMAP\n		#include <beginnormal_vertex>\n		#include <morphnormal_vertex>\n		#include <skinnormal_vertex>\n	#endif\n	#include <begin_vertex>\n	#include <morphtarget_vertex>\n	#include <skinning_vertex>\n	#include <displacementmap_vertex>\n	#include <project_vertex>\n	#include <logdepthbuf_vertex>\n	#include <clipping_planes_vertex>\n	vHighPrecisionZW = gl_Position.zw;\n}";
var fragment$e = "#if DEPTH_PACKING == 3200\n	uniform float opacity;\n#endif\n#include <common>\n#include <packing>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvarying vec2 vHighPrecisionZW;\nvoid main() {\n	#include <clipping_planes_fragment>\n	vec4 diffuseColor = vec4( 1.0 );\n	#if DEPTH_PACKING == 3200\n		diffuseColor.a = opacity;\n	#endif\n	#include <map_fragment>\n	#include <alphamap_fragment>\n	#include <alphatest_fragment>\n	#include <logdepthbuf_fragment>\n	float fragCoordZ = 0.5 * vHighPrecisionZW[0] / vHighPrecisionZW[1] + 0.5;\n	#if DEPTH_PACKING == 3200\n		gl_FragColor = vec4( vec3( 1.0 - fragCoordZ ), opacity );\n	#elif DEPTH_PACKING == 3201\n		gl_FragColor = packDepthToRGBA( fragCoordZ );\n	#endif\n}";
var vertex$d = "#define DISTANCE\nvarying vec3 vWorldPosition;\n#include <common>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n	#include <uv_vertex>\n	#include <skinbase_vertex>\n	#ifdef USE_DISPLACEMENTMAP\n		#include <beginnormal_vertex>\n		#include <morphnormal_vertex>\n		#include <skinnormal_vertex>\n	#endif\n	#include <begin_vertex>\n	#include <morphtarget_vertex>\n	#include <skinning_vertex>\n	#include <displacementmap_vertex>\n	#include <project_vertex>\n	#include <worldpos_vertex>\n	#include <clipping_planes_vertex>\n	vWorldPosition = worldPosition.xyz;\n}";
var fragment$d = "#define DISTANCE\nuniform vec3 referencePosition;\nuniform float nearDistance;\nuniform float farDistance;\nvarying vec3 vWorldPosition;\n#include <common>\n#include <packing>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main () {\n	#include <clipping_planes_fragment>\n	vec4 diffuseColor = vec4( 1.0 );\n	#include <map_fragment>\n	#include <alphamap_fragment>\n	#include <alphatest_fragment>\n	float dist = length( vWorldPosition - referencePosition );\n	dist = ( dist - nearDistance ) / ( farDistance - nearDistance );\n	dist = saturate( dist );\n	gl_FragColor = packDepthToRGBA( dist );\n}";
var vertex$c = "varying vec3 vWorldDirection;\n#include <common>\nvoid main() {\n	vWorldDirection = transformDirection( position, modelMatrix );\n	#include <begin_vertex>\n	#include <project_vertex>\n}";
var fragment$c = "uniform sampler2D tEquirect;\nvarying vec3 vWorldDirection;\n#include <common>\nvoid main() {\n	vec3 direction = normalize( vWorldDirection );\n	vec2 sampleUV = equirectUv( direction );\n	gl_FragColor = texture2D( tEquirect, sampleUV );\n	#include <tonemapping_fragment>\n	#include <encodings_fragment>\n}";
var vertex$b = "uniform float scale;\nattribute float lineDistance;\nvarying float vLineDistance;\n#include <common>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n	vLineDistance = scale * lineDistance;\n	#include <color_vertex>\n	#include <morphcolor_vertex>\n	#include <begin_vertex>\n	#include <morphtarget_vertex>\n	#include <project_vertex>\n	#include <logdepthbuf_vertex>\n	#include <clipping_planes_vertex>\n	#include <fog_vertex>\n}";
var fragment$b = "uniform vec3 diffuse;\nuniform float opacity;\nuniform float dashSize;\nuniform float totalSize;\nvarying float vLineDistance;\n#include <common>\n#include <color_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n	#include <clipping_planes_fragment>\n	if ( mod( vLineDistance, totalSize ) > dashSize ) {\n		discard;\n	}\n	vec3 outgoingLight = vec3( 0.0 );\n	vec4 diffuseColor = vec4( diffuse, opacity );\n	#include <logdepthbuf_fragment>\n	#include <color_fragment>\n	outgoingLight = diffuseColor.rgb;\n	#include <output_fragment>\n	#include <tonemapping_fragment>\n	#include <encodings_fragment>\n	#include <fog_fragment>\n	#include <premultiplied_alpha_fragment>\n}";
var vertex$a = "#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <envmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n	#include <uv_vertex>\n	#include <uv2_vertex>\n	#include <color_vertex>\n	#include <morphcolor_vertex>\n	#if defined ( USE_ENVMAP ) || defined ( USE_SKINNING )\n		#include <beginnormal_vertex>\n		#include <morphnormal_vertex>\n		#include <skinbase_vertex>\n		#include <skinnormal_vertex>\n		#include <defaultnormal_vertex>\n	#endif\n	#include <begin_vertex>\n	#include <morphtarget_vertex>\n	#include <skinning_vertex>\n	#include <project_vertex>\n	#include <logdepthbuf_vertex>\n	#include <clipping_planes_vertex>\n	#include <worldpos_vertex>\n	#include <envmap_vertex>\n	#include <fog_vertex>\n}";
var fragment$a = "uniform vec3 diffuse;\nuniform float opacity;\n#ifndef FLAT_SHADED\n	varying vec3 vNormal;\n#endif\n#include <common>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_pars_fragment>\n#include <cube_uv_reflection_fragment>\n#include <fog_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n	#include <clipping_planes_fragment>\n	vec4 diffuseColor = vec4( diffuse, opacity );\n	#include <logdepthbuf_fragment>\n	#include <map_fragment>\n	#include <color_fragment>\n	#include <alphamap_fragment>\n	#include <alphatest_fragment>\n	#include <specularmap_fragment>\n	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n	#ifdef USE_LIGHTMAP\n		vec4 lightMapTexel = texture2D( lightMap, vUv2 );\n		reflectedLight.indirectDiffuse += lightMapTexel.rgb * lightMapIntensity * RECIPROCAL_PI;\n	#else\n		reflectedLight.indirectDiffuse += vec3( 1.0 );\n	#endif\n	#include <aomap_fragment>\n	reflectedLight.indirectDiffuse *= diffuseColor.rgb;\n	vec3 outgoingLight = reflectedLight.indirectDiffuse;\n	#include <envmap_fragment>\n	#include <output_fragment>\n	#include <tonemapping_fragment>\n	#include <encodings_fragment>\n	#include <fog_fragment>\n	#include <premultiplied_alpha_fragment>\n	#include <dithering_fragment>\n}";
var vertex$9 = "#define LAMBERT\nvarying vec3 vLightFront;\nvarying vec3 vIndirectFront;\n#ifdef DOUBLE_SIDED\n	varying vec3 vLightBack;\n	varying vec3 vIndirectBack;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <envmap_pars_vertex>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n	#include <uv_vertex>\n	#include <uv2_vertex>\n	#include <color_vertex>\n	#include <morphcolor_vertex>\n	#include <beginnormal_vertex>\n	#include <morphnormal_vertex>\n	#include <skinbase_vertex>\n	#include <skinnormal_vertex>\n	#include <defaultnormal_vertex>\n	#include <begin_vertex>\n	#include <morphtarget_vertex>\n	#include <skinning_vertex>\n	#include <project_vertex>\n	#include <logdepthbuf_vertex>\n	#include <clipping_planes_vertex>\n	#include <worldpos_vertex>\n	#include <envmap_vertex>\n	#include <lights_lambert_vertex>\n	#include <shadowmap_vertex>\n	#include <fog_vertex>\n}";
var fragment$9 = "uniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float opacity;\nvarying vec3 vLightFront;\nvarying vec3 vIndirectFront;\n#ifdef DOUBLE_SIDED\n	varying vec3 vLightBack;\n	varying vec3 vIndirectBack;\n#endif\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_pars_fragment>\n#include <cube_uv_reflection_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <fog_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <shadowmask_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n	#include <clipping_planes_fragment>\n	vec4 diffuseColor = vec4( diffuse, opacity );\n	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n	vec3 totalEmissiveRadiance = emissive;\n	#include <logdepthbuf_fragment>\n	#include <map_fragment>\n	#include <color_fragment>\n	#include <alphamap_fragment>\n	#include <alphatest_fragment>\n	#include <specularmap_fragment>\n	#include <emissivemap_fragment>\n	#ifdef DOUBLE_SIDED\n		reflectedLight.indirectDiffuse += ( gl_FrontFacing ) ? vIndirectFront : vIndirectBack;\n	#else\n		reflectedLight.indirectDiffuse += vIndirectFront;\n	#endif\n	#include <lightmap_fragment>\n	reflectedLight.indirectDiffuse *= BRDF_Lambert( diffuseColor.rgb );\n	#ifdef DOUBLE_SIDED\n		reflectedLight.directDiffuse = ( gl_FrontFacing ) ? vLightFront : vLightBack;\n	#else\n		reflectedLight.directDiffuse = vLightFront;\n	#endif\n	reflectedLight.directDiffuse *= BRDF_Lambert( diffuseColor.rgb ) * getShadowMask();\n	#include <aomap_fragment>\n	vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;\n	#include <envmap_fragment>\n	#include <output_fragment>\n	#include <tonemapping_fragment>\n	#include <encodings_fragment>\n	#include <fog_fragment>\n	#include <premultiplied_alpha_fragment>\n	#include <dithering_fragment>\n}";
var vertex$8 = "#define MATCAP\nvarying vec3 vViewPosition;\n#include <common>\n#include <uv_pars_vertex>\n#include <color_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <fog_pars_vertex>\n#include <normal_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n	#include <uv_vertex>\n	#include <color_vertex>\n	#include <morphcolor_vertex>\n	#include <beginnormal_vertex>\n	#include <morphnormal_vertex>\n	#include <skinbase_vertex>\n	#include <skinnormal_vertex>\n	#include <defaultnormal_vertex>\n	#include <normal_vertex>\n	#include <begin_vertex>\n	#include <morphtarget_vertex>\n	#include <skinning_vertex>\n	#include <displacementmap_vertex>\n	#include <project_vertex>\n	#include <logdepthbuf_vertex>\n	#include <clipping_planes_vertex>\n	#include <fog_vertex>\n	vViewPosition = - mvPosition.xyz;\n}";
var fragment$8 = "#define MATCAP\nuniform vec3 diffuse;\nuniform float opacity;\nuniform sampler2D matcap;\nvarying vec3 vViewPosition;\n#include <common>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <fog_pars_fragment>\n#include <normal_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n	#include <clipping_planes_fragment>\n	vec4 diffuseColor = vec4( diffuse, opacity );\n	#include <logdepthbuf_fragment>\n	#include <map_fragment>\n	#include <color_fragment>\n	#include <alphamap_fragment>\n	#include <alphatest_fragment>\n	#include <normal_fragment_begin>\n	#include <normal_fragment_maps>\n	vec3 viewDir = normalize( vViewPosition );\n	vec3 x = normalize( vec3( viewDir.z, 0.0, - viewDir.x ) );\n	vec3 y = cross( viewDir, x );\n	vec2 uv = vec2( dot( x, normal ), dot( y, normal ) ) * 0.495 + 0.5;\n	#ifdef USE_MATCAP\n		vec4 matcapColor = texture2D( matcap, uv );\n	#else\n		vec4 matcapColor = vec4( vec3( mix( 0.2, 0.8, uv.y ) ), 1.0 );\n	#endif\n	vec3 outgoingLight = diffuseColor.rgb * matcapColor.rgb;\n	#include <output_fragment>\n	#include <tonemapping_fragment>\n	#include <encodings_fragment>\n	#include <fog_fragment>\n	#include <premultiplied_alpha_fragment>\n	#include <dithering_fragment>\n}";
var vertex$7 = "#define NORMAL\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( TANGENTSPACE_NORMALMAP )\n	varying vec3 vViewPosition;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <normal_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n	#include <uv_vertex>\n	#include <beginnormal_vertex>\n	#include <morphnormal_vertex>\n	#include <skinbase_vertex>\n	#include <skinnormal_vertex>\n	#include <defaultnormal_vertex>\n	#include <normal_vertex>\n	#include <begin_vertex>\n	#include <morphtarget_vertex>\n	#include <skinning_vertex>\n	#include <displacementmap_vertex>\n	#include <project_vertex>\n	#include <logdepthbuf_vertex>\n	#include <clipping_planes_vertex>\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( TANGENTSPACE_NORMALMAP )\n	vViewPosition = - mvPosition.xyz;\n#endif\n}";
var fragment$7 = "#define NORMAL\nuniform float opacity;\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( TANGENTSPACE_NORMALMAP )\n	varying vec3 vViewPosition;\n#endif\n#include <packing>\n#include <uv_pars_fragment>\n#include <normal_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n	#include <clipping_planes_fragment>\n	#include <logdepthbuf_fragment>\n	#include <normal_fragment_begin>\n	#include <normal_fragment_maps>\n	gl_FragColor = vec4( packNormalToRGB( normal ), opacity );\n	#ifdef OPAQUE\n		gl_FragColor.a = 1.0;\n	#endif\n}";
var vertex$6 = "#define PHONG\nvarying vec3 vViewPosition;\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <envmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <normal_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n	#include <uv_vertex>\n	#include <uv2_vertex>\n	#include <color_vertex>\n	#include <morphcolor_vertex>\n	#include <beginnormal_vertex>\n	#include <morphnormal_vertex>\n	#include <skinbase_vertex>\n	#include <skinnormal_vertex>\n	#include <defaultnormal_vertex>\n	#include <normal_vertex>\n	#include <begin_vertex>\n	#include <morphtarget_vertex>\n	#include <skinning_vertex>\n	#include <displacementmap_vertex>\n	#include <project_vertex>\n	#include <logdepthbuf_vertex>\n	#include <clipping_planes_vertex>\n	vViewPosition = - mvPosition.xyz;\n	#include <worldpos_vertex>\n	#include <envmap_vertex>\n	#include <shadowmap_vertex>\n	#include <fog_vertex>\n}";
var fragment$6 = "#define PHONG\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform vec3 specular;\nuniform float shininess;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_pars_fragment>\n#include <cube_uv_reflection_fragment>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <normal_pars_fragment>\n#include <lights_phong_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n	#include <clipping_planes_fragment>\n	vec4 diffuseColor = vec4( diffuse, opacity );\n	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n	vec3 totalEmissiveRadiance = emissive;\n	#include <logdepthbuf_fragment>\n	#include <map_fragment>\n	#include <color_fragment>\n	#include <alphamap_fragment>\n	#include <alphatest_fragment>\n	#include <specularmap_fragment>\n	#include <normal_fragment_begin>\n	#include <normal_fragment_maps>\n	#include <emissivemap_fragment>\n	#include <lights_phong_fragment>\n	#include <lights_fragment_begin>\n	#include <lights_fragment_maps>\n	#include <lights_fragment_end>\n	#include <aomap_fragment>\n	vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;\n	#include <envmap_fragment>\n	#include <output_fragment>\n	#include <tonemapping_fragment>\n	#include <encodings_fragment>\n	#include <fog_fragment>\n	#include <premultiplied_alpha_fragment>\n	#include <dithering_fragment>\n}";
var vertex$5 = "#define STANDARD\nvarying vec3 vViewPosition;\n#ifdef USE_TRANSMISSION\n	varying vec3 vWorldPosition;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <normal_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n	#include <uv_vertex>\n	#include <uv2_vertex>\n	#include <color_vertex>\n	#include <morphcolor_vertex>\n	#include <beginnormal_vertex>\n	#include <morphnormal_vertex>\n	#include <skinbase_vertex>\n	#include <skinnormal_vertex>\n	#include <defaultnormal_vertex>\n	#include <normal_vertex>\n	#include <begin_vertex>\n	#include <morphtarget_vertex>\n	#include <skinning_vertex>\n	#include <displacementmap_vertex>\n	#include <project_vertex>\n	#include <logdepthbuf_vertex>\n	#include <clipping_planes_vertex>\n	vViewPosition = - mvPosition.xyz;\n	#include <worldpos_vertex>\n	#include <shadowmap_vertex>\n	#include <fog_vertex>\n#ifdef USE_TRANSMISSION\n	vWorldPosition = worldPosition.xyz;\n#endif\n}";
var fragment$5 = "#define STANDARD\n#ifdef PHYSICAL\n	#define IOR\n	#define SPECULAR\n#endif\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float roughness;\nuniform float metalness;\nuniform float opacity;\n#ifdef IOR\n	uniform float ior;\n#endif\n#ifdef SPECULAR\n	uniform float specularIntensity;\n	uniform vec3 specularColor;\n	#ifdef USE_SPECULARINTENSITYMAP\n		uniform sampler2D specularIntensityMap;\n	#endif\n	#ifdef USE_SPECULARCOLORMAP\n		uniform sampler2D specularColorMap;\n	#endif\n#endif\n#ifdef USE_CLEARCOAT\n	uniform float clearcoat;\n	uniform float clearcoatRoughness;\n#endif\n#ifdef USE_IRIDESCENCE\n	uniform float iridescence;\n	uniform float iridescenceIOR;\n	uniform float iridescenceThicknessMinimum;\n	uniform float iridescenceThicknessMaximum;\n#endif\n#ifdef USE_SHEEN\n	uniform vec3 sheenColor;\n	uniform float sheenRoughness;\n	#ifdef USE_SHEENCOLORMAP\n		uniform sampler2D sheenColorMap;\n	#endif\n	#ifdef USE_SHEENROUGHNESSMAP\n		uniform sampler2D sheenRoughnessMap;\n	#endif\n#endif\nvarying vec3 vViewPosition;\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <bsdfs>\n#include <iridescence_fragment>\n#include <cube_uv_reflection_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_physical_pars_fragment>\n#include <fog_pars_fragment>\n#include <lights_pars_begin>\n#include <normal_pars_fragment>\n#include <lights_physical_pars_fragment>\n#include <transmission_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <clearcoat_pars_fragment>\n#include <iridescence_pars_fragment>\n#include <roughnessmap_pars_fragment>\n#include <metalnessmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n	#include <clipping_planes_fragment>\n	vec4 diffuseColor = vec4( diffuse, opacity );\n	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n	vec3 totalEmissiveRadiance = emissive;\n	#include <logdepthbuf_fragment>\n	#include <map_fragment>\n	#include <color_fragment>\n	#include <alphamap_fragment>\n	#include <alphatest_fragment>\n	#include <roughnessmap_fragment>\n	#include <metalnessmap_fragment>\n	#include <normal_fragment_begin>\n	#include <normal_fragment_maps>\n	#include <clearcoat_normal_fragment_begin>\n	#include <clearcoat_normal_fragment_maps>\n	#include <emissivemap_fragment>\n	#include <lights_physical_fragment>\n	#include <lights_fragment_begin>\n	#include <lights_fragment_maps>\n	#include <lights_fragment_end>\n	#include <aomap_fragment>\n	vec3 totalDiffuse = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse;\n	vec3 totalSpecular = reflectedLight.directSpecular + reflectedLight.indirectSpecular;\n	#include <transmission_fragment>\n	vec3 outgoingLight = totalDiffuse + totalSpecular + totalEmissiveRadiance;\n	#ifdef USE_SHEEN\n		float sheenEnergyComp = 1.0 - 0.157 * max3( material.sheenColor );\n		outgoingLight = outgoingLight * sheenEnergyComp + sheenSpecular;\n	#endif\n	#ifdef USE_CLEARCOAT\n		float dotNVcc = saturate( dot( geometry.clearcoatNormal, geometry.viewDir ) );\n		vec3 Fcc = F_Schlick( material.clearcoatF0, material.clearcoatF90, dotNVcc );\n		outgoingLight = outgoingLight * ( 1.0 - material.clearcoat * Fcc ) + clearcoatSpecular * material.clearcoat;\n	#endif\n	#include <output_fragment>\n	#include <tonemapping_fragment>\n	#include <encodings_fragment>\n	#include <fog_fragment>\n	#include <premultiplied_alpha_fragment>\n	#include <dithering_fragment>\n}";
var vertex$4 = "#define TOON\nvarying vec3 vViewPosition;\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <normal_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n	#include <uv_vertex>\n	#include <uv2_vertex>\n	#include <color_vertex>\n	#include <morphcolor_vertex>\n	#include <beginnormal_vertex>\n	#include <morphnormal_vertex>\n	#include <skinbase_vertex>\n	#include <skinnormal_vertex>\n	#include <defaultnormal_vertex>\n	#include <normal_vertex>\n	#include <begin_vertex>\n	#include <morphtarget_vertex>\n	#include <skinning_vertex>\n	#include <displacementmap_vertex>\n	#include <project_vertex>\n	#include <logdepthbuf_vertex>\n	#include <clipping_planes_vertex>\n	vViewPosition = - mvPosition.xyz;\n	#include <worldpos_vertex>\n	#include <shadowmap_vertex>\n	#include <fog_vertex>\n}";
var fragment$4 = "#define TOON\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <gradientmap_pars_fragment>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <normal_pars_fragment>\n#include <lights_toon_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n	#include <clipping_planes_fragment>\n	vec4 diffuseColor = vec4( diffuse, opacity );\n	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n	vec3 totalEmissiveRadiance = emissive;\n	#include <logdepthbuf_fragment>\n	#include <map_fragment>\n	#include <color_fragment>\n	#include <alphamap_fragment>\n	#include <alphatest_fragment>\n	#include <normal_fragment_begin>\n	#include <normal_fragment_maps>\n	#include <emissivemap_fragment>\n	#include <lights_toon_fragment>\n	#include <lights_fragment_begin>\n	#include <lights_fragment_maps>\n	#include <lights_fragment_end>\n	#include <aomap_fragment>\n	vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;\n	#include <output_fragment>\n	#include <tonemapping_fragment>\n	#include <encodings_fragment>\n	#include <fog_fragment>\n	#include <premultiplied_alpha_fragment>\n	#include <dithering_fragment>\n}";
var vertex$3 = "uniform float size;\nuniform float scale;\n#include <common>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n	#include <color_vertex>\n	#include <morphcolor_vertex>\n	#include <begin_vertex>\n	#include <morphtarget_vertex>\n	#include <project_vertex>\n	gl_PointSize = size;\n	#ifdef USE_SIZEATTENUATION\n		bool isPerspective = isPerspectiveMatrix( projectionMatrix );\n		if ( isPerspective ) gl_PointSize *= ( scale / - mvPosition.z );\n	#endif\n	#include <logdepthbuf_vertex>\n	#include <clipping_planes_vertex>\n	#include <worldpos_vertex>\n	#include <fog_vertex>\n}";
var fragment$3 = "uniform vec3 diffuse;\nuniform float opacity;\n#include <common>\n#include <color_pars_fragment>\n#include <map_particle_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n	#include <clipping_planes_fragment>\n	vec3 outgoingLight = vec3( 0.0 );\n	vec4 diffuseColor = vec4( diffuse, opacity );\n	#include <logdepthbuf_fragment>\n	#include <map_particle_fragment>\n	#include <color_fragment>\n	#include <alphatest_fragment>\n	outgoingLight = diffuseColor.rgb;\n	#include <output_fragment>\n	#include <tonemapping_fragment>\n	#include <encodings_fragment>\n	#include <fog_fragment>\n	#include <premultiplied_alpha_fragment>\n}";
var vertex$2 = "#include <common>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\nvoid main() {\n	#include <beginnormal_vertex>\n	#include <morphnormal_vertex>\n	#include <skinbase_vertex>\n	#include <skinnormal_vertex>\n	#include <defaultnormal_vertex>\n	#include <begin_vertex>\n	#include <morphtarget_vertex>\n	#include <skinning_vertex>\n	#include <project_vertex>\n	#include <worldpos_vertex>\n	#include <shadowmap_vertex>\n	#include <fog_vertex>\n}";
var fragment$2 = "uniform vec3 color;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <shadowmap_pars_fragment>\n#include <shadowmask_pars_fragment>\nvoid main() {\n	gl_FragColor = vec4( color, opacity * ( 1.0 - getShadowMask() ) );\n	#include <tonemapping_fragment>\n	#include <encodings_fragment>\n	#include <fog_fragment>\n}";
var vertex$1 = "uniform float rotation;\nuniform vec2 center;\n#include <common>\n#include <uv_pars_vertex>\n#include <fog_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n	#include <uv_vertex>\n	vec4 mvPosition = modelViewMatrix * vec4( 0.0, 0.0, 0.0, 1.0 );\n	vec2 scale;\n	scale.x = length( vec3( modelMatrix[ 0 ].x, modelMatrix[ 0 ].y, modelMatrix[ 0 ].z ) );\n	scale.y = length( vec3( modelMatrix[ 1 ].x, modelMatrix[ 1 ].y, modelMatrix[ 1 ].z ) );\n	#ifndef USE_SIZEATTENUATION\n		bool isPerspective = isPerspectiveMatrix( projectionMatrix );\n		if ( isPerspective ) scale *= - mvPosition.z;\n	#endif\n	vec2 alignedPosition = ( position.xy - ( center - vec2( 0.5 ) ) ) * scale;\n	vec2 rotatedPosition;\n	rotatedPosition.x = cos( rotation ) * alignedPosition.x - sin( rotation ) * alignedPosition.y;\n	rotatedPosition.y = sin( rotation ) * alignedPosition.x + cos( rotation ) * alignedPosition.y;\n	mvPosition.xy += rotatedPosition;\n	gl_Position = projectionMatrix * mvPosition;\n	#include <logdepthbuf_vertex>\n	#include <clipping_planes_vertex>\n	#include <fog_vertex>\n}";
var fragment$1 = "uniform vec3 diffuse;\nuniform float opacity;\n#include <common>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n	#include <clipping_planes_fragment>\n	vec3 outgoingLight = vec3( 0.0 );\n	vec4 diffuseColor = vec4( diffuse, opacity );\n	#include <logdepthbuf_fragment>\n	#include <map_fragment>\n	#include <alphamap_fragment>\n	#include <alphatest_fragment>\n	outgoingLight = diffuseColor.rgb;\n	#include <output_fragment>\n	#include <tonemapping_fragment>\n	#include <encodings_fragment>\n	#include <fog_fragment>\n}";
var ShaderChunk = {
  alphamap_fragment,
  alphamap_pars_fragment,
  alphatest_fragment,
  alphatest_pars_fragment,
  aomap_fragment,
  aomap_pars_fragment,
  begin_vertex,
  beginnormal_vertex,
  bsdfs,
  iridescence_fragment,
  bumpmap_pars_fragment,
  clipping_planes_fragment,
  clipping_planes_pars_fragment,
  clipping_planes_pars_vertex,
  clipping_planes_vertex,
  color_fragment,
  color_pars_fragment,
  color_pars_vertex,
  color_vertex,
  common,
  cube_uv_reflection_fragment,
  defaultnormal_vertex,
  displacementmap_pars_vertex,
  displacementmap_vertex,
  emissivemap_fragment,
  emissivemap_pars_fragment,
  encodings_fragment,
  encodings_pars_fragment,
  envmap_fragment,
  envmap_common_pars_fragment,
  envmap_pars_fragment,
  envmap_pars_vertex,
  envmap_physical_pars_fragment,
  envmap_vertex,
  fog_vertex,
  fog_pars_vertex,
  fog_fragment,
  fog_pars_fragment,
  gradientmap_pars_fragment,
  lightmap_fragment,
  lightmap_pars_fragment,
  lights_lambert_vertex,
  lights_pars_begin,
  lights_toon_fragment,
  lights_toon_pars_fragment,
  lights_phong_fragment,
  lights_phong_pars_fragment,
  lights_physical_fragment,
  lights_physical_pars_fragment,
  lights_fragment_begin,
  lights_fragment_maps,
  lights_fragment_end,
  logdepthbuf_fragment,
  logdepthbuf_pars_fragment,
  logdepthbuf_pars_vertex,
  logdepthbuf_vertex,
  map_fragment,
  map_pars_fragment,
  map_particle_fragment,
  map_particle_pars_fragment,
  metalnessmap_fragment,
  metalnessmap_pars_fragment,
  morphcolor_vertex,
  morphnormal_vertex,
  morphtarget_pars_vertex,
  morphtarget_vertex,
  normal_fragment_begin,
  normal_fragment_maps,
  normal_pars_fragment,
  normal_pars_vertex,
  normal_vertex,
  normalmap_pars_fragment,
  clearcoat_normal_fragment_begin,
  clearcoat_normal_fragment_maps,
  clearcoat_pars_fragment,
  iridescence_pars_fragment,
  output_fragment,
  packing,
  premultiplied_alpha_fragment,
  project_vertex,
  dithering_fragment,
  dithering_pars_fragment,
  roughnessmap_fragment,
  roughnessmap_pars_fragment,
  shadowmap_pars_fragment,
  shadowmap_pars_vertex,
  shadowmap_vertex,
  shadowmask_pars_fragment,
  skinbase_vertex,
  skinning_pars_vertex,
  skinning_vertex,
  skinnormal_vertex,
  specularmap_fragment,
  specularmap_pars_fragment,
  tonemapping_fragment,
  tonemapping_pars_fragment,
  transmission_fragment,
  transmission_pars_fragment,
  uv_pars_fragment,
  uv_pars_vertex,
  uv_vertex,
  uv2_pars_fragment,
  uv2_pars_vertex,
  uv2_vertex,
  worldpos_vertex,
  background_vert: vertex$g,
  background_frag: fragment$g,
  cube_vert: vertex$f,
  cube_frag: fragment$f,
  depth_vert: vertex$e,
  depth_frag: fragment$e,
  distanceRGBA_vert: vertex$d,
  distanceRGBA_frag: fragment$d,
  equirect_vert: vertex$c,
  equirect_frag: fragment$c,
  linedashed_vert: vertex$b,
  linedashed_frag: fragment$b,
  meshbasic_vert: vertex$a,
  meshbasic_frag: fragment$a,
  meshlambert_vert: vertex$9,
  meshlambert_frag: fragment$9,
  meshmatcap_vert: vertex$8,
  meshmatcap_frag: fragment$8,
  meshnormal_vert: vertex$7,
  meshnormal_frag: fragment$7,
  meshphong_vert: vertex$6,
  meshphong_frag: fragment$6,
  meshphysical_vert: vertex$5,
  meshphysical_frag: fragment$5,
  meshtoon_vert: vertex$4,
  meshtoon_frag: fragment$4,
  points_vert: vertex$3,
  points_frag: fragment$3,
  shadow_vert: vertex$2,
  shadow_frag: fragment$2,
  sprite_vert: vertex$1,
  sprite_frag: fragment$1
};
var UniformsLib = {
  common: {
    diffuse: { value: /* @__PURE__ */ new Color(16777215) },
    opacity: { value: 1 },
    map: { value: null },
    uvTransform: { value: /* @__PURE__ */ new Matrix3() },
    uv2Transform: { value: /* @__PURE__ */ new Matrix3() },
    alphaMap: { value: null },
    alphaTest: { value: 0 }
  },
  specularmap: {
    specularMap: { value: null }
  },
  envmap: {
    envMap: { value: null },
    flipEnvMap: { value: -1 },
    reflectivity: { value: 1 },
    ior: { value: 1.5 },
    refractionRatio: { value: 0.98 }
  },
  aomap: {
    aoMap: { value: null },
    aoMapIntensity: { value: 1 }
  },
  lightmap: {
    lightMap: { value: null },
    lightMapIntensity: { value: 1 }
  },
  emissivemap: {
    emissiveMap: { value: null }
  },
  bumpmap: {
    bumpMap: { value: null },
    bumpScale: { value: 1 }
  },
  normalmap: {
    normalMap: { value: null },
    normalScale: { value: /* @__PURE__ */ new Vector2(1, 1) }
  },
  displacementmap: {
    displacementMap: { value: null },
    displacementScale: { value: 1 },
    displacementBias: { value: 0 }
  },
  roughnessmap: {
    roughnessMap: { value: null }
  },
  metalnessmap: {
    metalnessMap: { value: null }
  },
  gradientmap: {
    gradientMap: { value: null }
  },
  fog: {
    fogDensity: { value: 25e-5 },
    fogNear: { value: 1 },
    fogFar: { value: 2e3 },
    fogColor: { value: /* @__PURE__ */ new Color(16777215) }
  },
  lights: {
    ambientLightColor: { value: [] },
    lightProbe: { value: [] },
    directionalLights: { value: [], properties: {
      direction: {},
      color: {}
    } },
    directionalLightShadows: { value: [], properties: {
      shadowBias: {},
      shadowNormalBias: {},
      shadowRadius: {},
      shadowMapSize: {}
    } },
    directionalShadowMap: { value: [] },
    directionalShadowMatrix: { value: [] },
    spotLights: { value: [], properties: {
      color: {},
      position: {},
      direction: {},
      distance: {},
      coneCos: {},
      penumbraCos: {},
      decay: {}
    } },
    spotLightShadows: { value: [], properties: {
      shadowBias: {},
      shadowNormalBias: {},
      shadowRadius: {},
      shadowMapSize: {}
    } },
    spotShadowMap: { value: [] },
    spotShadowMatrix: { value: [] },
    pointLights: { value: [], properties: {
      color: {},
      position: {},
      decay: {},
      distance: {}
    } },
    pointLightShadows: { value: [], properties: {
      shadowBias: {},
      shadowNormalBias: {},
      shadowRadius: {},
      shadowMapSize: {},
      shadowCameraNear: {},
      shadowCameraFar: {}
    } },
    pointShadowMap: { value: [] },
    pointShadowMatrix: { value: [] },
    hemisphereLights: { value: [], properties: {
      direction: {},
      skyColor: {},
      groundColor: {}
    } },
    rectAreaLights: { value: [], properties: {
      color: {},
      position: {},
      width: {},
      height: {}
    } },
    ltc_1: { value: null },
    ltc_2: { value: null }
  },
  points: {
    diffuse: { value: /* @__PURE__ */ new Color(16777215) },
    opacity: { value: 1 },
    size: { value: 1 },
    scale: { value: 1 },
    map: { value: null },
    alphaMap: { value: null },
    alphaTest: { value: 0 },
    uvTransform: { value: /* @__PURE__ */ new Matrix3() }
  },
  sprite: {
    diffuse: { value: /* @__PURE__ */ new Color(16777215) },
    opacity: { value: 1 },
    center: { value: /* @__PURE__ */ new Vector2(0.5, 0.5) },
    rotation: { value: 0 },
    map: { value: null },
    alphaMap: { value: null },
    alphaTest: { value: 0 },
    uvTransform: { value: /* @__PURE__ */ new Matrix3() }
  }
};
var ShaderLib = {
  basic: {
    uniforms: /* @__PURE__ */ mergeUniforms([
      UniformsLib.common,
      UniformsLib.specularmap,
      UniformsLib.envmap,
      UniformsLib.aomap,
      UniformsLib.lightmap,
      UniformsLib.fog
    ]),
    vertexShader: ShaderChunk.meshbasic_vert,
    fragmentShader: ShaderChunk.meshbasic_frag
  },
  lambert: {
    uniforms: /* @__PURE__ */ mergeUniforms([
      UniformsLib.common,
      UniformsLib.specularmap,
      UniformsLib.envmap,
      UniformsLib.aomap,
      UniformsLib.lightmap,
      UniformsLib.emissivemap,
      UniformsLib.fog,
      UniformsLib.lights,
      {
        emissive: { value: /* @__PURE__ */ new Color(0) }
      }
    ]),
    vertexShader: ShaderChunk.meshlambert_vert,
    fragmentShader: ShaderChunk.meshlambert_frag
  },
  phong: {
    uniforms: /* @__PURE__ */ mergeUniforms([
      UniformsLib.common,
      UniformsLib.specularmap,
      UniformsLib.envmap,
      UniformsLib.aomap,
      UniformsLib.lightmap,
      UniformsLib.emissivemap,
      UniformsLib.bumpmap,
      UniformsLib.normalmap,
      UniformsLib.displacementmap,
      UniformsLib.fog,
      UniformsLib.lights,
      {
        emissive: { value: /* @__PURE__ */ new Color(0) },
        specular: { value: /* @__PURE__ */ new Color(1118481) },
        shininess: { value: 30 }
      }
    ]),
    vertexShader: ShaderChunk.meshphong_vert,
    fragmentShader: ShaderChunk.meshphong_frag
  },
  standard: {
    uniforms: /* @__PURE__ */ mergeUniforms([
      UniformsLib.common,
      UniformsLib.envmap,
      UniformsLib.aomap,
      UniformsLib.lightmap,
      UniformsLib.emissivemap,
      UniformsLib.bumpmap,
      UniformsLib.normalmap,
      UniformsLib.displacementmap,
      UniformsLib.roughnessmap,
      UniformsLib.metalnessmap,
      UniformsLib.fog,
      UniformsLib.lights,
      {
        emissive: { value: /* @__PURE__ */ new Color(0) },
        roughness: { value: 1 },
        metalness: { value: 0 },
        envMapIntensity: { value: 1 }
      }
    ]),
    vertexShader: ShaderChunk.meshphysical_vert,
    fragmentShader: ShaderChunk.meshphysical_frag
  },
  toon: {
    uniforms: /* @__PURE__ */ mergeUniforms([
      UniformsLib.common,
      UniformsLib.aomap,
      UniformsLib.lightmap,
      UniformsLib.emissivemap,
      UniformsLib.bumpmap,
      UniformsLib.normalmap,
      UniformsLib.displacementmap,
      UniformsLib.gradientmap,
      UniformsLib.fog,
      UniformsLib.lights,
      {
        emissive: { value: /* @__PURE__ */ new Color(0) }
      }
    ]),
    vertexShader: ShaderChunk.meshtoon_vert,
    fragmentShader: ShaderChunk.meshtoon_frag
  },
  matcap: {
    uniforms: /* @__PURE__ */ mergeUniforms([
      UniformsLib.common,
      UniformsLib.bumpmap,
      UniformsLib.normalmap,
      UniformsLib.displacementmap,
      UniformsLib.fog,
      {
        matcap: { value: null }
      }
    ]),
    vertexShader: ShaderChunk.meshmatcap_vert,
    fragmentShader: ShaderChunk.meshmatcap_frag
  },
  points: {
    uniforms: /* @__PURE__ */ mergeUniforms([
      UniformsLib.points,
      UniformsLib.fog
    ]),
    vertexShader: ShaderChunk.points_vert,
    fragmentShader: ShaderChunk.points_frag
  },
  dashed: {
    uniforms: /* @__PURE__ */ mergeUniforms([
      UniformsLib.common,
      UniformsLib.fog,
      {
        scale: { value: 1 },
        dashSize: { value: 1 },
        totalSize: { value: 2 }
      }
    ]),
    vertexShader: ShaderChunk.linedashed_vert,
    fragmentShader: ShaderChunk.linedashed_frag
  },
  depth: {
    uniforms: /* @__PURE__ */ mergeUniforms([
      UniformsLib.common,
      UniformsLib.displacementmap
    ]),
    vertexShader: ShaderChunk.depth_vert,
    fragmentShader: ShaderChunk.depth_frag
  },
  normal: {
    uniforms: /* @__PURE__ */ mergeUniforms([
      UniformsLib.common,
      UniformsLib.bumpmap,
      UniformsLib.normalmap,
      UniformsLib.displacementmap,
      {
        opacity: { value: 1 }
      }
    ]),
    vertexShader: ShaderChunk.meshnormal_vert,
    fragmentShader: ShaderChunk.meshnormal_frag
  },
  sprite: {
    uniforms: /* @__PURE__ */ mergeUniforms([
      UniformsLib.sprite,
      UniformsLib.fog
    ]),
    vertexShader: ShaderChunk.sprite_vert,
    fragmentShader: ShaderChunk.sprite_frag
  },
  background: {
    uniforms: {
      uvTransform: { value: /* @__PURE__ */ new Matrix3() },
      t2D: { value: null }
    },
    vertexShader: ShaderChunk.background_vert,
    fragmentShader: ShaderChunk.background_frag
  },
  cube: {
    uniforms: /* @__PURE__ */ mergeUniforms([
      UniformsLib.envmap,
      {
        opacity: { value: 1 }
      }
    ]),
    vertexShader: ShaderChunk.cube_vert,
    fragmentShader: ShaderChunk.cube_frag
  },
  equirect: {
    uniforms: {
      tEquirect: { value: null }
    },
    vertexShader: ShaderChunk.equirect_vert,
    fragmentShader: ShaderChunk.equirect_frag
  },
  distanceRGBA: {
    uniforms: /* @__PURE__ */ mergeUniforms([
      UniformsLib.common,
      UniformsLib.displacementmap,
      {
        referencePosition: { value: /* @__PURE__ */ new Vector3() },
        nearDistance: { value: 1 },
        farDistance: { value: 1e3 }
      }
    ]),
    vertexShader: ShaderChunk.distanceRGBA_vert,
    fragmentShader: ShaderChunk.distanceRGBA_frag
  },
  shadow: {
    uniforms: /* @__PURE__ */ mergeUniforms([
      UniformsLib.lights,
      UniformsLib.fog,
      {
        color: { value: /* @__PURE__ */ new Color(0) },
        opacity: { value: 1 }
      }
    ]),
    vertexShader: ShaderChunk.shadow_vert,
    fragmentShader: ShaderChunk.shadow_frag
  }
};
ShaderLib.physical = {
  uniforms: /* @__PURE__ */ mergeUniforms([
    ShaderLib.standard.uniforms,
    {
      clearcoat: { value: 0 },
      clearcoatMap: { value: null },
      clearcoatRoughness: { value: 0 },
      clearcoatRoughnessMap: { value: null },
      clearcoatNormalScale: { value: /* @__PURE__ */ new Vector2(1, 1) },
      clearcoatNormalMap: { value: null },
      iridescence: { value: 0 },
      iridescenceMap: { value: null },
      iridescenceIOR: { value: 1.3 },
      iridescenceThicknessMinimum: { value: 100 },
      iridescenceThicknessMaximum: { value: 400 },
      iridescenceThicknessMap: { value: null },
      sheen: { value: 0 },
      sheenColor: { value: /* @__PURE__ */ new Color(0) },
      sheenColorMap: { value: null },
      sheenRoughness: { value: 1 },
      sheenRoughnessMap: { value: null },
      transmission: { value: 0 },
      transmissionMap: { value: null },
      transmissionSamplerSize: { value: /* @__PURE__ */ new Vector2() },
      transmissionSamplerMap: { value: null },
      thickness: { value: 0 },
      thicknessMap: { value: null },
      attenuationDistance: { value: 0 },
      attenuationColor: { value: /* @__PURE__ */ new Color(0) },
      specularIntensity: { value: 1 },
      specularIntensityMap: { value: null },
      specularColor: { value: /* @__PURE__ */ new Color(1, 1, 1) },
      specularColorMap: { value: null }
    }
  ]),
  vertexShader: ShaderChunk.meshphysical_vert,
  fragmentShader: ShaderChunk.meshphysical_frag
};
function WebGLBackground(renderer, cubemaps, state, objects, alpha, premultipliedAlpha) {
  const clearColor = new Color(0);
  let clearAlpha = alpha === true ? 0 : 1;
  let planeMesh;
  let boxMesh;
  let currentBackground = null;
  let currentBackgroundVersion = 0;
  let currentTonemapping = null;
  function render(renderList, scene) {
    let forceClear = false;
    let background = scene.isScene === true ? scene.background : null;
    if (background && background.isTexture) {
      background = cubemaps.get(background);
    }
    const xr = renderer.xr;
    const session = xr.getSession && xr.getSession();
    if (session && session.environmentBlendMode === "additive") {
      background = null;
    }
    if (background === null) {
      setClear(clearColor, clearAlpha);
    } else if (background && background.isColor) {
      setClear(background, 1);
      forceClear = true;
    }
    if (renderer.autoClear || forceClear) {
      renderer.clear(renderer.autoClearColor, renderer.autoClearDepth, renderer.autoClearStencil);
    }
    if (background && (background.isCubeTexture || background.mapping === CubeUVReflectionMapping)) {
      if (boxMesh === void 0) {
        boxMesh = new Mesh(
          new BoxGeometry(1, 1, 1),
          new ShaderMaterial({
            name: "BackgroundCubeMaterial",
            uniforms: cloneUniforms(ShaderLib.cube.uniforms),
            vertexShader: ShaderLib.cube.vertexShader,
            fragmentShader: ShaderLib.cube.fragmentShader,
            side: BackSide,
            depthTest: false,
            depthWrite: false,
            fog: false
          })
        );
        boxMesh.geometry.deleteAttribute("normal");
        boxMesh.geometry.deleteAttribute("uv");
        boxMesh.onBeforeRender = function(renderer2, scene2, camera) {
          this.matrixWorld.copyPosition(camera.matrixWorld);
        };
        Object.defineProperty(boxMesh.material, "envMap", {
          get: function() {
            return this.uniforms.envMap.value;
          }
        });
        objects.update(boxMesh);
      }
      boxMesh.material.uniforms.envMap.value = background;
      boxMesh.material.uniforms.flipEnvMap.value = background.isCubeTexture && background.isRenderTargetTexture === false ? -1 : 1;
      if (currentBackground !== background || currentBackgroundVersion !== background.version || currentTonemapping !== renderer.toneMapping) {
        boxMesh.material.needsUpdate = true;
        currentBackground = background;
        currentBackgroundVersion = background.version;
        currentTonemapping = renderer.toneMapping;
      }
      boxMesh.layers.enableAll();
      renderList.unshift(boxMesh, boxMesh.geometry, boxMesh.material, 0, 0, null);
    } else if (background && background.isTexture) {
      if (planeMesh === void 0) {
        planeMesh = new Mesh(
          new PlaneGeometry(2, 2),
          new ShaderMaterial({
            name: "BackgroundMaterial",
            uniforms: cloneUniforms(ShaderLib.background.uniforms),
            vertexShader: ShaderLib.background.vertexShader,
            fragmentShader: ShaderLib.background.fragmentShader,
            side: FrontSide,
            depthTest: false,
            depthWrite: false,
            fog: false
          })
        );
        planeMesh.geometry.deleteAttribute("normal");
        Object.defineProperty(planeMesh.material, "map", {
          get: function() {
            return this.uniforms.t2D.value;
          }
        });
        objects.update(planeMesh);
      }
      planeMesh.material.uniforms.t2D.value = background;
      if (background.matrixAutoUpdate === true) {
        background.updateMatrix();
      }
      planeMesh.material.uniforms.uvTransform.value.copy(background.matrix);
      if (currentBackground !== background || currentBackgroundVersion !== background.version || currentTonemapping !== renderer.toneMapping) {
        planeMesh.material.needsUpdate = true;
        currentBackground = background;
        currentBackgroundVersion = background.version;
        currentTonemapping = renderer.toneMapping;
      }
      planeMesh.layers.enableAll();
      renderList.unshift(planeMesh, planeMesh.geometry, planeMesh.material, 0, 0, null);
    }
  }
  function setClear(color, alpha2) {
    state.buffers.color.setClear(color.r, color.g, color.b, alpha2, premultipliedAlpha);
  }
  return {
    getClearColor: function() {
      return clearColor;
    },
    setClearColor: function(color, alpha2 = 1) {
      clearColor.set(color);
      clearAlpha = alpha2;
      setClear(clearColor, clearAlpha);
    },
    getClearAlpha: function() {
      return clearAlpha;
    },
    setClearAlpha: function(alpha2) {
      clearAlpha = alpha2;
      setClear(clearColor, clearAlpha);
    },
    render
  };
}
function WebGLBindingStates(gl, extensions, attributes, capabilities) {
  const maxVertexAttributes = gl.getParameter(34921);
  const extension = capabilities.isWebGL2 ? null : extensions.get("OES_vertex_array_object");
  const vaoAvailable = capabilities.isWebGL2 || extension !== null;
  const bindingStates = {};
  const defaultState = createBindingState(null);
  let currentState = defaultState;
  let forceUpdate = false;
  function setup(object, material, program, geometry, index) {
    let updateBuffers = false;
    if (vaoAvailable) {
      const state = getBindingState(geometry, program, material);
      if (currentState !== state) {
        currentState = state;
        bindVertexArrayObject(currentState.object);
      }
      updateBuffers = needsUpdate(object, geometry, program, index);
      if (updateBuffers)
        saveCache(object, geometry, program, index);
    } else {
      const wireframe = material.wireframe === true;
      if (currentState.geometry !== geometry.id || currentState.program !== program.id || currentState.wireframe !== wireframe) {
        currentState.geometry = geometry.id;
        currentState.program = program.id;
        currentState.wireframe = wireframe;
        updateBuffers = true;
      }
    }
    if (index !== null) {
      attributes.update(index, 34963);
    }
    if (updateBuffers || forceUpdate) {
      forceUpdate = false;
      setupVertexAttributes(object, material, program, geometry);
      if (index !== null) {
        gl.bindBuffer(34963, attributes.get(index).buffer);
      }
    }
  }
  function createVertexArrayObject() {
    if (capabilities.isWebGL2)
      return gl.createVertexArray();
    return extension.createVertexArrayOES();
  }
  function bindVertexArrayObject(vao) {
    if (capabilities.isWebGL2)
      return gl.bindVertexArray(vao);
    return extension.bindVertexArrayOES(vao);
  }
  function deleteVertexArrayObject(vao) {
    if (capabilities.isWebGL2)
      return gl.deleteVertexArray(vao);
    return extension.deleteVertexArrayOES(vao);
  }
  function getBindingState(geometry, program, material) {
    const wireframe = material.wireframe === true;
    let programMap = bindingStates[geometry.id];
    if (programMap === void 0) {
      programMap = {};
      bindingStates[geometry.id] = programMap;
    }
    let stateMap = programMap[program.id];
    if (stateMap === void 0) {
      stateMap = {};
      programMap[program.id] = stateMap;
    }
    let state = stateMap[wireframe];
    if (state === void 0) {
      state = createBindingState(createVertexArrayObject());
      stateMap[wireframe] = state;
    }
    return state;
  }
  function createBindingState(vao) {
    const newAttributes = [];
    const enabledAttributes = [];
    const attributeDivisors = [];
    for (let i2 = 0; i2 < maxVertexAttributes; i2++) {
      newAttributes[i2] = 0;
      enabledAttributes[i2] = 0;
      attributeDivisors[i2] = 0;
    }
    return {
      geometry: null,
      program: null,
      wireframe: false,
      newAttributes,
      enabledAttributes,
      attributeDivisors,
      object: vao,
      attributes: {},
      index: null
    };
  }
  function needsUpdate(object, geometry, program, index) {
    const cachedAttributes = currentState.attributes;
    const geometryAttributes = geometry.attributes;
    let attributesNum = 0;
    const programAttributes = program.getAttributes();
    for (const name in programAttributes) {
      const programAttribute = programAttributes[name];
      if (programAttribute.location >= 0) {
        const cachedAttribute = cachedAttributes[name];
        let geometryAttribute = geometryAttributes[name];
        if (geometryAttribute === void 0) {
          if (name === "instanceMatrix" && object.instanceMatrix)
            geometryAttribute = object.instanceMatrix;
          if (name === "instanceColor" && object.instanceColor)
            geometryAttribute = object.instanceColor;
        }
        if (cachedAttribute === void 0)
          return true;
        if (cachedAttribute.attribute !== geometryAttribute)
          return true;
        if (geometryAttribute && cachedAttribute.data !== geometryAttribute.data)
          return true;
        attributesNum++;
      }
    }
    if (currentState.attributesNum !== attributesNum)
      return true;
    if (currentState.index !== index)
      return true;
    return false;
  }
  function saveCache(object, geometry, program, index) {
    const cache = {};
    const attributes2 = geometry.attributes;
    let attributesNum = 0;
    const programAttributes = program.getAttributes();
    for (const name in programAttributes) {
      const programAttribute = programAttributes[name];
      if (programAttribute.location >= 0) {
        let attribute = attributes2[name];
        if (attribute === void 0) {
          if (name === "instanceMatrix" && object.instanceMatrix)
            attribute = object.instanceMatrix;
          if (name === "instanceColor" && object.instanceColor)
            attribute = object.instanceColor;
        }
        const data = {};
        data.attribute = attribute;
        if (attribute && attribute.data) {
          data.data = attribute.data;
        }
        cache[name] = data;
        attributesNum++;
      }
    }
    currentState.attributes = cache;
    currentState.attributesNum = attributesNum;
    currentState.index = index;
  }
  function initAttributes() {
    const newAttributes = currentState.newAttributes;
    for (let i2 = 0, il = newAttributes.length; i2 < il; i2++) {
      newAttributes[i2] = 0;
    }
  }
  function enableAttribute(attribute) {
    enableAttributeAndDivisor(attribute, 0);
  }
  function enableAttributeAndDivisor(attribute, meshPerAttribute) {
    const newAttributes = currentState.newAttributes;
    const enabledAttributes = currentState.enabledAttributes;
    const attributeDivisors = currentState.attributeDivisors;
    newAttributes[attribute] = 1;
    if (enabledAttributes[attribute] === 0) {
      gl.enableVertexAttribArray(attribute);
      enabledAttributes[attribute] = 1;
    }
    if (attributeDivisors[attribute] !== meshPerAttribute) {
      const extension2 = capabilities.isWebGL2 ? gl : extensions.get("ANGLE_instanced_arrays");
      extension2[capabilities.isWebGL2 ? "vertexAttribDivisor" : "vertexAttribDivisorANGLE"](attribute, meshPerAttribute);
      attributeDivisors[attribute] = meshPerAttribute;
    }
  }
  function disableUnusedAttributes() {
    const newAttributes = currentState.newAttributes;
    const enabledAttributes = currentState.enabledAttributes;
    for (let i2 = 0, il = enabledAttributes.length; i2 < il; i2++) {
      if (enabledAttributes[i2] !== newAttributes[i2]) {
        gl.disableVertexAttribArray(i2);
        enabledAttributes[i2] = 0;
      }
    }
  }
  function vertexAttribPointer(index, size, type, normalized, stride, offset) {
    if (capabilities.isWebGL2 === true && (type === 5124 || type === 5125)) {
      gl.vertexAttribIPointer(index, size, type, stride, offset);
    } else {
      gl.vertexAttribPointer(index, size, type, normalized, stride, offset);
    }
  }
  function setupVertexAttributes(object, material, program, geometry) {
    if (capabilities.isWebGL2 === false && (object.isInstancedMesh || geometry.isInstancedBufferGeometry)) {
      if (extensions.get("ANGLE_instanced_arrays") === null)
        return;
    }
    initAttributes();
    const geometryAttributes = geometry.attributes;
    const programAttributes = program.getAttributes();
    const materialDefaultAttributeValues = material.defaultAttributeValues;
    for (const name in programAttributes) {
      const programAttribute = programAttributes[name];
      if (programAttribute.location >= 0) {
        let geometryAttribute = geometryAttributes[name];
        if (geometryAttribute === void 0) {
          if (name === "instanceMatrix" && object.instanceMatrix)
            geometryAttribute = object.instanceMatrix;
          if (name === "instanceColor" && object.instanceColor)
            geometryAttribute = object.instanceColor;
        }
        if (geometryAttribute !== void 0) {
          const normalized = geometryAttribute.normalized;
          const size = geometryAttribute.itemSize;
          const attribute = attributes.get(geometryAttribute);
          if (attribute === void 0)
            continue;
          const buffer = attribute.buffer;
          const type = attribute.type;
          const bytesPerElement = attribute.bytesPerElement;
          if (geometryAttribute.isInterleavedBufferAttribute) {
            const data = geometryAttribute.data;
            const stride = data.stride;
            const offset = geometryAttribute.offset;
            if (data.isInstancedInterleavedBuffer) {
              for (let i2 = 0; i2 < programAttribute.locationSize; i2++) {
                enableAttributeAndDivisor(programAttribute.location + i2, data.meshPerAttribute);
              }
              if (object.isInstancedMesh !== true && geometry._maxInstanceCount === void 0) {
                geometry._maxInstanceCount = data.meshPerAttribute * data.count;
              }
            } else {
              for (let i2 = 0; i2 < programAttribute.locationSize; i2++) {
                enableAttribute(programAttribute.location + i2);
              }
            }
            gl.bindBuffer(34962, buffer);
            for (let i2 = 0; i2 < programAttribute.locationSize; i2++) {
              vertexAttribPointer(
                programAttribute.location + i2,
                size / programAttribute.locationSize,
                type,
                normalized,
                stride * bytesPerElement,
                (offset + size / programAttribute.locationSize * i2) * bytesPerElement
              );
            }
          } else {
            if (geometryAttribute.isInstancedBufferAttribute) {
              for (let i2 = 0; i2 < programAttribute.locationSize; i2++) {
                enableAttributeAndDivisor(programAttribute.location + i2, geometryAttribute.meshPerAttribute);
              }
              if (object.isInstancedMesh !== true && geometry._maxInstanceCount === void 0) {
                geometry._maxInstanceCount = geometryAttribute.meshPerAttribute * geometryAttribute.count;
              }
            } else {
              for (let i2 = 0; i2 < programAttribute.locationSize; i2++) {
                enableAttribute(programAttribute.location + i2);
              }
            }
            gl.bindBuffer(34962, buffer);
            for (let i2 = 0; i2 < programAttribute.locationSize; i2++) {
              vertexAttribPointer(
                programAttribute.location + i2,
                size / programAttribute.locationSize,
                type,
                normalized,
                size * bytesPerElement,
                size / programAttribute.locationSize * i2 * bytesPerElement
              );
            }
          }
        } else if (materialDefaultAttributeValues !== void 0) {
          const value = materialDefaultAttributeValues[name];
          if (value !== void 0) {
            switch (value.length) {
              case 2:
                gl.vertexAttrib2fv(programAttribute.location, value);
                break;
              case 3:
                gl.vertexAttrib3fv(programAttribute.location, value);
                break;
              case 4:
                gl.vertexAttrib4fv(programAttribute.location, value);
                break;
              default:
                gl.vertexAttrib1fv(programAttribute.location, value);
            }
          }
        }
      }
    }
    disableUnusedAttributes();
  }
  function dispose() {
    reset();
    for (const geometryId in bindingStates) {
      const programMap = bindingStates[geometryId];
      for (const programId in programMap) {
        const stateMap = programMap[programId];
        for (const wireframe in stateMap) {
          deleteVertexArrayObject(stateMap[wireframe].object);
          delete stateMap[wireframe];
        }
        delete programMap[programId];
      }
      delete bindingStates[geometryId];
    }
  }
  function releaseStatesOfGeometry(geometry) {
    if (bindingStates[geometry.id] === void 0)
      return;
    const programMap = bindingStates[geometry.id];
    for (const programId in programMap) {
      const stateMap = programMap[programId];
      for (const wireframe in stateMap) {
        deleteVertexArrayObject(stateMap[wireframe].object);
        delete stateMap[wireframe];
      }
      delete programMap[programId];
    }
    delete bindingStates[geometry.id];
  }
  function releaseStatesOfProgram(program) {
    for (const geometryId in bindingStates) {
      const programMap = bindingStates[geometryId];
      if (programMap[program.id] === void 0)
        continue;
      const stateMap = programMap[program.id];
      for (const wireframe in stateMap) {
        deleteVertexArrayObject(stateMap[wireframe].object);
        delete stateMap[wireframe];
      }
      delete programMap[program.id];
    }
  }
  function reset() {
    resetDefaultState();
    forceUpdate = true;
    if (currentState === defaultState)
      return;
    currentState = defaultState;
    bindVertexArrayObject(currentState.object);
  }
  function resetDefaultState() {
    defaultState.geometry = null;
    defaultState.program = null;
    defaultState.wireframe = false;
  }
  return {
    setup,
    reset,
    resetDefaultState,
    dispose,
    releaseStatesOfGeometry,
    releaseStatesOfProgram,
    initAttributes,
    enableAttribute,
    disableUnusedAttributes
  };
}
function WebGLBufferRenderer(gl, extensions, info, capabilities) {
  const isWebGL2 = capabilities.isWebGL2;
  let mode;
  function setMode(value) {
    mode = value;
  }
  function render(start, count) {
    gl.drawArrays(mode, start, count);
    info.update(count, mode, 1);
  }
  function renderInstances(start, count, primcount) {
    if (primcount === 0)
      return;
    let extension, methodName;
    if (isWebGL2) {
      extension = gl;
      methodName = "drawArraysInstanced";
    } else {
      extension = extensions.get("ANGLE_instanced_arrays");
      methodName = "drawArraysInstancedANGLE";
      if (extension === null) {
        console.error("THREE.WebGLBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.");
        return;
      }
    }
    extension[methodName](mode, start, count, primcount);
    info.update(count, mode, primcount);
  }
  this.setMode = setMode;
  this.render = render;
  this.renderInstances = renderInstances;
}
function WebGLCapabilities(gl, extensions, parameters) {
  let maxAnisotropy;
  function getMaxAnisotropy() {
    if (maxAnisotropy !== void 0)
      return maxAnisotropy;
    if (extensions.has("EXT_texture_filter_anisotropic") === true) {
      const extension = extensions.get("EXT_texture_filter_anisotropic");
      maxAnisotropy = gl.getParameter(extension.MAX_TEXTURE_MAX_ANISOTROPY_EXT);
    } else {
      maxAnisotropy = 0;
    }
    return maxAnisotropy;
  }
  function getMaxPrecision(precision2) {
    if (precision2 === "highp") {
      if (gl.getShaderPrecisionFormat(35633, 36338).precision > 0 && gl.getShaderPrecisionFormat(35632, 36338).precision > 0) {
        return "highp";
      }
      precision2 = "mediump";
    }
    if (precision2 === "mediump") {
      if (gl.getShaderPrecisionFormat(35633, 36337).precision > 0 && gl.getShaderPrecisionFormat(35632, 36337).precision > 0) {
        return "mediump";
      }
    }
    return "lowp";
  }
  const isWebGL2 = typeof WebGL2RenderingContext !== "undefined" && gl instanceof WebGL2RenderingContext || typeof WebGL2ComputeRenderingContext !== "undefined" && gl instanceof WebGL2ComputeRenderingContext;
  let precision = parameters.precision !== void 0 ? parameters.precision : "highp";
  const maxPrecision = getMaxPrecision(precision);
  if (maxPrecision !== precision) {
    console.warn("THREE.WebGLRenderer:", precision, "not supported, using", maxPrecision, "instead.");
    precision = maxPrecision;
  }
  const drawBuffers = isWebGL2 || extensions.has("WEBGL_draw_buffers");
  const logarithmicDepthBuffer = parameters.logarithmicDepthBuffer === true;
  const maxTextures = gl.getParameter(34930);
  const maxVertexTextures = gl.getParameter(35660);
  const maxTextureSize = gl.getParameter(3379);
  const maxCubemapSize = gl.getParameter(34076);
  const maxAttributes = gl.getParameter(34921);
  const maxVertexUniforms = gl.getParameter(36347);
  const maxVaryings = gl.getParameter(36348);
  const maxFragmentUniforms = gl.getParameter(36349);
  const vertexTextures = maxVertexTextures > 0;
  const floatFragmentTextures = isWebGL2 || extensions.has("OES_texture_float");
  const floatVertexTextures = vertexTextures && floatFragmentTextures;
  const maxSamples = isWebGL2 ? gl.getParameter(36183) : 0;
  return {
    isWebGL2,
    drawBuffers,
    getMaxAnisotropy,
    getMaxPrecision,
    precision,
    logarithmicDepthBuffer,
    maxTextures,
    maxVertexTextures,
    maxTextureSize,
    maxCubemapSize,
    maxAttributes,
    maxVertexUniforms,
    maxVaryings,
    maxFragmentUniforms,
    vertexTextures,
    floatFragmentTextures,
    floatVertexTextures,
    maxSamples
  };
}
function WebGLClipping(properties) {
  const scope = this;
  let globalState = null, numGlobalPlanes = 0, localClippingEnabled = false, renderingShadows = false;
  const plane = new Plane(), viewNormalMatrix = new Matrix3(), uniform = { value: null, needsUpdate: false };
  this.uniform = uniform;
  this.numPlanes = 0;
  this.numIntersection = 0;
  this.init = function(planes, enableLocalClipping, camera) {
    const enabled = planes.length !== 0 || enableLocalClipping || numGlobalPlanes !== 0 || localClippingEnabled;
    localClippingEnabled = enableLocalClipping;
    globalState = projectPlanes(planes, camera, 0);
    numGlobalPlanes = planes.length;
    return enabled;
  };
  this.beginShadows = function() {
    renderingShadows = true;
    projectPlanes(null);
  };
  this.endShadows = function() {
    renderingShadows = false;
    resetGlobalState();
  };
  this.setState = function(material, camera, useCache) {
    const planes = material.clippingPlanes, clipIntersection = material.clipIntersection, clipShadows = material.clipShadows;
    const materialProperties = properties.get(material);
    if (!localClippingEnabled || planes === null || planes.length === 0 || renderingShadows && !clipShadows) {
      if (renderingShadows) {
        projectPlanes(null);
      } else {
        resetGlobalState();
      }
    } else {
      const nGlobal = renderingShadows ? 0 : numGlobalPlanes, lGlobal = nGlobal * 4;
      let dstArray = materialProperties.clippingState || null;
      uniform.value = dstArray;
      dstArray = projectPlanes(planes, camera, lGlobal, useCache);
      for (let i2 = 0; i2 !== lGlobal; ++i2) {
        dstArray[i2] = globalState[i2];
      }
      materialProperties.clippingState = dstArray;
      this.numIntersection = clipIntersection ? this.numPlanes : 0;
      this.numPlanes += nGlobal;
    }
  };
  function resetGlobalState() {
    if (uniform.value !== globalState) {
      uniform.value = globalState;
      uniform.needsUpdate = numGlobalPlanes > 0;
    }
    scope.numPlanes = numGlobalPlanes;
    scope.numIntersection = 0;
  }
  function projectPlanes(planes, camera, dstOffset, skipTransform) {
    const nPlanes = planes !== null ? planes.length : 0;
    let dstArray = null;
    if (nPlanes !== 0) {
      dstArray = uniform.value;
      if (skipTransform !== true || dstArray === null) {
        const flatSize = dstOffset + nPlanes * 4, viewMatrix = camera.matrixWorldInverse;
        viewNormalMatrix.getNormalMatrix(viewMatrix);
        if (dstArray === null || dstArray.length < flatSize) {
          dstArray = new Float32Array(flatSize);
        }
        for (let i2 = 0, i4 = dstOffset; i2 !== nPlanes; ++i2, i4 += 4) {
          plane.copy(planes[i2]).applyMatrix4(viewMatrix, viewNormalMatrix);
          plane.normal.toArray(dstArray, i4);
          dstArray[i4 + 3] = plane.constant;
        }
      }
      uniform.value = dstArray;
      uniform.needsUpdate = true;
    }
    scope.numPlanes = nPlanes;
    scope.numIntersection = 0;
    return dstArray;
  }
}
function WebGLCubeMaps(renderer) {
  let cubemaps = /* @__PURE__ */ new WeakMap();
  function mapTextureMapping(texture, mapping) {
    if (mapping === EquirectangularReflectionMapping) {
      texture.mapping = CubeReflectionMapping;
    } else if (mapping === EquirectangularRefractionMapping) {
      texture.mapping = CubeRefractionMapping;
    }
    return texture;
  }
  function get(texture) {
    if (texture && texture.isTexture && texture.isRenderTargetTexture === false) {
      const mapping = texture.mapping;
      if (mapping === EquirectangularReflectionMapping || mapping === EquirectangularRefractionMapping) {
        if (cubemaps.has(texture)) {
          const cubemap = cubemaps.get(texture).texture;
          return mapTextureMapping(cubemap, texture.mapping);
        } else {
          const image = texture.image;
          if (image && image.height > 0) {
            const renderTarget = new WebGLCubeRenderTarget(image.height / 2);
            renderTarget.fromEquirectangularTexture(renderer, texture);
            cubemaps.set(texture, renderTarget);
            texture.addEventListener("dispose", onTextureDispose);
            return mapTextureMapping(renderTarget.texture, texture.mapping);
          } else {
            return null;
          }
        }
      }
    }
    return texture;
  }
  function onTextureDispose(event) {
    const texture = event.target;
    texture.removeEventListener("dispose", onTextureDispose);
    const cubemap = cubemaps.get(texture);
    if (cubemap !== void 0) {
      cubemaps.delete(texture);
      cubemap.dispose();
    }
  }
  function dispose() {
    cubemaps = /* @__PURE__ */ new WeakMap();
  }
  return {
    get,
    dispose
  };
}
var OrthographicCamera = class extends Camera {
  constructor(left = -1, right = 1, top = 1, bottom = -1, near = 0.1, far = 2e3) {
    super();
    this.isOrthographicCamera = true;
    this.type = "OrthographicCamera";
    this.zoom = 1;
    this.view = null;
    this.left = left;
    this.right = right;
    this.top = top;
    this.bottom = bottom;
    this.near = near;
    this.far = far;
    this.updateProjectionMatrix();
  }
  copy(source, recursive) {
    super.copy(source, recursive);
    this.left = source.left;
    this.right = source.right;
    this.top = source.top;
    this.bottom = source.bottom;
    this.near = source.near;
    this.far = source.far;
    this.zoom = source.zoom;
    this.view = source.view === null ? null : Object.assign({}, source.view);
    return this;
  }
  setViewOffset(fullWidth, fullHeight, x, y, width, height) {
    if (this.view === null) {
      this.view = {
        enabled: true,
        fullWidth: 1,
        fullHeight: 1,
        offsetX: 0,
        offsetY: 0,
        width: 1,
        height: 1
      };
    }
    this.view.enabled = true;
    this.view.fullWidth = fullWidth;
    this.view.fullHeight = fullHeight;
    this.view.offsetX = x;
    this.view.offsetY = y;
    this.view.width = width;
    this.view.height = height;
    this.updateProjectionMatrix();
  }
  clearViewOffset() {
    if (this.view !== null) {
      this.view.enabled = false;
    }
    this.updateProjectionMatrix();
  }
  updateProjectionMatrix() {
    const dx = (this.right - this.left) / (2 * this.zoom);
    const dy = (this.top - this.bottom) / (2 * this.zoom);
    const cx = (this.right + this.left) / 2;
    const cy = (this.top + this.bottom) / 2;
    let left = cx - dx;
    let right = cx + dx;
    let top = cy + dy;
    let bottom = cy - dy;
    if (this.view !== null && this.view.enabled) {
      const scaleW = (this.right - this.left) / this.view.fullWidth / this.zoom;
      const scaleH = (this.top - this.bottom) / this.view.fullHeight / this.zoom;
      left += scaleW * this.view.offsetX;
      right = left + scaleW * this.view.width;
      top -= scaleH * this.view.offsetY;
      bottom = top - scaleH * this.view.height;
    }
    this.projectionMatrix.makeOrthographic(left, right, top, bottom, this.near, this.far);
    this.projectionMatrixInverse.copy(this.projectionMatrix).invert();
  }
  toJSON(meta) {
    const data = super.toJSON(meta);
    data.object.zoom = this.zoom;
    data.object.left = this.left;
    data.object.right = this.right;
    data.object.top = this.top;
    data.object.bottom = this.bottom;
    data.object.near = this.near;
    data.object.far = this.far;
    if (this.view !== null)
      data.object.view = Object.assign({}, this.view);
    return data;
  }
};
var LOD_MIN = 4;
var EXTRA_LOD_SIGMA = [0.125, 0.215, 0.35, 0.446, 0.526, 0.582];
var MAX_SAMPLES = 20;
var _flatCamera = /* @__PURE__ */ new OrthographicCamera();
var _clearColor = /* @__PURE__ */ new Color();
var _oldTarget = null;
var PHI = (1 + Math.sqrt(5)) / 2;
var INV_PHI = 1 / PHI;
var _axisDirections = [
  /* @__PURE__ */ new Vector3(1, 1, 1),
  /* @__PURE__ */ new Vector3(-1, 1, 1),
  /* @__PURE__ */ new Vector3(1, 1, -1),
  /* @__PURE__ */ new Vector3(-1, 1, -1),
  /* @__PURE__ */ new Vector3(0, PHI, INV_PHI),
  /* @__PURE__ */ new Vector3(0, PHI, -INV_PHI),
  /* @__PURE__ */ new Vector3(INV_PHI, 0, PHI),
  /* @__PURE__ */ new Vector3(-INV_PHI, 0, PHI),
  /* @__PURE__ */ new Vector3(PHI, INV_PHI, 0),
  /* @__PURE__ */ new Vector3(-PHI, INV_PHI, 0)
];
var PMREMGenerator = class {
  constructor(renderer) {
    this._renderer = renderer;
    this._pingPongRenderTarget = null;
    this._lodMax = 0;
    this._cubeSize = 0;
    this._lodPlanes = [];
    this._sizeLods = [];
    this._sigmas = [];
    this._blurMaterial = null;
    this._cubemapMaterial = null;
    this._equirectMaterial = null;
    this._compileMaterial(this._blurMaterial);
  }
  fromScene(scene, sigma = 0, near = 0.1, far = 100) {
    _oldTarget = this._renderer.getRenderTarget();
    this._setSize(256);
    const cubeUVRenderTarget = this._allocateTargets();
    cubeUVRenderTarget.depthBuffer = true;
    this._sceneToCubeUV(scene, near, far, cubeUVRenderTarget);
    if (sigma > 0) {
      this._blur(cubeUVRenderTarget, 0, 0, sigma);
    }
    this._applyPMREM(cubeUVRenderTarget);
    this._cleanup(cubeUVRenderTarget);
    return cubeUVRenderTarget;
  }
  fromEquirectangular(equirectangular, renderTarget = null) {
    return this._fromTexture(equirectangular, renderTarget);
  }
  fromCubemap(cubemap, renderTarget = null) {
    return this._fromTexture(cubemap, renderTarget);
  }
  compileCubemapShader() {
    if (this._cubemapMaterial === null) {
      this._cubemapMaterial = _getCubemapMaterial();
      this._compileMaterial(this._cubemapMaterial);
    }
  }
  compileEquirectangularShader() {
    if (this._equirectMaterial === null) {
      this._equirectMaterial = _getEquirectMaterial();
      this._compileMaterial(this._equirectMaterial);
    }
  }
  dispose() {
    this._dispose();
    if (this._cubemapMaterial !== null)
      this._cubemapMaterial.dispose();
    if (this._equirectMaterial !== null)
      this._equirectMaterial.dispose();
  }
  _setSize(cubeSize) {
    this._lodMax = Math.floor(Math.log2(cubeSize));
    this._cubeSize = Math.pow(2, this._lodMax);
  }
  _dispose() {
    if (this._blurMaterial !== null)
      this._blurMaterial.dispose();
    if (this._pingPongRenderTarget !== null)
      this._pingPongRenderTarget.dispose();
    for (let i2 = 0; i2 < this._lodPlanes.length; i2++) {
      this._lodPlanes[i2].dispose();
    }
  }
  _cleanup(outputTarget) {
    this._renderer.setRenderTarget(_oldTarget);
    outputTarget.scissorTest = false;
    _setViewport(outputTarget, 0, 0, outputTarget.width, outputTarget.height);
  }
  _fromTexture(texture, renderTarget) {
    if (texture.mapping === CubeReflectionMapping || texture.mapping === CubeRefractionMapping) {
      this._setSize(texture.image.length === 0 ? 16 : texture.image[0].width || texture.image[0].image.width);
    } else {
      this._setSize(texture.image.width / 4);
    }
    _oldTarget = this._renderer.getRenderTarget();
    const cubeUVRenderTarget = renderTarget || this._allocateTargets();
    this._textureToCubeUV(texture, cubeUVRenderTarget);
    this._applyPMREM(cubeUVRenderTarget);
    this._cleanup(cubeUVRenderTarget);
    return cubeUVRenderTarget;
  }
  _allocateTargets() {
    const width = 3 * Math.max(this._cubeSize, 16 * 7);
    const height = 4 * this._cubeSize;
    const params = {
      magFilter: LinearFilter,
      minFilter: LinearFilter,
      generateMipmaps: false,
      type: HalfFloatType,
      format: RGBAFormat,
      encoding: LinearEncoding,
      depthBuffer: false
    };
    const cubeUVRenderTarget = _createRenderTarget(width, height, params);
    if (this._pingPongRenderTarget === null || this._pingPongRenderTarget.width !== width) {
      if (this._pingPongRenderTarget !== null) {
        this._dispose();
      }
      this._pingPongRenderTarget = _createRenderTarget(width, height, params);
      const { _lodMax } = this;
      ({ sizeLods: this._sizeLods, lodPlanes: this._lodPlanes, sigmas: this._sigmas } = _createPlanes(_lodMax));
      this._blurMaterial = _getBlurShader(_lodMax, width, height);
    }
    return cubeUVRenderTarget;
  }
  _compileMaterial(material) {
    const tmpMesh = new Mesh(this._lodPlanes[0], material);
    this._renderer.compile(tmpMesh, _flatCamera);
  }
  _sceneToCubeUV(scene, near, far, cubeUVRenderTarget) {
    const fov2 = 90;
    const aspect2 = 1;
    const cubeCamera = new PerspectiveCamera(fov2, aspect2, near, far);
    const upSign = [1, -1, 1, 1, 1, 1];
    const forwardSign = [1, 1, 1, -1, -1, -1];
    const renderer = this._renderer;
    const originalAutoClear = renderer.autoClear;
    const toneMapping = renderer.toneMapping;
    renderer.getClearColor(_clearColor);
    renderer.toneMapping = NoToneMapping;
    renderer.autoClear = false;
    const backgroundMaterial = new MeshBasicMaterial({
      name: "PMREM.Background",
      side: BackSide,
      depthWrite: false,
      depthTest: false
    });
    const backgroundBox = new Mesh(new BoxGeometry(), backgroundMaterial);
    let useSolidColor = false;
    const background = scene.background;
    if (background) {
      if (background.isColor) {
        backgroundMaterial.color.copy(background);
        scene.background = null;
        useSolidColor = true;
      }
    } else {
      backgroundMaterial.color.copy(_clearColor);
      useSolidColor = true;
    }
    for (let i2 = 0; i2 < 6; i2++) {
      const col = i2 % 3;
      if (col === 0) {
        cubeCamera.up.set(0, upSign[i2], 0);
        cubeCamera.lookAt(forwardSign[i2], 0, 0);
      } else if (col === 1) {
        cubeCamera.up.set(0, 0, upSign[i2]);
        cubeCamera.lookAt(0, forwardSign[i2], 0);
      } else {
        cubeCamera.up.set(0, upSign[i2], 0);
        cubeCamera.lookAt(0, 0, forwardSign[i2]);
      }
      const size = this._cubeSize;
      _setViewport(cubeUVRenderTarget, col * size, i2 > 2 ? size : 0, size, size);
      renderer.setRenderTarget(cubeUVRenderTarget);
      if (useSolidColor) {
        renderer.render(backgroundBox, cubeCamera);
      }
      renderer.render(scene, cubeCamera);
    }
    backgroundBox.geometry.dispose();
    backgroundBox.material.dispose();
    renderer.toneMapping = toneMapping;
    renderer.autoClear = originalAutoClear;
    scene.background = background;
  }
  _textureToCubeUV(texture, cubeUVRenderTarget) {
    const renderer = this._renderer;
    const isCubeTexture = texture.mapping === CubeReflectionMapping || texture.mapping === CubeRefractionMapping;
    if (isCubeTexture) {
      if (this._cubemapMaterial === null) {
        this._cubemapMaterial = _getCubemapMaterial();
      }
      this._cubemapMaterial.uniforms.flipEnvMap.value = texture.isRenderTargetTexture === false ? -1 : 1;
    } else {
      if (this._equirectMaterial === null) {
        this._equirectMaterial = _getEquirectMaterial();
      }
    }
    const material = isCubeTexture ? this._cubemapMaterial : this._equirectMaterial;
    const mesh = new Mesh(this._lodPlanes[0], material);
    const uniforms = material.uniforms;
    uniforms["envMap"].value = texture;
    const size = this._cubeSize;
    _setViewport(cubeUVRenderTarget, 0, 0, 3 * size, 2 * size);
    renderer.setRenderTarget(cubeUVRenderTarget);
    renderer.render(mesh, _flatCamera);
  }
  _applyPMREM(cubeUVRenderTarget) {
    const renderer = this._renderer;
    const autoClear = renderer.autoClear;
    renderer.autoClear = false;
    for (let i2 = 1; i2 < this._lodPlanes.length; i2++) {
      const sigma = Math.sqrt(this._sigmas[i2] * this._sigmas[i2] - this._sigmas[i2 - 1] * this._sigmas[i2 - 1]);
      const poleAxis = _axisDirections[(i2 - 1) % _axisDirections.length];
      this._blur(cubeUVRenderTarget, i2 - 1, i2, sigma, poleAxis);
    }
    renderer.autoClear = autoClear;
  }
  _blur(cubeUVRenderTarget, lodIn, lodOut, sigma, poleAxis) {
    const pingPongRenderTarget = this._pingPongRenderTarget;
    this._halfBlur(
      cubeUVRenderTarget,
      pingPongRenderTarget,
      lodIn,
      lodOut,
      sigma,
      "latitudinal",
      poleAxis
    );
    this._halfBlur(
      pingPongRenderTarget,
      cubeUVRenderTarget,
      lodOut,
      lodOut,
      sigma,
      "longitudinal",
      poleAxis
    );
  }
  _halfBlur(targetIn, targetOut, lodIn, lodOut, sigmaRadians, direction, poleAxis) {
    const renderer = this._renderer;
    const blurMaterial = this._blurMaterial;
    if (direction !== "latitudinal" && direction !== "longitudinal") {
      console.error(
        "blur direction must be either latitudinal or longitudinal!"
      );
    }
    const STANDARD_DEVIATIONS = 3;
    const blurMesh = new Mesh(this._lodPlanes[lodOut], blurMaterial);
    const blurUniforms = blurMaterial.uniforms;
    const pixels = this._sizeLods[lodIn] - 1;
    const radiansPerPixel = isFinite(sigmaRadians) ? Math.PI / (2 * pixels) : 2 * Math.PI / (2 * MAX_SAMPLES - 1);
    const sigmaPixels = sigmaRadians / radiansPerPixel;
    const samples = isFinite(sigmaRadians) ? 1 + Math.floor(STANDARD_DEVIATIONS * sigmaPixels) : MAX_SAMPLES;
    if (samples > MAX_SAMPLES) {
      console.warn(`sigmaRadians, ${sigmaRadians}, is too large and will clip, as it requested ${samples} samples when the maximum is set to ${MAX_SAMPLES}`);
    }
    const weights = [];
    let sum = 0;
    for (let i2 = 0; i2 < MAX_SAMPLES; ++i2) {
      const x2 = i2 / sigmaPixels;
      const weight = Math.exp(-x2 * x2 / 2);
      weights.push(weight);
      if (i2 === 0) {
        sum += weight;
      } else if (i2 < samples) {
        sum += 2 * weight;
      }
    }
    for (let i2 = 0; i2 < weights.length; i2++) {
      weights[i2] = weights[i2] / sum;
    }
    blurUniforms["envMap"].value = targetIn.texture;
    blurUniforms["samples"].value = samples;
    blurUniforms["weights"].value = weights;
    blurUniforms["latitudinal"].value = direction === "latitudinal";
    if (poleAxis) {
      blurUniforms["poleAxis"].value = poleAxis;
    }
    const { _lodMax } = this;
    blurUniforms["dTheta"].value = radiansPerPixel;
    blurUniforms["mipInt"].value = _lodMax - lodIn;
    const outputSize = this._sizeLods[lodOut];
    const x = 3 * outputSize * (lodOut > _lodMax - LOD_MIN ? lodOut - _lodMax + LOD_MIN : 0);
    const y = 4 * (this._cubeSize - outputSize);
    _setViewport(targetOut, x, y, 3 * outputSize, 2 * outputSize);
    renderer.setRenderTarget(targetOut);
    renderer.render(blurMesh, _flatCamera);
  }
};
function _createPlanes(lodMax) {
  const lodPlanes = [];
  const sizeLods = [];
  const sigmas = [];
  let lod = lodMax;
  const totalLods = lodMax - LOD_MIN + 1 + EXTRA_LOD_SIGMA.length;
  for (let i2 = 0; i2 < totalLods; i2++) {
    const sizeLod = Math.pow(2, lod);
    sizeLods.push(sizeLod);
    let sigma = 1 / sizeLod;
    if (i2 > lodMax - LOD_MIN) {
      sigma = EXTRA_LOD_SIGMA[i2 - lodMax + LOD_MIN - 1];
    } else if (i2 === 0) {
      sigma = 0;
    }
    sigmas.push(sigma);
    const texelSize = 1 / (sizeLod - 2);
    const min = -texelSize;
    const max = 1 + texelSize;
    const uv1 = [min, min, max, min, max, max, min, min, max, max, min, max];
    const cubeFaces = 6;
    const vertices = 6;
    const positionSize = 3;
    const uvSize = 2;
    const faceIndexSize = 1;
    const position = new Float32Array(positionSize * vertices * cubeFaces);
    const uv = new Float32Array(uvSize * vertices * cubeFaces);
    const faceIndex = new Float32Array(faceIndexSize * vertices * cubeFaces);
    for (let face = 0; face < cubeFaces; face++) {
      const x = face % 3 * 2 / 3 - 1;
      const y = face > 2 ? 0 : -1;
      const coordinates = [
        x,
        y,
        0,
        x + 2 / 3,
        y,
        0,
        x + 2 / 3,
        y + 1,
        0,
        x,
        y,
        0,
        x + 2 / 3,
        y + 1,
        0,
        x,
        y + 1,
        0
      ];
      position.set(coordinates, positionSize * vertices * face);
      uv.set(uv1, uvSize * vertices * face);
      const fill = [face, face, face, face, face, face];
      faceIndex.set(fill, faceIndexSize * vertices * face);
    }
    const planes = new BufferGeometry();
    planes.setAttribute("position", new BufferAttribute(position, positionSize));
    planes.setAttribute("uv", new BufferAttribute(uv, uvSize));
    planes.setAttribute("faceIndex", new BufferAttribute(faceIndex, faceIndexSize));
    lodPlanes.push(planes);
    if (lod > LOD_MIN) {
      lod--;
    }
  }
  return { lodPlanes, sizeLods, sigmas };
}
function _createRenderTarget(width, height, params) {
  const cubeUVRenderTarget = new WebGLRenderTarget(width, height, params);
  cubeUVRenderTarget.texture.mapping = CubeUVReflectionMapping;
  cubeUVRenderTarget.texture.name = "PMREM.cubeUv";
  cubeUVRenderTarget.scissorTest = true;
  return cubeUVRenderTarget;
}
function _setViewport(target, x, y, width, height) {
  target.viewport.set(x, y, width, height);
  target.scissor.set(x, y, width, height);
}
function _getBlurShader(lodMax, width, height) {
  const weights = new Float32Array(MAX_SAMPLES);
  const poleAxis = new Vector3(0, 1, 0);
  const shaderMaterial = new ShaderMaterial({
    name: "SphericalGaussianBlur",
    defines: {
      "n": MAX_SAMPLES,
      "CUBEUV_TEXEL_WIDTH": 1 / width,
      "CUBEUV_TEXEL_HEIGHT": 1 / height,
      "CUBEUV_MAX_MIP": `${lodMax}.0`
    },
    uniforms: {
      "envMap": { value: null },
      "samples": { value: 1 },
      "weights": { value: weights },
      "latitudinal": { value: false },
      "dTheta": { value: 0 },
      "mipInt": { value: 0 },
      "poleAxis": { value: poleAxis }
    },
    vertexShader: _getCommonVertexShader(),
    fragmentShader: `

			precision mediump float;
			precision mediump int;

			varying vec3 vOutputDirection;

			uniform sampler2D envMap;
			uniform int samples;
			uniform float weights[ n ];
			uniform bool latitudinal;
			uniform float dTheta;
			uniform float mipInt;
			uniform vec3 poleAxis;

			#define ENVMAP_TYPE_CUBE_UV
			#include <cube_uv_reflection_fragment>

			vec3 getSample( float theta, vec3 axis ) {

				float cosTheta = cos( theta );
				// Rodrigues' axis-angle rotation
				vec3 sampleDirection = vOutputDirection * cosTheta
					+ cross( axis, vOutputDirection ) * sin( theta )
					+ axis * dot( axis, vOutputDirection ) * ( 1.0 - cosTheta );

				return bilinearCubeUV( envMap, sampleDirection, mipInt );

			}

			void main() {

				vec3 axis = latitudinal ? poleAxis : cross( poleAxis, vOutputDirection );

				if ( all( equal( axis, vec3( 0.0 ) ) ) ) {

					axis = vec3( vOutputDirection.z, 0.0, - vOutputDirection.x );

				}

				axis = normalize( axis );

				gl_FragColor = vec4( 0.0, 0.0, 0.0, 1.0 );
				gl_FragColor.rgb += weights[ 0 ] * getSample( 0.0, axis );

				for ( int i = 1; i < n; i++ ) {

					if ( i >= samples ) {

						break;

					}

					float theta = dTheta * float( i );
					gl_FragColor.rgb += weights[ i ] * getSample( -1.0 * theta, axis );
					gl_FragColor.rgb += weights[ i ] * getSample( theta, axis );

				}

			}
		`,
    blending: NoBlending,
    depthTest: false,
    depthWrite: false
  });
  return shaderMaterial;
}
function _getEquirectMaterial() {
  return new ShaderMaterial({
    name: "EquirectangularToCubeUV",
    uniforms: {
      "envMap": { value: null }
    },
    vertexShader: _getCommonVertexShader(),
    fragmentShader: `

			precision mediump float;
			precision mediump int;

			varying vec3 vOutputDirection;

			uniform sampler2D envMap;

			#include <common>

			void main() {

				vec3 outputDirection = normalize( vOutputDirection );
				vec2 uv = equirectUv( outputDirection );

				gl_FragColor = vec4( texture2D ( envMap, uv ).rgb, 1.0 );

			}
		`,
    blending: NoBlending,
    depthTest: false,
    depthWrite: false
  });
}
function _getCubemapMaterial() {
  return new ShaderMaterial({
    name: "CubemapToCubeUV",
    uniforms: {
      "envMap": { value: null },
      "flipEnvMap": { value: -1 }
    },
    vertexShader: _getCommonVertexShader(),
    fragmentShader: `

			precision mediump float;
			precision mediump int;

			uniform float flipEnvMap;

			varying vec3 vOutputDirection;

			uniform samplerCube envMap;

			void main() {

				gl_FragColor = textureCube( envMap, vec3( flipEnvMap * vOutputDirection.x, vOutputDirection.yz ) );

			}
		`,
    blending: NoBlending,
    depthTest: false,
    depthWrite: false
  });
}
function _getCommonVertexShader() {
  return `

		precision mediump float;
		precision mediump int;

		attribute float faceIndex;

		varying vec3 vOutputDirection;

		// RH coordinate system; PMREM face-indexing convention
		vec3 getDirection( vec2 uv, float face ) {

			uv = 2.0 * uv - 1.0;

			vec3 direction = vec3( uv, 1.0 );

			if ( face == 0.0 ) {

				direction = direction.zyx; // ( 1, v, u ) pos x

			} else if ( face == 1.0 ) {

				direction = direction.xzy;
				direction.xz *= -1.0; // ( -u, 1, -v ) pos y

			} else if ( face == 2.0 ) {

				direction.x *= -1.0; // ( -u, v, 1 ) pos z

			} else if ( face == 3.0 ) {

				direction = direction.zyx;
				direction.xz *= -1.0; // ( -1, v, -u ) neg x

			} else if ( face == 4.0 ) {

				direction = direction.xzy;
				direction.xy *= -1.0; // ( -u, -1, v ) neg y

			} else if ( face == 5.0 ) {

				direction.z *= -1.0; // ( u, v, -1 ) neg z

			}

			return direction;

		}

		void main() {

			vOutputDirection = getDirection( uv, faceIndex );
			gl_Position = vec4( position, 1.0 );

		}
	`;
}
function WebGLCubeUVMaps(renderer) {
  let cubeUVmaps = /* @__PURE__ */ new WeakMap();
  let pmremGenerator = null;
  function get(texture) {
    if (texture && texture.isTexture) {
      const mapping = texture.mapping;
      const isEquirectMap = mapping === EquirectangularReflectionMapping || mapping === EquirectangularRefractionMapping;
      const isCubeMap = mapping === CubeReflectionMapping || mapping === CubeRefractionMapping;
      if (isEquirectMap || isCubeMap) {
        if (texture.isRenderTargetTexture && texture.needsPMREMUpdate === true) {
          texture.needsPMREMUpdate = false;
          let renderTarget = cubeUVmaps.get(texture);
          if (pmremGenerator === null)
            pmremGenerator = new PMREMGenerator(renderer);
          renderTarget = isEquirectMap ? pmremGenerator.fromEquirectangular(texture, renderTarget) : pmremGenerator.fromCubemap(texture, renderTarget);
          cubeUVmaps.set(texture, renderTarget);
          return renderTarget.texture;
        } else {
          if (cubeUVmaps.has(texture)) {
            return cubeUVmaps.get(texture).texture;
          } else {
            const image = texture.image;
            if (isEquirectMap && image && image.height > 0 || isCubeMap && image && isCubeTextureComplete(image)) {
              if (pmremGenerator === null)
                pmremGenerator = new PMREMGenerator(renderer);
              const renderTarget = isEquirectMap ? pmremGenerator.fromEquirectangular(texture) : pmremGenerator.fromCubemap(texture);
              cubeUVmaps.set(texture, renderTarget);
              texture.addEventListener("dispose", onTextureDispose);
              return renderTarget.texture;
            } else {
              return null;
            }
          }
        }
      }
    }
    return texture;
  }
  function isCubeTextureComplete(image) {
    let count = 0;
    const length = 6;
    for (let i2 = 0; i2 < length; i2++) {
      if (image[i2] !== void 0)
        count++;
    }
    return count === length;
  }
  function onTextureDispose(event) {
    const texture = event.target;
    texture.removeEventListener("dispose", onTextureDispose);
    const cubemapUV = cubeUVmaps.get(texture);
    if (cubemapUV !== void 0) {
      cubeUVmaps.delete(texture);
      cubemapUV.dispose();
    }
  }
  function dispose() {
    cubeUVmaps = /* @__PURE__ */ new WeakMap();
    if (pmremGenerator !== null) {
      pmremGenerator.dispose();
      pmremGenerator = null;
    }
  }
  return {
    get,
    dispose
  };
}
function WebGLExtensions(gl) {
  const extensions = {};
  function getExtension(name) {
    if (extensions[name] !== void 0) {
      return extensions[name];
    }
    let extension;
    switch (name) {
      case "WEBGL_depth_texture":
        extension = gl.getExtension("WEBGL_depth_texture") || gl.getExtension("MOZ_WEBGL_depth_texture") || gl.getExtension("WEBKIT_WEBGL_depth_texture");
        break;
      case "EXT_texture_filter_anisotropic":
        extension = gl.getExtension("EXT_texture_filter_anisotropic") || gl.getExtension("MOZ_EXT_texture_filter_anisotropic") || gl.getExtension("WEBKIT_EXT_texture_filter_anisotropic");
        break;
      case "WEBGL_compressed_texture_s3tc":
        extension = gl.getExtension("WEBGL_compressed_texture_s3tc") || gl.getExtension("MOZ_WEBGL_compressed_texture_s3tc") || gl.getExtension("WEBKIT_WEBGL_compressed_texture_s3tc");
        break;
      case "WEBGL_compressed_texture_pvrtc":
        extension = gl.getExtension("WEBGL_compressed_texture_pvrtc") || gl.getExtension("WEBKIT_WEBGL_compressed_texture_pvrtc");
        break;
      default:
        extension = gl.getExtension(name);
    }
    extensions[name] = extension;
    return extension;
  }
  return {
    has: function(name) {
      return getExtension(name) !== null;
    },
    init: function(capabilities) {
      if (capabilities.isWebGL2) {
        getExtension("EXT_color_buffer_float");
      } else {
        getExtension("WEBGL_depth_texture");
        getExtension("OES_texture_float");
        getExtension("OES_texture_half_float");
        getExtension("OES_texture_half_float_linear");
        getExtension("OES_standard_derivatives");
        getExtension("OES_element_index_uint");
        getExtension("OES_vertex_array_object");
        getExtension("ANGLE_instanced_arrays");
      }
      getExtension("OES_texture_float_linear");
      getExtension("EXT_color_buffer_half_float");
      getExtension("WEBGL_multisampled_render_to_texture");
    },
    get: function(name) {
      const extension = getExtension(name);
      if (extension === null) {
        console.warn("THREE.WebGLRenderer: " + name + " extension not supported.");
      }
      return extension;
    }
  };
}
function WebGLGeometries(gl, attributes, info, bindingStates) {
  const geometries = {};
  const wireframeAttributes = /* @__PURE__ */ new WeakMap();
  function onGeometryDispose(event) {
    const geometry = event.target;
    if (geometry.index !== null) {
      attributes.remove(geometry.index);
    }
    for (const name in geometry.attributes) {
      attributes.remove(geometry.attributes[name]);
    }
    geometry.removeEventListener("dispose", onGeometryDispose);
    delete geometries[geometry.id];
    const attribute = wireframeAttributes.get(geometry);
    if (attribute) {
      attributes.remove(attribute);
      wireframeAttributes.delete(geometry);
    }
    bindingStates.releaseStatesOfGeometry(geometry);
    if (geometry.isInstancedBufferGeometry === true) {
      delete geometry._maxInstanceCount;
    }
    info.memory.geometries--;
  }
  function get(object, geometry) {
    if (geometries[geometry.id] === true)
      return geometry;
    geometry.addEventListener("dispose", onGeometryDispose);
    geometries[geometry.id] = true;
    info.memory.geometries++;
    return geometry;
  }
  function update(geometry) {
    const geometryAttributes = geometry.attributes;
    for (const name in geometryAttributes) {
      attributes.update(geometryAttributes[name], 34962);
    }
    const morphAttributes = geometry.morphAttributes;
    for (const name in morphAttributes) {
      const array = morphAttributes[name];
      for (let i2 = 0, l = array.length; i2 < l; i2++) {
        attributes.update(array[i2], 34962);
      }
    }
  }
  function updateWireframeAttribute(geometry) {
    const indices = [];
    const geometryIndex = geometry.index;
    const geometryPosition = geometry.attributes.position;
    let version = 0;
    if (geometryIndex !== null) {
      const array = geometryIndex.array;
      version = geometryIndex.version;
      for (let i2 = 0, l = array.length; i2 < l; i2 += 3) {
        const a = array[i2 + 0];
        const b = array[i2 + 1];
        const c = array[i2 + 2];
        indices.push(a, b, b, c, c, a);
      }
    } else {
      const array = geometryPosition.array;
      version = geometryPosition.version;
      for (let i2 = 0, l = array.length / 3 - 1; i2 < l; i2 += 3) {
        const a = i2 + 0;
        const b = i2 + 1;
        const c = i2 + 2;
        indices.push(a, b, b, c, c, a);
      }
    }
    const attribute = new (arrayNeedsUint32(indices) ? Uint32BufferAttribute : Uint16BufferAttribute)(indices, 1);
    attribute.version = version;
    const previousAttribute = wireframeAttributes.get(geometry);
    if (previousAttribute)
      attributes.remove(previousAttribute);
    wireframeAttributes.set(geometry, attribute);
  }
  function getWireframeAttribute(geometry) {
    const currentAttribute = wireframeAttributes.get(geometry);
    if (currentAttribute) {
      const geometryIndex = geometry.index;
      if (geometryIndex !== null) {
        if (currentAttribute.version < geometryIndex.version) {
          updateWireframeAttribute(geometry);
        }
      }
    } else {
      updateWireframeAttribute(geometry);
    }
    return wireframeAttributes.get(geometry);
  }
  return {
    get,
    update,
    getWireframeAttribute
  };
}
function WebGLIndexedBufferRenderer(gl, extensions, info, capabilities) {
  const isWebGL2 = capabilities.isWebGL2;
  let mode;
  function setMode(value) {
    mode = value;
  }
  let type, bytesPerElement;
  function setIndex(value) {
    type = value.type;
    bytesPerElement = value.bytesPerElement;
  }
  function render(start, count) {
    gl.drawElements(mode, count, type, start * bytesPerElement);
    info.update(count, mode, 1);
  }
  function renderInstances(start, count, primcount) {
    if (primcount === 0)
      return;
    let extension, methodName;
    if (isWebGL2) {
      extension = gl;
      methodName = "drawElementsInstanced";
    } else {
      extension = extensions.get("ANGLE_instanced_arrays");
      methodName = "drawElementsInstancedANGLE";
      if (extension === null) {
        console.error("THREE.WebGLIndexedBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.");
        return;
      }
    }
    extension[methodName](mode, count, type, start * bytesPerElement, primcount);
    info.update(count, mode, primcount);
  }
  this.setMode = setMode;
  this.setIndex = setIndex;
  this.render = render;
  this.renderInstances = renderInstances;
}
function WebGLInfo(gl) {
  const memory = {
    geometries: 0,
    textures: 0
  };
  const render = {
    frame: 0,
    calls: 0,
    triangles: 0,
    points: 0,
    lines: 0
  };
  function update(count, mode, instanceCount) {
    render.calls++;
    switch (mode) {
      case 4:
        render.triangles += instanceCount * (count / 3);
        break;
      case 1:
        render.lines += instanceCount * (count / 2);
        break;
      case 3:
        render.lines += instanceCount * (count - 1);
        break;
      case 2:
        render.lines += instanceCount * count;
        break;
      case 0:
        render.points += instanceCount * count;
        break;
      default:
        console.error("THREE.WebGLInfo: Unknown draw mode:", mode);
        break;
    }
  }
  function reset() {
    render.frame++;
    render.calls = 0;
    render.triangles = 0;
    render.points = 0;
    render.lines = 0;
  }
  return {
    memory,
    render,
    programs: null,
    autoReset: true,
    reset,
    update
  };
}
function numericalSort(a, b) {
  return a[0] - b[0];
}
function absNumericalSort(a, b) {
  return Math.abs(b[1]) - Math.abs(a[1]);
}
function denormalize(morph, attribute) {
  let denominator = 1;
  const array = attribute.isInterleavedBufferAttribute ? attribute.data.array : attribute.array;
  if (array instanceof Int8Array)
    denominator = 127;
  else if (array instanceof Uint8Array)
    denominator = 255;
  else if (array instanceof Uint16Array)
    denominator = 65535;
  else if (array instanceof Int16Array)
    denominator = 32767;
  else if (array instanceof Int32Array)
    denominator = 2147483647;
  else
    console.error("THREE.WebGLMorphtargets: Unsupported morph attribute data type: ", array);
  morph.divideScalar(denominator);
}
function WebGLMorphtargets(gl, capabilities, textures) {
  const influencesList = {};
  const morphInfluences = new Float32Array(8);
  const morphTextures = /* @__PURE__ */ new WeakMap();
  const morph = new Vector4();
  const workInfluences = [];
  for (let i2 = 0; i2 < 8; i2++) {
    workInfluences[i2] = [i2, 0];
  }
  function update(object, geometry, material, program) {
    const objectInfluences = object.morphTargetInfluences;
    if (capabilities.isWebGL2 === true) {
      const morphAttribute = geometry.morphAttributes.position || geometry.morphAttributes.normal || geometry.morphAttributes.color;
      const morphTargetsCount = morphAttribute !== void 0 ? morphAttribute.length : 0;
      let entry = morphTextures.get(geometry);
      if (entry === void 0 || entry.count !== morphTargetsCount) {
        let disposeTexture = function() {
          texture.dispose();
          morphTextures.delete(geometry);
          geometry.removeEventListener("dispose", disposeTexture);
        };
        if (entry !== void 0)
          entry.texture.dispose();
        const hasMorphPosition = geometry.morphAttributes.position !== void 0;
        const hasMorphNormals = geometry.morphAttributes.normal !== void 0;
        const hasMorphColors = geometry.morphAttributes.color !== void 0;
        const morphTargets = geometry.morphAttributes.position || [];
        const morphNormals = geometry.morphAttributes.normal || [];
        const morphColors = geometry.morphAttributes.color || [];
        let vertexDataCount = 0;
        if (hasMorphPosition === true)
          vertexDataCount = 1;
        if (hasMorphNormals === true)
          vertexDataCount = 2;
        if (hasMorphColors === true)
          vertexDataCount = 3;
        let width = geometry.attributes.position.count * vertexDataCount;
        let height = 1;
        if (width > capabilities.maxTextureSize) {
          height = Math.ceil(width / capabilities.maxTextureSize);
          width = capabilities.maxTextureSize;
        }
        const buffer = new Float32Array(width * height * 4 * morphTargetsCount);
        const texture = new DataArrayTexture(buffer, width, height, morphTargetsCount);
        texture.type = FloatType;
        texture.needsUpdate = true;
        const vertexDataStride = vertexDataCount * 4;
        for (let i2 = 0; i2 < morphTargetsCount; i2++) {
          const morphTarget = morphTargets[i2];
          const morphNormal = morphNormals[i2];
          const morphColor = morphColors[i2];
          const offset = width * height * 4 * i2;
          for (let j = 0; j < morphTarget.count; j++) {
            const stride = j * vertexDataStride;
            if (hasMorphPosition === true) {
              morph.fromBufferAttribute(morphTarget, j);
              if (morphTarget.normalized === true)
                denormalize(morph, morphTarget);
              buffer[offset + stride + 0] = morph.x;
              buffer[offset + stride + 1] = morph.y;
              buffer[offset + stride + 2] = morph.z;
              buffer[offset + stride + 3] = 0;
            }
            if (hasMorphNormals === true) {
              morph.fromBufferAttribute(morphNormal, j);
              if (morphNormal.normalized === true)
                denormalize(morph, morphNormal);
              buffer[offset + stride + 4] = morph.x;
              buffer[offset + stride + 5] = morph.y;
              buffer[offset + stride + 6] = morph.z;
              buffer[offset + stride + 7] = 0;
            }
            if (hasMorphColors === true) {
              morph.fromBufferAttribute(morphColor, j);
              if (morphColor.normalized === true)
                denormalize(morph, morphColor);
              buffer[offset + stride + 8] = morph.x;
              buffer[offset + stride + 9] = morph.y;
              buffer[offset + stride + 10] = morph.z;
              buffer[offset + stride + 11] = morphColor.itemSize === 4 ? morph.w : 1;
            }
          }
        }
        entry = {
          count: morphTargetsCount,
          texture,
          size: new Vector2(width, height)
        };
        morphTextures.set(geometry, entry);
        geometry.addEventListener("dispose", disposeTexture);
      }
      let morphInfluencesSum = 0;
      for (let i2 = 0; i2 < objectInfluences.length; i2++) {
        morphInfluencesSum += objectInfluences[i2];
      }
      const morphBaseInfluence = geometry.morphTargetsRelative ? 1 : 1 - morphInfluencesSum;
      program.getUniforms().setValue(gl, "morphTargetBaseInfluence", morphBaseInfluence);
      program.getUniforms().setValue(gl, "morphTargetInfluences", objectInfluences);
      program.getUniforms().setValue(gl, "morphTargetsTexture", entry.texture, textures);
      program.getUniforms().setValue(gl, "morphTargetsTextureSize", entry.size);
    } else {
      const length = objectInfluences === void 0 ? 0 : objectInfluences.length;
      let influences = influencesList[geometry.id];
      if (influences === void 0 || influences.length !== length) {
        influences = [];
        for (let i2 = 0; i2 < length; i2++) {
          influences[i2] = [i2, 0];
        }
        influencesList[geometry.id] = influences;
      }
      for (let i2 = 0; i2 < length; i2++) {
        const influence = influences[i2];
        influence[0] = i2;
        influence[1] = objectInfluences[i2];
      }
      influences.sort(absNumericalSort);
      for (let i2 = 0; i2 < 8; i2++) {
        if (i2 < length && influences[i2][1]) {
          workInfluences[i2][0] = influences[i2][0];
          workInfluences[i2][1] = influences[i2][1];
        } else {
          workInfluences[i2][0] = Number.MAX_SAFE_INTEGER;
          workInfluences[i2][1] = 0;
        }
      }
      workInfluences.sort(numericalSort);
      const morphTargets = geometry.morphAttributes.position;
      const morphNormals = geometry.morphAttributes.normal;
      let morphInfluencesSum = 0;
      for (let i2 = 0; i2 < 8; i2++) {
        const influence = workInfluences[i2];
        const index = influence[0];
        const value = influence[1];
        if (index !== Number.MAX_SAFE_INTEGER && value) {
          if (morphTargets && geometry.getAttribute("morphTarget" + i2) !== morphTargets[index]) {
            geometry.setAttribute("morphTarget" + i2, morphTargets[index]);
          }
          if (morphNormals && geometry.getAttribute("morphNormal" + i2) !== morphNormals[index]) {
            geometry.setAttribute("morphNormal" + i2, morphNormals[index]);
          }
          morphInfluences[i2] = value;
          morphInfluencesSum += value;
        } else {
          if (morphTargets && geometry.hasAttribute("morphTarget" + i2) === true) {
            geometry.deleteAttribute("morphTarget" + i2);
          }
          if (morphNormals && geometry.hasAttribute("morphNormal" + i2) === true) {
            geometry.deleteAttribute("morphNormal" + i2);
          }
          morphInfluences[i2] = 0;
        }
      }
      const morphBaseInfluence = geometry.morphTargetsRelative ? 1 : 1 - morphInfluencesSum;
      program.getUniforms().setValue(gl, "morphTargetBaseInfluence", morphBaseInfluence);
      program.getUniforms().setValue(gl, "morphTargetInfluences", morphInfluences);
    }
  }
  return {
    update
  };
}
function WebGLObjects(gl, geometries, attributes, info) {
  let updateMap = /* @__PURE__ */ new WeakMap();
  function update(object) {
    const frame = info.render.frame;
    const geometry = object.geometry;
    const buffergeometry = geometries.get(object, geometry);
    if (updateMap.get(buffergeometry) !== frame) {
      geometries.update(buffergeometry);
      updateMap.set(buffergeometry, frame);
    }
    if (object.isInstancedMesh) {
      if (object.hasEventListener("dispose", onInstancedMeshDispose) === false) {
        object.addEventListener("dispose", onInstancedMeshDispose);
      }
      attributes.update(object.instanceMatrix, 34962);
      if (object.instanceColor !== null) {
        attributes.update(object.instanceColor, 34962);
      }
    }
    return buffergeometry;
  }
  function dispose() {
    updateMap = /* @__PURE__ */ new WeakMap();
  }
  function onInstancedMeshDispose(event) {
    const instancedMesh = event.target;
    instancedMesh.removeEventListener("dispose", onInstancedMeshDispose);
    attributes.remove(instancedMesh.instanceMatrix);
    if (instancedMesh.instanceColor !== null)
      attributes.remove(instancedMesh.instanceColor);
  }
  return {
    update,
    dispose
  };
}
var emptyTexture = /* @__PURE__ */ new Texture();
var emptyArrayTexture = /* @__PURE__ */ new DataArrayTexture();
var empty3dTexture = /* @__PURE__ */ new Data3DTexture();
var emptyCubeTexture = /* @__PURE__ */ new CubeTexture();
var arrayCacheF32 = [];
var arrayCacheI32 = [];
var mat4array = new Float32Array(16);
var mat3array = new Float32Array(9);
var mat2array = new Float32Array(4);
function flatten(array, nBlocks, blockSize) {
  const firstElem = array[0];
  if (firstElem <= 0 || firstElem > 0)
    return array;
  const n = nBlocks * blockSize;
  let r = arrayCacheF32[n];
  if (r === void 0) {
    r = new Float32Array(n);
    arrayCacheF32[n] = r;
  }
  if (nBlocks !== 0) {
    firstElem.toArray(r, 0);
    for (let i2 = 1, offset = 0; i2 !== nBlocks; ++i2) {
      offset += blockSize;
      array[i2].toArray(r, offset);
    }
  }
  return r;
}
function arraysEqual(a, b) {
  if (a.length !== b.length)
    return false;
  for (let i2 = 0, l = a.length; i2 < l; i2++) {
    if (a[i2] !== b[i2])
      return false;
  }
  return true;
}
function copyArray(a, b) {
  for (let i2 = 0, l = b.length; i2 < l; i2++) {
    a[i2] = b[i2];
  }
}
function allocTexUnits(textures, n) {
  let r = arrayCacheI32[n];
  if (r === void 0) {
    r = new Int32Array(n);
    arrayCacheI32[n] = r;
  }
  for (let i2 = 0; i2 !== n; ++i2) {
    r[i2] = textures.allocateTextureUnit();
  }
  return r;
}
function setValueV1f(gl, v) {
  const cache = this.cache;
  if (cache[0] === v)
    return;
  gl.uniform1f(this.addr, v);
  cache[0] = v;
}
function setValueV2f(gl, v) {
  const cache = this.cache;
  if (v.x !== void 0) {
    if (cache[0] !== v.x || cache[1] !== v.y) {
      gl.uniform2f(this.addr, v.x, v.y);
      cache[0] = v.x;
      cache[1] = v.y;
    }
  } else {
    if (arraysEqual(cache, v))
      return;
    gl.uniform2fv(this.addr, v);
    copyArray(cache, v);
  }
}
function setValueV3f(gl, v) {
  const cache = this.cache;
  if (v.x !== void 0) {
    if (cache[0] !== v.x || cache[1] !== v.y || cache[2] !== v.z) {
      gl.uniform3f(this.addr, v.x, v.y, v.z);
      cache[0] = v.x;
      cache[1] = v.y;
      cache[2] = v.z;
    }
  } else if (v.r !== void 0) {
    if (cache[0] !== v.r || cache[1] !== v.g || cache[2] !== v.b) {
      gl.uniform3f(this.addr, v.r, v.g, v.b);
      cache[0] = v.r;
      cache[1] = v.g;
      cache[2] = v.b;
    }
  } else {
    if (arraysEqual(cache, v))
      return;
    gl.uniform3fv(this.addr, v);
    copyArray(cache, v);
  }
}
function setValueV4f(gl, v) {
  const cache = this.cache;
  if (v.x !== void 0) {
    if (cache[0] !== v.x || cache[1] !== v.y || cache[2] !== v.z || cache[3] !== v.w) {
      gl.uniform4f(this.addr, v.x, v.y, v.z, v.w);
      cache[0] = v.x;
      cache[1] = v.y;
      cache[2] = v.z;
      cache[3] = v.w;
    }
  } else {
    if (arraysEqual(cache, v))
      return;
    gl.uniform4fv(this.addr, v);
    copyArray(cache, v);
  }
}
function setValueM2(gl, v) {
  const cache = this.cache;
  const elements = v.elements;
  if (elements === void 0) {
    if (arraysEqual(cache, v))
      return;
    gl.uniformMatrix2fv(this.addr, false, v);
    copyArray(cache, v);
  } else {
    if (arraysEqual(cache, elements))
      return;
    mat2array.set(elements);
    gl.uniformMatrix2fv(this.addr, false, mat2array);
    copyArray(cache, elements);
  }
}
function setValueM3(gl, v) {
  const cache = this.cache;
  const elements = v.elements;
  if (elements === void 0) {
    if (arraysEqual(cache, v))
      return;
    gl.uniformMatrix3fv(this.addr, false, v);
    copyArray(cache, v);
  } else {
    if (arraysEqual(cache, elements))
      return;
    mat3array.set(elements);
    gl.uniformMatrix3fv(this.addr, false, mat3array);
    copyArray(cache, elements);
  }
}
function setValueM4(gl, v) {
  const cache = this.cache;
  const elements = v.elements;
  if (elements === void 0) {
    if (arraysEqual(cache, v))
      return;
    gl.uniformMatrix4fv(this.addr, false, v);
    copyArray(cache, v);
  } else {
    if (arraysEqual(cache, elements))
      return;
    mat4array.set(elements);
    gl.uniformMatrix4fv(this.addr, false, mat4array);
    copyArray(cache, elements);
  }
}
function setValueV1i(gl, v) {
  const cache = this.cache;
  if (cache[0] === v)
    return;
  gl.uniform1i(this.addr, v);
  cache[0] = v;
}
function setValueV2i(gl, v) {
  const cache = this.cache;
  if (arraysEqual(cache, v))
    return;
  gl.uniform2iv(this.addr, v);
  copyArray(cache, v);
}
function setValueV3i(gl, v) {
  const cache = this.cache;
  if (arraysEqual(cache, v))
    return;
  gl.uniform3iv(this.addr, v);
  copyArray(cache, v);
}
function setValueV4i(gl, v) {
  const cache = this.cache;
  if (arraysEqual(cache, v))
    return;
  gl.uniform4iv(this.addr, v);
  copyArray(cache, v);
}
function setValueV1ui(gl, v) {
  const cache = this.cache;
  if (cache[0] === v)
    return;
  gl.uniform1ui(this.addr, v);
  cache[0] = v;
}
function setValueV2ui(gl, v) {
  const cache = this.cache;
  if (arraysEqual(cache, v))
    return;
  gl.uniform2uiv(this.addr, v);
  copyArray(cache, v);
}
function setValueV3ui(gl, v) {
  const cache = this.cache;
  if (arraysEqual(cache, v))
    return;
  gl.uniform3uiv(this.addr, v);
  copyArray(cache, v);
}
function setValueV4ui(gl, v) {
  const cache = this.cache;
  if (arraysEqual(cache, v))
    return;
  gl.uniform4uiv(this.addr, v);
  copyArray(cache, v);
}
function setValueT1(gl, v, textures) {
  const cache = this.cache;
  const unit = textures.allocateTextureUnit();
  if (cache[0] !== unit) {
    gl.uniform1i(this.addr, unit);
    cache[0] = unit;
  }
  textures.setTexture2D(v || emptyTexture, unit);
}
function setValueT3D1(gl, v, textures) {
  const cache = this.cache;
  const unit = textures.allocateTextureUnit();
  if (cache[0] !== unit) {
    gl.uniform1i(this.addr, unit);
    cache[0] = unit;
  }
  textures.setTexture3D(v || empty3dTexture, unit);
}
function setValueT6(gl, v, textures) {
  const cache = this.cache;
  const unit = textures.allocateTextureUnit();
  if (cache[0] !== unit) {
    gl.uniform1i(this.addr, unit);
    cache[0] = unit;
  }
  textures.setTextureCube(v || emptyCubeTexture, unit);
}
function setValueT2DArray1(gl, v, textures) {
  const cache = this.cache;
  const unit = textures.allocateTextureUnit();
  if (cache[0] !== unit) {
    gl.uniform1i(this.addr, unit);
    cache[0] = unit;
  }
  textures.setTexture2DArray(v || emptyArrayTexture, unit);
}
function getSingularSetter(type) {
  switch (type) {
    case 5126:
      return setValueV1f;
    case 35664:
      return setValueV2f;
    case 35665:
      return setValueV3f;
    case 35666:
      return setValueV4f;
    case 35674:
      return setValueM2;
    case 35675:
      return setValueM3;
    case 35676:
      return setValueM4;
    case 5124:
    case 35670:
      return setValueV1i;
    case 35667:
    case 35671:
      return setValueV2i;
    case 35668:
    case 35672:
      return setValueV3i;
    case 35669:
    case 35673:
      return setValueV4i;
    case 5125:
      return setValueV1ui;
    case 36294:
      return setValueV2ui;
    case 36295:
      return setValueV3ui;
    case 36296:
      return setValueV4ui;
    case 35678:
    case 36198:
    case 36298:
    case 36306:
    case 35682:
      return setValueT1;
    case 35679:
    case 36299:
    case 36307:
      return setValueT3D1;
    case 35680:
    case 36300:
    case 36308:
    case 36293:
      return setValueT6;
    case 36289:
    case 36303:
    case 36311:
    case 36292:
      return setValueT2DArray1;
  }
}
function setValueV1fArray(gl, v) {
  gl.uniform1fv(this.addr, v);
}
function setValueV2fArray(gl, v) {
  const data = flatten(v, this.size, 2);
  gl.uniform2fv(this.addr, data);
}
function setValueV3fArray(gl, v) {
  const data = flatten(v, this.size, 3);
  gl.uniform3fv(this.addr, data);
}
function setValueV4fArray(gl, v) {
  const data = flatten(v, this.size, 4);
  gl.uniform4fv(this.addr, data);
}
function setValueM2Array(gl, v) {
  const data = flatten(v, this.size, 4);
  gl.uniformMatrix2fv(this.addr, false, data);
}
function setValueM3Array(gl, v) {
  const data = flatten(v, this.size, 9);
  gl.uniformMatrix3fv(this.addr, false, data);
}
function setValueM4Array(gl, v) {
  const data = flatten(v, this.size, 16);
  gl.uniformMatrix4fv(this.addr, false, data);
}
function setValueV1iArray(gl, v) {
  gl.uniform1iv(this.addr, v);
}
function setValueV2iArray(gl, v) {
  gl.uniform2iv(this.addr, v);
}
function setValueV3iArray(gl, v) {
  gl.uniform3iv(this.addr, v);
}
function setValueV4iArray(gl, v) {
  gl.uniform4iv(this.addr, v);
}
function setValueV1uiArray(gl, v) {
  gl.uniform1uiv(this.addr, v);
}
function setValueV2uiArray(gl, v) {
  gl.uniform2uiv(this.addr, v);
}
function setValueV3uiArray(gl, v) {
  gl.uniform3uiv(this.addr, v);
}
function setValueV4uiArray(gl, v) {
  gl.uniform4uiv(this.addr, v);
}
function setValueT1Array(gl, v, textures) {
  const n = v.length;
  const units = allocTexUnits(textures, n);
  gl.uniform1iv(this.addr, units);
  for (let i2 = 0; i2 !== n; ++i2) {
    textures.setTexture2D(v[i2] || emptyTexture, units[i2]);
  }
}
function setValueT3DArray(gl, v, textures) {
  const n = v.length;
  const units = allocTexUnits(textures, n);
  gl.uniform1iv(this.addr, units);
  for (let i2 = 0; i2 !== n; ++i2) {
    textures.setTexture3D(v[i2] || empty3dTexture, units[i2]);
  }
}
function setValueT6Array(gl, v, textures) {
  const n = v.length;
  const units = allocTexUnits(textures, n);
  gl.uniform1iv(this.addr, units);
  for (let i2 = 0; i2 !== n; ++i2) {
    textures.setTextureCube(v[i2] || emptyCubeTexture, units[i2]);
  }
}
function setValueT2DArrayArray(gl, v, textures) {
  const n = v.length;
  const units = allocTexUnits(textures, n);
  gl.uniform1iv(this.addr, units);
  for (let i2 = 0; i2 !== n; ++i2) {
    textures.setTexture2DArray(v[i2] || emptyArrayTexture, units[i2]);
  }
}
function getPureArraySetter(type) {
  switch (type) {
    case 5126:
      return setValueV1fArray;
    case 35664:
      return setValueV2fArray;
    case 35665:
      return setValueV3fArray;
    case 35666:
      return setValueV4fArray;
    case 35674:
      return setValueM2Array;
    case 35675:
      return setValueM3Array;
    case 35676:
      return setValueM4Array;
    case 5124:
    case 35670:
      return setValueV1iArray;
    case 35667:
    case 35671:
      return setValueV2iArray;
    case 35668:
    case 35672:
      return setValueV3iArray;
    case 35669:
    case 35673:
      return setValueV4iArray;
    case 5125:
      return setValueV1uiArray;
    case 36294:
      return setValueV2uiArray;
    case 36295:
      return setValueV3uiArray;
    case 36296:
      return setValueV4uiArray;
    case 35678:
    case 36198:
    case 36298:
    case 36306:
    case 35682:
      return setValueT1Array;
    case 35679:
    case 36299:
    case 36307:
      return setValueT3DArray;
    case 35680:
    case 36300:
    case 36308:
    case 36293:
      return setValueT6Array;
    case 36289:
    case 36303:
    case 36311:
    case 36292:
      return setValueT2DArrayArray;
  }
}
var SingleUniform = class {
  constructor(id, activeInfo, addr) {
    this.id = id;
    this.addr = addr;
    this.cache = [];
    this.setValue = getSingularSetter(activeInfo.type);
  }
};
var PureArrayUniform = class {
  constructor(id, activeInfo, addr) {
    this.id = id;
    this.addr = addr;
    this.cache = [];
    this.size = activeInfo.size;
    this.setValue = getPureArraySetter(activeInfo.type);
  }
};
var StructuredUniform = class {
  constructor(id) {
    this.id = id;
    this.seq = [];
    this.map = {};
  }
  setValue(gl, value, textures) {
    const seq = this.seq;
    for (let i2 = 0, n = seq.length; i2 !== n; ++i2) {
      const u = seq[i2];
      u.setValue(gl, value[u.id], textures);
    }
  }
};
var RePathPart = /(\w+)(\])?(\[|\.)?/g;
function addUniform(container, uniformObject) {
  container.seq.push(uniformObject);
  container.map[uniformObject.id] = uniformObject;
}
function parseUniform(activeInfo, addr, container) {
  const path = activeInfo.name, pathLength = path.length;
  RePathPart.lastIndex = 0;
  while (true) {
    const match = RePathPart.exec(path), matchEnd = RePathPart.lastIndex;
    let id = match[1];
    const idIsIndex = match[2] === "]", subscript = match[3];
    if (idIsIndex)
      id = id | 0;
    if (subscript === void 0 || subscript === "[" && matchEnd + 2 === pathLength) {
      addUniform(container, subscript === void 0 ? new SingleUniform(id, activeInfo, addr) : new PureArrayUniform(id, activeInfo, addr));
      break;
    } else {
      const map = container.map;
      let next = map[id];
      if (next === void 0) {
        next = new StructuredUniform(id);
        addUniform(container, next);
      }
      container = next;
    }
  }
}
var WebGLUniforms = class {
  constructor(gl, program) {
    this.seq = [];
    this.map = {};
    const n = gl.getProgramParameter(program, 35718);
    for (let i2 = 0; i2 < n; ++i2) {
      const info = gl.getActiveUniform(program, i2), addr = gl.getUniformLocation(program, info.name);
      parseUniform(info, addr, this);
    }
  }
  setValue(gl, name, value, textures) {
    const u = this.map[name];
    if (u !== void 0)
      u.setValue(gl, value, textures);
  }
  setOptional(gl, object, name) {
    const v = object[name];
    if (v !== void 0)
      this.setValue(gl, name, v);
  }
  static upload(gl, seq, values, textures) {
    for (let i2 = 0, n = seq.length; i2 !== n; ++i2) {
      const u = seq[i2], v = values[u.id];
      if (v.needsUpdate !== false) {
        u.setValue(gl, v.value, textures);
      }
    }
  }
  static seqWithValue(seq, values) {
    const r = [];
    for (let i2 = 0, n = seq.length; i2 !== n; ++i2) {
      const u = seq[i2];
      if (u.id in values)
        r.push(u);
    }
    return r;
  }
};
function WebGLShader(gl, type, string) {
  const shader = gl.createShader(type);
  gl.shaderSource(shader, string);
  gl.compileShader(shader);
  return shader;
}
var programIdCount = 0;
function handleSource(string, errorLine) {
  const lines = string.split("\n");
  const lines2 = [];
  const from = Math.max(errorLine - 6, 0);
  const to = Math.min(errorLine + 6, lines.length);
  for (let i2 = from; i2 < to; i2++) {
    const line = i2 + 1;
    lines2.push(`${line === errorLine ? ">" : " "} ${line}: ${lines[i2]}`);
  }
  return lines2.join("\n");
}
function getEncodingComponents(encoding) {
  switch (encoding) {
    case LinearEncoding:
      return ["Linear", "( value )"];
    case sRGBEncoding:
      return ["sRGB", "( value )"];
    default:
      console.warn("THREE.WebGLProgram: Unsupported encoding:", encoding);
      return ["Linear", "( value )"];
  }
}
function getShaderErrors(gl, shader, type) {
  const status = gl.getShaderParameter(shader, 35713);
  const errors = gl.getShaderInfoLog(shader).trim();
  if (status && errors === "")
    return "";
  const errorMatches = /ERROR: 0:(\d+)/.exec(errors);
  if (errorMatches) {
    const errorLine = parseInt(errorMatches[1]);
    return type.toUpperCase() + "\n\n" + errors + "\n\n" + handleSource(gl.getShaderSource(shader), errorLine);
  } else {
    return errors;
  }
}
function getTexelEncodingFunction(functionName, encoding) {
  const components = getEncodingComponents(encoding);
  return "vec4 " + functionName + "( vec4 value ) { return LinearTo" + components[0] + components[1] + "; }";
}
function getToneMappingFunction(functionName, toneMapping) {
  let toneMappingName;
  switch (toneMapping) {
    case LinearToneMapping:
      toneMappingName = "Linear";
      break;
    case ReinhardToneMapping:
      toneMappingName = "Reinhard";
      break;
    case CineonToneMapping:
      toneMappingName = "OptimizedCineon";
      break;
    case ACESFilmicToneMapping:
      toneMappingName = "ACESFilmic";
      break;
    case CustomToneMapping:
      toneMappingName = "Custom";
      break;
    default:
      console.warn("THREE.WebGLProgram: Unsupported toneMapping:", toneMapping);
      toneMappingName = "Linear";
  }
  return "vec3 " + functionName + "( vec3 color ) { return " + toneMappingName + "ToneMapping( color ); }";
}
function generateExtensions(parameters) {
  const chunks = [
    parameters.extensionDerivatives || !!parameters.envMapCubeUVHeight || parameters.bumpMap || parameters.tangentSpaceNormalMap || parameters.clearcoatNormalMap || parameters.flatShading || parameters.shaderID === "physical" ? "#extension GL_OES_standard_derivatives : enable" : "",
    (parameters.extensionFragDepth || parameters.logarithmicDepthBuffer) && parameters.rendererExtensionFragDepth ? "#extension GL_EXT_frag_depth : enable" : "",
    parameters.extensionDrawBuffers && parameters.rendererExtensionDrawBuffers ? "#extension GL_EXT_draw_buffers : require" : "",
    (parameters.extensionShaderTextureLOD || parameters.envMap || parameters.transmission) && parameters.rendererExtensionShaderTextureLod ? "#extension GL_EXT_shader_texture_lod : enable" : ""
  ];
  return chunks.filter(filterEmptyLine).join("\n");
}
function generateDefines(defines) {
  const chunks = [];
  for (const name in defines) {
    const value = defines[name];
    if (value === false)
      continue;
    chunks.push("#define " + name + " " + value);
  }
  return chunks.join("\n");
}
function fetchAttributeLocations(gl, program) {
  const attributes = {};
  const n = gl.getProgramParameter(program, 35721);
  for (let i2 = 0; i2 < n; i2++) {
    const info = gl.getActiveAttrib(program, i2);
    const name = info.name;
    let locationSize = 1;
    if (info.type === 35674)
      locationSize = 2;
    if (info.type === 35675)
      locationSize = 3;
    if (info.type === 35676)
      locationSize = 4;
    attributes[name] = {
      type: info.type,
      location: gl.getAttribLocation(program, name),
      locationSize
    };
  }
  return attributes;
}
function filterEmptyLine(string) {
  return string !== "";
}
function replaceLightNums(string, parameters) {
  return string.replace(/NUM_DIR_LIGHTS/g, parameters.numDirLights).replace(/NUM_SPOT_LIGHTS/g, parameters.numSpotLights).replace(/NUM_RECT_AREA_LIGHTS/g, parameters.numRectAreaLights).replace(/NUM_POINT_LIGHTS/g, parameters.numPointLights).replace(/NUM_HEMI_LIGHTS/g, parameters.numHemiLights).replace(/NUM_DIR_LIGHT_SHADOWS/g, parameters.numDirLightShadows).replace(/NUM_SPOT_LIGHT_SHADOWS/g, parameters.numSpotLightShadows).replace(/NUM_POINT_LIGHT_SHADOWS/g, parameters.numPointLightShadows);
}
function replaceClippingPlaneNums(string, parameters) {
  return string.replace(/NUM_CLIPPING_PLANES/g, parameters.numClippingPlanes).replace(/UNION_CLIPPING_PLANES/g, parameters.numClippingPlanes - parameters.numClipIntersection);
}
var includePattern = /^[ \t]*#include +<([\w\d./]+)>/gm;
function resolveIncludes(string) {
  return string.replace(includePattern, includeReplacer);
}
function includeReplacer(match, include) {
  const string = ShaderChunk[include];
  if (string === void 0) {
    throw new Error("Can not resolve #include <" + include + ">");
  }
  return resolveIncludes(string);
}
var deprecatedUnrollLoopPattern = /#pragma unroll_loop[\s]+?for \( int i \= (\d+)\; i < (\d+)\; i \+\+ \) \{([\s\S]+?)(?=\})\}/g;
var unrollLoopPattern = /#pragma unroll_loop_start\s+for\s*\(\s*int\s+i\s*=\s*(\d+)\s*;\s*i\s*<\s*(\d+)\s*;\s*i\s*\+\+\s*\)\s*{([\s\S]+?)}\s+#pragma unroll_loop_end/g;
function unrollLoops(string) {
  return string.replace(unrollLoopPattern, loopReplacer).replace(deprecatedUnrollLoopPattern, deprecatedLoopReplacer);
}
function deprecatedLoopReplacer(match, start, end, snippet) {
  console.warn("WebGLProgram: #pragma unroll_loop shader syntax is deprecated. Please use #pragma unroll_loop_start syntax instead.");
  return loopReplacer(match, start, end, snippet);
}
function loopReplacer(match, start, end, snippet) {
  let string = "";
  for (let i2 = parseInt(start); i2 < parseInt(end); i2++) {
    string += snippet.replace(/\[\s*i\s*\]/g, "[ " + i2 + " ]").replace(/UNROLLED_LOOP_INDEX/g, i2);
  }
  return string;
}
function generatePrecision(parameters) {
  let precisionstring = "precision " + parameters.precision + " float;\nprecision " + parameters.precision + " int;";
  if (parameters.precision === "highp") {
    precisionstring += "\n#define HIGH_PRECISION";
  } else if (parameters.precision === "mediump") {
    precisionstring += "\n#define MEDIUM_PRECISION";
  } else if (parameters.precision === "lowp") {
    precisionstring += "\n#define LOW_PRECISION";
  }
  return precisionstring;
}
function generateShadowMapTypeDefine(parameters) {
  let shadowMapTypeDefine = "SHADOWMAP_TYPE_BASIC";
  if (parameters.shadowMapType === PCFShadowMap) {
    shadowMapTypeDefine = "SHADOWMAP_TYPE_PCF";
  } else if (parameters.shadowMapType === PCFSoftShadowMap) {
    shadowMapTypeDefine = "SHADOWMAP_TYPE_PCF_SOFT";
  } else if (parameters.shadowMapType === VSMShadowMap) {
    shadowMapTypeDefine = "SHADOWMAP_TYPE_VSM";
  }
  return shadowMapTypeDefine;
}
function generateEnvMapTypeDefine(parameters) {
  let envMapTypeDefine = "ENVMAP_TYPE_CUBE";
  if (parameters.envMap) {
    switch (parameters.envMapMode) {
      case CubeReflectionMapping:
      case CubeRefractionMapping:
        envMapTypeDefine = "ENVMAP_TYPE_CUBE";
        break;
      case CubeUVReflectionMapping:
        envMapTypeDefine = "ENVMAP_TYPE_CUBE_UV";
        break;
    }
  }
  return envMapTypeDefine;
}
function generateEnvMapModeDefine(parameters) {
  let envMapModeDefine = "ENVMAP_MODE_REFLECTION";
  if (parameters.envMap) {
    switch (parameters.envMapMode) {
      case CubeRefractionMapping:
        envMapModeDefine = "ENVMAP_MODE_REFRACTION";
        break;
    }
  }
  return envMapModeDefine;
}
function generateEnvMapBlendingDefine(parameters) {
  let envMapBlendingDefine = "ENVMAP_BLENDING_NONE";
  if (parameters.envMap) {
    switch (parameters.combine) {
      case MultiplyOperation:
        envMapBlendingDefine = "ENVMAP_BLENDING_MULTIPLY";
        break;
      case MixOperation:
        envMapBlendingDefine = "ENVMAP_BLENDING_MIX";
        break;
      case AddOperation:
        envMapBlendingDefine = "ENVMAP_BLENDING_ADD";
        break;
    }
  }
  return envMapBlendingDefine;
}
function generateCubeUVSize(parameters) {
  const imageHeight = parameters.envMapCubeUVHeight;
  if (imageHeight === null)
    return null;
  const maxMip = Math.log2(imageHeight) - 2;
  const texelHeight = 1 / imageHeight;
  const texelWidth = 1 / (3 * Math.max(Math.pow(2, maxMip), 7 * 16));
  return { texelWidth, texelHeight, maxMip };
}
function WebGLProgram(renderer, cacheKey, parameters, bindingStates) {
  const gl = renderer.getContext();
  const defines = parameters.defines;
  let vertexShader = parameters.vertexShader;
  let fragmentShader = parameters.fragmentShader;
  const shadowMapTypeDefine = generateShadowMapTypeDefine(parameters);
  const envMapTypeDefine = generateEnvMapTypeDefine(parameters);
  const envMapModeDefine = generateEnvMapModeDefine(parameters);
  const envMapBlendingDefine = generateEnvMapBlendingDefine(parameters);
  const envMapCubeUVSize = generateCubeUVSize(parameters);
  const customExtensions = parameters.isWebGL2 ? "" : generateExtensions(parameters);
  const customDefines = generateDefines(defines);
  const program = gl.createProgram();
  let prefixVertex, prefixFragment;
  let versionString = parameters.glslVersion ? "#version " + parameters.glslVersion + "\n" : "";
  if (parameters.isRawShaderMaterial) {
    prefixVertex = [
      customDefines
    ].filter(filterEmptyLine).join("\n");
    if (prefixVertex.length > 0) {
      prefixVertex += "\n";
    }
    prefixFragment = [
      customExtensions,
      customDefines
    ].filter(filterEmptyLine).join("\n");
    if (prefixFragment.length > 0) {
      prefixFragment += "\n";
    }
  } else {
    prefixVertex = [
      generatePrecision(parameters),
      "#define SHADER_NAME " + parameters.shaderName,
      customDefines,
      parameters.instancing ? "#define USE_INSTANCING" : "",
      parameters.instancingColor ? "#define USE_INSTANCING_COLOR" : "",
      parameters.supportsVertexTextures ? "#define VERTEX_TEXTURES" : "",
      parameters.useFog && parameters.fog ? "#define USE_FOG" : "",
      parameters.useFog && parameters.fogExp2 ? "#define FOG_EXP2" : "",
      parameters.map ? "#define USE_MAP" : "",
      parameters.envMap ? "#define USE_ENVMAP" : "",
      parameters.envMap ? "#define " + envMapModeDefine : "",
      parameters.lightMap ? "#define USE_LIGHTMAP" : "",
      parameters.aoMap ? "#define USE_AOMAP" : "",
      parameters.emissiveMap ? "#define USE_EMISSIVEMAP" : "",
      parameters.bumpMap ? "#define USE_BUMPMAP" : "",
      parameters.normalMap ? "#define USE_NORMALMAP" : "",
      parameters.normalMap && parameters.objectSpaceNormalMap ? "#define OBJECTSPACE_NORMALMAP" : "",
      parameters.normalMap && parameters.tangentSpaceNormalMap ? "#define TANGENTSPACE_NORMALMAP" : "",
      parameters.clearcoatMap ? "#define USE_CLEARCOATMAP" : "",
      parameters.clearcoatRoughnessMap ? "#define USE_CLEARCOAT_ROUGHNESSMAP" : "",
      parameters.clearcoatNormalMap ? "#define USE_CLEARCOAT_NORMALMAP" : "",
      parameters.iridescenceMap ? "#define USE_IRIDESCENCEMAP" : "",
      parameters.iridescenceThicknessMap ? "#define USE_IRIDESCENCE_THICKNESSMAP" : "",
      parameters.displacementMap && parameters.supportsVertexTextures ? "#define USE_DISPLACEMENTMAP" : "",
      parameters.specularMap ? "#define USE_SPECULARMAP" : "",
      parameters.specularIntensityMap ? "#define USE_SPECULARINTENSITYMAP" : "",
      parameters.specularColorMap ? "#define USE_SPECULARCOLORMAP" : "",
      parameters.roughnessMap ? "#define USE_ROUGHNESSMAP" : "",
      parameters.metalnessMap ? "#define USE_METALNESSMAP" : "",
      parameters.alphaMap ? "#define USE_ALPHAMAP" : "",
      parameters.transmission ? "#define USE_TRANSMISSION" : "",
      parameters.transmissionMap ? "#define USE_TRANSMISSIONMAP" : "",
      parameters.thicknessMap ? "#define USE_THICKNESSMAP" : "",
      parameters.sheenColorMap ? "#define USE_SHEENCOLORMAP" : "",
      parameters.sheenRoughnessMap ? "#define USE_SHEENROUGHNESSMAP" : "",
      parameters.vertexTangents ? "#define USE_TANGENT" : "",
      parameters.vertexColors ? "#define USE_COLOR" : "",
      parameters.vertexAlphas ? "#define USE_COLOR_ALPHA" : "",
      parameters.vertexUvs ? "#define USE_UV" : "",
      parameters.uvsVertexOnly ? "#define UVS_VERTEX_ONLY" : "",
      parameters.flatShading ? "#define FLAT_SHADED" : "",
      parameters.skinning ? "#define USE_SKINNING" : "",
      parameters.morphTargets ? "#define USE_MORPHTARGETS" : "",
      parameters.morphNormals && parameters.flatShading === false ? "#define USE_MORPHNORMALS" : "",
      parameters.morphColors && parameters.isWebGL2 ? "#define USE_MORPHCOLORS" : "",
      parameters.morphTargetsCount > 0 && parameters.isWebGL2 ? "#define MORPHTARGETS_TEXTURE" : "",
      parameters.morphTargetsCount > 0 && parameters.isWebGL2 ? "#define MORPHTARGETS_TEXTURE_STRIDE " + parameters.morphTextureStride : "",
      parameters.morphTargetsCount > 0 && parameters.isWebGL2 ? "#define MORPHTARGETS_COUNT " + parameters.morphTargetsCount : "",
      parameters.doubleSided ? "#define DOUBLE_SIDED" : "",
      parameters.flipSided ? "#define FLIP_SIDED" : "",
      parameters.shadowMapEnabled ? "#define USE_SHADOWMAP" : "",
      parameters.shadowMapEnabled ? "#define " + shadowMapTypeDefine : "",
      parameters.sizeAttenuation ? "#define USE_SIZEATTENUATION" : "",
      parameters.logarithmicDepthBuffer ? "#define USE_LOGDEPTHBUF" : "",
      parameters.logarithmicDepthBuffer && parameters.rendererExtensionFragDepth ? "#define USE_LOGDEPTHBUF_EXT" : "",
      "uniform mat4 modelMatrix;",
      "uniform mat4 modelViewMatrix;",
      "uniform mat4 projectionMatrix;",
      "uniform mat4 viewMatrix;",
      "uniform mat3 normalMatrix;",
      "uniform vec3 cameraPosition;",
      "uniform bool isOrthographic;",
      "#ifdef USE_INSTANCING",
      "	attribute mat4 instanceMatrix;",
      "#endif",
      "#ifdef USE_INSTANCING_COLOR",
      "	attribute vec3 instanceColor;",
      "#endif",
      "attribute vec3 position;",
      "attribute vec3 normal;",
      "attribute vec2 uv;",
      "#ifdef USE_TANGENT",
      "	attribute vec4 tangent;",
      "#endif",
      "#if defined( USE_COLOR_ALPHA )",
      "	attribute vec4 color;",
      "#elif defined( USE_COLOR )",
      "	attribute vec3 color;",
      "#endif",
      "#if ( defined( USE_MORPHTARGETS ) && ! defined( MORPHTARGETS_TEXTURE ) )",
      "	attribute vec3 morphTarget0;",
      "	attribute vec3 morphTarget1;",
      "	attribute vec3 morphTarget2;",
      "	attribute vec3 morphTarget3;",
      "	#ifdef USE_MORPHNORMALS",
      "		attribute vec3 morphNormal0;",
      "		attribute vec3 morphNormal1;",
      "		attribute vec3 morphNormal2;",
      "		attribute vec3 morphNormal3;",
      "	#else",
      "		attribute vec3 morphTarget4;",
      "		attribute vec3 morphTarget5;",
      "		attribute vec3 morphTarget6;",
      "		attribute vec3 morphTarget7;",
      "	#endif",
      "#endif",
      "#ifdef USE_SKINNING",
      "	attribute vec4 skinIndex;",
      "	attribute vec4 skinWeight;",
      "#endif",
      "\n"
    ].filter(filterEmptyLine).join("\n");
    prefixFragment = [
      customExtensions,
      generatePrecision(parameters),
      "#define SHADER_NAME " + parameters.shaderName,
      customDefines,
      parameters.useFog && parameters.fog ? "#define USE_FOG" : "",
      parameters.useFog && parameters.fogExp2 ? "#define FOG_EXP2" : "",
      parameters.map ? "#define USE_MAP" : "",
      parameters.matcap ? "#define USE_MATCAP" : "",
      parameters.envMap ? "#define USE_ENVMAP" : "",
      parameters.envMap ? "#define " + envMapTypeDefine : "",
      parameters.envMap ? "#define " + envMapModeDefine : "",
      parameters.envMap ? "#define " + envMapBlendingDefine : "",
      envMapCubeUVSize ? "#define CUBEUV_TEXEL_WIDTH " + envMapCubeUVSize.texelWidth : "",
      envMapCubeUVSize ? "#define CUBEUV_TEXEL_HEIGHT " + envMapCubeUVSize.texelHeight : "",
      envMapCubeUVSize ? "#define CUBEUV_MAX_MIP " + envMapCubeUVSize.maxMip + ".0" : "",
      parameters.lightMap ? "#define USE_LIGHTMAP" : "",
      parameters.aoMap ? "#define USE_AOMAP" : "",
      parameters.emissiveMap ? "#define USE_EMISSIVEMAP" : "",
      parameters.bumpMap ? "#define USE_BUMPMAP" : "",
      parameters.normalMap ? "#define USE_NORMALMAP" : "",
      parameters.normalMap && parameters.objectSpaceNormalMap ? "#define OBJECTSPACE_NORMALMAP" : "",
      parameters.normalMap && parameters.tangentSpaceNormalMap ? "#define TANGENTSPACE_NORMALMAP" : "",
      parameters.clearcoat ? "#define USE_CLEARCOAT" : "",
      parameters.clearcoatMap ? "#define USE_CLEARCOATMAP" : "",
      parameters.clearcoatRoughnessMap ? "#define USE_CLEARCOAT_ROUGHNESSMAP" : "",
      parameters.clearcoatNormalMap ? "#define USE_CLEARCOAT_NORMALMAP" : "",
      parameters.iridescence ? "#define USE_IRIDESCENCE" : "",
      parameters.iridescenceMap ? "#define USE_IRIDESCENCEMAP" : "",
      parameters.iridescenceThicknessMap ? "#define USE_IRIDESCENCE_THICKNESSMAP" : "",
      parameters.specularMap ? "#define USE_SPECULARMAP" : "",
      parameters.specularIntensityMap ? "#define USE_SPECULARINTENSITYMAP" : "",
      parameters.specularColorMap ? "#define USE_SPECULARCOLORMAP" : "",
      parameters.roughnessMap ? "#define USE_ROUGHNESSMAP" : "",
      parameters.metalnessMap ? "#define USE_METALNESSMAP" : "",
      parameters.alphaMap ? "#define USE_ALPHAMAP" : "",
      parameters.alphaTest ? "#define USE_ALPHATEST" : "",
      parameters.sheen ? "#define USE_SHEEN" : "",
      parameters.sheenColorMap ? "#define USE_SHEENCOLORMAP" : "",
      parameters.sheenRoughnessMap ? "#define USE_SHEENROUGHNESSMAP" : "",
      parameters.transmission ? "#define USE_TRANSMISSION" : "",
      parameters.transmissionMap ? "#define USE_TRANSMISSIONMAP" : "",
      parameters.thicknessMap ? "#define USE_THICKNESSMAP" : "",
      parameters.decodeVideoTexture ? "#define DECODE_VIDEO_TEXTURE" : "",
      parameters.vertexTangents ? "#define USE_TANGENT" : "",
      parameters.vertexColors || parameters.instancingColor ? "#define USE_COLOR" : "",
      parameters.vertexAlphas ? "#define USE_COLOR_ALPHA" : "",
      parameters.vertexUvs ? "#define USE_UV" : "",
      parameters.uvsVertexOnly ? "#define UVS_VERTEX_ONLY" : "",
      parameters.gradientMap ? "#define USE_GRADIENTMAP" : "",
      parameters.flatShading ? "#define FLAT_SHADED" : "",
      parameters.doubleSided ? "#define DOUBLE_SIDED" : "",
      parameters.flipSided ? "#define FLIP_SIDED" : "",
      parameters.shadowMapEnabled ? "#define USE_SHADOWMAP" : "",
      parameters.shadowMapEnabled ? "#define " + shadowMapTypeDefine : "",
      parameters.premultipliedAlpha ? "#define PREMULTIPLIED_ALPHA" : "",
      parameters.physicallyCorrectLights ? "#define PHYSICALLY_CORRECT_LIGHTS" : "",
      parameters.logarithmicDepthBuffer ? "#define USE_LOGDEPTHBUF" : "",
      parameters.logarithmicDepthBuffer && parameters.rendererExtensionFragDepth ? "#define USE_LOGDEPTHBUF_EXT" : "",
      "uniform mat4 viewMatrix;",
      "uniform vec3 cameraPosition;",
      "uniform bool isOrthographic;",
      parameters.toneMapping !== NoToneMapping ? "#define TONE_MAPPING" : "",
      parameters.toneMapping !== NoToneMapping ? ShaderChunk["tonemapping_pars_fragment"] : "",
      parameters.toneMapping !== NoToneMapping ? getToneMappingFunction("toneMapping", parameters.toneMapping) : "",
      parameters.dithering ? "#define DITHERING" : "",
      parameters.opaque ? "#define OPAQUE" : "",
      ShaderChunk["encodings_pars_fragment"],
      getTexelEncodingFunction("linearToOutputTexel", parameters.outputEncoding),
      parameters.useDepthPacking ? "#define DEPTH_PACKING " + parameters.depthPacking : "",
      "\n"
    ].filter(filterEmptyLine).join("\n");
  }
  vertexShader = resolveIncludes(vertexShader);
  vertexShader = replaceLightNums(vertexShader, parameters);
  vertexShader = replaceClippingPlaneNums(vertexShader, parameters);
  fragmentShader = resolveIncludes(fragmentShader);
  fragmentShader = replaceLightNums(fragmentShader, parameters);
  fragmentShader = replaceClippingPlaneNums(fragmentShader, parameters);
  vertexShader = unrollLoops(vertexShader);
  fragmentShader = unrollLoops(fragmentShader);
  if (parameters.isWebGL2 && parameters.isRawShaderMaterial !== true) {
    versionString = "#version 300 es\n";
    prefixVertex = [
      "precision mediump sampler2DArray;",
      "#define attribute in",
      "#define varying out",
      "#define texture2D texture"
    ].join("\n") + "\n" + prefixVertex;
    prefixFragment = [
      "#define varying in",
      parameters.glslVersion === GLSL3 ? "" : "layout(location = 0) out highp vec4 pc_fragColor;",
      parameters.glslVersion === GLSL3 ? "" : "#define gl_FragColor pc_fragColor",
      "#define gl_FragDepthEXT gl_FragDepth",
      "#define texture2D texture",
      "#define textureCube texture",
      "#define texture2DProj textureProj",
      "#define texture2DLodEXT textureLod",
      "#define texture2DProjLodEXT textureProjLod",
      "#define textureCubeLodEXT textureLod",
      "#define texture2DGradEXT textureGrad",
      "#define texture2DProjGradEXT textureProjGrad",
      "#define textureCubeGradEXT textureGrad"
    ].join("\n") + "\n" + prefixFragment;
  }
  const vertexGlsl = versionString + prefixVertex + vertexShader;
  const fragmentGlsl = versionString + prefixFragment + fragmentShader;
  const glVertexShader = WebGLShader(gl, 35633, vertexGlsl);
  const glFragmentShader = WebGLShader(gl, 35632, fragmentGlsl);
  gl.attachShader(program, glVertexShader);
  gl.attachShader(program, glFragmentShader);
  if (parameters.index0AttributeName !== void 0) {
    gl.bindAttribLocation(program, 0, parameters.index0AttributeName);
  } else if (parameters.morphTargets === true) {
    gl.bindAttribLocation(program, 0, "position");
  }
  gl.linkProgram(program);
  if (renderer.debug.checkShaderErrors) {
    const programLog = gl.getProgramInfoLog(program).trim();
    const vertexLog = gl.getShaderInfoLog(glVertexShader).trim();
    const fragmentLog = gl.getShaderInfoLog(glFragmentShader).trim();
    let runnable = true;
    let haveDiagnostics = true;
    if (gl.getProgramParameter(program, 35714) === false) {
      runnable = false;
      const vertexErrors = getShaderErrors(gl, glVertexShader, "vertex");
      const fragmentErrors = getShaderErrors(gl, glFragmentShader, "fragment");
      console.error(
        "THREE.WebGLProgram: Shader Error " + gl.getError() + " - VALIDATE_STATUS " + gl.getProgramParameter(program, 35715) + "\n\nProgram Info Log: " + programLog + "\n" + vertexErrors + "\n" + fragmentErrors
      );
    } else if (programLog !== "") {
      console.warn("THREE.WebGLProgram: Program Info Log:", programLog);
    } else if (vertexLog === "" || fragmentLog === "") {
      haveDiagnostics = false;
    }
    if (haveDiagnostics) {
      this.diagnostics = {
        runnable,
        programLog,
        vertexShader: {
          log: vertexLog,
          prefix: prefixVertex
        },
        fragmentShader: {
          log: fragmentLog,
          prefix: prefixFragment
        }
      };
    }
  }
  gl.deleteShader(glVertexShader);
  gl.deleteShader(glFragmentShader);
  let cachedUniforms;
  this.getUniforms = function() {
    if (cachedUniforms === void 0) {
      cachedUniforms = new WebGLUniforms(gl, program);
    }
    return cachedUniforms;
  };
  let cachedAttributes;
  this.getAttributes = function() {
    if (cachedAttributes === void 0) {
      cachedAttributes = fetchAttributeLocations(gl, program);
    }
    return cachedAttributes;
  };
  this.destroy = function() {
    bindingStates.releaseStatesOfProgram(this);
    gl.deleteProgram(program);
    this.program = void 0;
  };
  this.name = parameters.shaderName;
  this.id = programIdCount++;
  this.cacheKey = cacheKey;
  this.usedTimes = 1;
  this.program = program;
  this.vertexShader = glVertexShader;
  this.fragmentShader = glFragmentShader;
  return this;
}
var _id = 0;
var WebGLShaderCache = class {
  constructor() {
    this.shaderCache = /* @__PURE__ */ new Map();
    this.materialCache = /* @__PURE__ */ new Map();
  }
  update(material) {
    const vertexShader = material.vertexShader;
    const fragmentShader = material.fragmentShader;
    const vertexShaderStage = this._getShaderStage(vertexShader);
    const fragmentShaderStage = this._getShaderStage(fragmentShader);
    const materialShaders = this._getShaderCacheForMaterial(material);
    if (materialShaders.has(vertexShaderStage) === false) {
      materialShaders.add(vertexShaderStage);
      vertexShaderStage.usedTimes++;
    }
    if (materialShaders.has(fragmentShaderStage) === false) {
      materialShaders.add(fragmentShaderStage);
      fragmentShaderStage.usedTimes++;
    }
    return this;
  }
  remove(material) {
    const materialShaders = this.materialCache.get(material);
    for (const shaderStage of materialShaders) {
      shaderStage.usedTimes--;
      if (shaderStage.usedTimes === 0)
        this.shaderCache.delete(shaderStage.code);
    }
    this.materialCache.delete(material);
    return this;
  }
  getVertexShaderID(material) {
    return this._getShaderStage(material.vertexShader).id;
  }
  getFragmentShaderID(material) {
    return this._getShaderStage(material.fragmentShader).id;
  }
  dispose() {
    this.shaderCache.clear();
    this.materialCache.clear();
  }
  _getShaderCacheForMaterial(material) {
    const cache = this.materialCache;
    if (cache.has(material) === false) {
      cache.set(material, /* @__PURE__ */ new Set());
    }
    return cache.get(material);
  }
  _getShaderStage(code) {
    const cache = this.shaderCache;
    if (cache.has(code) === false) {
      const stage = new WebGLShaderStage(code);
      cache.set(code, stage);
    }
    return cache.get(code);
  }
};
var WebGLShaderStage = class {
  constructor(code) {
    this.id = _id++;
    this.code = code;
    this.usedTimes = 0;
  }
};
function WebGLPrograms(renderer, cubemaps, cubeuvmaps, extensions, capabilities, bindingStates, clipping) {
  const _programLayers = new Layers();
  const _customShaders = new WebGLShaderCache();
  const programs = [];
  const isWebGL2 = capabilities.isWebGL2;
  const logarithmicDepthBuffer = capabilities.logarithmicDepthBuffer;
  const vertexTextures = capabilities.vertexTextures;
  let precision = capabilities.precision;
  const shaderIDs = {
    MeshDepthMaterial: "depth",
    MeshDistanceMaterial: "distanceRGBA",
    MeshNormalMaterial: "normal",
    MeshBasicMaterial: "basic",
    MeshLambertMaterial: "lambert",
    MeshPhongMaterial: "phong",
    MeshToonMaterial: "toon",
    MeshStandardMaterial: "physical",
    MeshPhysicalMaterial: "physical",
    MeshMatcapMaterial: "matcap",
    LineBasicMaterial: "basic",
    LineDashedMaterial: "dashed",
    PointsMaterial: "points",
    ShadowMaterial: "shadow",
    SpriteMaterial: "sprite"
  };
  function getParameters(material, lights, shadows, scene, object) {
    const fog = scene.fog;
    const geometry = object.geometry;
    const environment = material.isMeshStandardMaterial ? scene.environment : null;
    const envMap = (material.isMeshStandardMaterial ? cubeuvmaps : cubemaps).get(material.envMap || environment);
    const envMapCubeUVHeight = !!envMap && envMap.mapping === CubeUVReflectionMapping ? envMap.image.height : null;
    const shaderID = shaderIDs[material.type];
    if (material.precision !== null) {
      precision = capabilities.getMaxPrecision(material.precision);
      if (precision !== material.precision) {
        console.warn("THREE.WebGLProgram.getParameters:", material.precision, "not supported, using", precision, "instead.");
      }
    }
    const morphAttribute = geometry.morphAttributes.position || geometry.morphAttributes.normal || geometry.morphAttributes.color;
    const morphTargetsCount = morphAttribute !== void 0 ? morphAttribute.length : 0;
    let morphTextureStride = 0;
    if (geometry.morphAttributes.position !== void 0)
      morphTextureStride = 1;
    if (geometry.morphAttributes.normal !== void 0)
      morphTextureStride = 2;
    if (geometry.morphAttributes.color !== void 0)
      morphTextureStride = 3;
    let vertexShader, fragmentShader;
    let customVertexShaderID, customFragmentShaderID;
    if (shaderID) {
      const shader = ShaderLib[shaderID];
      vertexShader = shader.vertexShader;
      fragmentShader = shader.fragmentShader;
    } else {
      vertexShader = material.vertexShader;
      fragmentShader = material.fragmentShader;
      _customShaders.update(material);
      customVertexShaderID = _customShaders.getVertexShaderID(material);
      customFragmentShaderID = _customShaders.getFragmentShaderID(material);
    }
    const currentRenderTarget = renderer.getRenderTarget();
    const useAlphaTest = material.alphaTest > 0;
    const useClearcoat = material.clearcoat > 0;
    const useIridescence = material.iridescence > 0;
    const parameters = {
      isWebGL2,
      shaderID,
      shaderName: material.type,
      vertexShader,
      fragmentShader,
      defines: material.defines,
      customVertexShaderID,
      customFragmentShaderID,
      isRawShaderMaterial: material.isRawShaderMaterial === true,
      glslVersion: material.glslVersion,
      precision,
      instancing: object.isInstancedMesh === true,
      instancingColor: object.isInstancedMesh === true && object.instanceColor !== null,
      supportsVertexTextures: vertexTextures,
      outputEncoding: currentRenderTarget === null ? renderer.outputEncoding : currentRenderTarget.isXRRenderTarget === true ? currentRenderTarget.texture.encoding : LinearEncoding,
      map: !!material.map,
      matcap: !!material.matcap,
      envMap: !!envMap,
      envMapMode: envMap && envMap.mapping,
      envMapCubeUVHeight,
      lightMap: !!material.lightMap,
      aoMap: !!material.aoMap,
      emissiveMap: !!material.emissiveMap,
      bumpMap: !!material.bumpMap,
      normalMap: !!material.normalMap,
      objectSpaceNormalMap: material.normalMapType === ObjectSpaceNormalMap,
      tangentSpaceNormalMap: material.normalMapType === TangentSpaceNormalMap,
      decodeVideoTexture: !!material.map && material.map.isVideoTexture === true && material.map.encoding === sRGBEncoding,
      clearcoat: useClearcoat,
      clearcoatMap: useClearcoat && !!material.clearcoatMap,
      clearcoatRoughnessMap: useClearcoat && !!material.clearcoatRoughnessMap,
      clearcoatNormalMap: useClearcoat && !!material.clearcoatNormalMap,
      iridescence: useIridescence,
      iridescenceMap: useIridescence && !!material.iridescenceMap,
      iridescenceThicknessMap: useIridescence && !!material.iridescenceThicknessMap,
      displacementMap: !!material.displacementMap,
      roughnessMap: !!material.roughnessMap,
      metalnessMap: !!material.metalnessMap,
      specularMap: !!material.specularMap,
      specularIntensityMap: !!material.specularIntensityMap,
      specularColorMap: !!material.specularColorMap,
      opaque: material.transparent === false && material.blending === NormalBlending,
      alphaMap: !!material.alphaMap,
      alphaTest: useAlphaTest,
      gradientMap: !!material.gradientMap,
      sheen: material.sheen > 0,
      sheenColorMap: !!material.sheenColorMap,
      sheenRoughnessMap: !!material.sheenRoughnessMap,
      transmission: material.transmission > 0,
      transmissionMap: !!material.transmissionMap,
      thicknessMap: !!material.thicknessMap,
      combine: material.combine,
      vertexTangents: !!material.normalMap && !!geometry.attributes.tangent,
      vertexColors: material.vertexColors,
      vertexAlphas: material.vertexColors === true && !!geometry.attributes.color && geometry.attributes.color.itemSize === 4,
      vertexUvs: !!material.map || !!material.bumpMap || !!material.normalMap || !!material.specularMap || !!material.alphaMap || !!material.emissiveMap || !!material.roughnessMap || !!material.metalnessMap || !!material.clearcoatMap || !!material.clearcoatRoughnessMap || !!material.clearcoatNormalMap || !!material.iridescenceMap || !!material.iridescenceThicknessMap || !!material.displacementMap || !!material.transmissionMap || !!material.thicknessMap || !!material.specularIntensityMap || !!material.specularColorMap || !!material.sheenColorMap || !!material.sheenRoughnessMap,
      uvsVertexOnly: !(!!material.map || !!material.bumpMap || !!material.normalMap || !!material.specularMap || !!material.alphaMap || !!material.emissiveMap || !!material.roughnessMap || !!material.metalnessMap || !!material.clearcoatNormalMap || !!material.iridescenceMap || !!material.iridescenceThicknessMap || material.transmission > 0 || !!material.transmissionMap || !!material.thicknessMap || !!material.specularIntensityMap || !!material.specularColorMap || material.sheen > 0 || !!material.sheenColorMap || !!material.sheenRoughnessMap) && !!material.displacementMap,
      fog: !!fog,
      useFog: material.fog === true,
      fogExp2: fog && fog.isFogExp2,
      flatShading: !!material.flatShading,
      sizeAttenuation: material.sizeAttenuation,
      logarithmicDepthBuffer,
      skinning: object.isSkinnedMesh === true,
      morphTargets: geometry.morphAttributes.position !== void 0,
      morphNormals: geometry.morphAttributes.normal !== void 0,
      morphColors: geometry.morphAttributes.color !== void 0,
      morphTargetsCount,
      morphTextureStride,
      numDirLights: lights.directional.length,
      numPointLights: lights.point.length,
      numSpotLights: lights.spot.length,
      numRectAreaLights: lights.rectArea.length,
      numHemiLights: lights.hemi.length,
      numDirLightShadows: lights.directionalShadowMap.length,
      numPointLightShadows: lights.pointShadowMap.length,
      numSpotLightShadows: lights.spotShadowMap.length,
      numClippingPlanes: clipping.numPlanes,
      numClipIntersection: clipping.numIntersection,
      dithering: material.dithering,
      shadowMapEnabled: renderer.shadowMap.enabled && shadows.length > 0,
      shadowMapType: renderer.shadowMap.type,
      toneMapping: material.toneMapped ? renderer.toneMapping : NoToneMapping,
      physicallyCorrectLights: renderer.physicallyCorrectLights,
      premultipliedAlpha: material.premultipliedAlpha,
      doubleSided: material.side === DoubleSide,
      flipSided: material.side === BackSide,
      useDepthPacking: !!material.depthPacking,
      depthPacking: material.depthPacking || 0,
      index0AttributeName: material.index0AttributeName,
      extensionDerivatives: material.extensions && material.extensions.derivatives,
      extensionFragDepth: material.extensions && material.extensions.fragDepth,
      extensionDrawBuffers: material.extensions && material.extensions.drawBuffers,
      extensionShaderTextureLOD: material.extensions && material.extensions.shaderTextureLOD,
      rendererExtensionFragDepth: isWebGL2 || extensions.has("EXT_frag_depth"),
      rendererExtensionDrawBuffers: isWebGL2 || extensions.has("WEBGL_draw_buffers"),
      rendererExtensionShaderTextureLod: isWebGL2 || extensions.has("EXT_shader_texture_lod"),
      customProgramCacheKey: material.customProgramCacheKey()
    };
    return parameters;
  }
  function getProgramCacheKey(parameters) {
    const array = [];
    if (parameters.shaderID) {
      array.push(parameters.shaderID);
    } else {
      array.push(parameters.customVertexShaderID);
      array.push(parameters.customFragmentShaderID);
    }
    if (parameters.defines !== void 0) {
      for (const name in parameters.defines) {
        array.push(name);
        array.push(parameters.defines[name]);
      }
    }
    if (parameters.isRawShaderMaterial === false) {
      getProgramCacheKeyParameters(array, parameters);
      getProgramCacheKeyBooleans(array, parameters);
      array.push(renderer.outputEncoding);
    }
    array.push(parameters.customProgramCacheKey);
    return array.join();
  }
  function getProgramCacheKeyParameters(array, parameters) {
    array.push(parameters.precision);
    array.push(parameters.outputEncoding);
    array.push(parameters.envMapMode);
    array.push(parameters.envMapCubeUVHeight);
    array.push(parameters.combine);
    array.push(parameters.vertexUvs);
    array.push(parameters.fogExp2);
    array.push(parameters.sizeAttenuation);
    array.push(parameters.morphTargetsCount);
    array.push(parameters.morphAttributeCount);
    array.push(parameters.numDirLights);
    array.push(parameters.numPointLights);
    array.push(parameters.numSpotLights);
    array.push(parameters.numHemiLights);
    array.push(parameters.numRectAreaLights);
    array.push(parameters.numDirLightShadows);
    array.push(parameters.numPointLightShadows);
    array.push(parameters.numSpotLightShadows);
    array.push(parameters.shadowMapType);
    array.push(parameters.toneMapping);
    array.push(parameters.numClippingPlanes);
    array.push(parameters.numClipIntersection);
    array.push(parameters.depthPacking);
  }
  function getProgramCacheKeyBooleans(array, parameters) {
    _programLayers.disableAll();
    if (parameters.isWebGL2)
      _programLayers.enable(0);
    if (parameters.supportsVertexTextures)
      _programLayers.enable(1);
    if (parameters.instancing)
      _programLayers.enable(2);
    if (parameters.instancingColor)
      _programLayers.enable(3);
    if (parameters.map)
      _programLayers.enable(4);
    if (parameters.matcap)
      _programLayers.enable(5);
    if (parameters.envMap)
      _programLayers.enable(6);
    if (parameters.lightMap)
      _programLayers.enable(7);
    if (parameters.aoMap)
      _programLayers.enable(8);
    if (parameters.emissiveMap)
      _programLayers.enable(9);
    if (parameters.bumpMap)
      _programLayers.enable(10);
    if (parameters.normalMap)
      _programLayers.enable(11);
    if (parameters.objectSpaceNormalMap)
      _programLayers.enable(12);
    if (parameters.tangentSpaceNormalMap)
      _programLayers.enable(13);
    if (parameters.clearcoat)
      _programLayers.enable(14);
    if (parameters.clearcoatMap)
      _programLayers.enable(15);
    if (parameters.clearcoatRoughnessMap)
      _programLayers.enable(16);
    if (parameters.clearcoatNormalMap)
      _programLayers.enable(17);
    if (parameters.iridescence)
      _programLayers.enable(18);
    if (parameters.iridescenceMap)
      _programLayers.enable(19);
    if (parameters.iridescenceThicknessMap)
      _programLayers.enable(20);
    if (parameters.displacementMap)
      _programLayers.enable(21);
    if (parameters.specularMap)
      _programLayers.enable(22);
    if (parameters.roughnessMap)
      _programLayers.enable(23);
    if (parameters.metalnessMap)
      _programLayers.enable(24);
    if (parameters.gradientMap)
      _programLayers.enable(25);
    if (parameters.alphaMap)
      _programLayers.enable(26);
    if (parameters.alphaTest)
      _programLayers.enable(27);
    if (parameters.vertexColors)
      _programLayers.enable(28);
    if (parameters.vertexAlphas)
      _programLayers.enable(29);
    if (parameters.vertexUvs)
      _programLayers.enable(30);
    if (parameters.vertexTangents)
      _programLayers.enable(31);
    if (parameters.uvsVertexOnly)
      _programLayers.enable(32);
    if (parameters.fog)
      _programLayers.enable(33);
    array.push(_programLayers.mask);
    _programLayers.disableAll();
    if (parameters.useFog)
      _programLayers.enable(0);
    if (parameters.flatShading)
      _programLayers.enable(1);
    if (parameters.logarithmicDepthBuffer)
      _programLayers.enable(2);
    if (parameters.skinning)
      _programLayers.enable(3);
    if (parameters.morphTargets)
      _programLayers.enable(4);
    if (parameters.morphNormals)
      _programLayers.enable(5);
    if (parameters.morphColors)
      _programLayers.enable(6);
    if (parameters.premultipliedAlpha)
      _programLayers.enable(7);
    if (parameters.shadowMapEnabled)
      _programLayers.enable(8);
    if (parameters.physicallyCorrectLights)
      _programLayers.enable(9);
    if (parameters.doubleSided)
      _programLayers.enable(10);
    if (parameters.flipSided)
      _programLayers.enable(11);
    if (parameters.useDepthPacking)
      _programLayers.enable(12);
    if (parameters.dithering)
      _programLayers.enable(13);
    if (parameters.specularIntensityMap)
      _programLayers.enable(14);
    if (parameters.specularColorMap)
      _programLayers.enable(15);
    if (parameters.transmission)
      _programLayers.enable(16);
    if (parameters.transmissionMap)
      _programLayers.enable(17);
    if (parameters.thicknessMap)
      _programLayers.enable(18);
    if (parameters.sheen)
      _programLayers.enable(19);
    if (parameters.sheenColorMap)
      _programLayers.enable(20);
    if (parameters.sheenRoughnessMap)
      _programLayers.enable(21);
    if (parameters.decodeVideoTexture)
      _programLayers.enable(22);
    if (parameters.opaque)
      _programLayers.enable(23);
    array.push(_programLayers.mask);
  }
  function getUniforms(material) {
    const shaderID = shaderIDs[material.type];
    let uniforms;
    if (shaderID) {
      const shader = ShaderLib[shaderID];
      uniforms = UniformsUtils.clone(shader.uniforms);
    } else {
      uniforms = material.uniforms;
    }
    return uniforms;
  }
  function acquireProgram(parameters, cacheKey) {
    let program;
    for (let p = 0, pl = programs.length; p < pl; p++) {
      const preexistingProgram = programs[p];
      if (preexistingProgram.cacheKey === cacheKey) {
        program = preexistingProgram;
        ++program.usedTimes;
        break;
      }
    }
    if (program === void 0) {
      program = new WebGLProgram(renderer, cacheKey, parameters, bindingStates);
      programs.push(program);
    }
    return program;
  }
  function releaseProgram(program) {
    if (--program.usedTimes === 0) {
      const i2 = programs.indexOf(program);
      programs[i2] = programs[programs.length - 1];
      programs.pop();
      program.destroy();
    }
  }
  function releaseShaderCache(material) {
    _customShaders.remove(material);
  }
  function dispose() {
    _customShaders.dispose();
  }
  return {
    getParameters,
    getProgramCacheKey,
    getUniforms,
    acquireProgram,
    releaseProgram,
    releaseShaderCache,
    programs,
    dispose
  };
}
function WebGLProperties() {
  let properties = /* @__PURE__ */ new WeakMap();
  function get(object) {
    let map = properties.get(object);
    if (map === void 0) {
      map = {};
      properties.set(object, map);
    }
    return map;
  }
  function remove(object) {
    properties.delete(object);
  }
  function update(object, key, value) {
    properties.get(object)[key] = value;
  }
  function dispose() {
    properties = /* @__PURE__ */ new WeakMap();
  }
  return {
    get,
    remove,
    update,
    dispose
  };
}
function painterSortStable(a, b) {
  if (a.groupOrder !== b.groupOrder) {
    return a.groupOrder - b.groupOrder;
  } else if (a.renderOrder !== b.renderOrder) {
    return a.renderOrder - b.renderOrder;
  } else if (a.material.id !== b.material.id) {
    return a.material.id - b.material.id;
  } else if (a.z !== b.z) {
    return a.z - b.z;
  } else {
    return a.id - b.id;
  }
}
function reversePainterSortStable(a, b) {
  if (a.groupOrder !== b.groupOrder) {
    return a.groupOrder - b.groupOrder;
  } else if (a.renderOrder !== b.renderOrder) {
    return a.renderOrder - b.renderOrder;
  } else if (a.z !== b.z) {
    return b.z - a.z;
  } else {
    return a.id - b.id;
  }
}
function WebGLRenderList() {
  const renderItems = [];
  let renderItemsIndex = 0;
  const opaque = [];
  const transmissive = [];
  const transparent = [];
  function init() {
    renderItemsIndex = 0;
    opaque.length = 0;
    transmissive.length = 0;
    transparent.length = 0;
  }
  function getNextRenderItem(object, geometry, material, groupOrder, z, group) {
    let renderItem = renderItems[renderItemsIndex];
    if (renderItem === void 0) {
      renderItem = {
        id: object.id,
        object,
        geometry,
        material,
        groupOrder,
        renderOrder: object.renderOrder,
        z,
        group
      };
      renderItems[renderItemsIndex] = renderItem;
    } else {
      renderItem.id = object.id;
      renderItem.object = object;
      renderItem.geometry = geometry;
      renderItem.material = material;
      renderItem.groupOrder = groupOrder;
      renderItem.renderOrder = object.renderOrder;
      renderItem.z = z;
      renderItem.group = group;
    }
    renderItemsIndex++;
    return renderItem;
  }
  function push(object, geometry, material, groupOrder, z, group) {
    const renderItem = getNextRenderItem(object, geometry, material, groupOrder, z, group);
    if (material.transmission > 0) {
      transmissive.push(renderItem);
    } else if (material.transparent === true) {
      transparent.push(renderItem);
    } else {
      opaque.push(renderItem);
    }
  }
  function unshift(object, geometry, material, groupOrder, z, group) {
    const renderItem = getNextRenderItem(object, geometry, material, groupOrder, z, group);
    if (material.transmission > 0) {
      transmissive.unshift(renderItem);
    } else if (material.transparent === true) {
      transparent.unshift(renderItem);
    } else {
      opaque.unshift(renderItem);
    }
  }
  function sort(customOpaqueSort, customTransparentSort) {
    if (opaque.length > 1)
      opaque.sort(customOpaqueSort || painterSortStable);
    if (transmissive.length > 1)
      transmissive.sort(customTransparentSort || reversePainterSortStable);
    if (transparent.length > 1)
      transparent.sort(customTransparentSort || reversePainterSortStable);
  }
  function finish() {
    for (let i2 = renderItemsIndex, il = renderItems.length; i2 < il; i2++) {
      const renderItem = renderItems[i2];
      if (renderItem.id === null)
        break;
      renderItem.id = null;
      renderItem.object = null;
      renderItem.geometry = null;
      renderItem.material = null;
      renderItem.group = null;
    }
  }
  return {
    opaque,
    transmissive,
    transparent,
    init,
    push,
    unshift,
    finish,
    sort
  };
}
function WebGLRenderLists() {
  let lists = /* @__PURE__ */ new WeakMap();
  function get(scene, renderCallDepth) {
    let list;
    if (lists.has(scene) === false) {
      list = new WebGLRenderList();
      lists.set(scene, [list]);
    } else {
      if (renderCallDepth >= lists.get(scene).length) {
        list = new WebGLRenderList();
        lists.get(scene).push(list);
      } else {
        list = lists.get(scene)[renderCallDepth];
      }
    }
    return list;
  }
  function dispose() {
    lists = /* @__PURE__ */ new WeakMap();
  }
  return {
    get,
    dispose
  };
}
function UniformsCache() {
  const lights = {};
  return {
    get: function(light) {
      if (lights[light.id] !== void 0) {
        return lights[light.id];
      }
      let uniforms;
      switch (light.type) {
        case "DirectionalLight":
          uniforms = {
            direction: new Vector3(),
            color: new Color()
          };
          break;
        case "SpotLight":
          uniforms = {
            position: new Vector3(),
            direction: new Vector3(),
            color: new Color(),
            distance: 0,
            coneCos: 0,
            penumbraCos: 0,
            decay: 0
          };
          break;
        case "PointLight":
          uniforms = {
            position: new Vector3(),
            color: new Color(),
            distance: 0,
            decay: 0
          };
          break;
        case "HemisphereLight":
          uniforms = {
            direction: new Vector3(),
            skyColor: new Color(),
            groundColor: new Color()
          };
          break;
        case "RectAreaLight":
          uniforms = {
            color: new Color(),
            position: new Vector3(),
            halfWidth: new Vector3(),
            halfHeight: new Vector3()
          };
          break;
      }
      lights[light.id] = uniforms;
      return uniforms;
    }
  };
}
function ShadowUniformsCache() {
  const lights = {};
  return {
    get: function(light) {
      if (lights[light.id] !== void 0) {
        return lights[light.id];
      }
      let uniforms;
      switch (light.type) {
        case "DirectionalLight":
          uniforms = {
            shadowBias: 0,
            shadowNormalBias: 0,
            shadowRadius: 1,
            shadowMapSize: new Vector2()
          };
          break;
        case "SpotLight":
          uniforms = {
            shadowBias: 0,
            shadowNormalBias: 0,
            shadowRadius: 1,
            shadowMapSize: new Vector2()
          };
          break;
        case "PointLight":
          uniforms = {
            shadowBias: 0,
            shadowNormalBias: 0,
            shadowRadius: 1,
            shadowMapSize: new Vector2(),
            shadowCameraNear: 1,
            shadowCameraFar: 1e3
          };
          break;
      }
      lights[light.id] = uniforms;
      return uniforms;
    }
  };
}
var nextVersion = 0;
function shadowCastingLightsFirst(lightA, lightB) {
  return (lightB.castShadow ? 1 : 0) - (lightA.castShadow ? 1 : 0);
}
function WebGLLights(extensions, capabilities) {
  const cache = new UniformsCache();
  const shadowCache = ShadowUniformsCache();
  const state = {
    version: 0,
    hash: {
      directionalLength: -1,
      pointLength: -1,
      spotLength: -1,
      rectAreaLength: -1,
      hemiLength: -1,
      numDirectionalShadows: -1,
      numPointShadows: -1,
      numSpotShadows: -1
    },
    ambient: [0, 0, 0],
    probe: [],
    directional: [],
    directionalShadow: [],
    directionalShadowMap: [],
    directionalShadowMatrix: [],
    spot: [],
    spotShadow: [],
    spotShadowMap: [],
    spotShadowMatrix: [],
    rectArea: [],
    rectAreaLTC1: null,
    rectAreaLTC2: null,
    point: [],
    pointShadow: [],
    pointShadowMap: [],
    pointShadowMatrix: [],
    hemi: []
  };
  for (let i2 = 0; i2 < 9; i2++)
    state.probe.push(new Vector3());
  const vector3 = new Vector3();
  const matrix4 = new Matrix4();
  const matrix42 = new Matrix4();
  function setup(lights, physicallyCorrectLights) {
    let r = 0, g2 = 0, b = 0;
    for (let i2 = 0; i2 < 9; i2++)
      state.probe[i2].set(0, 0, 0);
    let directionalLength = 0;
    let pointLength = 0;
    let spotLength = 0;
    let rectAreaLength = 0;
    let hemiLength = 0;
    let numDirectionalShadows = 0;
    let numPointShadows = 0;
    let numSpotShadows = 0;
    lights.sort(shadowCastingLightsFirst);
    const scaleFactor = physicallyCorrectLights !== true ? Math.PI : 1;
    for (let i2 = 0, l = lights.length; i2 < l; i2++) {
      const light = lights[i2];
      const color = light.color;
      const intensity = light.intensity;
      const distance = light.distance;
      const shadowMap = light.shadow && light.shadow.map ? light.shadow.map.texture : null;
      if (light.isAmbientLight) {
        r += color.r * intensity * scaleFactor;
        g2 += color.g * intensity * scaleFactor;
        b += color.b * intensity * scaleFactor;
      } else if (light.isLightProbe) {
        for (let j = 0; j < 9; j++) {
          state.probe[j].addScaledVector(light.sh.coefficients[j], intensity);
        }
      } else if (light.isDirectionalLight) {
        const uniforms = cache.get(light);
        uniforms.color.copy(light.color).multiplyScalar(light.intensity * scaleFactor);
        if (light.castShadow) {
          const shadow = light.shadow;
          const shadowUniforms = shadowCache.get(light);
          shadowUniforms.shadowBias = shadow.bias;
          shadowUniforms.shadowNormalBias = shadow.normalBias;
          shadowUniforms.shadowRadius = shadow.radius;
          shadowUniforms.shadowMapSize = shadow.mapSize;
          state.directionalShadow[directionalLength] = shadowUniforms;
          state.directionalShadowMap[directionalLength] = shadowMap;
          state.directionalShadowMatrix[directionalLength] = light.shadow.matrix;
          numDirectionalShadows++;
        }
        state.directional[directionalLength] = uniforms;
        directionalLength++;
      } else if (light.isSpotLight) {
        const uniforms = cache.get(light);
        uniforms.position.setFromMatrixPosition(light.matrixWorld);
        uniforms.color.copy(color).multiplyScalar(intensity * scaleFactor);
        uniforms.distance = distance;
        uniforms.coneCos = Math.cos(light.angle);
        uniforms.penumbraCos = Math.cos(light.angle * (1 - light.penumbra));
        uniforms.decay = light.decay;
        if (light.castShadow) {
          const shadow = light.shadow;
          const shadowUniforms = shadowCache.get(light);
          shadowUniforms.shadowBias = shadow.bias;
          shadowUniforms.shadowNormalBias = shadow.normalBias;
          shadowUniforms.shadowRadius = shadow.radius;
          shadowUniforms.shadowMapSize = shadow.mapSize;
          state.spotShadow[spotLength] = shadowUniforms;
          state.spotShadowMap[spotLength] = shadowMap;
          state.spotShadowMatrix[spotLength] = light.shadow.matrix;
          numSpotShadows++;
        }
        state.spot[spotLength] = uniforms;
        spotLength++;
      } else if (light.isRectAreaLight) {
        const uniforms = cache.get(light);
        uniforms.color.copy(color).multiplyScalar(intensity);
        uniforms.halfWidth.set(light.width * 0.5, 0, 0);
        uniforms.halfHeight.set(0, light.height * 0.5, 0);
        state.rectArea[rectAreaLength] = uniforms;
        rectAreaLength++;
      } else if (light.isPointLight) {
        const uniforms = cache.get(light);
        uniforms.color.copy(light.color).multiplyScalar(light.intensity * scaleFactor);
        uniforms.distance = light.distance;
        uniforms.decay = light.decay;
        if (light.castShadow) {
          const shadow = light.shadow;
          const shadowUniforms = shadowCache.get(light);
          shadowUniforms.shadowBias = shadow.bias;
          shadowUniforms.shadowNormalBias = shadow.normalBias;
          shadowUniforms.shadowRadius = shadow.radius;
          shadowUniforms.shadowMapSize = shadow.mapSize;
          shadowUniforms.shadowCameraNear = shadow.camera.near;
          shadowUniforms.shadowCameraFar = shadow.camera.far;
          state.pointShadow[pointLength] = shadowUniforms;
          state.pointShadowMap[pointLength] = shadowMap;
          state.pointShadowMatrix[pointLength] = light.shadow.matrix;
          numPointShadows++;
        }
        state.point[pointLength] = uniforms;
        pointLength++;
      } else if (light.isHemisphereLight) {
        const uniforms = cache.get(light);
        uniforms.skyColor.copy(light.color).multiplyScalar(intensity * scaleFactor);
        uniforms.groundColor.copy(light.groundColor).multiplyScalar(intensity * scaleFactor);
        state.hemi[hemiLength] = uniforms;
        hemiLength++;
      }
    }
    if (rectAreaLength > 0) {
      if (capabilities.isWebGL2) {
        state.rectAreaLTC1 = UniformsLib.LTC_FLOAT_1;
        state.rectAreaLTC2 = UniformsLib.LTC_FLOAT_2;
      } else {
        if (extensions.has("OES_texture_float_linear") === true) {
          state.rectAreaLTC1 = UniformsLib.LTC_FLOAT_1;
          state.rectAreaLTC2 = UniformsLib.LTC_FLOAT_2;
        } else if (extensions.has("OES_texture_half_float_linear") === true) {
          state.rectAreaLTC1 = UniformsLib.LTC_HALF_1;
          state.rectAreaLTC2 = UniformsLib.LTC_HALF_2;
        } else {
          console.error("THREE.WebGLRenderer: Unable to use RectAreaLight. Missing WebGL extensions.");
        }
      }
    }
    state.ambient[0] = r;
    state.ambient[1] = g2;
    state.ambient[2] = b;
    const hash2 = state.hash;
    if (hash2.directionalLength !== directionalLength || hash2.pointLength !== pointLength || hash2.spotLength !== spotLength || hash2.rectAreaLength !== rectAreaLength || hash2.hemiLength !== hemiLength || hash2.numDirectionalShadows !== numDirectionalShadows || hash2.numPointShadows !== numPointShadows || hash2.numSpotShadows !== numSpotShadows) {
      state.directional.length = directionalLength;
      state.spot.length = spotLength;
      state.rectArea.length = rectAreaLength;
      state.point.length = pointLength;
      state.hemi.length = hemiLength;
      state.directionalShadow.length = numDirectionalShadows;
      state.directionalShadowMap.length = numDirectionalShadows;
      state.pointShadow.length = numPointShadows;
      state.pointShadowMap.length = numPointShadows;
      state.spotShadow.length = numSpotShadows;
      state.spotShadowMap.length = numSpotShadows;
      state.directionalShadowMatrix.length = numDirectionalShadows;
      state.pointShadowMatrix.length = numPointShadows;
      state.spotShadowMatrix.length = numSpotShadows;
      hash2.directionalLength = directionalLength;
      hash2.pointLength = pointLength;
      hash2.spotLength = spotLength;
      hash2.rectAreaLength = rectAreaLength;
      hash2.hemiLength = hemiLength;
      hash2.numDirectionalShadows = numDirectionalShadows;
      hash2.numPointShadows = numPointShadows;
      hash2.numSpotShadows = numSpotShadows;
      state.version = nextVersion++;
    }
  }
  function setupView(lights, camera) {
    let directionalLength = 0;
    let pointLength = 0;
    let spotLength = 0;
    let rectAreaLength = 0;
    let hemiLength = 0;
    const viewMatrix = camera.matrixWorldInverse;
    for (let i2 = 0, l = lights.length; i2 < l; i2++) {
      const light = lights[i2];
      if (light.isDirectionalLight) {
        const uniforms = state.directional[directionalLength];
        uniforms.direction.setFromMatrixPosition(light.matrixWorld);
        vector3.setFromMatrixPosition(light.target.matrixWorld);
        uniforms.direction.sub(vector3);
        uniforms.direction.transformDirection(viewMatrix);
        directionalLength++;
      } else if (light.isSpotLight) {
        const uniforms = state.spot[spotLength];
        uniforms.position.setFromMatrixPosition(light.matrixWorld);
        uniforms.position.applyMatrix4(viewMatrix);
        uniforms.direction.setFromMatrixPosition(light.matrixWorld);
        vector3.setFromMatrixPosition(light.target.matrixWorld);
        uniforms.direction.sub(vector3);
        uniforms.direction.transformDirection(viewMatrix);
        spotLength++;
      } else if (light.isRectAreaLight) {
        const uniforms = state.rectArea[rectAreaLength];
        uniforms.position.setFromMatrixPosition(light.matrixWorld);
        uniforms.position.applyMatrix4(viewMatrix);
        matrix42.identity();
        matrix4.copy(light.matrixWorld);
        matrix4.premultiply(viewMatrix);
        matrix42.extractRotation(matrix4);
        uniforms.halfWidth.set(light.width * 0.5, 0, 0);
        uniforms.halfHeight.set(0, light.height * 0.5, 0);
        uniforms.halfWidth.applyMatrix4(matrix42);
        uniforms.halfHeight.applyMatrix4(matrix42);
        rectAreaLength++;
      } else if (light.isPointLight) {
        const uniforms = state.point[pointLength];
        uniforms.position.setFromMatrixPosition(light.matrixWorld);
        uniforms.position.applyMatrix4(viewMatrix);
        pointLength++;
      } else if (light.isHemisphereLight) {
        const uniforms = state.hemi[hemiLength];
        uniforms.direction.setFromMatrixPosition(light.matrixWorld);
        uniforms.direction.transformDirection(viewMatrix);
        hemiLength++;
      }
    }
  }
  return {
    setup,
    setupView,
    state
  };
}
function WebGLRenderState(extensions, capabilities) {
  const lights = new WebGLLights(extensions, capabilities);
  const lightsArray = [];
  const shadowsArray = [];
  function init() {
    lightsArray.length = 0;
    shadowsArray.length = 0;
  }
  function pushLight(light) {
    lightsArray.push(light);
  }
  function pushShadow(shadowLight) {
    shadowsArray.push(shadowLight);
  }
  function setupLights(physicallyCorrectLights) {
    lights.setup(lightsArray, physicallyCorrectLights);
  }
  function setupLightsView(camera) {
    lights.setupView(lightsArray, camera);
  }
  const state = {
    lightsArray,
    shadowsArray,
    lights
  };
  return {
    init,
    state,
    setupLights,
    setupLightsView,
    pushLight,
    pushShadow
  };
}
function WebGLRenderStates(extensions, capabilities) {
  let renderStates = /* @__PURE__ */ new WeakMap();
  function get(scene, renderCallDepth = 0) {
    let renderState;
    if (renderStates.has(scene) === false) {
      renderState = new WebGLRenderState(extensions, capabilities);
      renderStates.set(scene, [renderState]);
    } else {
      if (renderCallDepth >= renderStates.get(scene).length) {
        renderState = new WebGLRenderState(extensions, capabilities);
        renderStates.get(scene).push(renderState);
      } else {
        renderState = renderStates.get(scene)[renderCallDepth];
      }
    }
    return renderState;
  }
  function dispose() {
    renderStates = /* @__PURE__ */ new WeakMap();
  }
  return {
    get,
    dispose
  };
}
var MeshDepthMaterial = class extends Material {
  constructor(parameters) {
    super();
    this.isMeshDepthMaterial = true;
    this.type = "MeshDepthMaterial";
    this.depthPacking = BasicDepthPacking;
    this.map = null;
    this.alphaMap = null;
    this.displacementMap = null;
    this.displacementScale = 1;
    this.displacementBias = 0;
    this.wireframe = false;
    this.wireframeLinewidth = 1;
    this.setValues(parameters);
  }
  copy(source) {
    super.copy(source);
    this.depthPacking = source.depthPacking;
    this.map = source.map;
    this.alphaMap = source.alphaMap;
    this.displacementMap = source.displacementMap;
    this.displacementScale = source.displacementScale;
    this.displacementBias = source.displacementBias;
    this.wireframe = source.wireframe;
    this.wireframeLinewidth = source.wireframeLinewidth;
    return this;
  }
};
var MeshDistanceMaterial = class extends Material {
  constructor(parameters) {
    super();
    this.isMeshDistanceMaterial = true;
    this.type = "MeshDistanceMaterial";
    this.referencePosition = new Vector3();
    this.nearDistance = 1;
    this.farDistance = 1e3;
    this.map = null;
    this.alphaMap = null;
    this.displacementMap = null;
    this.displacementScale = 1;
    this.displacementBias = 0;
    this.setValues(parameters);
  }
  copy(source) {
    super.copy(source);
    this.referencePosition.copy(source.referencePosition);
    this.nearDistance = source.nearDistance;
    this.farDistance = source.farDistance;
    this.map = source.map;
    this.alphaMap = source.alphaMap;
    this.displacementMap = source.displacementMap;
    this.displacementScale = source.displacementScale;
    this.displacementBias = source.displacementBias;
    return this;
  }
};
var vertex = "void main() {\n	gl_Position = vec4( position, 1.0 );\n}";
var fragment = "uniform sampler2D shadow_pass;\nuniform vec2 resolution;\nuniform float radius;\n#include <packing>\nvoid main() {\n	const float samples = float( VSM_SAMPLES );\n	float mean = 0.0;\n	float squared_mean = 0.0;\n	float uvStride = samples <= 1.0 ? 0.0 : 2.0 / ( samples - 1.0 );\n	float uvStart = samples <= 1.0 ? 0.0 : - 1.0;\n	for ( float i = 0.0; i < samples; i ++ ) {\n		float uvOffset = uvStart + i * uvStride;\n		#ifdef HORIZONTAL_PASS\n			vec2 distribution = unpackRGBATo2Half( texture2D( shadow_pass, ( gl_FragCoord.xy + vec2( uvOffset, 0.0 ) * radius ) / resolution ) );\n			mean += distribution.x;\n			squared_mean += distribution.y * distribution.y + distribution.x * distribution.x;\n		#else\n			float depth = unpackRGBAToDepth( texture2D( shadow_pass, ( gl_FragCoord.xy + vec2( 0.0, uvOffset ) * radius ) / resolution ) );\n			mean += depth;\n			squared_mean += depth * depth;\n		#endif\n	}\n	mean = mean / samples;\n	squared_mean = squared_mean / samples;\n	float std_dev = sqrt( squared_mean - mean * mean );\n	gl_FragColor = pack2HalfToRGBA( vec2( mean, std_dev ) );\n}";
function WebGLShadowMap(_renderer, _objects, _capabilities) {
  let _frustum = new Frustum();
  const _shadowMapSize = new Vector2(), _viewportSize = new Vector2(), _viewport = new Vector4(), _depthMaterial = new MeshDepthMaterial({ depthPacking: RGBADepthPacking }), _distanceMaterial = new MeshDistanceMaterial(), _materialCache = {}, _maxTextureSize = _capabilities.maxTextureSize;
  const shadowSide = { 0: BackSide, 1: FrontSide, 2: DoubleSide };
  const shadowMaterialVertical = new ShaderMaterial({
    defines: {
      VSM_SAMPLES: 8
    },
    uniforms: {
      shadow_pass: { value: null },
      resolution: { value: new Vector2() },
      radius: { value: 4 }
    },
    vertexShader: vertex,
    fragmentShader: fragment
  });
  const shadowMaterialHorizontal = shadowMaterialVertical.clone();
  shadowMaterialHorizontal.defines.HORIZONTAL_PASS = 1;
  const fullScreenTri = new BufferGeometry();
  fullScreenTri.setAttribute(
    "position",
    new BufferAttribute(
      new Float32Array([-1, -1, 0.5, 3, -1, 0.5, -1, 3, 0.5]),
      3
    )
  );
  const fullScreenMesh = new Mesh(fullScreenTri, shadowMaterialVertical);
  const scope = this;
  this.enabled = false;
  this.autoUpdate = true;
  this.needsUpdate = false;
  this.type = PCFShadowMap;
  this.render = function(lights, scene, camera) {
    if (scope.enabled === false)
      return;
    if (scope.autoUpdate === false && scope.needsUpdate === false)
      return;
    if (lights.length === 0)
      return;
    const currentRenderTarget = _renderer.getRenderTarget();
    const activeCubeFace = _renderer.getActiveCubeFace();
    const activeMipmapLevel = _renderer.getActiveMipmapLevel();
    const _state = _renderer.state;
    _state.setBlending(NoBlending);
    _state.buffers.color.setClear(1, 1, 1, 1);
    _state.buffers.depth.setTest(true);
    _state.setScissorTest(false);
    for (let i2 = 0, il = lights.length; i2 < il; i2++) {
      const light = lights[i2];
      const shadow = light.shadow;
      if (shadow === void 0) {
        console.warn("THREE.WebGLShadowMap:", light, "has no shadow.");
        continue;
      }
      if (shadow.autoUpdate === false && shadow.needsUpdate === false)
        continue;
      _shadowMapSize.copy(shadow.mapSize);
      const shadowFrameExtents = shadow.getFrameExtents();
      _shadowMapSize.multiply(shadowFrameExtents);
      _viewportSize.copy(shadow.mapSize);
      if (_shadowMapSize.x > _maxTextureSize || _shadowMapSize.y > _maxTextureSize) {
        if (_shadowMapSize.x > _maxTextureSize) {
          _viewportSize.x = Math.floor(_maxTextureSize / shadowFrameExtents.x);
          _shadowMapSize.x = _viewportSize.x * shadowFrameExtents.x;
          shadow.mapSize.x = _viewportSize.x;
        }
        if (_shadowMapSize.y > _maxTextureSize) {
          _viewportSize.y = Math.floor(_maxTextureSize / shadowFrameExtents.y);
          _shadowMapSize.y = _viewportSize.y * shadowFrameExtents.y;
          shadow.mapSize.y = _viewportSize.y;
        }
      }
      if (shadow.map === null) {
        const pars = this.type !== VSMShadowMap ? { minFilter: NearestFilter, magFilter: NearestFilter } : {};
        shadow.map = new WebGLRenderTarget(_shadowMapSize.x, _shadowMapSize.y, pars);
        shadow.map.texture.name = light.name + ".shadowMap";
        shadow.camera.updateProjectionMatrix();
      }
      _renderer.setRenderTarget(shadow.map);
      _renderer.clear();
      const viewportCount = shadow.getViewportCount();
      for (let vp = 0; vp < viewportCount; vp++) {
        const viewport = shadow.getViewport(vp);
        _viewport.set(
          _viewportSize.x * viewport.x,
          _viewportSize.y * viewport.y,
          _viewportSize.x * viewport.z,
          _viewportSize.y * viewport.w
        );
        _state.viewport(_viewport);
        shadow.updateMatrices(light, vp);
        _frustum = shadow.getFrustum();
        renderObject(scene, camera, shadow.camera, light, this.type);
      }
      if (shadow.isPointLightShadow !== true && this.type === VSMShadowMap) {
        VSMPass(shadow, camera);
      }
      shadow.needsUpdate = false;
    }
    scope.needsUpdate = false;
    _renderer.setRenderTarget(currentRenderTarget, activeCubeFace, activeMipmapLevel);
  };
  function VSMPass(shadow, camera) {
    const geometry = _objects.update(fullScreenMesh);
    if (shadowMaterialVertical.defines.VSM_SAMPLES !== shadow.blurSamples) {
      shadowMaterialVertical.defines.VSM_SAMPLES = shadow.blurSamples;
      shadowMaterialHorizontal.defines.VSM_SAMPLES = shadow.blurSamples;
      shadowMaterialVertical.needsUpdate = true;
      shadowMaterialHorizontal.needsUpdate = true;
    }
    if (shadow.mapPass === null) {
      shadow.mapPass = new WebGLRenderTarget(_shadowMapSize.x, _shadowMapSize.y);
    }
    shadowMaterialVertical.uniforms.shadow_pass.value = shadow.map.texture;
    shadowMaterialVertical.uniforms.resolution.value = shadow.mapSize;
    shadowMaterialVertical.uniforms.radius.value = shadow.radius;
    _renderer.setRenderTarget(shadow.mapPass);
    _renderer.clear();
    _renderer.renderBufferDirect(camera, null, geometry, shadowMaterialVertical, fullScreenMesh, null);
    shadowMaterialHorizontal.uniforms.shadow_pass.value = shadow.mapPass.texture;
    shadowMaterialHorizontal.uniforms.resolution.value = shadow.mapSize;
    shadowMaterialHorizontal.uniforms.radius.value = shadow.radius;
    _renderer.setRenderTarget(shadow.map);
    _renderer.clear();
    _renderer.renderBufferDirect(camera, null, geometry, shadowMaterialHorizontal, fullScreenMesh, null);
  }
  function getDepthMaterial(object, material, light, shadowCameraNear, shadowCameraFar, type) {
    let result = null;
    const customMaterial = light.isPointLight === true ? object.customDistanceMaterial : object.customDepthMaterial;
    if (customMaterial !== void 0) {
      result = customMaterial;
    } else {
      result = light.isPointLight === true ? _distanceMaterial : _depthMaterial;
    }
    if (_renderer.localClippingEnabled && material.clipShadows === true && Array.isArray(material.clippingPlanes) && material.clippingPlanes.length !== 0 || material.displacementMap && material.displacementScale !== 0 || material.alphaMap && material.alphaTest > 0) {
      const keyA = result.uuid, keyB = material.uuid;
      let materialsForVariant = _materialCache[keyA];
      if (materialsForVariant === void 0) {
        materialsForVariant = {};
        _materialCache[keyA] = materialsForVariant;
      }
      let cachedMaterial = materialsForVariant[keyB];
      if (cachedMaterial === void 0) {
        cachedMaterial = result.clone();
        materialsForVariant[keyB] = cachedMaterial;
      }
      result = cachedMaterial;
    }
    result.visible = material.visible;
    result.wireframe = material.wireframe;
    if (type === VSMShadowMap) {
      result.side = material.shadowSide !== null ? material.shadowSide : material.side;
    } else {
      result.side = material.shadowSide !== null ? material.shadowSide : shadowSide[material.side];
    }
    result.alphaMap = material.alphaMap;
    result.alphaTest = material.alphaTest;
    result.clipShadows = material.clipShadows;
    result.clippingPlanes = material.clippingPlanes;
    result.clipIntersection = material.clipIntersection;
    result.displacementMap = material.displacementMap;
    result.displacementScale = material.displacementScale;
    result.displacementBias = material.displacementBias;
    result.wireframeLinewidth = material.wireframeLinewidth;
    result.linewidth = material.linewidth;
    if (light.isPointLight === true && result.isMeshDistanceMaterial === true) {
      result.referencePosition.setFromMatrixPosition(light.matrixWorld);
      result.nearDistance = shadowCameraNear;
      result.farDistance = shadowCameraFar;
    }
    return result;
  }
  function renderObject(object, camera, shadowCamera, light, type) {
    if (object.visible === false)
      return;
    const visible = object.layers.test(camera.layers);
    if (visible && (object.isMesh || object.isLine || object.isPoints)) {
      if ((object.castShadow || object.receiveShadow && type === VSMShadowMap) && (!object.frustumCulled || _frustum.intersectsObject(object))) {
        object.modelViewMatrix.multiplyMatrices(shadowCamera.matrixWorldInverse, object.matrixWorld);
        const geometry = _objects.update(object);
        const material = object.material;
        if (Array.isArray(material)) {
          const groups = geometry.groups;
          for (let k = 0, kl = groups.length; k < kl; k++) {
            const group = groups[k];
            const groupMaterial = material[group.materialIndex];
            if (groupMaterial && groupMaterial.visible) {
              const depthMaterial = getDepthMaterial(object, groupMaterial, light, shadowCamera.near, shadowCamera.far, type);
              _renderer.renderBufferDirect(shadowCamera, null, geometry, depthMaterial, object, group);
            }
          }
        } else if (material.visible) {
          const depthMaterial = getDepthMaterial(object, material, light, shadowCamera.near, shadowCamera.far, type);
          _renderer.renderBufferDirect(shadowCamera, null, geometry, depthMaterial, object, null);
        }
      }
    }
    const children = object.children;
    for (let i2 = 0, l = children.length; i2 < l; i2++) {
      renderObject(children[i2], camera, shadowCamera, light, type);
    }
  }
}
function WebGLState(gl, extensions, capabilities) {
  const isWebGL2 = capabilities.isWebGL2;
  function ColorBuffer() {
    let locked = false;
    const color = new Vector4();
    let currentColorMask = null;
    const currentColorClear = new Vector4(0, 0, 0, 0);
    return {
      setMask: function(colorMask) {
        if (currentColorMask !== colorMask && !locked) {
          gl.colorMask(colorMask, colorMask, colorMask, colorMask);
          currentColorMask = colorMask;
        }
      },
      setLocked: function(lock) {
        locked = lock;
      },
      setClear: function(r, g2, b, a, premultipliedAlpha) {
        if (premultipliedAlpha === true) {
          r *= a;
          g2 *= a;
          b *= a;
        }
        color.set(r, g2, b, a);
        if (currentColorClear.equals(color) === false) {
          gl.clearColor(r, g2, b, a);
          currentColorClear.copy(color);
        }
      },
      reset: function() {
        locked = false;
        currentColorMask = null;
        currentColorClear.set(-1, 0, 0, 0);
      }
    };
  }
  function DepthBuffer() {
    let locked = false;
    let currentDepthMask = null;
    let currentDepthFunc = null;
    let currentDepthClear = null;
    return {
      setTest: function(depthTest) {
        if (depthTest) {
          enable(2929);
        } else {
          disable(2929);
        }
      },
      setMask: function(depthMask) {
        if (currentDepthMask !== depthMask && !locked) {
          gl.depthMask(depthMask);
          currentDepthMask = depthMask;
        }
      },
      setFunc: function(depthFunc) {
        if (currentDepthFunc !== depthFunc) {
          if (depthFunc) {
            switch (depthFunc) {
              case NeverDepth:
                gl.depthFunc(512);
                break;
              case AlwaysDepth:
                gl.depthFunc(519);
                break;
              case LessDepth:
                gl.depthFunc(513);
                break;
              case LessEqualDepth:
                gl.depthFunc(515);
                break;
              case EqualDepth:
                gl.depthFunc(514);
                break;
              case GreaterEqualDepth:
                gl.depthFunc(518);
                break;
              case GreaterDepth:
                gl.depthFunc(516);
                break;
              case NotEqualDepth:
                gl.depthFunc(517);
                break;
              default:
                gl.depthFunc(515);
            }
          } else {
            gl.depthFunc(515);
          }
          currentDepthFunc = depthFunc;
        }
      },
      setLocked: function(lock) {
        locked = lock;
      },
      setClear: function(depth) {
        if (currentDepthClear !== depth) {
          gl.clearDepth(depth);
          currentDepthClear = depth;
        }
      },
      reset: function() {
        locked = false;
        currentDepthMask = null;
        currentDepthFunc = null;
        currentDepthClear = null;
      }
    };
  }
  function StencilBuffer() {
    let locked = false;
    let currentStencilMask = null;
    let currentStencilFunc = null;
    let currentStencilRef = null;
    let currentStencilFuncMask = null;
    let currentStencilFail = null;
    let currentStencilZFail = null;
    let currentStencilZPass = null;
    let currentStencilClear = null;
    return {
      setTest: function(stencilTest) {
        if (!locked) {
          if (stencilTest) {
            enable(2960);
          } else {
            disable(2960);
          }
        }
      },
      setMask: function(stencilMask) {
        if (currentStencilMask !== stencilMask && !locked) {
          gl.stencilMask(stencilMask);
          currentStencilMask = stencilMask;
        }
      },
      setFunc: function(stencilFunc, stencilRef, stencilMask) {
        if (currentStencilFunc !== stencilFunc || currentStencilRef !== stencilRef || currentStencilFuncMask !== stencilMask) {
          gl.stencilFunc(stencilFunc, stencilRef, stencilMask);
          currentStencilFunc = stencilFunc;
          currentStencilRef = stencilRef;
          currentStencilFuncMask = stencilMask;
        }
      },
      setOp: function(stencilFail, stencilZFail, stencilZPass) {
        if (currentStencilFail !== stencilFail || currentStencilZFail !== stencilZFail || currentStencilZPass !== stencilZPass) {
          gl.stencilOp(stencilFail, stencilZFail, stencilZPass);
          currentStencilFail = stencilFail;
          currentStencilZFail = stencilZFail;
          currentStencilZPass = stencilZPass;
        }
      },
      setLocked: function(lock) {
        locked = lock;
      },
      setClear: function(stencil) {
        if (currentStencilClear !== stencil) {
          gl.clearStencil(stencil);
          currentStencilClear = stencil;
        }
      },
      reset: function() {
        locked = false;
        currentStencilMask = null;
        currentStencilFunc = null;
        currentStencilRef = null;
        currentStencilFuncMask = null;
        currentStencilFail = null;
        currentStencilZFail = null;
        currentStencilZPass = null;
        currentStencilClear = null;
      }
    };
  }
  const colorBuffer = new ColorBuffer();
  const depthBuffer = new DepthBuffer();
  const stencilBuffer = new StencilBuffer();
  const uboBindings = /* @__PURE__ */ new WeakMap();
  const uboProgamMap = /* @__PURE__ */ new WeakMap();
  let enabledCapabilities = {};
  let currentBoundFramebuffers = {};
  let currentDrawbuffers = /* @__PURE__ */ new WeakMap();
  let defaultDrawbuffers = [];
  let currentProgram = null;
  let currentBlendingEnabled = false;
  let currentBlending = null;
  let currentBlendEquation = null;
  let currentBlendSrc = null;
  let currentBlendDst = null;
  let currentBlendEquationAlpha = null;
  let currentBlendSrcAlpha = null;
  let currentBlendDstAlpha = null;
  let currentPremultipledAlpha = false;
  let currentFlipSided = null;
  let currentCullFace = null;
  let currentLineWidth = null;
  let currentPolygonOffsetFactor = null;
  let currentPolygonOffsetUnits = null;
  const maxTextures = gl.getParameter(35661);
  let lineWidthAvailable = false;
  let version = 0;
  const glVersion = gl.getParameter(7938);
  if (glVersion.indexOf("WebGL") !== -1) {
    version = parseFloat(/^WebGL (\d)/.exec(glVersion)[1]);
    lineWidthAvailable = version >= 1;
  } else if (glVersion.indexOf("OpenGL ES") !== -1) {
    version = parseFloat(/^OpenGL ES (\d)/.exec(glVersion)[1]);
    lineWidthAvailable = version >= 2;
  }
  let currentTextureSlot = null;
  let currentBoundTextures = {};
  const scissorParam = gl.getParameter(3088);
  const viewportParam = gl.getParameter(2978);
  const currentScissor = new Vector4().fromArray(scissorParam);
  const currentViewport = new Vector4().fromArray(viewportParam);
  function createTexture(type, target, count) {
    const data = new Uint8Array(4);
    const texture = gl.createTexture();
    gl.bindTexture(type, texture);
    gl.texParameteri(type, 10241, 9728);
    gl.texParameteri(type, 10240, 9728);
    for (let i2 = 0; i2 < count; i2++) {
      gl.texImage2D(target + i2, 0, 6408, 1, 1, 0, 6408, 5121, data);
    }
    return texture;
  }
  const emptyTextures = {};
  emptyTextures[3553] = createTexture(3553, 3553, 1);
  emptyTextures[34067] = createTexture(34067, 34069, 6);
  colorBuffer.setClear(0, 0, 0, 1);
  depthBuffer.setClear(1);
  stencilBuffer.setClear(0);
  enable(2929);
  depthBuffer.setFunc(LessEqualDepth);
  setFlipSided(false);
  setCullFace(CullFaceBack);
  enable(2884);
  setBlending(NoBlending);
  function enable(id) {
    if (enabledCapabilities[id] !== true) {
      gl.enable(id);
      enabledCapabilities[id] = true;
    }
  }
  function disable(id) {
    if (enabledCapabilities[id] !== false) {
      gl.disable(id);
      enabledCapabilities[id] = false;
    }
  }
  function bindFramebuffer(target, framebuffer) {
    if (currentBoundFramebuffers[target] !== framebuffer) {
      gl.bindFramebuffer(target, framebuffer);
      currentBoundFramebuffers[target] = framebuffer;
      if (isWebGL2) {
        if (target === 36009) {
          currentBoundFramebuffers[36160] = framebuffer;
        }
        if (target === 36160) {
          currentBoundFramebuffers[36009] = framebuffer;
        }
      }
      return true;
    }
    return false;
  }
  function drawBuffers(renderTarget, framebuffer) {
    let drawBuffers2 = defaultDrawbuffers;
    let needsUpdate = false;
    if (renderTarget) {
      drawBuffers2 = currentDrawbuffers.get(framebuffer);
      if (drawBuffers2 === void 0) {
        drawBuffers2 = [];
        currentDrawbuffers.set(framebuffer, drawBuffers2);
      }
      if (renderTarget.isWebGLMultipleRenderTargets) {
        const textures = renderTarget.texture;
        if (drawBuffers2.length !== textures.length || drawBuffers2[0] !== 36064) {
          for (let i2 = 0, il = textures.length; i2 < il; i2++) {
            drawBuffers2[i2] = 36064 + i2;
          }
          drawBuffers2.length = textures.length;
          needsUpdate = true;
        }
      } else {
        if (drawBuffers2[0] !== 36064) {
          drawBuffers2[0] = 36064;
          needsUpdate = true;
        }
      }
    } else {
      if (drawBuffers2[0] !== 1029) {
        drawBuffers2[0] = 1029;
        needsUpdate = true;
      }
    }
    if (needsUpdate) {
      if (capabilities.isWebGL2) {
        gl.drawBuffers(drawBuffers2);
      } else {
        extensions.get("WEBGL_draw_buffers").drawBuffersWEBGL(drawBuffers2);
      }
    }
  }
  function useProgram(program) {
    if (currentProgram !== program) {
      gl.useProgram(program);
      currentProgram = program;
      return true;
    }
    return false;
  }
  const equationToGL = {
    [AddEquation]: 32774,
    [SubtractEquation]: 32778,
    [ReverseSubtractEquation]: 32779
  };
  if (isWebGL2) {
    equationToGL[MinEquation] = 32775;
    equationToGL[MaxEquation] = 32776;
  } else {
    const extension = extensions.get("EXT_blend_minmax");
    if (extension !== null) {
      equationToGL[MinEquation] = extension.MIN_EXT;
      equationToGL[MaxEquation] = extension.MAX_EXT;
    }
  }
  const factorToGL = {
    [ZeroFactor]: 0,
    [OneFactor]: 1,
    [SrcColorFactor]: 768,
    [SrcAlphaFactor]: 770,
    [SrcAlphaSaturateFactor]: 776,
    [DstColorFactor]: 774,
    [DstAlphaFactor]: 772,
    [OneMinusSrcColorFactor]: 769,
    [OneMinusSrcAlphaFactor]: 771,
    [OneMinusDstColorFactor]: 775,
    [OneMinusDstAlphaFactor]: 773
  };
  function setBlending(blending, blendEquation, blendSrc, blendDst, blendEquationAlpha, blendSrcAlpha, blendDstAlpha, premultipliedAlpha) {
    if (blending === NoBlending) {
      if (currentBlendingEnabled === true) {
        disable(3042);
        currentBlendingEnabled = false;
      }
      return;
    }
    if (currentBlendingEnabled === false) {
      enable(3042);
      currentBlendingEnabled = true;
    }
    if (blending !== CustomBlending) {
      if (blending !== currentBlending || premultipliedAlpha !== currentPremultipledAlpha) {
        if (currentBlendEquation !== AddEquation || currentBlendEquationAlpha !== AddEquation) {
          gl.blendEquation(32774);
          currentBlendEquation = AddEquation;
          currentBlendEquationAlpha = AddEquation;
        }
        if (premultipliedAlpha) {
          switch (blending) {
            case NormalBlending:
              gl.blendFuncSeparate(1, 771, 1, 771);
              break;
            case AdditiveBlending:
              gl.blendFunc(1, 1);
              break;
            case SubtractiveBlending:
              gl.blendFuncSeparate(0, 769, 0, 1);
              break;
            case MultiplyBlending:
              gl.blendFuncSeparate(0, 768, 0, 770);
              break;
            default:
              console.error("THREE.WebGLState: Invalid blending: ", blending);
              break;
          }
        } else {
          switch (blending) {
            case NormalBlending:
              gl.blendFuncSeparate(770, 771, 1, 771);
              break;
            case AdditiveBlending:
              gl.blendFunc(770, 1);
              break;
            case SubtractiveBlending:
              gl.blendFuncSeparate(0, 769, 0, 1);
              break;
            case MultiplyBlending:
              gl.blendFunc(0, 768);
              break;
            default:
              console.error("THREE.WebGLState: Invalid blending: ", blending);
              break;
          }
        }
        currentBlendSrc = null;
        currentBlendDst = null;
        currentBlendSrcAlpha = null;
        currentBlendDstAlpha = null;
        currentBlending = blending;
        currentPremultipledAlpha = premultipliedAlpha;
      }
      return;
    }
    blendEquationAlpha = blendEquationAlpha || blendEquation;
    blendSrcAlpha = blendSrcAlpha || blendSrc;
    blendDstAlpha = blendDstAlpha || blendDst;
    if (blendEquation !== currentBlendEquation || blendEquationAlpha !== currentBlendEquationAlpha) {
      gl.blendEquationSeparate(equationToGL[blendEquation], equationToGL[blendEquationAlpha]);
      currentBlendEquation = blendEquation;
      currentBlendEquationAlpha = blendEquationAlpha;
    }
    if (blendSrc !== currentBlendSrc || blendDst !== currentBlendDst || blendSrcAlpha !== currentBlendSrcAlpha || blendDstAlpha !== currentBlendDstAlpha) {
      gl.blendFuncSeparate(factorToGL[blendSrc], factorToGL[blendDst], factorToGL[blendSrcAlpha], factorToGL[blendDstAlpha]);
      currentBlendSrc = blendSrc;
      currentBlendDst = blendDst;
      currentBlendSrcAlpha = blendSrcAlpha;
      currentBlendDstAlpha = blendDstAlpha;
    }
    currentBlending = blending;
    currentPremultipledAlpha = null;
  }
  function setMaterial(material, frontFaceCW) {
    material.side === DoubleSide ? disable(2884) : enable(2884);
    let flipSided = material.side === BackSide;
    if (frontFaceCW)
      flipSided = !flipSided;
    setFlipSided(flipSided);
    material.blending === NormalBlending && material.transparent === false ? setBlending(NoBlending) : setBlending(material.blending, material.blendEquation, material.blendSrc, material.blendDst, material.blendEquationAlpha, material.blendSrcAlpha, material.blendDstAlpha, material.premultipliedAlpha);
    depthBuffer.setFunc(material.depthFunc);
    depthBuffer.setTest(material.depthTest);
    depthBuffer.setMask(material.depthWrite);
    colorBuffer.setMask(material.colorWrite);
    const stencilWrite = material.stencilWrite;
    stencilBuffer.setTest(stencilWrite);
    if (stencilWrite) {
      stencilBuffer.setMask(material.stencilWriteMask);
      stencilBuffer.setFunc(material.stencilFunc, material.stencilRef, material.stencilFuncMask);
      stencilBuffer.setOp(material.stencilFail, material.stencilZFail, material.stencilZPass);
    }
    setPolygonOffset(material.polygonOffset, material.polygonOffsetFactor, material.polygonOffsetUnits);
    material.alphaToCoverage === true ? enable(32926) : disable(32926);
  }
  function setFlipSided(flipSided) {
    if (currentFlipSided !== flipSided) {
      if (flipSided) {
        gl.frontFace(2304);
      } else {
        gl.frontFace(2305);
      }
      currentFlipSided = flipSided;
    }
  }
  function setCullFace(cullFace) {
    if (cullFace !== CullFaceNone) {
      enable(2884);
      if (cullFace !== currentCullFace) {
        if (cullFace === CullFaceBack) {
          gl.cullFace(1029);
        } else if (cullFace === CullFaceFront) {
          gl.cullFace(1028);
        } else {
          gl.cullFace(1032);
        }
      }
    } else {
      disable(2884);
    }
    currentCullFace = cullFace;
  }
  function setLineWidth(width) {
    if (width !== currentLineWidth) {
      if (lineWidthAvailable)
        gl.lineWidth(width);
      currentLineWidth = width;
    }
  }
  function setPolygonOffset(polygonOffset, factor, units) {
    if (polygonOffset) {
      enable(32823);
      if (currentPolygonOffsetFactor !== factor || currentPolygonOffsetUnits !== units) {
        gl.polygonOffset(factor, units);
        currentPolygonOffsetFactor = factor;
        currentPolygonOffsetUnits = units;
      }
    } else {
      disable(32823);
    }
  }
  function setScissorTest(scissorTest) {
    if (scissorTest) {
      enable(3089);
    } else {
      disable(3089);
    }
  }
  function activeTexture(webglSlot) {
    if (webglSlot === void 0)
      webglSlot = 33984 + maxTextures - 1;
    if (currentTextureSlot !== webglSlot) {
      gl.activeTexture(webglSlot);
      currentTextureSlot = webglSlot;
    }
  }
  function bindTexture(webglType, webglTexture) {
    if (currentTextureSlot === null) {
      activeTexture();
    }
    let boundTexture = currentBoundTextures[currentTextureSlot];
    if (boundTexture === void 0) {
      boundTexture = { type: void 0, texture: void 0 };
      currentBoundTextures[currentTextureSlot] = boundTexture;
    }
    if (boundTexture.type !== webglType || boundTexture.texture !== webglTexture) {
      gl.bindTexture(webglType, webglTexture || emptyTextures[webglType]);
      boundTexture.type = webglType;
      boundTexture.texture = webglTexture;
    }
  }
  function unbindTexture() {
    const boundTexture = currentBoundTextures[currentTextureSlot];
    if (boundTexture !== void 0 && boundTexture.type !== void 0) {
      gl.bindTexture(boundTexture.type, null);
      boundTexture.type = void 0;
      boundTexture.texture = void 0;
    }
  }
  function compressedTexImage2D() {
    try {
      gl.compressedTexImage2D.apply(gl, arguments);
    } catch (error) {
      console.error("THREE.WebGLState:", error);
    }
  }
  function texSubImage2D() {
    try {
      gl.texSubImage2D.apply(gl, arguments);
    } catch (error) {
      console.error("THREE.WebGLState:", error);
    }
  }
  function texSubImage3D() {
    try {
      gl.texSubImage3D.apply(gl, arguments);
    } catch (error) {
      console.error("THREE.WebGLState:", error);
    }
  }
  function compressedTexSubImage2D() {
    try {
      gl.compressedTexSubImage2D.apply(gl, arguments);
    } catch (error) {
      console.error("THREE.WebGLState:", error);
    }
  }
  function texStorage2D() {
    try {
      gl.texStorage2D.apply(gl, arguments);
    } catch (error) {
      console.error("THREE.WebGLState:", error);
    }
  }
  function texStorage3D() {
    try {
      gl.texStorage3D.apply(gl, arguments);
    } catch (error) {
      console.error("THREE.WebGLState:", error);
    }
  }
  function texImage2D() {
    try {
      gl.texImage2D.apply(gl, arguments);
    } catch (error) {
      console.error("THREE.WebGLState:", error);
    }
  }
  function texImage3D() {
    try {
      gl.texImage3D.apply(gl, arguments);
    } catch (error) {
      console.error("THREE.WebGLState:", error);
    }
  }
  function scissor(scissor2) {
    if (currentScissor.equals(scissor2) === false) {
      gl.scissor(scissor2.x, scissor2.y, scissor2.z, scissor2.w);
      currentScissor.copy(scissor2);
    }
  }
  function viewport(viewport2) {
    if (currentViewport.equals(viewport2) === false) {
      gl.viewport(viewport2.x, viewport2.y, viewport2.z, viewport2.w);
      currentViewport.copy(viewport2);
    }
  }
  function updateUBOMapping(uniformsGroup, program) {
    let mapping = uboProgamMap.get(program);
    if (mapping === void 0) {
      mapping = /* @__PURE__ */ new WeakMap();
      uboProgamMap.set(program, mapping);
    }
    let blockIndex = mapping.get(uniformsGroup);
    if (blockIndex === void 0) {
      blockIndex = gl.getUniformBlockIndex(program, uniformsGroup.name);
      mapping.set(uniformsGroup, blockIndex);
    }
  }
  function uniformBlockBinding(uniformsGroup, program) {
    const mapping = uboProgamMap.get(program);
    const blockIndex = mapping.get(uniformsGroup);
    if (uboBindings.get(uniformsGroup) !== blockIndex) {
      gl.uniformBlockBinding(program, blockIndex, uniformsGroup.__bindingPointIndex);
      uboBindings.set(uniformsGroup, blockIndex);
    }
  }
  function reset() {
    gl.disable(3042);
    gl.disable(2884);
    gl.disable(2929);
    gl.disable(32823);
    gl.disable(3089);
    gl.disable(2960);
    gl.disable(32926);
    gl.blendEquation(32774);
    gl.blendFunc(1, 0);
    gl.blendFuncSeparate(1, 0, 1, 0);
    gl.colorMask(true, true, true, true);
    gl.clearColor(0, 0, 0, 0);
    gl.depthMask(true);
    gl.depthFunc(513);
    gl.clearDepth(1);
    gl.stencilMask(4294967295);
    gl.stencilFunc(519, 0, 4294967295);
    gl.stencilOp(7680, 7680, 7680);
    gl.clearStencil(0);
    gl.cullFace(1029);
    gl.frontFace(2305);
    gl.polygonOffset(0, 0);
    gl.activeTexture(33984);
    gl.bindFramebuffer(36160, null);
    if (isWebGL2 === true) {
      gl.bindFramebuffer(36009, null);
      gl.bindFramebuffer(36008, null);
    }
    gl.useProgram(null);
    gl.lineWidth(1);
    gl.scissor(0, 0, gl.canvas.width, gl.canvas.height);
    gl.viewport(0, 0, gl.canvas.width, gl.canvas.height);
    enabledCapabilities = {};
    currentTextureSlot = null;
    currentBoundTextures = {};
    currentBoundFramebuffers = {};
    currentDrawbuffers = /* @__PURE__ */ new WeakMap();
    defaultDrawbuffers = [];
    currentProgram = null;
    currentBlendingEnabled = false;
    currentBlending = null;
    currentBlendEquation = null;
    currentBlendSrc = null;
    currentBlendDst = null;
    currentBlendEquationAlpha = null;
    currentBlendSrcAlpha = null;
    currentBlendDstAlpha = null;
    currentPremultipledAlpha = false;
    currentFlipSided = null;
    currentCullFace = null;
    currentLineWidth = null;
    currentPolygonOffsetFactor = null;
    currentPolygonOffsetUnits = null;
    currentScissor.set(0, 0, gl.canvas.width, gl.canvas.height);
    currentViewport.set(0, 0, gl.canvas.width, gl.canvas.height);
    colorBuffer.reset();
    depthBuffer.reset();
    stencilBuffer.reset();
  }
  return {
    buffers: {
      color: colorBuffer,
      depth: depthBuffer,
      stencil: stencilBuffer
    },
    enable,
    disable,
    bindFramebuffer,
    drawBuffers,
    useProgram,
    setBlending,
    setMaterial,
    setFlipSided,
    setCullFace,
    setLineWidth,
    setPolygonOffset,
    setScissorTest,
    activeTexture,
    bindTexture,
    unbindTexture,
    compressedTexImage2D,
    texImage2D,
    texImage3D,
    updateUBOMapping,
    uniformBlockBinding,
    texStorage2D,
    texStorage3D,
    texSubImage2D,
    texSubImage3D,
    compressedTexSubImage2D,
    scissor,
    viewport,
    reset
  };
}
function WebGLTextures(_gl, extensions, state, properties, capabilities, utils, info) {
  const isWebGL2 = capabilities.isWebGL2;
  const maxTextures = capabilities.maxTextures;
  const maxCubemapSize = capabilities.maxCubemapSize;
  const maxTextureSize = capabilities.maxTextureSize;
  const maxSamples = capabilities.maxSamples;
  const multisampledRTTExt = extensions.has("WEBGL_multisampled_render_to_texture") ? extensions.get("WEBGL_multisampled_render_to_texture") : null;
  const supportsInvalidateFramebuffer = /OculusBrowser/g.test(navigator.userAgent);
  const _videoTextures = /* @__PURE__ */ new WeakMap();
  let _canvas2;
  const _sources = /* @__PURE__ */ new WeakMap();
  let useOffscreenCanvas = false;
  try {
    useOffscreenCanvas = typeof OffscreenCanvas !== "undefined" && new OffscreenCanvas(1, 1).getContext("2d") !== null;
  } catch (err) {
  }
  function createCanvas(width, height) {
    return useOffscreenCanvas ? new OffscreenCanvas(width, height) : createElementNS("canvas");
  }
  function resizeImage(image, needsPowerOfTwo, needsNewCanvas, maxSize) {
    let scale = 1;
    if (image.width > maxSize || image.height > maxSize) {
      scale = maxSize / Math.max(image.width, image.height);
    }
    if (scale < 1 || needsPowerOfTwo === true) {
      if (typeof HTMLImageElement !== "undefined" && image instanceof HTMLImageElement || typeof HTMLCanvasElement !== "undefined" && image instanceof HTMLCanvasElement || typeof ImageBitmap !== "undefined" && image instanceof ImageBitmap) {
        const floor = needsPowerOfTwo ? floorPowerOfTwo : Math.floor;
        const width = floor(scale * image.width);
        const height = floor(scale * image.height);
        if (_canvas2 === void 0)
          _canvas2 = createCanvas(width, height);
        const canvas = needsNewCanvas ? createCanvas(width, height) : _canvas2;
        canvas.width = width;
        canvas.height = height;
        const context = canvas.getContext("2d");
        context.drawImage(image, 0, 0, width, height);
        console.warn("THREE.WebGLRenderer: Texture has been resized from (" + image.width + "x" + image.height + ") to (" + width + "x" + height + ").");
        return canvas;
      } else {
        if ("data" in image) {
          console.warn("THREE.WebGLRenderer: Image in DataTexture is too big (" + image.width + "x" + image.height + ").");
        }
        return image;
      }
    }
    return image;
  }
  function isPowerOfTwo$1(image) {
    return isPowerOfTwo(image.width) && isPowerOfTwo(image.height);
  }
  function textureNeedsPowerOfTwo(texture) {
    if (isWebGL2)
      return false;
    return texture.wrapS !== ClampToEdgeWrapping || texture.wrapT !== ClampToEdgeWrapping || texture.minFilter !== NearestFilter && texture.minFilter !== LinearFilter;
  }
  function textureNeedsGenerateMipmaps(texture, supportsMips) {
    return texture.generateMipmaps && supportsMips && texture.minFilter !== NearestFilter && texture.minFilter !== LinearFilter;
  }
  function generateMipmap(target) {
    _gl.generateMipmap(target);
  }
  function getInternalFormat(internalFormatName, glFormat, glType, encoding, isVideoTexture = false) {
    if (isWebGL2 === false)
      return glFormat;
    if (internalFormatName !== null) {
      if (_gl[internalFormatName] !== void 0)
        return _gl[internalFormatName];
      console.warn("THREE.WebGLRenderer: Attempt to use non-existing WebGL internal format '" + internalFormatName + "'");
    }
    let internalFormat = glFormat;
    if (glFormat === 6403) {
      if (glType === 5126)
        internalFormat = 33326;
      if (glType === 5131)
        internalFormat = 33325;
      if (glType === 5121)
        internalFormat = 33321;
    }
    if (glFormat === 33319) {
      if (glType === 5126)
        internalFormat = 33328;
      if (glType === 5131)
        internalFormat = 33327;
      if (glType === 5121)
        internalFormat = 33323;
    }
    if (glFormat === 6408) {
      if (glType === 5126)
        internalFormat = 34836;
      if (glType === 5131)
        internalFormat = 34842;
      if (glType === 5121)
        internalFormat = encoding === sRGBEncoding && isVideoTexture === false ? 35907 : 32856;
      if (glType === 32819)
        internalFormat = 32854;
      if (glType === 32820)
        internalFormat = 32855;
    }
    if (internalFormat === 33325 || internalFormat === 33326 || internalFormat === 33327 || internalFormat === 33328 || internalFormat === 34842 || internalFormat === 34836) {
      extensions.get("EXT_color_buffer_float");
    }
    return internalFormat;
  }
  function getMipLevels(texture, image, supportsMips) {
    if (textureNeedsGenerateMipmaps(texture, supportsMips) === true || texture.isFramebufferTexture && texture.minFilter !== NearestFilter && texture.minFilter !== LinearFilter) {
      return Math.log2(Math.max(image.width, image.height)) + 1;
    } else if (texture.mipmaps !== void 0 && texture.mipmaps.length > 0) {
      return texture.mipmaps.length;
    } else if (texture.isCompressedTexture && Array.isArray(texture.image)) {
      return image.mipmaps.length;
    } else {
      return 1;
    }
  }
  function filterFallback(f) {
    if (f === NearestFilter || f === NearestMipmapNearestFilter || f === NearestMipmapLinearFilter) {
      return 9728;
    }
    return 9729;
  }
  function onTextureDispose(event) {
    const texture = event.target;
    texture.removeEventListener("dispose", onTextureDispose);
    deallocateTexture(texture);
    if (texture.isVideoTexture) {
      _videoTextures.delete(texture);
    }
  }
  function onRenderTargetDispose(event) {
    const renderTarget = event.target;
    renderTarget.removeEventListener("dispose", onRenderTargetDispose);
    deallocateRenderTarget(renderTarget);
  }
  function deallocateTexture(texture) {
    const textureProperties = properties.get(texture);
    if (textureProperties.__webglInit === void 0)
      return;
    const source = texture.source;
    const webglTextures = _sources.get(source);
    if (webglTextures) {
      const webglTexture = webglTextures[textureProperties.__cacheKey];
      webglTexture.usedTimes--;
      if (webglTexture.usedTimes === 0) {
        deleteTexture(texture);
      }
      if (Object.keys(webglTextures).length === 0) {
        _sources.delete(source);
      }
    }
    properties.remove(texture);
  }
  function deleteTexture(texture) {
    const textureProperties = properties.get(texture);
    _gl.deleteTexture(textureProperties.__webglTexture);
    const source = texture.source;
    const webglTextures = _sources.get(source);
    delete webglTextures[textureProperties.__cacheKey];
    info.memory.textures--;
  }
  function deallocateRenderTarget(renderTarget) {
    const texture = renderTarget.texture;
    const renderTargetProperties = properties.get(renderTarget);
    const textureProperties = properties.get(texture);
    if (textureProperties.__webglTexture !== void 0) {
      _gl.deleteTexture(textureProperties.__webglTexture);
      info.memory.textures--;
    }
    if (renderTarget.depthTexture) {
      renderTarget.depthTexture.dispose();
    }
    if (renderTarget.isWebGLCubeRenderTarget) {
      for (let i2 = 0; i2 < 6; i2++) {
        _gl.deleteFramebuffer(renderTargetProperties.__webglFramebuffer[i2]);
        if (renderTargetProperties.__webglDepthbuffer)
          _gl.deleteRenderbuffer(renderTargetProperties.__webglDepthbuffer[i2]);
      }
    } else {
      _gl.deleteFramebuffer(renderTargetProperties.__webglFramebuffer);
      if (renderTargetProperties.__webglDepthbuffer)
        _gl.deleteRenderbuffer(renderTargetProperties.__webglDepthbuffer);
      if (renderTargetProperties.__webglMultisampledFramebuffer)
        _gl.deleteFramebuffer(renderTargetProperties.__webglMultisampledFramebuffer);
      if (renderTargetProperties.__webglColorRenderbuffer) {
        for (let i2 = 0; i2 < renderTargetProperties.__webglColorRenderbuffer.length; i2++) {
          if (renderTargetProperties.__webglColorRenderbuffer[i2])
            _gl.deleteRenderbuffer(renderTargetProperties.__webglColorRenderbuffer[i2]);
        }
      }
      if (renderTargetProperties.__webglDepthRenderbuffer)
        _gl.deleteRenderbuffer(renderTargetProperties.__webglDepthRenderbuffer);
    }
    if (renderTarget.isWebGLMultipleRenderTargets) {
      for (let i2 = 0, il = texture.length; i2 < il; i2++) {
        const attachmentProperties = properties.get(texture[i2]);
        if (attachmentProperties.__webglTexture) {
          _gl.deleteTexture(attachmentProperties.__webglTexture);
          info.memory.textures--;
        }
        properties.remove(texture[i2]);
      }
    }
    properties.remove(texture);
    properties.remove(renderTarget);
  }
  let textureUnits = 0;
  function resetTextureUnits() {
    textureUnits = 0;
  }
  function allocateTextureUnit() {
    const textureUnit = textureUnits;
    if (textureUnit >= maxTextures) {
      console.warn("THREE.WebGLTextures: Trying to use " + textureUnit + " texture units while this GPU supports only " + maxTextures);
    }
    textureUnits += 1;
    return textureUnit;
  }
  function getTextureCacheKey(texture) {
    const array = [];
    array.push(texture.wrapS);
    array.push(texture.wrapT);
    array.push(texture.magFilter);
    array.push(texture.minFilter);
    array.push(texture.anisotropy);
    array.push(texture.internalFormat);
    array.push(texture.format);
    array.push(texture.type);
    array.push(texture.generateMipmaps);
    array.push(texture.premultiplyAlpha);
    array.push(texture.flipY);
    array.push(texture.unpackAlignment);
    array.push(texture.encoding);
    return array.join();
  }
  function setTexture2D(texture, slot) {
    const textureProperties = properties.get(texture);
    if (texture.isVideoTexture)
      updateVideoTexture(texture);
    if (texture.isRenderTargetTexture === false && texture.version > 0 && textureProperties.__version !== texture.version) {
      const image = texture.image;
      if (image === null) {
        console.warn("THREE.WebGLRenderer: Texture marked for update but no image data found.");
      } else if (image.complete === false) {
        console.warn("THREE.WebGLRenderer: Texture marked for update but image is incomplete");
      } else {
        uploadTexture(textureProperties, texture, slot);
        return;
      }
    }
    state.activeTexture(33984 + slot);
    state.bindTexture(3553, textureProperties.__webglTexture);
  }
  function setTexture2DArray(texture, slot) {
    const textureProperties = properties.get(texture);
    if (texture.version > 0 && textureProperties.__version !== texture.version) {
      uploadTexture(textureProperties, texture, slot);
      return;
    }
    state.activeTexture(33984 + slot);
    state.bindTexture(35866, textureProperties.__webglTexture);
  }
  function setTexture3D(texture, slot) {
    const textureProperties = properties.get(texture);
    if (texture.version > 0 && textureProperties.__version !== texture.version) {
      uploadTexture(textureProperties, texture, slot);
      return;
    }
    state.activeTexture(33984 + slot);
    state.bindTexture(32879, textureProperties.__webglTexture);
  }
  function setTextureCube(texture, slot) {
    const textureProperties = properties.get(texture);
    if (texture.version > 0 && textureProperties.__version !== texture.version) {
      uploadCubeTexture(textureProperties, texture, slot);
      return;
    }
    state.activeTexture(33984 + slot);
    state.bindTexture(34067, textureProperties.__webglTexture);
  }
  const wrappingToGL = {
    [RepeatWrapping]: 10497,
    [ClampToEdgeWrapping]: 33071,
    [MirroredRepeatWrapping]: 33648
  };
  const filterToGL = {
    [NearestFilter]: 9728,
    [NearestMipmapNearestFilter]: 9984,
    [NearestMipmapLinearFilter]: 9986,
    [LinearFilter]: 9729,
    [LinearMipmapNearestFilter]: 9985,
    [LinearMipmapLinearFilter]: 9987
  };
  function setTextureParameters(textureType, texture, supportsMips) {
    if (supportsMips) {
      _gl.texParameteri(textureType, 10242, wrappingToGL[texture.wrapS]);
      _gl.texParameteri(textureType, 10243, wrappingToGL[texture.wrapT]);
      if (textureType === 32879 || textureType === 35866) {
        _gl.texParameteri(textureType, 32882, wrappingToGL[texture.wrapR]);
      }
      _gl.texParameteri(textureType, 10240, filterToGL[texture.magFilter]);
      _gl.texParameteri(textureType, 10241, filterToGL[texture.minFilter]);
    } else {
      _gl.texParameteri(textureType, 10242, 33071);
      _gl.texParameteri(textureType, 10243, 33071);
      if (textureType === 32879 || textureType === 35866) {
        _gl.texParameteri(textureType, 32882, 33071);
      }
      if (texture.wrapS !== ClampToEdgeWrapping || texture.wrapT !== ClampToEdgeWrapping) {
        console.warn("THREE.WebGLRenderer: Texture is not power of two. Texture.wrapS and Texture.wrapT should be set to THREE.ClampToEdgeWrapping.");
      }
      _gl.texParameteri(textureType, 10240, filterFallback(texture.magFilter));
      _gl.texParameteri(textureType, 10241, filterFallback(texture.minFilter));
      if (texture.minFilter !== NearestFilter && texture.minFilter !== LinearFilter) {
        console.warn("THREE.WebGLRenderer: Texture is not power of two. Texture.minFilter should be set to THREE.NearestFilter or THREE.LinearFilter.");
      }
    }
    if (extensions.has("EXT_texture_filter_anisotropic") === true) {
      const extension = extensions.get("EXT_texture_filter_anisotropic");
      if (texture.type === FloatType && extensions.has("OES_texture_float_linear") === false)
        return;
      if (isWebGL2 === false && (texture.type === HalfFloatType && extensions.has("OES_texture_half_float_linear") === false))
        return;
      if (texture.anisotropy > 1 || properties.get(texture).__currentAnisotropy) {
        _gl.texParameterf(textureType, extension.TEXTURE_MAX_ANISOTROPY_EXT, Math.min(texture.anisotropy, capabilities.getMaxAnisotropy()));
        properties.get(texture).__currentAnisotropy = texture.anisotropy;
      }
    }
  }
  function initTexture(textureProperties, texture) {
    let forceUpload = false;
    if (textureProperties.__webglInit === void 0) {
      textureProperties.__webglInit = true;
      texture.addEventListener("dispose", onTextureDispose);
    }
    const source = texture.source;
    let webglTextures = _sources.get(source);
    if (webglTextures === void 0) {
      webglTextures = {};
      _sources.set(source, webglTextures);
    }
    const textureCacheKey = getTextureCacheKey(texture);
    if (textureCacheKey !== textureProperties.__cacheKey) {
      if (webglTextures[textureCacheKey] === void 0) {
        webglTextures[textureCacheKey] = {
          texture: _gl.createTexture(),
          usedTimes: 0
        };
        info.memory.textures++;
        forceUpload = true;
      }
      webglTextures[textureCacheKey].usedTimes++;
      const webglTexture = webglTextures[textureProperties.__cacheKey];
      if (webglTexture !== void 0) {
        webglTextures[textureProperties.__cacheKey].usedTimes--;
        if (webglTexture.usedTimes === 0) {
          deleteTexture(texture);
        }
      }
      textureProperties.__cacheKey = textureCacheKey;
      textureProperties.__webglTexture = webglTextures[textureCacheKey].texture;
    }
    return forceUpload;
  }
  function uploadTexture(textureProperties, texture, slot) {
    let textureType = 3553;
    if (texture.isDataArrayTexture)
      textureType = 35866;
    if (texture.isData3DTexture)
      textureType = 32879;
    const forceUpload = initTexture(textureProperties, texture);
    const source = texture.source;
    state.activeTexture(33984 + slot);
    state.bindTexture(textureType, textureProperties.__webglTexture);
    if (source.version !== source.__currentVersion || forceUpload === true) {
      _gl.pixelStorei(37440, texture.flipY);
      _gl.pixelStorei(37441, texture.premultiplyAlpha);
      _gl.pixelStorei(3317, texture.unpackAlignment);
      _gl.pixelStorei(37443, 0);
      const needsPowerOfTwo = textureNeedsPowerOfTwo(texture) && isPowerOfTwo$1(texture.image) === false;
      let image = resizeImage(texture.image, needsPowerOfTwo, false, maxTextureSize);
      image = verifyColorSpace(texture, image);
      const supportsMips = isPowerOfTwo$1(image) || isWebGL2, glFormat = utils.convert(texture.format, texture.encoding);
      let glType = utils.convert(texture.type), glInternalFormat = getInternalFormat(texture.internalFormat, glFormat, glType, texture.encoding, texture.isVideoTexture);
      setTextureParameters(textureType, texture, supportsMips);
      let mipmap;
      const mipmaps = texture.mipmaps;
      const useTexStorage = isWebGL2 && texture.isVideoTexture !== true;
      const allocateMemory = source.__currentVersion === void 0 || forceUpload === true;
      const levels = getMipLevels(texture, image, supportsMips);
      if (texture.isDepthTexture) {
        glInternalFormat = 6402;
        if (isWebGL2) {
          if (texture.type === FloatType) {
            glInternalFormat = 36012;
          } else if (texture.type === UnsignedIntType) {
            glInternalFormat = 33190;
          } else if (texture.type === UnsignedInt248Type) {
            glInternalFormat = 35056;
          } else {
            glInternalFormat = 33189;
          }
        } else {
          if (texture.type === FloatType) {
            console.error("WebGLRenderer: Floating point depth texture requires WebGL2.");
          }
        }
        if (texture.format === DepthFormat && glInternalFormat === 6402) {
          if (texture.type !== UnsignedShortType && texture.type !== UnsignedIntType) {
            console.warn("THREE.WebGLRenderer: Use UnsignedShortType or UnsignedIntType for DepthFormat DepthTexture.");
            texture.type = UnsignedIntType;
            glType = utils.convert(texture.type);
          }
        }
        if (texture.format === DepthStencilFormat && glInternalFormat === 6402) {
          glInternalFormat = 34041;
          if (texture.type !== UnsignedInt248Type) {
            console.warn("THREE.WebGLRenderer: Use UnsignedInt248Type for DepthStencilFormat DepthTexture.");
            texture.type = UnsignedInt248Type;
            glType = utils.convert(texture.type);
          }
        }
        if (allocateMemory) {
          if (useTexStorage) {
            state.texStorage2D(3553, 1, glInternalFormat, image.width, image.height);
          } else {
            state.texImage2D(3553, 0, glInternalFormat, image.width, image.height, 0, glFormat, glType, null);
          }
        }
      } else if (texture.isDataTexture) {
        if (mipmaps.length > 0 && supportsMips) {
          if (useTexStorage && allocateMemory) {
            state.texStorage2D(3553, levels, glInternalFormat, mipmaps[0].width, mipmaps[0].height);
          }
          for (let i2 = 0, il = mipmaps.length; i2 < il; i2++) {
            mipmap = mipmaps[i2];
            if (useTexStorage) {
              state.texSubImage2D(3553, i2, 0, 0, mipmap.width, mipmap.height, glFormat, glType, mipmap.data);
            } else {
              state.texImage2D(3553, i2, glInternalFormat, mipmap.width, mipmap.height, 0, glFormat, glType, mipmap.data);
            }
          }
          texture.generateMipmaps = false;
        } else {
          if (useTexStorage) {
            if (allocateMemory) {
              state.texStorage2D(3553, levels, glInternalFormat, image.width, image.height);
            }
            state.texSubImage2D(3553, 0, 0, 0, image.width, image.height, glFormat, glType, image.data);
          } else {
            state.texImage2D(3553, 0, glInternalFormat, image.width, image.height, 0, glFormat, glType, image.data);
          }
        }
      } else if (texture.isCompressedTexture) {
        if (useTexStorage && allocateMemory) {
          state.texStorage2D(3553, levels, glInternalFormat, mipmaps[0].width, mipmaps[0].height);
        }
        for (let i2 = 0, il = mipmaps.length; i2 < il; i2++) {
          mipmap = mipmaps[i2];
          if (texture.format !== RGBAFormat) {
            if (glFormat !== null) {
              if (useTexStorage) {
                state.compressedTexSubImage2D(3553, i2, 0, 0, mipmap.width, mipmap.height, glFormat, mipmap.data);
              } else {
                state.compressedTexImage2D(3553, i2, glInternalFormat, mipmap.width, mipmap.height, 0, mipmap.data);
              }
            } else {
              console.warn("THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .uploadTexture()");
            }
          } else {
            if (useTexStorage) {
              state.texSubImage2D(3553, i2, 0, 0, mipmap.width, mipmap.height, glFormat, glType, mipmap.data);
            } else {
              state.texImage2D(3553, i2, glInternalFormat, mipmap.width, mipmap.height, 0, glFormat, glType, mipmap.data);
            }
          }
        }
      } else if (texture.isDataArrayTexture) {
        if (useTexStorage) {
          if (allocateMemory) {
            state.texStorage3D(35866, levels, glInternalFormat, image.width, image.height, image.depth);
          }
          state.texSubImage3D(35866, 0, 0, 0, 0, image.width, image.height, image.depth, glFormat, glType, image.data);
        } else {
          state.texImage3D(35866, 0, glInternalFormat, image.width, image.height, image.depth, 0, glFormat, glType, image.data);
        }
      } else if (texture.isData3DTexture) {
        if (useTexStorage) {
          if (allocateMemory) {
            state.texStorage3D(32879, levels, glInternalFormat, image.width, image.height, image.depth);
          }
          state.texSubImage3D(32879, 0, 0, 0, 0, image.width, image.height, image.depth, glFormat, glType, image.data);
        } else {
          state.texImage3D(32879, 0, glInternalFormat, image.width, image.height, image.depth, 0, glFormat, glType, image.data);
        }
      } else if (texture.isFramebufferTexture) {
        if (allocateMemory) {
          if (useTexStorage) {
            state.texStorage2D(3553, levels, glInternalFormat, image.width, image.height);
          } else {
            let width = image.width, height = image.height;
            for (let i2 = 0; i2 < levels; i2++) {
              state.texImage2D(3553, i2, glInternalFormat, width, height, 0, glFormat, glType, null);
              width >>= 1;
              height >>= 1;
            }
          }
        }
      } else {
        if (mipmaps.length > 0 && supportsMips) {
          if (useTexStorage && allocateMemory) {
            state.texStorage2D(3553, levels, glInternalFormat, mipmaps[0].width, mipmaps[0].height);
          }
          for (let i2 = 0, il = mipmaps.length; i2 < il; i2++) {
            mipmap = mipmaps[i2];
            if (useTexStorage) {
              state.texSubImage2D(3553, i2, 0, 0, glFormat, glType, mipmap);
            } else {
              state.texImage2D(3553, i2, glInternalFormat, glFormat, glType, mipmap);
            }
          }
          texture.generateMipmaps = false;
        } else {
          if (useTexStorage) {
            if (allocateMemory) {
              state.texStorage2D(3553, levels, glInternalFormat, image.width, image.height);
            }
            state.texSubImage2D(3553, 0, 0, 0, glFormat, glType, image);
          } else {
            state.texImage2D(3553, 0, glInternalFormat, glFormat, glType, image);
          }
        }
      }
      if (textureNeedsGenerateMipmaps(texture, supportsMips)) {
        generateMipmap(textureType);
      }
      source.__currentVersion = source.version;
      if (texture.onUpdate)
        texture.onUpdate(texture);
    }
    textureProperties.__version = texture.version;
  }
  function uploadCubeTexture(textureProperties, texture, slot) {
    if (texture.image.length !== 6)
      return;
    const forceUpload = initTexture(textureProperties, texture);
    const source = texture.source;
    state.activeTexture(33984 + slot);
    state.bindTexture(34067, textureProperties.__webglTexture);
    if (source.version !== source.__currentVersion || forceUpload === true) {
      _gl.pixelStorei(37440, texture.flipY);
      _gl.pixelStorei(37441, texture.premultiplyAlpha);
      _gl.pixelStorei(3317, texture.unpackAlignment);
      _gl.pixelStorei(37443, 0);
      const isCompressed = texture.isCompressedTexture || texture.image[0].isCompressedTexture;
      const isDataTexture = texture.image[0] && texture.image[0].isDataTexture;
      const cubeImage = [];
      for (let i2 = 0; i2 < 6; i2++) {
        if (!isCompressed && !isDataTexture) {
          cubeImage[i2] = resizeImage(texture.image[i2], false, true, maxCubemapSize);
        } else {
          cubeImage[i2] = isDataTexture ? texture.image[i2].image : texture.image[i2];
        }
        cubeImage[i2] = verifyColorSpace(texture, cubeImage[i2]);
      }
      const image = cubeImage[0], supportsMips = isPowerOfTwo$1(image) || isWebGL2, glFormat = utils.convert(texture.format, texture.encoding), glType = utils.convert(texture.type), glInternalFormat = getInternalFormat(texture.internalFormat, glFormat, glType, texture.encoding);
      const useTexStorage = isWebGL2 && texture.isVideoTexture !== true;
      const allocateMemory = source.__currentVersion === void 0 || forceUpload === true;
      let levels = getMipLevels(texture, image, supportsMips);
      setTextureParameters(34067, texture, supportsMips);
      let mipmaps;
      if (isCompressed) {
        if (useTexStorage && allocateMemory) {
          state.texStorage2D(34067, levels, glInternalFormat, image.width, image.height);
        }
        for (let i2 = 0; i2 < 6; i2++) {
          mipmaps = cubeImage[i2].mipmaps;
          for (let j = 0; j < mipmaps.length; j++) {
            const mipmap = mipmaps[j];
            if (texture.format !== RGBAFormat) {
              if (glFormat !== null) {
                if (useTexStorage) {
                  state.compressedTexSubImage2D(34069 + i2, j, 0, 0, mipmap.width, mipmap.height, glFormat, mipmap.data);
                } else {
                  state.compressedTexImage2D(34069 + i2, j, glInternalFormat, mipmap.width, mipmap.height, 0, mipmap.data);
                }
              } else {
                console.warn("THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .setTextureCube()");
              }
            } else {
              if (useTexStorage) {
                state.texSubImage2D(34069 + i2, j, 0, 0, mipmap.width, mipmap.height, glFormat, glType, mipmap.data);
              } else {
                state.texImage2D(34069 + i2, j, glInternalFormat, mipmap.width, mipmap.height, 0, glFormat, glType, mipmap.data);
              }
            }
          }
        }
      } else {
        mipmaps = texture.mipmaps;
        if (useTexStorage && allocateMemory) {
          if (mipmaps.length > 0)
            levels++;
          state.texStorage2D(34067, levels, glInternalFormat, cubeImage[0].width, cubeImage[0].height);
        }
        for (let i2 = 0; i2 < 6; i2++) {
          if (isDataTexture) {
            if (useTexStorage) {
              state.texSubImage2D(34069 + i2, 0, 0, 0, cubeImage[i2].width, cubeImage[i2].height, glFormat, glType, cubeImage[i2].data);
            } else {
              state.texImage2D(34069 + i2, 0, glInternalFormat, cubeImage[i2].width, cubeImage[i2].height, 0, glFormat, glType, cubeImage[i2].data);
            }
            for (let j = 0; j < mipmaps.length; j++) {
              const mipmap = mipmaps[j];
              const mipmapImage = mipmap.image[i2].image;
              if (useTexStorage) {
                state.texSubImage2D(34069 + i2, j + 1, 0, 0, mipmapImage.width, mipmapImage.height, glFormat, glType, mipmapImage.data);
              } else {
                state.texImage2D(34069 + i2, j + 1, glInternalFormat, mipmapImage.width, mipmapImage.height, 0, glFormat, glType, mipmapImage.data);
              }
            }
          } else {
            if (useTexStorage) {
              state.texSubImage2D(34069 + i2, 0, 0, 0, glFormat, glType, cubeImage[i2]);
            } else {
              state.texImage2D(34069 + i2, 0, glInternalFormat, glFormat, glType, cubeImage[i2]);
            }
            for (let j = 0; j < mipmaps.length; j++) {
              const mipmap = mipmaps[j];
              if (useTexStorage) {
                state.texSubImage2D(34069 + i2, j + 1, 0, 0, glFormat, glType, mipmap.image[i2]);
              } else {
                state.texImage2D(34069 + i2, j + 1, glInternalFormat, glFormat, glType, mipmap.image[i2]);
              }
            }
          }
        }
      }
      if (textureNeedsGenerateMipmaps(texture, supportsMips)) {
        generateMipmap(34067);
      }
      source.__currentVersion = source.version;
      if (texture.onUpdate)
        texture.onUpdate(texture);
    }
    textureProperties.__version = texture.version;
  }
  function setupFrameBufferTexture(framebuffer, renderTarget, texture, attachment, textureTarget) {
    const glFormat = utils.convert(texture.format, texture.encoding);
    const glType = utils.convert(texture.type);
    const glInternalFormat = getInternalFormat(texture.internalFormat, glFormat, glType, texture.encoding);
    const renderTargetProperties = properties.get(renderTarget);
    if (!renderTargetProperties.__hasExternalTextures) {
      if (textureTarget === 32879 || textureTarget === 35866) {
        state.texImage3D(textureTarget, 0, glInternalFormat, renderTarget.width, renderTarget.height, renderTarget.depth, 0, glFormat, glType, null);
      } else {
        state.texImage2D(textureTarget, 0, glInternalFormat, renderTarget.width, renderTarget.height, 0, glFormat, glType, null);
      }
    }
    state.bindFramebuffer(36160, framebuffer);
    if (useMultisampledRTT(renderTarget)) {
      multisampledRTTExt.framebufferTexture2DMultisampleEXT(36160, attachment, textureTarget, properties.get(texture).__webglTexture, 0, getRenderTargetSamples(renderTarget));
    } else {
      _gl.framebufferTexture2D(36160, attachment, textureTarget, properties.get(texture).__webglTexture, 0);
    }
    state.bindFramebuffer(36160, null);
  }
  function setupRenderBufferStorage(renderbuffer, renderTarget, isMultisample) {
    _gl.bindRenderbuffer(36161, renderbuffer);
    if (renderTarget.depthBuffer && !renderTarget.stencilBuffer) {
      let glInternalFormat = 33189;
      if (isMultisample || useMultisampledRTT(renderTarget)) {
        const depthTexture = renderTarget.depthTexture;
        if (depthTexture && depthTexture.isDepthTexture) {
          if (depthTexture.type === FloatType) {
            glInternalFormat = 36012;
          } else if (depthTexture.type === UnsignedIntType) {
            glInternalFormat = 33190;
          }
        }
        const samples = getRenderTargetSamples(renderTarget);
        if (useMultisampledRTT(renderTarget)) {
          multisampledRTTExt.renderbufferStorageMultisampleEXT(36161, samples, glInternalFormat, renderTarget.width, renderTarget.height);
        } else {
          _gl.renderbufferStorageMultisample(36161, samples, glInternalFormat, renderTarget.width, renderTarget.height);
        }
      } else {
        _gl.renderbufferStorage(36161, glInternalFormat, renderTarget.width, renderTarget.height);
      }
      _gl.framebufferRenderbuffer(36160, 36096, 36161, renderbuffer);
    } else if (renderTarget.depthBuffer && renderTarget.stencilBuffer) {
      const samples = getRenderTargetSamples(renderTarget);
      if (isMultisample && useMultisampledRTT(renderTarget) === false) {
        _gl.renderbufferStorageMultisample(36161, samples, 35056, renderTarget.width, renderTarget.height);
      } else if (useMultisampledRTT(renderTarget)) {
        multisampledRTTExt.renderbufferStorageMultisampleEXT(36161, samples, 35056, renderTarget.width, renderTarget.height);
      } else {
        _gl.renderbufferStorage(36161, 34041, renderTarget.width, renderTarget.height);
      }
      _gl.framebufferRenderbuffer(36160, 33306, 36161, renderbuffer);
    } else {
      const textures = renderTarget.isWebGLMultipleRenderTargets === true ? renderTarget.texture : [renderTarget.texture];
      for (let i2 = 0; i2 < textures.length; i2++) {
        const texture = textures[i2];
        const glFormat = utils.convert(texture.format, texture.encoding);
        const glType = utils.convert(texture.type);
        const glInternalFormat = getInternalFormat(texture.internalFormat, glFormat, glType, texture.encoding);
        const samples = getRenderTargetSamples(renderTarget);
        if (isMultisample && useMultisampledRTT(renderTarget) === false) {
          _gl.renderbufferStorageMultisample(36161, samples, glInternalFormat, renderTarget.width, renderTarget.height);
        } else if (useMultisampledRTT(renderTarget)) {
          multisampledRTTExt.renderbufferStorageMultisampleEXT(36161, samples, glInternalFormat, renderTarget.width, renderTarget.height);
        } else {
          _gl.renderbufferStorage(36161, glInternalFormat, renderTarget.width, renderTarget.height);
        }
      }
    }
    _gl.bindRenderbuffer(36161, null);
  }
  function setupDepthTexture(framebuffer, renderTarget) {
    const isCube = renderTarget && renderTarget.isWebGLCubeRenderTarget;
    if (isCube)
      throw new Error("Depth Texture with cube render targets is not supported");
    state.bindFramebuffer(36160, framebuffer);
    if (!(renderTarget.depthTexture && renderTarget.depthTexture.isDepthTexture)) {
      throw new Error("renderTarget.depthTexture must be an instance of THREE.DepthTexture");
    }
    if (!properties.get(renderTarget.depthTexture).__webglTexture || renderTarget.depthTexture.image.width !== renderTarget.width || renderTarget.depthTexture.image.height !== renderTarget.height) {
      renderTarget.depthTexture.image.width = renderTarget.width;
      renderTarget.depthTexture.image.height = renderTarget.height;
      renderTarget.depthTexture.needsUpdate = true;
    }
    setTexture2D(renderTarget.depthTexture, 0);
    const webglDepthTexture = properties.get(renderTarget.depthTexture).__webglTexture;
    const samples = getRenderTargetSamples(renderTarget);
    if (renderTarget.depthTexture.format === DepthFormat) {
      if (useMultisampledRTT(renderTarget)) {
        multisampledRTTExt.framebufferTexture2DMultisampleEXT(36160, 36096, 3553, webglDepthTexture, 0, samples);
      } else {
        _gl.framebufferTexture2D(36160, 36096, 3553, webglDepthTexture, 0);
      }
    } else if (renderTarget.depthTexture.format === DepthStencilFormat) {
      if (useMultisampledRTT(renderTarget)) {
        multisampledRTTExt.framebufferTexture2DMultisampleEXT(36160, 33306, 3553, webglDepthTexture, 0, samples);
      } else {
        _gl.framebufferTexture2D(36160, 33306, 3553, webglDepthTexture, 0);
      }
    } else {
      throw new Error("Unknown depthTexture format");
    }
  }
  function setupDepthRenderbuffer(renderTarget) {
    const renderTargetProperties = properties.get(renderTarget);
    const isCube = renderTarget.isWebGLCubeRenderTarget === true;
    if (renderTarget.depthTexture && !renderTargetProperties.__autoAllocateDepthBuffer) {
      if (isCube)
        throw new Error("target.depthTexture not supported in Cube render targets");
      setupDepthTexture(renderTargetProperties.__webglFramebuffer, renderTarget);
    } else {
      if (isCube) {
        renderTargetProperties.__webglDepthbuffer = [];
        for (let i2 = 0; i2 < 6; i2++) {
          state.bindFramebuffer(36160, renderTargetProperties.__webglFramebuffer[i2]);
          renderTargetProperties.__webglDepthbuffer[i2] = _gl.createRenderbuffer();
          setupRenderBufferStorage(renderTargetProperties.__webglDepthbuffer[i2], renderTarget, false);
        }
      } else {
        state.bindFramebuffer(36160, renderTargetProperties.__webglFramebuffer);
        renderTargetProperties.__webglDepthbuffer = _gl.createRenderbuffer();
        setupRenderBufferStorage(renderTargetProperties.__webglDepthbuffer, renderTarget, false);
      }
    }
    state.bindFramebuffer(36160, null);
  }
  function rebindTextures(renderTarget, colorTexture, depthTexture) {
    const renderTargetProperties = properties.get(renderTarget);
    if (colorTexture !== void 0) {
      setupFrameBufferTexture(renderTargetProperties.__webglFramebuffer, renderTarget, renderTarget.texture, 36064, 3553);
    }
    if (depthTexture !== void 0) {
      setupDepthRenderbuffer(renderTarget);
    }
  }
  function setupRenderTarget(renderTarget) {
    const texture = renderTarget.texture;
    const renderTargetProperties = properties.get(renderTarget);
    const textureProperties = properties.get(texture);
    renderTarget.addEventListener("dispose", onRenderTargetDispose);
    if (renderTarget.isWebGLMultipleRenderTargets !== true) {
      if (textureProperties.__webglTexture === void 0) {
        textureProperties.__webglTexture = _gl.createTexture();
      }
      textureProperties.__version = texture.version;
      info.memory.textures++;
    }
    const isCube = renderTarget.isWebGLCubeRenderTarget === true;
    const isMultipleRenderTargets = renderTarget.isWebGLMultipleRenderTargets === true;
    const supportsMips = isPowerOfTwo$1(renderTarget) || isWebGL2;
    if (isCube) {
      renderTargetProperties.__webglFramebuffer = [];
      for (let i2 = 0; i2 < 6; i2++) {
        renderTargetProperties.__webglFramebuffer[i2] = _gl.createFramebuffer();
      }
    } else {
      renderTargetProperties.__webglFramebuffer = _gl.createFramebuffer();
      if (isMultipleRenderTargets) {
        if (capabilities.drawBuffers) {
          const textures = renderTarget.texture;
          for (let i2 = 0, il = textures.length; i2 < il; i2++) {
            const attachmentProperties = properties.get(textures[i2]);
            if (attachmentProperties.__webglTexture === void 0) {
              attachmentProperties.__webglTexture = _gl.createTexture();
              info.memory.textures++;
            }
          }
        } else {
          console.warn("THREE.WebGLRenderer: WebGLMultipleRenderTargets can only be used with WebGL2 or WEBGL_draw_buffers extension.");
        }
      }
      if (isWebGL2 && renderTarget.samples > 0 && useMultisampledRTT(renderTarget) === false) {
        const textures = isMultipleRenderTargets ? texture : [texture];
        renderTargetProperties.__webglMultisampledFramebuffer = _gl.createFramebuffer();
        renderTargetProperties.__webglColorRenderbuffer = [];
        state.bindFramebuffer(36160, renderTargetProperties.__webglMultisampledFramebuffer);
        for (let i2 = 0; i2 < textures.length; i2++) {
          const texture2 = textures[i2];
          renderTargetProperties.__webglColorRenderbuffer[i2] = _gl.createRenderbuffer();
          _gl.bindRenderbuffer(36161, renderTargetProperties.__webglColorRenderbuffer[i2]);
          const glFormat = utils.convert(texture2.format, texture2.encoding);
          const glType = utils.convert(texture2.type);
          const glInternalFormat = getInternalFormat(texture2.internalFormat, glFormat, glType, texture2.encoding);
          const samples = getRenderTargetSamples(renderTarget);
          _gl.renderbufferStorageMultisample(36161, samples, glInternalFormat, renderTarget.width, renderTarget.height);
          _gl.framebufferRenderbuffer(36160, 36064 + i2, 36161, renderTargetProperties.__webglColorRenderbuffer[i2]);
        }
        _gl.bindRenderbuffer(36161, null);
        if (renderTarget.depthBuffer) {
          renderTargetProperties.__webglDepthRenderbuffer = _gl.createRenderbuffer();
          setupRenderBufferStorage(renderTargetProperties.__webglDepthRenderbuffer, renderTarget, true);
        }
        state.bindFramebuffer(36160, null);
      }
    }
    if (isCube) {
      state.bindTexture(34067, textureProperties.__webglTexture);
      setTextureParameters(34067, texture, supportsMips);
      for (let i2 = 0; i2 < 6; i2++) {
        setupFrameBufferTexture(renderTargetProperties.__webglFramebuffer[i2], renderTarget, texture, 36064, 34069 + i2);
      }
      if (textureNeedsGenerateMipmaps(texture, supportsMips)) {
        generateMipmap(34067);
      }
      state.unbindTexture();
    } else if (isMultipleRenderTargets) {
      const textures = renderTarget.texture;
      for (let i2 = 0, il = textures.length; i2 < il; i2++) {
        const attachment = textures[i2];
        const attachmentProperties = properties.get(attachment);
        state.bindTexture(3553, attachmentProperties.__webglTexture);
        setTextureParameters(3553, attachment, supportsMips);
        setupFrameBufferTexture(renderTargetProperties.__webglFramebuffer, renderTarget, attachment, 36064 + i2, 3553);
        if (textureNeedsGenerateMipmaps(attachment, supportsMips)) {
          generateMipmap(3553);
        }
      }
      state.unbindTexture();
    } else {
      let glTextureType = 3553;
      if (renderTarget.isWebGL3DRenderTarget || renderTarget.isWebGLArrayRenderTarget) {
        if (isWebGL2) {
          glTextureType = renderTarget.isWebGL3DRenderTarget ? 32879 : 35866;
        } else {
          console.error("THREE.WebGLTextures: THREE.Data3DTexture and THREE.DataArrayTexture only supported with WebGL2.");
        }
      }
      state.bindTexture(glTextureType, textureProperties.__webglTexture);
      setTextureParameters(glTextureType, texture, supportsMips);
      setupFrameBufferTexture(renderTargetProperties.__webglFramebuffer, renderTarget, texture, 36064, glTextureType);
      if (textureNeedsGenerateMipmaps(texture, supportsMips)) {
        generateMipmap(glTextureType);
      }
      state.unbindTexture();
    }
    if (renderTarget.depthBuffer) {
      setupDepthRenderbuffer(renderTarget);
    }
  }
  function updateRenderTargetMipmap(renderTarget) {
    const supportsMips = isPowerOfTwo$1(renderTarget) || isWebGL2;
    const textures = renderTarget.isWebGLMultipleRenderTargets === true ? renderTarget.texture : [renderTarget.texture];
    for (let i2 = 0, il = textures.length; i2 < il; i2++) {
      const texture = textures[i2];
      if (textureNeedsGenerateMipmaps(texture, supportsMips)) {
        const target = renderTarget.isWebGLCubeRenderTarget ? 34067 : 3553;
        const webglTexture = properties.get(texture).__webglTexture;
        state.bindTexture(target, webglTexture);
        generateMipmap(target);
        state.unbindTexture();
      }
    }
  }
  function updateMultisampleRenderTarget(renderTarget) {
    if (isWebGL2 && renderTarget.samples > 0 && useMultisampledRTT(renderTarget) === false) {
      const textures = renderTarget.isWebGLMultipleRenderTargets ? renderTarget.texture : [renderTarget.texture];
      const width = renderTarget.width;
      const height = renderTarget.height;
      let mask = 16384;
      const invalidationArray = [];
      const depthStyle = renderTarget.stencilBuffer ? 33306 : 36096;
      const renderTargetProperties = properties.get(renderTarget);
      const isMultipleRenderTargets = renderTarget.isWebGLMultipleRenderTargets === true;
      if (isMultipleRenderTargets) {
        for (let i2 = 0; i2 < textures.length; i2++) {
          state.bindFramebuffer(36160, renderTargetProperties.__webglMultisampledFramebuffer);
          _gl.framebufferRenderbuffer(36160, 36064 + i2, 36161, null);
          state.bindFramebuffer(36160, renderTargetProperties.__webglFramebuffer);
          _gl.framebufferTexture2D(36009, 36064 + i2, 3553, null, 0);
        }
      }
      state.bindFramebuffer(36008, renderTargetProperties.__webglMultisampledFramebuffer);
      state.bindFramebuffer(36009, renderTargetProperties.__webglFramebuffer);
      for (let i2 = 0; i2 < textures.length; i2++) {
        invalidationArray.push(36064 + i2);
        if (renderTarget.depthBuffer) {
          invalidationArray.push(depthStyle);
        }
        const ignoreDepthValues = renderTargetProperties.__ignoreDepthValues !== void 0 ? renderTargetProperties.__ignoreDepthValues : false;
        if (ignoreDepthValues === false) {
          if (renderTarget.depthBuffer)
            mask |= 256;
          if (renderTarget.stencilBuffer)
            mask |= 1024;
        }
        if (isMultipleRenderTargets) {
          _gl.framebufferRenderbuffer(36008, 36064, 36161, renderTargetProperties.__webglColorRenderbuffer[i2]);
        }
        if (ignoreDepthValues === true) {
          _gl.invalidateFramebuffer(36008, [depthStyle]);
          _gl.invalidateFramebuffer(36009, [depthStyle]);
        }
        if (isMultipleRenderTargets) {
          const webglTexture = properties.get(textures[i2]).__webglTexture;
          _gl.framebufferTexture2D(36009, 36064, 3553, webglTexture, 0);
        }
        _gl.blitFramebuffer(0, 0, width, height, 0, 0, width, height, mask, 9728);
        if (supportsInvalidateFramebuffer) {
          _gl.invalidateFramebuffer(36008, invalidationArray);
        }
      }
      state.bindFramebuffer(36008, null);
      state.bindFramebuffer(36009, null);
      if (isMultipleRenderTargets) {
        for (let i2 = 0; i2 < textures.length; i2++) {
          state.bindFramebuffer(36160, renderTargetProperties.__webglMultisampledFramebuffer);
          _gl.framebufferRenderbuffer(36160, 36064 + i2, 36161, renderTargetProperties.__webglColorRenderbuffer[i2]);
          const webglTexture = properties.get(textures[i2]).__webglTexture;
          state.bindFramebuffer(36160, renderTargetProperties.__webglFramebuffer);
          _gl.framebufferTexture2D(36009, 36064 + i2, 3553, webglTexture, 0);
        }
      }
      state.bindFramebuffer(36009, renderTargetProperties.__webglMultisampledFramebuffer);
    }
  }
  function getRenderTargetSamples(renderTarget) {
    return Math.min(maxSamples, renderTarget.samples);
  }
  function useMultisampledRTT(renderTarget) {
    const renderTargetProperties = properties.get(renderTarget);
    return isWebGL2 && renderTarget.samples > 0 && extensions.has("WEBGL_multisampled_render_to_texture") === true && renderTargetProperties.__useRenderToTexture !== false;
  }
  function updateVideoTexture(texture) {
    const frame = info.render.frame;
    if (_videoTextures.get(texture) !== frame) {
      _videoTextures.set(texture, frame);
      texture.update();
    }
  }
  function verifyColorSpace(texture, image) {
    const encoding = texture.encoding;
    const format = texture.format;
    const type = texture.type;
    if (texture.isCompressedTexture === true || texture.isVideoTexture === true || texture.format === _SRGBAFormat)
      return image;
    if (encoding !== LinearEncoding) {
      if (encoding === sRGBEncoding) {
        if (isWebGL2 === false) {
          if (extensions.has("EXT_sRGB") === true && format === RGBAFormat) {
            texture.format = _SRGBAFormat;
            texture.minFilter = LinearFilter;
            texture.generateMipmaps = false;
          } else {
            image = ImageUtils.sRGBToLinear(image);
          }
        } else {
          if (format !== RGBAFormat || type !== UnsignedByteType) {
            console.warn("THREE.WebGLTextures: sRGB encoded textures have to use RGBAFormat and UnsignedByteType.");
          }
        }
      } else {
        console.error("THREE.WebGLTextures: Unsupported texture encoding:", encoding);
      }
    }
    return image;
  }
  this.allocateTextureUnit = allocateTextureUnit;
  this.resetTextureUnits = resetTextureUnits;
  this.setTexture2D = setTexture2D;
  this.setTexture2DArray = setTexture2DArray;
  this.setTexture3D = setTexture3D;
  this.setTextureCube = setTextureCube;
  this.rebindTextures = rebindTextures;
  this.setupRenderTarget = setupRenderTarget;
  this.updateRenderTargetMipmap = updateRenderTargetMipmap;
  this.updateMultisampleRenderTarget = updateMultisampleRenderTarget;
  this.setupDepthRenderbuffer = setupDepthRenderbuffer;
  this.setupFrameBufferTexture = setupFrameBufferTexture;
  this.useMultisampledRTT = useMultisampledRTT;
}
function WebGLUtils(gl, extensions, capabilities) {
  const isWebGL2 = capabilities.isWebGL2;
  function convert(p, encoding = null) {
    let extension;
    if (p === UnsignedByteType)
      return 5121;
    if (p === UnsignedShort4444Type)
      return 32819;
    if (p === UnsignedShort5551Type)
      return 32820;
    if (p === ByteType)
      return 5120;
    if (p === ShortType)
      return 5122;
    if (p === UnsignedShortType)
      return 5123;
    if (p === IntType)
      return 5124;
    if (p === UnsignedIntType)
      return 5125;
    if (p === FloatType)
      return 5126;
    if (p === HalfFloatType) {
      if (isWebGL2)
        return 5131;
      extension = extensions.get("OES_texture_half_float");
      if (extension !== null) {
        return extension.HALF_FLOAT_OES;
      } else {
        return null;
      }
    }
    if (p === AlphaFormat)
      return 6406;
    if (p === RGBAFormat)
      return 6408;
    if (p === LuminanceFormat)
      return 6409;
    if (p === LuminanceAlphaFormat)
      return 6410;
    if (p === DepthFormat)
      return 6402;
    if (p === DepthStencilFormat)
      return 34041;
    if (p === RedFormat)
      return 6403;
    if (p === RGBFormat) {
      console.warn("THREE.WebGLRenderer: THREE.RGBFormat has been removed. Use THREE.RGBAFormat instead. https://github.com/mrdoob/three.js/pull/23228");
      return 6408;
    }
    if (p === _SRGBAFormat) {
      extension = extensions.get("EXT_sRGB");
      if (extension !== null) {
        return extension.SRGB_ALPHA_EXT;
      } else {
        return null;
      }
    }
    if (p === RedIntegerFormat)
      return 36244;
    if (p === RGFormat)
      return 33319;
    if (p === RGIntegerFormat)
      return 33320;
    if (p === RGBAIntegerFormat)
      return 36249;
    if (p === RGB_S3TC_DXT1_Format || p === RGBA_S3TC_DXT1_Format || p === RGBA_S3TC_DXT3_Format || p === RGBA_S3TC_DXT5_Format) {
      if (encoding === sRGBEncoding) {
        extension = extensions.get("WEBGL_compressed_texture_s3tc_srgb");
        if (extension !== null) {
          if (p === RGB_S3TC_DXT1_Format)
            return extension.COMPRESSED_SRGB_S3TC_DXT1_EXT;
          if (p === RGBA_S3TC_DXT1_Format)
            return extension.COMPRESSED_SRGB_ALPHA_S3TC_DXT1_EXT;
          if (p === RGBA_S3TC_DXT3_Format)
            return extension.COMPRESSED_SRGB_ALPHA_S3TC_DXT3_EXT;
          if (p === RGBA_S3TC_DXT5_Format)
            return extension.COMPRESSED_SRGB_ALPHA_S3TC_DXT5_EXT;
        } else {
          return null;
        }
      } else {
        extension = extensions.get("WEBGL_compressed_texture_s3tc");
        if (extension !== null) {
          if (p === RGB_S3TC_DXT1_Format)
            return extension.COMPRESSED_RGB_S3TC_DXT1_EXT;
          if (p === RGBA_S3TC_DXT1_Format)
            return extension.COMPRESSED_RGBA_S3TC_DXT1_EXT;
          if (p === RGBA_S3TC_DXT3_Format)
            return extension.COMPRESSED_RGBA_S3TC_DXT3_EXT;
          if (p === RGBA_S3TC_DXT5_Format)
            return extension.COMPRESSED_RGBA_S3TC_DXT5_EXT;
        } else {
          return null;
        }
      }
    }
    if (p === RGB_PVRTC_4BPPV1_Format || p === RGB_PVRTC_2BPPV1_Format || p === RGBA_PVRTC_4BPPV1_Format || p === RGBA_PVRTC_2BPPV1_Format) {
      extension = extensions.get("WEBGL_compressed_texture_pvrtc");
      if (extension !== null) {
        if (p === RGB_PVRTC_4BPPV1_Format)
          return extension.COMPRESSED_RGB_PVRTC_4BPPV1_IMG;
        if (p === RGB_PVRTC_2BPPV1_Format)
          return extension.COMPRESSED_RGB_PVRTC_2BPPV1_IMG;
        if (p === RGBA_PVRTC_4BPPV1_Format)
          return extension.COMPRESSED_RGBA_PVRTC_4BPPV1_IMG;
        if (p === RGBA_PVRTC_2BPPV1_Format)
          return extension.COMPRESSED_RGBA_PVRTC_2BPPV1_IMG;
      } else {
        return null;
      }
    }
    if (p === RGB_ETC1_Format) {
      extension = extensions.get("WEBGL_compressed_texture_etc1");
      if (extension !== null) {
        return extension.COMPRESSED_RGB_ETC1_WEBGL;
      } else {
        return null;
      }
    }
    if (p === RGB_ETC2_Format || p === RGBA_ETC2_EAC_Format) {
      extension = extensions.get("WEBGL_compressed_texture_etc");
      if (extension !== null) {
        if (p === RGB_ETC2_Format)
          return encoding === sRGBEncoding ? extension.COMPRESSED_SRGB8_ETC2 : extension.COMPRESSED_RGB8_ETC2;
        if (p === RGBA_ETC2_EAC_Format)
          return encoding === sRGBEncoding ? extension.COMPRESSED_SRGB8_ALPHA8_ETC2_EAC : extension.COMPRESSED_RGBA8_ETC2_EAC;
      } else {
        return null;
      }
    }
    if (p === RGBA_ASTC_4x4_Format || p === RGBA_ASTC_5x4_Format || p === RGBA_ASTC_5x5_Format || p === RGBA_ASTC_6x5_Format || p === RGBA_ASTC_6x6_Format || p === RGBA_ASTC_8x5_Format || p === RGBA_ASTC_8x6_Format || p === RGBA_ASTC_8x8_Format || p === RGBA_ASTC_10x5_Format || p === RGBA_ASTC_10x6_Format || p === RGBA_ASTC_10x8_Format || p === RGBA_ASTC_10x10_Format || p === RGBA_ASTC_12x10_Format || p === RGBA_ASTC_12x12_Format) {
      extension = extensions.get("WEBGL_compressed_texture_astc");
      if (extension !== null) {
        if (p === RGBA_ASTC_4x4_Format)
          return encoding === sRGBEncoding ? extension.COMPRESSED_SRGB8_ALPHA8_ASTC_4x4_KHR : extension.COMPRESSED_RGBA_ASTC_4x4_KHR;
        if (p === RGBA_ASTC_5x4_Format)
          return encoding === sRGBEncoding ? extension.COMPRESSED_SRGB8_ALPHA8_ASTC_5x4_KHR : extension.COMPRESSED_RGBA_ASTC_5x4_KHR;
        if (p === RGBA_ASTC_5x5_Format)
          return encoding === sRGBEncoding ? extension.COMPRESSED_SRGB8_ALPHA8_ASTC_5x5_KHR : extension.COMPRESSED_RGBA_ASTC_5x5_KHR;
        if (p === RGBA_ASTC_6x5_Format)
          return encoding === sRGBEncoding ? extension.COMPRESSED_SRGB8_ALPHA8_ASTC_6x5_KHR : extension.COMPRESSED_RGBA_ASTC_6x5_KHR;
        if (p === RGBA_ASTC_6x6_Format)
          return encoding === sRGBEncoding ? extension.COMPRESSED_SRGB8_ALPHA8_ASTC_6x6_KHR : extension.COMPRESSED_RGBA_ASTC_6x6_KHR;
        if (p === RGBA_ASTC_8x5_Format)
          return encoding === sRGBEncoding ? extension.COMPRESSED_SRGB8_ALPHA8_ASTC_8x5_KHR : extension.COMPRESSED_RGBA_ASTC_8x5_KHR;
        if (p === RGBA_ASTC_8x6_Format)
          return encoding === sRGBEncoding ? extension.COMPRESSED_SRGB8_ALPHA8_ASTC_8x6_KHR : extension.COMPRESSED_RGBA_ASTC_8x6_KHR;
        if (p === RGBA_ASTC_8x8_Format)
          return encoding === sRGBEncoding ? extension.COMPRESSED_SRGB8_ALPHA8_ASTC_8x8_KHR : extension.COMPRESSED_RGBA_ASTC_8x8_KHR;
        if (p === RGBA_ASTC_10x5_Format)
          return encoding === sRGBEncoding ? extension.COMPRESSED_SRGB8_ALPHA8_ASTC_10x5_KHR : extension.COMPRESSED_RGBA_ASTC_10x5_KHR;
        if (p === RGBA_ASTC_10x6_Format)
          return encoding === sRGBEncoding ? extension.COMPRESSED_SRGB8_ALPHA8_ASTC_10x6_KHR : extension.COMPRESSED_RGBA_ASTC_10x6_KHR;
        if (p === RGBA_ASTC_10x8_Format)
          return encoding === sRGBEncoding ? extension.COMPRESSED_SRGB8_ALPHA8_ASTC_10x8_KHR : extension.COMPRESSED_RGBA_ASTC_10x8_KHR;
        if (p === RGBA_ASTC_10x10_Format)
          return encoding === sRGBEncoding ? extension.COMPRESSED_SRGB8_ALPHA8_ASTC_10x10_KHR : extension.COMPRESSED_RGBA_ASTC_10x10_KHR;
        if (p === RGBA_ASTC_12x10_Format)
          return encoding === sRGBEncoding ? extension.COMPRESSED_SRGB8_ALPHA8_ASTC_12x10_KHR : extension.COMPRESSED_RGBA_ASTC_12x10_KHR;
        if (p === RGBA_ASTC_12x12_Format)
          return encoding === sRGBEncoding ? extension.COMPRESSED_SRGB8_ALPHA8_ASTC_12x12_KHR : extension.COMPRESSED_RGBA_ASTC_12x12_KHR;
      } else {
        return null;
      }
    }
    if (p === RGBA_BPTC_Format) {
      extension = extensions.get("EXT_texture_compression_bptc");
      if (extension !== null) {
        if (p === RGBA_BPTC_Format)
          return encoding === sRGBEncoding ? extension.COMPRESSED_SRGB_ALPHA_BPTC_UNORM_EXT : extension.COMPRESSED_RGBA_BPTC_UNORM_EXT;
      } else {
        return null;
      }
    }
    if (p === UnsignedInt248Type) {
      if (isWebGL2)
        return 34042;
      extension = extensions.get("WEBGL_depth_texture");
      if (extension !== null) {
        return extension.UNSIGNED_INT_24_8_WEBGL;
      } else {
        return null;
      }
    }
    return gl[p] !== void 0 ? gl[p] : null;
  }
  return { convert };
}
var ArrayCamera = class extends PerspectiveCamera {
  constructor(array = []) {
    super();
    this.isArrayCamera = true;
    this.cameras = array;
  }
};
var Group = class extends Object3D {
  constructor() {
    super();
    this.isGroup = true;
    this.type = "Group";
  }
};
var _moveEvent = { type: "move" };
var WebXRController = class {
  constructor() {
    this._targetRay = null;
    this._grip = null;
    this._hand = null;
  }
  getHandSpace() {
    if (this._hand === null) {
      this._hand = new Group();
      this._hand.matrixAutoUpdate = false;
      this._hand.visible = false;
      this._hand.joints = {};
      this._hand.inputState = { pinching: false };
    }
    return this._hand;
  }
  getTargetRaySpace() {
    if (this._targetRay === null) {
      this._targetRay = new Group();
      this._targetRay.matrixAutoUpdate = false;
      this._targetRay.visible = false;
      this._targetRay.hasLinearVelocity = false;
      this._targetRay.linearVelocity = new Vector3();
      this._targetRay.hasAngularVelocity = false;
      this._targetRay.angularVelocity = new Vector3();
    }
    return this._targetRay;
  }
  getGripSpace() {
    if (this._grip === null) {
      this._grip = new Group();
      this._grip.matrixAutoUpdate = false;
      this._grip.visible = false;
      this._grip.hasLinearVelocity = false;
      this._grip.linearVelocity = new Vector3();
      this._grip.hasAngularVelocity = false;
      this._grip.angularVelocity = new Vector3();
    }
    return this._grip;
  }
  dispatchEvent(event) {
    if (this._targetRay !== null) {
      this._targetRay.dispatchEvent(event);
    }
    if (this._grip !== null) {
      this._grip.dispatchEvent(event);
    }
    if (this._hand !== null) {
      this._hand.dispatchEvent(event);
    }
    return this;
  }
  disconnect(inputSource) {
    this.dispatchEvent({ type: "disconnected", data: inputSource });
    if (this._targetRay !== null) {
      this._targetRay.visible = false;
    }
    if (this._grip !== null) {
      this._grip.visible = false;
    }
    if (this._hand !== null) {
      this._hand.visible = false;
    }
    return this;
  }
  update(inputSource, frame, referenceSpace) {
    let inputPose = null;
    let gripPose = null;
    let handPose = null;
    const targetRay = this._targetRay;
    const grip = this._grip;
    const hand = this._hand;
    if (inputSource && frame.session.visibilityState !== "visible-blurred") {
      if (hand && inputSource.hand) {
        handPose = true;
        for (const inputjoint of inputSource.hand.values()) {
          const jointPose = frame.getJointPose(inputjoint, referenceSpace);
          if (hand.joints[inputjoint.jointName] === void 0) {
            const joint2 = new Group();
            joint2.matrixAutoUpdate = false;
            joint2.visible = false;
            hand.joints[inputjoint.jointName] = joint2;
            hand.add(joint2);
          }
          const joint = hand.joints[inputjoint.jointName];
          if (jointPose !== null) {
            joint.matrix.fromArray(jointPose.transform.matrix);
            joint.matrix.decompose(joint.position, joint.rotation, joint.scale);
            joint.jointRadius = jointPose.radius;
          }
          joint.visible = jointPose !== null;
        }
        const indexTip = hand.joints["index-finger-tip"];
        const thumbTip = hand.joints["thumb-tip"];
        const distance = indexTip.position.distanceTo(thumbTip.position);
        const distanceToPinch = 0.02;
        const threshold = 5e-3;
        if (hand.inputState.pinching && distance > distanceToPinch + threshold) {
          hand.inputState.pinching = false;
          this.dispatchEvent({
            type: "pinchend",
            handedness: inputSource.handedness,
            target: this
          });
        } else if (!hand.inputState.pinching && distance <= distanceToPinch - threshold) {
          hand.inputState.pinching = true;
          this.dispatchEvent({
            type: "pinchstart",
            handedness: inputSource.handedness,
            target: this
          });
        }
      } else {
        if (grip !== null && inputSource.gripSpace) {
          gripPose = frame.getPose(inputSource.gripSpace, referenceSpace);
          if (gripPose !== null) {
            grip.matrix.fromArray(gripPose.transform.matrix);
            grip.matrix.decompose(grip.position, grip.rotation, grip.scale);
            if (gripPose.linearVelocity) {
              grip.hasLinearVelocity = true;
              grip.linearVelocity.copy(gripPose.linearVelocity);
            } else {
              grip.hasLinearVelocity = false;
            }
            if (gripPose.angularVelocity) {
              grip.hasAngularVelocity = true;
              grip.angularVelocity.copy(gripPose.angularVelocity);
            } else {
              grip.hasAngularVelocity = false;
            }
          }
        }
      }
      if (targetRay !== null) {
        inputPose = frame.getPose(inputSource.targetRaySpace, referenceSpace);
        if (inputPose === null && gripPose !== null) {
          inputPose = gripPose;
        }
        if (inputPose !== null) {
          targetRay.matrix.fromArray(inputPose.transform.matrix);
          targetRay.matrix.decompose(targetRay.position, targetRay.rotation, targetRay.scale);
          if (inputPose.linearVelocity) {
            targetRay.hasLinearVelocity = true;
            targetRay.linearVelocity.copy(inputPose.linearVelocity);
          } else {
            targetRay.hasLinearVelocity = false;
          }
          if (inputPose.angularVelocity) {
            targetRay.hasAngularVelocity = true;
            targetRay.angularVelocity.copy(inputPose.angularVelocity);
          } else {
            targetRay.hasAngularVelocity = false;
          }
          this.dispatchEvent(_moveEvent);
        }
      }
    }
    if (targetRay !== null) {
      targetRay.visible = inputPose !== null;
    }
    if (grip !== null) {
      grip.visible = gripPose !== null;
    }
    if (hand !== null) {
      hand.visible = handPose !== null;
    }
    return this;
  }
};
var DepthTexture = class extends Texture {
  constructor(width, height, type, mapping, wrapS, wrapT, magFilter, minFilter, anisotropy, format) {
    format = format !== void 0 ? format : DepthFormat;
    if (format !== DepthFormat && format !== DepthStencilFormat) {
      throw new Error("DepthTexture format must be either THREE.DepthFormat or THREE.DepthStencilFormat");
    }
    if (type === void 0 && format === DepthFormat)
      type = UnsignedIntType;
    if (type === void 0 && format === DepthStencilFormat)
      type = UnsignedInt248Type;
    super(null, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy);
    this.isDepthTexture = true;
    this.image = { width, height };
    this.magFilter = magFilter !== void 0 ? magFilter : NearestFilter;
    this.minFilter = minFilter !== void 0 ? minFilter : NearestFilter;
    this.flipY = false;
    this.generateMipmaps = false;
  }
};
var WebXRManager = class extends EventDispatcher {
  constructor(renderer, gl) {
    super();
    const scope = this;
    let session = null;
    let framebufferScaleFactor = 1;
    let referenceSpace = null;
    let referenceSpaceType = "local-floor";
    let customReferenceSpace = null;
    let pose = null;
    let glBinding = null;
    let glProjLayer = null;
    let glBaseLayer = null;
    let xrFrame = null;
    const attributes = gl.getContextAttributes();
    let initialRenderTarget = null;
    let newRenderTarget = null;
    const controllers = [];
    const controllerInputSources = [];
    const cameraL = new PerspectiveCamera();
    cameraL.layers.enable(1);
    cameraL.viewport = new Vector4();
    const cameraR = new PerspectiveCamera();
    cameraR.layers.enable(2);
    cameraR.viewport = new Vector4();
    const cameras = [cameraL, cameraR];
    const cameraVR = new ArrayCamera();
    cameraVR.layers.enable(1);
    cameraVR.layers.enable(2);
    let _currentDepthNear = null;
    let _currentDepthFar = null;
    this.cameraAutoUpdate = true;
    this.enabled = false;
    this.isPresenting = false;
    this.getController = function(index) {
      let controller = controllers[index];
      if (controller === void 0) {
        controller = new WebXRController();
        controllers[index] = controller;
      }
      return controller.getTargetRaySpace();
    };
    this.getControllerGrip = function(index) {
      let controller = controllers[index];
      if (controller === void 0) {
        controller = new WebXRController();
        controllers[index] = controller;
      }
      return controller.getGripSpace();
    };
    this.getHand = function(index) {
      let controller = controllers[index];
      if (controller === void 0) {
        controller = new WebXRController();
        controllers[index] = controller;
      }
      return controller.getHandSpace();
    };
    function onSessionEvent(event) {
      const controllerIndex = controllerInputSources.indexOf(event.inputSource);
      if (controllerIndex === -1) {
        return;
      }
      const controller = controllers[controllerIndex];
      if (controller !== void 0) {
        controller.dispatchEvent({ type: event.type, data: event.inputSource });
      }
    }
    function onSessionEnd() {
      session.removeEventListener("select", onSessionEvent);
      session.removeEventListener("selectstart", onSessionEvent);
      session.removeEventListener("selectend", onSessionEvent);
      session.removeEventListener("squeeze", onSessionEvent);
      session.removeEventListener("squeezestart", onSessionEvent);
      session.removeEventListener("squeezeend", onSessionEvent);
      session.removeEventListener("end", onSessionEnd);
      session.removeEventListener("inputsourceschange", onInputSourcesChange);
      for (let i2 = 0; i2 < controllers.length; i2++) {
        const inputSource = controllerInputSources[i2];
        if (inputSource === null)
          continue;
        controllerInputSources[i2] = null;
        controllers[i2].disconnect(inputSource);
      }
      _currentDepthNear = null;
      _currentDepthFar = null;
      renderer.setRenderTarget(initialRenderTarget);
      glBaseLayer = null;
      glProjLayer = null;
      glBinding = null;
      session = null;
      newRenderTarget = null;
      animation.stop();
      scope.isPresenting = false;
      scope.dispatchEvent({ type: "sessionend" });
    }
    this.setFramebufferScaleFactor = function(value) {
      framebufferScaleFactor = value;
      if (scope.isPresenting === true) {
        console.warn("THREE.WebXRManager: Cannot change framebuffer scale while presenting.");
      }
    };
    this.setReferenceSpaceType = function(value) {
      referenceSpaceType = value;
      if (scope.isPresenting === true) {
        console.warn("THREE.WebXRManager: Cannot change reference space type while presenting.");
      }
    };
    this.getReferenceSpace = function() {
      return customReferenceSpace || referenceSpace;
    };
    this.setReferenceSpace = function(space) {
      customReferenceSpace = space;
    };
    this.getBaseLayer = function() {
      return glProjLayer !== null ? glProjLayer : glBaseLayer;
    };
    this.getBinding = function() {
      return glBinding;
    };
    this.getFrame = function() {
      return xrFrame;
    };
    this.getSession = function() {
      return session;
    };
    this.setSession = async function(value) {
      session = value;
      if (session !== null) {
        initialRenderTarget = renderer.getRenderTarget();
        session.addEventListener("select", onSessionEvent);
        session.addEventListener("selectstart", onSessionEvent);
        session.addEventListener("selectend", onSessionEvent);
        session.addEventListener("squeeze", onSessionEvent);
        session.addEventListener("squeezestart", onSessionEvent);
        session.addEventListener("squeezeend", onSessionEvent);
        session.addEventListener("end", onSessionEnd);
        session.addEventListener("inputsourceschange", onInputSourcesChange);
        if (attributes.xrCompatible !== true) {
          await gl.makeXRCompatible();
        }
        if (session.renderState.layers === void 0 || renderer.capabilities.isWebGL2 === false) {
          const layerInit = {
            antialias: session.renderState.layers === void 0 ? attributes.antialias : true,
            alpha: attributes.alpha,
            depth: attributes.depth,
            stencil: attributes.stencil,
            framebufferScaleFactor
          };
          glBaseLayer = new XRWebGLLayer(session, gl, layerInit);
          session.updateRenderState({ baseLayer: glBaseLayer });
          newRenderTarget = new WebGLRenderTarget(
            glBaseLayer.framebufferWidth,
            glBaseLayer.framebufferHeight,
            {
              format: RGBAFormat,
              type: UnsignedByteType,
              encoding: renderer.outputEncoding
            }
          );
        } else {
          let depthFormat = null;
          let depthType = null;
          let glDepthFormat = null;
          if (attributes.depth) {
            glDepthFormat = attributes.stencil ? 35056 : 33190;
            depthFormat = attributes.stencil ? DepthStencilFormat : DepthFormat;
            depthType = attributes.stencil ? UnsignedInt248Type : UnsignedIntType;
          }
          const projectionlayerInit = {
            colorFormat: 32856,
            depthFormat: glDepthFormat,
            scaleFactor: framebufferScaleFactor
          };
          glBinding = new XRWebGLBinding(session, gl);
          glProjLayer = glBinding.createProjectionLayer(projectionlayerInit);
          session.updateRenderState({ layers: [glProjLayer] });
          newRenderTarget = new WebGLRenderTarget(
            glProjLayer.textureWidth,
            glProjLayer.textureHeight,
            {
              format: RGBAFormat,
              type: UnsignedByteType,
              depthTexture: new DepthTexture(glProjLayer.textureWidth, glProjLayer.textureHeight, depthType, void 0, void 0, void 0, void 0, void 0, void 0, depthFormat),
              stencilBuffer: attributes.stencil,
              encoding: renderer.outputEncoding,
              samples: attributes.antialias ? 4 : 0
            }
          );
          const renderTargetProperties = renderer.properties.get(newRenderTarget);
          renderTargetProperties.__ignoreDepthValues = glProjLayer.ignoreDepthValues;
        }
        newRenderTarget.isXRRenderTarget = true;
        this.setFoveation(1);
        customReferenceSpace = null;
        referenceSpace = await session.requestReferenceSpace(referenceSpaceType);
        animation.setContext(session);
        animation.start();
        scope.isPresenting = true;
        scope.dispatchEvent({ type: "sessionstart" });
      }
    };
    function onInputSourcesChange(event) {
      for (let i2 = 0; i2 < event.removed.length; i2++) {
        const inputSource = event.removed[i2];
        const index = controllerInputSources.indexOf(inputSource);
        if (index >= 0) {
          controllerInputSources[index] = null;
          controllers[index].dispatchEvent({ type: "disconnected", data: inputSource });
        }
      }
      for (let i2 = 0; i2 < event.added.length; i2++) {
        const inputSource = event.added[i2];
        let controllerIndex = controllerInputSources.indexOf(inputSource);
        if (controllerIndex === -1) {
          for (let i3 = 0; i3 < controllers.length; i3++) {
            if (i3 >= controllerInputSources.length) {
              controllerInputSources.push(inputSource);
              controllerIndex = i3;
              break;
            } else if (controllerInputSources[i3] === null) {
              controllerInputSources[i3] = inputSource;
              controllerIndex = i3;
              break;
            }
          }
          if (controllerIndex === -1)
            break;
        }
        const controller = controllers[controllerIndex];
        if (controller) {
          controller.dispatchEvent({ type: "connected", data: inputSource });
        }
      }
    }
    const cameraLPos = new Vector3();
    const cameraRPos = new Vector3();
    function setProjectionFromUnion(camera, cameraL2, cameraR2) {
      cameraLPos.setFromMatrixPosition(cameraL2.matrixWorld);
      cameraRPos.setFromMatrixPosition(cameraR2.matrixWorld);
      const ipd = cameraLPos.distanceTo(cameraRPos);
      const projL = cameraL2.projectionMatrix.elements;
      const projR = cameraR2.projectionMatrix.elements;
      const near = projL[14] / (projL[10] - 1);
      const far = projL[14] / (projL[10] + 1);
      const topFov = (projL[9] + 1) / projL[5];
      const bottomFov = (projL[9] - 1) / projL[5];
      const leftFov = (projL[8] - 1) / projL[0];
      const rightFov = (projR[8] + 1) / projR[0];
      const left = near * leftFov;
      const right = near * rightFov;
      const zOffset = ipd / (-leftFov + rightFov);
      const xOffset = zOffset * -leftFov;
      cameraL2.matrixWorld.decompose(camera.position, camera.quaternion, camera.scale);
      camera.translateX(xOffset);
      camera.translateZ(zOffset);
      camera.matrixWorld.compose(camera.position, camera.quaternion, camera.scale);
      camera.matrixWorldInverse.copy(camera.matrixWorld).invert();
      const near2 = near + zOffset;
      const far2 = far + zOffset;
      const left2 = left - xOffset;
      const right2 = right + (ipd - xOffset);
      const top2 = topFov * far / far2 * near2;
      const bottom2 = bottomFov * far / far2 * near2;
      camera.projectionMatrix.makePerspective(left2, right2, top2, bottom2, near2, far2);
    }
    function updateCamera(camera, parent) {
      if (parent === null) {
        camera.matrixWorld.copy(camera.matrix);
      } else {
        camera.matrixWorld.multiplyMatrices(parent.matrixWorld, camera.matrix);
      }
      camera.matrixWorldInverse.copy(camera.matrixWorld).invert();
    }
    this.updateCamera = function(camera) {
      if (session === null)
        return;
      cameraVR.near = cameraR.near = cameraL.near = camera.near;
      cameraVR.far = cameraR.far = cameraL.far = camera.far;
      if (_currentDepthNear !== cameraVR.near || _currentDepthFar !== cameraVR.far) {
        session.updateRenderState({
          depthNear: cameraVR.near,
          depthFar: cameraVR.far
        });
        _currentDepthNear = cameraVR.near;
        _currentDepthFar = cameraVR.far;
      }
      const parent = camera.parent;
      const cameras2 = cameraVR.cameras;
      updateCamera(cameraVR, parent);
      for (let i2 = 0; i2 < cameras2.length; i2++) {
        updateCamera(cameras2[i2], parent);
      }
      cameraVR.matrixWorld.decompose(cameraVR.position, cameraVR.quaternion, cameraVR.scale);
      camera.position.copy(cameraVR.position);
      camera.quaternion.copy(cameraVR.quaternion);
      camera.scale.copy(cameraVR.scale);
      camera.matrix.copy(cameraVR.matrix);
      camera.matrixWorld.copy(cameraVR.matrixWorld);
      const children = camera.children;
      for (let i2 = 0, l = children.length; i2 < l; i2++) {
        children[i2].updateMatrixWorld(true);
      }
      if (cameras2.length === 2) {
        setProjectionFromUnion(cameraVR, cameraL, cameraR);
      } else {
        cameraVR.projectionMatrix.copy(cameraL.projectionMatrix);
      }
    };
    this.getCamera = function() {
      return cameraVR;
    };
    this.getFoveation = function() {
      if (glProjLayer !== null) {
        return glProjLayer.fixedFoveation;
      }
      if (glBaseLayer !== null) {
        return glBaseLayer.fixedFoveation;
      }
      return void 0;
    };
    this.setFoveation = function(foveation) {
      if (glProjLayer !== null) {
        glProjLayer.fixedFoveation = foveation;
      }
      if (glBaseLayer !== null && glBaseLayer.fixedFoveation !== void 0) {
        glBaseLayer.fixedFoveation = foveation;
      }
    };
    let onAnimationFrameCallback = null;
    function onAnimationFrame(time, frame) {
      pose = frame.getViewerPose(customReferenceSpace || referenceSpace);
      xrFrame = frame;
      if (pose !== null) {
        const views = pose.views;
        if (glBaseLayer !== null) {
          renderer.setRenderTargetFramebuffer(newRenderTarget, glBaseLayer.framebuffer);
          renderer.setRenderTarget(newRenderTarget);
        }
        let cameraVRNeedsUpdate = false;
        if (views.length !== cameraVR.cameras.length) {
          cameraVR.cameras.length = 0;
          cameraVRNeedsUpdate = true;
        }
        for (let i2 = 0; i2 < views.length; i2++) {
          const view = views[i2];
          let viewport = null;
          if (glBaseLayer !== null) {
            viewport = glBaseLayer.getViewport(view);
          } else {
            const glSubImage = glBinding.getViewSubImage(glProjLayer, view);
            viewport = glSubImage.viewport;
            if (i2 === 0) {
              renderer.setRenderTargetTextures(
                newRenderTarget,
                glSubImage.colorTexture,
                glProjLayer.ignoreDepthValues ? void 0 : glSubImage.depthStencilTexture
              );
              renderer.setRenderTarget(newRenderTarget);
            }
          }
          let camera = cameras[i2];
          if (camera === void 0) {
            camera = new PerspectiveCamera();
            camera.layers.enable(i2);
            camera.viewport = new Vector4();
            cameras[i2] = camera;
          }
          camera.matrix.fromArray(view.transform.matrix);
          camera.projectionMatrix.fromArray(view.projectionMatrix);
          camera.viewport.set(viewport.x, viewport.y, viewport.width, viewport.height);
          if (i2 === 0) {
            cameraVR.matrix.copy(camera.matrix);
          }
          if (cameraVRNeedsUpdate === true) {
            cameraVR.cameras.push(camera);
          }
        }
      }
      for (let i2 = 0; i2 < controllers.length; i2++) {
        const inputSource = controllerInputSources[i2];
        const controller = controllers[i2];
        if (inputSource !== null && controller !== void 0) {
          controller.update(inputSource, frame, customReferenceSpace || referenceSpace);
        }
      }
      if (onAnimationFrameCallback)
        onAnimationFrameCallback(time, frame);
      xrFrame = null;
    }
    const animation = new WebGLAnimation();
    animation.setAnimationLoop(onAnimationFrame);
    this.setAnimationLoop = function(callback) {
      onAnimationFrameCallback = callback;
    };
    this.dispose = function() {
    };
  }
};
function WebGLMaterials(renderer, properties) {
  function refreshFogUniforms(uniforms, fog) {
    uniforms.fogColor.value.copy(fog.color);
    if (fog.isFog) {
      uniforms.fogNear.value = fog.near;
      uniforms.fogFar.value = fog.far;
    } else if (fog.isFogExp2) {
      uniforms.fogDensity.value = fog.density;
    }
  }
  function refreshMaterialUniforms(uniforms, material, pixelRatio, height, transmissionRenderTarget) {
    if (material.isMeshBasicMaterial) {
      refreshUniformsCommon(uniforms, material);
    } else if (material.isMeshLambertMaterial) {
      refreshUniformsCommon(uniforms, material);
    } else if (material.isMeshToonMaterial) {
      refreshUniformsCommon(uniforms, material);
      refreshUniformsToon(uniforms, material);
    } else if (material.isMeshPhongMaterial) {
      refreshUniformsCommon(uniforms, material);
      refreshUniformsPhong(uniforms, material);
    } else if (material.isMeshStandardMaterial) {
      refreshUniformsCommon(uniforms, material);
      refreshUniformsStandard(uniforms, material);
      if (material.isMeshPhysicalMaterial) {
        refreshUniformsPhysical(uniforms, material, transmissionRenderTarget);
      }
    } else if (material.isMeshMatcapMaterial) {
      refreshUniformsCommon(uniforms, material);
      refreshUniformsMatcap(uniforms, material);
    } else if (material.isMeshDepthMaterial) {
      refreshUniformsCommon(uniforms, material);
    } else if (material.isMeshDistanceMaterial) {
      refreshUniformsCommon(uniforms, material);
      refreshUniformsDistance(uniforms, material);
    } else if (material.isMeshNormalMaterial) {
      refreshUniformsCommon(uniforms, material);
    } else if (material.isLineBasicMaterial) {
      refreshUniformsLine(uniforms, material);
      if (material.isLineDashedMaterial) {
        refreshUniformsDash(uniforms, material);
      }
    } else if (material.isPointsMaterial) {
      refreshUniformsPoints(uniforms, material, pixelRatio, height);
    } else if (material.isSpriteMaterial) {
      refreshUniformsSprites(uniforms, material);
    } else if (material.isShadowMaterial) {
      uniforms.color.value.copy(material.color);
      uniforms.opacity.value = material.opacity;
    } else if (material.isShaderMaterial) {
      material.uniformsNeedUpdate = false;
    }
  }
  function refreshUniformsCommon(uniforms, material) {
    uniforms.opacity.value = material.opacity;
    if (material.color) {
      uniforms.diffuse.value.copy(material.color);
    }
    if (material.emissive) {
      uniforms.emissive.value.copy(material.emissive).multiplyScalar(material.emissiveIntensity);
    }
    if (material.map) {
      uniforms.map.value = material.map;
    }
    if (material.alphaMap) {
      uniforms.alphaMap.value = material.alphaMap;
    }
    if (material.bumpMap) {
      uniforms.bumpMap.value = material.bumpMap;
      uniforms.bumpScale.value = material.bumpScale;
      if (material.side === BackSide)
        uniforms.bumpScale.value *= -1;
    }
    if (material.displacementMap) {
      uniforms.displacementMap.value = material.displacementMap;
      uniforms.displacementScale.value = material.displacementScale;
      uniforms.displacementBias.value = material.displacementBias;
    }
    if (material.emissiveMap) {
      uniforms.emissiveMap.value = material.emissiveMap;
    }
    if (material.normalMap) {
      uniforms.normalMap.value = material.normalMap;
      uniforms.normalScale.value.copy(material.normalScale);
      if (material.side === BackSide)
        uniforms.normalScale.value.negate();
    }
    if (material.specularMap) {
      uniforms.specularMap.value = material.specularMap;
    }
    if (material.alphaTest > 0) {
      uniforms.alphaTest.value = material.alphaTest;
    }
    const envMap = properties.get(material).envMap;
    if (envMap) {
      uniforms.envMap.value = envMap;
      uniforms.flipEnvMap.value = envMap.isCubeTexture && envMap.isRenderTargetTexture === false ? -1 : 1;
      uniforms.reflectivity.value = material.reflectivity;
      uniforms.ior.value = material.ior;
      uniforms.refractionRatio.value = material.refractionRatio;
    }
    if (material.lightMap) {
      uniforms.lightMap.value = material.lightMap;
      const scaleFactor = renderer.physicallyCorrectLights !== true ? Math.PI : 1;
      uniforms.lightMapIntensity.value = material.lightMapIntensity * scaleFactor;
    }
    if (material.aoMap) {
      uniforms.aoMap.value = material.aoMap;
      uniforms.aoMapIntensity.value = material.aoMapIntensity;
    }
    let uvScaleMap;
    if (material.map) {
      uvScaleMap = material.map;
    } else if (material.specularMap) {
      uvScaleMap = material.specularMap;
    } else if (material.displacementMap) {
      uvScaleMap = material.displacementMap;
    } else if (material.normalMap) {
      uvScaleMap = material.normalMap;
    } else if (material.bumpMap) {
      uvScaleMap = material.bumpMap;
    } else if (material.roughnessMap) {
      uvScaleMap = material.roughnessMap;
    } else if (material.metalnessMap) {
      uvScaleMap = material.metalnessMap;
    } else if (material.alphaMap) {
      uvScaleMap = material.alphaMap;
    } else if (material.emissiveMap) {
      uvScaleMap = material.emissiveMap;
    } else if (material.clearcoatMap) {
      uvScaleMap = material.clearcoatMap;
    } else if (material.clearcoatNormalMap) {
      uvScaleMap = material.clearcoatNormalMap;
    } else if (material.clearcoatRoughnessMap) {
      uvScaleMap = material.clearcoatRoughnessMap;
    } else if (material.iridescenceMap) {
      uvScaleMap = material.iridescenceMap;
    } else if (material.iridescenceThicknessMap) {
      uvScaleMap = material.iridescenceThicknessMap;
    } else if (material.specularIntensityMap) {
      uvScaleMap = material.specularIntensityMap;
    } else if (material.specularColorMap) {
      uvScaleMap = material.specularColorMap;
    } else if (material.transmissionMap) {
      uvScaleMap = material.transmissionMap;
    } else if (material.thicknessMap) {
      uvScaleMap = material.thicknessMap;
    } else if (material.sheenColorMap) {
      uvScaleMap = material.sheenColorMap;
    } else if (material.sheenRoughnessMap) {
      uvScaleMap = material.sheenRoughnessMap;
    }
    if (uvScaleMap !== void 0) {
      if (uvScaleMap.isWebGLRenderTarget) {
        uvScaleMap = uvScaleMap.texture;
      }
      if (uvScaleMap.matrixAutoUpdate === true) {
        uvScaleMap.updateMatrix();
      }
      uniforms.uvTransform.value.copy(uvScaleMap.matrix);
    }
    let uv2ScaleMap;
    if (material.aoMap) {
      uv2ScaleMap = material.aoMap;
    } else if (material.lightMap) {
      uv2ScaleMap = material.lightMap;
    }
    if (uv2ScaleMap !== void 0) {
      if (uv2ScaleMap.isWebGLRenderTarget) {
        uv2ScaleMap = uv2ScaleMap.texture;
      }
      if (uv2ScaleMap.matrixAutoUpdate === true) {
        uv2ScaleMap.updateMatrix();
      }
      uniforms.uv2Transform.value.copy(uv2ScaleMap.matrix);
    }
  }
  function refreshUniformsLine(uniforms, material) {
    uniforms.diffuse.value.copy(material.color);
    uniforms.opacity.value = material.opacity;
  }
  function refreshUniformsDash(uniforms, material) {
    uniforms.dashSize.value = material.dashSize;
    uniforms.totalSize.value = material.dashSize + material.gapSize;
    uniforms.scale.value = material.scale;
  }
  function refreshUniformsPoints(uniforms, material, pixelRatio, height) {
    uniforms.diffuse.value.copy(material.color);
    uniforms.opacity.value = material.opacity;
    uniforms.size.value = material.size * pixelRatio;
    uniforms.scale.value = height * 0.5;
    if (material.map) {
      uniforms.map.value = material.map;
    }
    if (material.alphaMap) {
      uniforms.alphaMap.value = material.alphaMap;
    }
    if (material.alphaTest > 0) {
      uniforms.alphaTest.value = material.alphaTest;
    }
    let uvScaleMap;
    if (material.map) {
      uvScaleMap = material.map;
    } else if (material.alphaMap) {
      uvScaleMap = material.alphaMap;
    }
    if (uvScaleMap !== void 0) {
      if (uvScaleMap.matrixAutoUpdate === true) {
        uvScaleMap.updateMatrix();
      }
      uniforms.uvTransform.value.copy(uvScaleMap.matrix);
    }
  }
  function refreshUniformsSprites(uniforms, material) {
    uniforms.diffuse.value.copy(material.color);
    uniforms.opacity.value = material.opacity;
    uniforms.rotation.value = material.rotation;
    if (material.map) {
      uniforms.map.value = material.map;
    }
    if (material.alphaMap) {
      uniforms.alphaMap.value = material.alphaMap;
    }
    if (material.alphaTest > 0) {
      uniforms.alphaTest.value = material.alphaTest;
    }
    let uvScaleMap;
    if (material.map) {
      uvScaleMap = material.map;
    } else if (material.alphaMap) {
      uvScaleMap = material.alphaMap;
    }
    if (uvScaleMap !== void 0) {
      if (uvScaleMap.matrixAutoUpdate === true) {
        uvScaleMap.updateMatrix();
      }
      uniforms.uvTransform.value.copy(uvScaleMap.matrix);
    }
  }
  function refreshUniformsPhong(uniforms, material) {
    uniforms.specular.value.copy(material.specular);
    uniforms.shininess.value = Math.max(material.shininess, 1e-4);
  }
  function refreshUniformsToon(uniforms, material) {
    if (material.gradientMap) {
      uniforms.gradientMap.value = material.gradientMap;
    }
  }
  function refreshUniformsStandard(uniforms, material) {
    uniforms.roughness.value = material.roughness;
    uniforms.metalness.value = material.metalness;
    if (material.roughnessMap) {
      uniforms.roughnessMap.value = material.roughnessMap;
    }
    if (material.metalnessMap) {
      uniforms.metalnessMap.value = material.metalnessMap;
    }
    const envMap = properties.get(material).envMap;
    if (envMap) {
      uniforms.envMapIntensity.value = material.envMapIntensity;
    }
  }
  function refreshUniformsPhysical(uniforms, material, transmissionRenderTarget) {
    uniforms.ior.value = material.ior;
    if (material.sheen > 0) {
      uniforms.sheenColor.value.copy(material.sheenColor).multiplyScalar(material.sheen);
      uniforms.sheenRoughness.value = material.sheenRoughness;
      if (material.sheenColorMap) {
        uniforms.sheenColorMap.value = material.sheenColorMap;
      }
      if (material.sheenRoughnessMap) {
        uniforms.sheenRoughnessMap.value = material.sheenRoughnessMap;
      }
    }
    if (material.clearcoat > 0) {
      uniforms.clearcoat.value = material.clearcoat;
      uniforms.clearcoatRoughness.value = material.clearcoatRoughness;
      if (material.clearcoatMap) {
        uniforms.clearcoatMap.value = material.clearcoatMap;
      }
      if (material.clearcoatRoughnessMap) {
        uniforms.clearcoatRoughnessMap.value = material.clearcoatRoughnessMap;
      }
      if (material.clearcoatNormalMap) {
        uniforms.clearcoatNormalScale.value.copy(material.clearcoatNormalScale);
        uniforms.clearcoatNormalMap.value = material.clearcoatNormalMap;
        if (material.side === BackSide) {
          uniforms.clearcoatNormalScale.value.negate();
        }
      }
    }
    if (material.iridescence > 0) {
      uniforms.iridescence.value = material.iridescence;
      uniforms.iridescenceIOR.value = material.iridescenceIOR;
      uniforms.iridescenceThicknessMinimum.value = material.iridescenceThicknessRange[0];
      uniforms.iridescenceThicknessMaximum.value = material.iridescenceThicknessRange[1];
      if (material.iridescenceMap) {
        uniforms.iridescenceMap.value = material.iridescenceMap;
      }
      if (material.iridescenceThicknessMap) {
        uniforms.iridescenceThicknessMap.value = material.iridescenceThicknessMap;
      }
    }
    if (material.transmission > 0) {
      uniforms.transmission.value = material.transmission;
      uniforms.transmissionSamplerMap.value = transmissionRenderTarget.texture;
      uniforms.transmissionSamplerSize.value.set(transmissionRenderTarget.width, transmissionRenderTarget.height);
      if (material.transmissionMap) {
        uniforms.transmissionMap.value = material.transmissionMap;
      }
      uniforms.thickness.value = material.thickness;
      if (material.thicknessMap) {
        uniforms.thicknessMap.value = material.thicknessMap;
      }
      uniforms.attenuationDistance.value = material.attenuationDistance;
      uniforms.attenuationColor.value.copy(material.attenuationColor);
    }
    uniforms.specularIntensity.value = material.specularIntensity;
    uniforms.specularColor.value.copy(material.specularColor);
    if (material.specularIntensityMap) {
      uniforms.specularIntensityMap.value = material.specularIntensityMap;
    }
    if (material.specularColorMap) {
      uniforms.specularColorMap.value = material.specularColorMap;
    }
  }
  function refreshUniformsMatcap(uniforms, material) {
    if (material.matcap) {
      uniforms.matcap.value = material.matcap;
    }
  }
  function refreshUniformsDistance(uniforms, material) {
    uniforms.referencePosition.value.copy(material.referencePosition);
    uniforms.nearDistance.value = material.nearDistance;
    uniforms.farDistance.value = material.farDistance;
  }
  return {
    refreshFogUniforms,
    refreshMaterialUniforms
  };
}
function WebGLUniformsGroups(gl, info, capabilities, state) {
  let buffers = {};
  let updateList = {};
  let allocatedBindingPoints = [];
  const maxBindingPoints = capabilities.isWebGL2 ? gl.getParameter(35375) : 0;
  function bind(uniformsGroup, program) {
    const webglProgram = program.program;
    state.uniformBlockBinding(uniformsGroup, webglProgram);
  }
  function update(uniformsGroup, program) {
    let buffer = buffers[uniformsGroup.id];
    if (buffer === void 0) {
      prepareUniformsGroup(uniformsGroup);
      buffer = createBuffer(uniformsGroup);
      buffers[uniformsGroup.id] = buffer;
      uniformsGroup.addEventListener("dispose", onUniformsGroupsDispose);
    }
    const webglProgram = program.program;
    state.updateUBOMapping(uniformsGroup, webglProgram);
    const frame = info.render.frame;
    if (updateList[uniformsGroup.id] !== frame) {
      updateBufferData(uniformsGroup);
      updateList[uniformsGroup.id] = frame;
    }
  }
  function createBuffer(uniformsGroup) {
    const bindingPointIndex = allocateBindingPointIndex();
    uniformsGroup.__bindingPointIndex = bindingPointIndex;
    const buffer = gl.createBuffer();
    const size = uniformsGroup.__size;
    const usage = uniformsGroup.usage;
    gl.bindBuffer(35345, buffer);
    gl.bufferData(35345, size, usage);
    gl.bindBuffer(35345, null);
    gl.bindBufferBase(35345, bindingPointIndex, buffer);
    return buffer;
  }
  function allocateBindingPointIndex() {
    for (let i2 = 0; i2 < maxBindingPoints; i2++) {
      if (allocatedBindingPoints.indexOf(i2) === -1) {
        allocatedBindingPoints.push(i2);
        return i2;
      }
    }
    console.error("THREE.WebGLRenderer: Maximum number of simultaneously usable uniforms groups reached.");
    return 0;
  }
  function updateBufferData(uniformsGroup) {
    const buffer = buffers[uniformsGroup.id];
    const uniforms = uniformsGroup.uniforms;
    const cache = uniformsGroup.__cache;
    gl.bindBuffer(35345, buffer);
    for (let i2 = 0, il = uniforms.length; i2 < il; i2++) {
      const uniform = uniforms[i2];
      if (hasUniformChanged(uniform, i2, cache) === true) {
        const value = uniform.value;
        const offset = uniform.__offset;
        if (typeof value === "number") {
          uniform.__data[0] = value;
          gl.bufferSubData(35345, offset, uniform.__data);
        } else {
          if (uniform.value.isMatrix3) {
            uniform.__data[0] = uniform.value.elements[0];
            uniform.__data[1] = uniform.value.elements[1];
            uniform.__data[2] = uniform.value.elements[2];
            uniform.__data[3] = uniform.value.elements[0];
            uniform.__data[4] = uniform.value.elements[3];
            uniform.__data[5] = uniform.value.elements[4];
            uniform.__data[6] = uniform.value.elements[5];
            uniform.__data[7] = uniform.value.elements[0];
            uniform.__data[8] = uniform.value.elements[6];
            uniform.__data[9] = uniform.value.elements[7];
            uniform.__data[10] = uniform.value.elements[8];
            uniform.__data[11] = uniform.value.elements[0];
          } else {
            value.toArray(uniform.__data);
          }
          gl.bufferSubData(35345, offset, uniform.__data);
        }
      }
    }
    gl.bindBuffer(35345, null);
  }
  function hasUniformChanged(uniform, index, cache) {
    const value = uniform.value;
    if (cache[index] === void 0) {
      if (typeof value === "number") {
        cache[index] = value;
      } else {
        cache[index] = value.clone();
      }
      return true;
    } else {
      if (typeof value === "number") {
        if (cache[index] !== value) {
          cache[index] = value;
          return true;
        }
      } else {
        const cachedObject = cache[index];
        if (cachedObject.equals(value) === false) {
          cachedObject.copy(value);
          return true;
        }
      }
    }
    return false;
  }
  function prepareUniformsGroup(uniformsGroup) {
    const uniforms = uniformsGroup.uniforms;
    let offset = 0;
    const chunkSize = 16;
    let chunkOffset = 0;
    for (let i2 = 0, l = uniforms.length; i2 < l; i2++) {
      const uniform = uniforms[i2];
      const info2 = getUniformSize(uniform);
      uniform.__data = new Float32Array(info2.storage / Float32Array.BYTES_PER_ELEMENT);
      uniform.__offset = offset;
      if (i2 > 0) {
        chunkOffset = offset % chunkSize;
        const remainingSizeInChunk = chunkSize - chunkOffset;
        if (chunkOffset !== 0 && remainingSizeInChunk - info2.boundary < 0) {
          offset += chunkSize - chunkOffset;
          uniform.__offset = offset;
        }
      }
      offset += info2.storage;
    }
    chunkOffset = offset % chunkSize;
    if (chunkOffset > 0)
      offset += chunkSize - chunkOffset;
    uniformsGroup.__size = offset;
    uniformsGroup.__cache = {};
    return this;
  }
  function getUniformSize(uniform) {
    const value = uniform.value;
    const info2 = {
      boundary: 0,
      storage: 0
    };
    if (typeof value === "number") {
      info2.boundary = 4;
      info2.storage = 4;
    } else if (value.isVector2) {
      info2.boundary = 8;
      info2.storage = 8;
    } else if (value.isVector3 || value.isColor) {
      info2.boundary = 16;
      info2.storage = 12;
    } else if (value.isVector4) {
      info2.boundary = 16;
      info2.storage = 16;
    } else if (value.isMatrix3) {
      info2.boundary = 48;
      info2.storage = 48;
    } else if (value.isMatrix4) {
      info2.boundary = 64;
      info2.storage = 64;
    } else if (value.isTexture) {
      console.warn("THREE.WebGLRenderer: Texture samplers can not be part of an uniforms group.");
    } else {
      console.warn("THREE.WebGLRenderer: Unsupported uniform value type.", value);
    }
    return info2;
  }
  function onUniformsGroupsDispose(event) {
    const uniformsGroup = event.target;
    uniformsGroup.removeEventListener("dispose", onUniformsGroupsDispose);
    const index = allocatedBindingPoints.indexOf(uniformsGroup.__bindingPointIndex);
    allocatedBindingPoints.splice(index, 1);
    gl.deleteBuffer(buffers[uniformsGroup.id]);
    delete buffers[uniformsGroup.id];
    delete updateList[uniformsGroup.id];
  }
  function dispose() {
    for (const id in buffers) {
      gl.deleteBuffer(buffers[id]);
    }
    allocatedBindingPoints = [];
    buffers = {};
    updateList = {};
  }
  return {
    bind,
    update,
    dispose
  };
}
function createCanvasElement() {
  const canvas = createElementNS("canvas");
  canvas.style.display = "block";
  return canvas;
}
function WebGLRenderer(parameters = {}) {
  this.isWebGLRenderer = true;
  const _canvas2 = parameters.canvas !== void 0 ? parameters.canvas : createCanvasElement(), _context = parameters.context !== void 0 ? parameters.context : null, _depth = parameters.depth !== void 0 ? parameters.depth : true, _stencil = parameters.stencil !== void 0 ? parameters.stencil : true, _antialias = parameters.antialias !== void 0 ? parameters.antialias : false, _premultipliedAlpha = parameters.premultipliedAlpha !== void 0 ? parameters.premultipliedAlpha : true, _preserveDrawingBuffer = parameters.preserveDrawingBuffer !== void 0 ? parameters.preserveDrawingBuffer : false, _powerPreference = parameters.powerPreference !== void 0 ? parameters.powerPreference : "default", _failIfMajorPerformanceCaveat = parameters.failIfMajorPerformanceCaveat !== void 0 ? parameters.failIfMajorPerformanceCaveat : false;
  let _alpha;
  if (_context !== null) {
    _alpha = _context.getContextAttributes().alpha;
  } else {
    _alpha = parameters.alpha !== void 0 ? parameters.alpha : false;
  }
  let currentRenderList = null;
  let currentRenderState = null;
  const renderListStack = [];
  const renderStateStack = [];
  this.domElement = _canvas2;
  this.debug = {
    checkShaderErrors: true
  };
  this.autoClear = true;
  this.autoClearColor = true;
  this.autoClearDepth = true;
  this.autoClearStencil = true;
  this.sortObjects = true;
  this.clippingPlanes = [];
  this.localClippingEnabled = false;
  this.outputEncoding = LinearEncoding;
  this.physicallyCorrectLights = false;
  this.toneMapping = NoToneMapping;
  this.toneMappingExposure = 1;
  Object.defineProperties(this, {
    gammaFactor: {
      get: function() {
        console.warn("THREE.WebGLRenderer: .gammaFactor has been removed.");
        return 2;
      },
      set: function() {
        console.warn("THREE.WebGLRenderer: .gammaFactor has been removed.");
      }
    }
  });
  const _this = this;
  let _isContextLost = false;
  let _currentActiveCubeFace = 0;
  let _currentActiveMipmapLevel = 0;
  let _currentRenderTarget = null;
  let _currentMaterialId = -1;
  let _currentCamera = null;
  const _currentViewport = new Vector4();
  const _currentScissor = new Vector4();
  let _currentScissorTest = null;
  let _width = _canvas2.width;
  let _height = _canvas2.height;
  let _pixelRatio = 1;
  let _opaqueSort = null;
  let _transparentSort = null;
  const _viewport = new Vector4(0, 0, _width, _height);
  const _scissor = new Vector4(0, 0, _width, _height);
  let _scissorTest = false;
  const _frustum = new Frustum();
  let _clippingEnabled = false;
  let _localClippingEnabled = false;
  let _transmissionRenderTarget = null;
  const _projScreenMatrix = new Matrix4();
  const _vector22 = new Vector2();
  const _vector3 = new Vector3();
  const _emptyScene = { background: null, fog: null, environment: null, overrideMaterial: null, isScene: true };
  function getTargetPixelRatio() {
    return _currentRenderTarget === null ? _pixelRatio : 1;
  }
  let _gl = _context;
  function getContext(contextNames, contextAttributes) {
    for (let i2 = 0; i2 < contextNames.length; i2++) {
      const contextName = contextNames[i2];
      const context = _canvas2.getContext(contextName, contextAttributes);
      if (context !== null)
        return context;
    }
    return null;
  }
  try {
    const contextAttributes = {
      alpha: true,
      depth: _depth,
      stencil: _stencil,
      antialias: _antialias,
      premultipliedAlpha: _premultipliedAlpha,
      preserveDrawingBuffer: _preserveDrawingBuffer,
      powerPreference: _powerPreference,
      failIfMajorPerformanceCaveat: _failIfMajorPerformanceCaveat
    };
    if ("setAttribute" in _canvas2)
      _canvas2.setAttribute("data-engine", `three.js r${REVISION}`);
    _canvas2.addEventListener("webglcontextlost", onContextLost, false);
    _canvas2.addEventListener("webglcontextrestored", onContextRestore, false);
    _canvas2.addEventListener("webglcontextcreationerror", onContextCreationError, false);
    if (_gl === null) {
      const contextNames = ["webgl2", "webgl", "experimental-webgl"];
      if (_this.isWebGL1Renderer === true) {
        contextNames.shift();
      }
      _gl = getContext(contextNames, contextAttributes);
      if (_gl === null) {
        if (getContext(contextNames)) {
          throw new Error("Error creating WebGL context with your selected attributes.");
        } else {
          throw new Error("Error creating WebGL context.");
        }
      }
    }
    if (_gl.getShaderPrecisionFormat === void 0) {
      _gl.getShaderPrecisionFormat = function() {
        return { "rangeMin": 1, "rangeMax": 1, "precision": 1 };
      };
    }
  } catch (error) {
    console.error("THREE.WebGLRenderer: " + error.message);
    throw error;
  }
  let extensions, capabilities, state, info;
  let properties, textures, cubemaps, cubeuvmaps, attributes, geometries, objects;
  let programCache, materials, renderLists, renderStates, clipping, shadowMap;
  let background, morphtargets, bufferRenderer, indexedBufferRenderer;
  let utils, bindingStates, uniformsGroups;
  function initGLContext() {
    extensions = new WebGLExtensions(_gl);
    capabilities = new WebGLCapabilities(_gl, extensions, parameters);
    extensions.init(capabilities);
    utils = new WebGLUtils(_gl, extensions, capabilities);
    state = new WebGLState(_gl, extensions, capabilities);
    info = new WebGLInfo();
    properties = new WebGLProperties();
    textures = new WebGLTextures(_gl, extensions, state, properties, capabilities, utils, info);
    cubemaps = new WebGLCubeMaps(_this);
    cubeuvmaps = new WebGLCubeUVMaps(_this);
    attributes = new WebGLAttributes(_gl, capabilities);
    bindingStates = new WebGLBindingStates(_gl, extensions, attributes, capabilities);
    geometries = new WebGLGeometries(_gl, attributes, info, bindingStates);
    objects = new WebGLObjects(_gl, geometries, attributes, info);
    morphtargets = new WebGLMorphtargets(_gl, capabilities, textures);
    clipping = new WebGLClipping(properties);
    programCache = new WebGLPrograms(_this, cubemaps, cubeuvmaps, extensions, capabilities, bindingStates, clipping);
    materials = new WebGLMaterials(_this, properties);
    renderLists = new WebGLRenderLists();
    renderStates = new WebGLRenderStates(extensions, capabilities);
    background = new WebGLBackground(_this, cubemaps, state, objects, _alpha, _premultipliedAlpha);
    shadowMap = new WebGLShadowMap(_this, objects, capabilities);
    uniformsGroups = new WebGLUniformsGroups(_gl, info, capabilities, state);
    bufferRenderer = new WebGLBufferRenderer(_gl, extensions, info, capabilities);
    indexedBufferRenderer = new WebGLIndexedBufferRenderer(_gl, extensions, info, capabilities);
    info.programs = programCache.programs;
    _this.capabilities = capabilities;
    _this.extensions = extensions;
    _this.properties = properties;
    _this.renderLists = renderLists;
    _this.shadowMap = shadowMap;
    _this.state = state;
    _this.info = info;
  }
  initGLContext();
  const xr = new WebXRManager(_this, _gl);
  this.xr = xr;
  this.getContext = function() {
    return _gl;
  };
  this.getContextAttributes = function() {
    return _gl.getContextAttributes();
  };
  this.forceContextLoss = function() {
    const extension = extensions.get("WEBGL_lose_context");
    if (extension)
      extension.loseContext();
  };
  this.forceContextRestore = function() {
    const extension = extensions.get("WEBGL_lose_context");
    if (extension)
      extension.restoreContext();
  };
  this.getPixelRatio = function() {
    return _pixelRatio;
  };
  this.setPixelRatio = function(value) {
    if (value === void 0)
      return;
    _pixelRatio = value;
    this.setSize(_width, _height, false);
  };
  this.getSize = function(target) {
    return target.set(_width, _height);
  };
  this.setSize = function(width, height, updateStyle) {
    if (xr.isPresenting) {
      console.warn("THREE.WebGLRenderer: Can't change size while VR device is presenting.");
      return;
    }
    _width = width;
    _height = height;
    _canvas2.width = Math.floor(width * _pixelRatio);
    _canvas2.height = Math.floor(height * _pixelRatio);
    if (updateStyle !== false) {
      _canvas2.style.width = width + "px";
      _canvas2.style.height = height + "px";
    }
    this.setViewport(0, 0, width, height);
  };
  this.getDrawingBufferSize = function(target) {
    return target.set(_width * _pixelRatio, _height * _pixelRatio).floor();
  };
  this.setDrawingBufferSize = function(width, height, pixelRatio) {
    _width = width;
    _height = height;
    _pixelRatio = pixelRatio;
    _canvas2.width = Math.floor(width * pixelRatio);
    _canvas2.height = Math.floor(height * pixelRatio);
    this.setViewport(0, 0, width, height);
  };
  this.getCurrentViewport = function(target) {
    return target.copy(_currentViewport);
  };
  this.getViewport = function(target) {
    return target.copy(_viewport);
  };
  this.setViewport = function(x, y, width, height) {
    if (x.isVector4) {
      _viewport.set(x.x, x.y, x.z, x.w);
    } else {
      _viewport.set(x, y, width, height);
    }
    state.viewport(_currentViewport.copy(_viewport).multiplyScalar(_pixelRatio).floor());
  };
  this.getScissor = function(target) {
    return target.copy(_scissor);
  };
  this.setScissor = function(x, y, width, height) {
    if (x.isVector4) {
      _scissor.set(x.x, x.y, x.z, x.w);
    } else {
      _scissor.set(x, y, width, height);
    }
    state.scissor(_currentScissor.copy(_scissor).multiplyScalar(_pixelRatio).floor());
  };
  this.getScissorTest = function() {
    return _scissorTest;
  };
  this.setScissorTest = function(boolean) {
    state.setScissorTest(_scissorTest = boolean);
  };
  this.setOpaqueSort = function(method) {
    _opaqueSort = method;
  };
  this.setTransparentSort = function(method) {
    _transparentSort = method;
  };
  this.getClearColor = function(target) {
    return target.copy(background.getClearColor());
  };
  this.setClearColor = function() {
    background.setClearColor.apply(background, arguments);
  };
  this.getClearAlpha = function() {
    return background.getClearAlpha();
  };
  this.setClearAlpha = function() {
    background.setClearAlpha.apply(background, arguments);
  };
  this.clear = function(color = true, depth = true, stencil = true) {
    let bits = 0;
    if (color)
      bits |= 16384;
    if (depth)
      bits |= 256;
    if (stencil)
      bits |= 1024;
    _gl.clear(bits);
  };
  this.clearColor = function() {
    this.clear(true, false, false);
  };
  this.clearDepth = function() {
    this.clear(false, true, false);
  };
  this.clearStencil = function() {
    this.clear(false, false, true);
  };
  this.dispose = function() {
    _canvas2.removeEventListener("webglcontextlost", onContextLost, false);
    _canvas2.removeEventListener("webglcontextrestored", onContextRestore, false);
    _canvas2.removeEventListener("webglcontextcreationerror", onContextCreationError, false);
    renderLists.dispose();
    renderStates.dispose();
    properties.dispose();
    cubemaps.dispose();
    cubeuvmaps.dispose();
    objects.dispose();
    bindingStates.dispose();
    uniformsGroups.dispose();
    programCache.dispose();
    xr.dispose();
    xr.removeEventListener("sessionstart", onXRSessionStart);
    xr.removeEventListener("sessionend", onXRSessionEnd);
    if (_transmissionRenderTarget) {
      _transmissionRenderTarget.dispose();
      _transmissionRenderTarget = null;
    }
    animation.stop();
  };
  function onContextLost(event) {
    event.preventDefault();
    console.log("THREE.WebGLRenderer: Context Lost.");
    _isContextLost = true;
  }
  function onContextRestore() {
    console.log("THREE.WebGLRenderer: Context Restored.");
    _isContextLost = false;
    const infoAutoReset = info.autoReset;
    const shadowMapEnabled = shadowMap.enabled;
    const shadowMapAutoUpdate = shadowMap.autoUpdate;
    const shadowMapNeedsUpdate = shadowMap.needsUpdate;
    const shadowMapType = shadowMap.type;
    initGLContext();
    info.autoReset = infoAutoReset;
    shadowMap.enabled = shadowMapEnabled;
    shadowMap.autoUpdate = shadowMapAutoUpdate;
    shadowMap.needsUpdate = shadowMapNeedsUpdate;
    shadowMap.type = shadowMapType;
  }
  function onContextCreationError(event) {
    console.error("THREE.WebGLRenderer: A WebGL context could not be created. Reason: ", event.statusMessage);
  }
  function onMaterialDispose(event) {
    const material = event.target;
    material.removeEventListener("dispose", onMaterialDispose);
    deallocateMaterial(material);
  }
  function deallocateMaterial(material) {
    releaseMaterialProgramReferences(material);
    properties.remove(material);
  }
  function releaseMaterialProgramReferences(material) {
    const programs = properties.get(material).programs;
    if (programs !== void 0) {
      programs.forEach(function(program) {
        programCache.releaseProgram(program);
      });
      if (material.isShaderMaterial) {
        programCache.releaseShaderCache(material);
      }
    }
  }
  this.renderBufferDirect = function(camera, scene, geometry, material, object, group) {
    if (scene === null)
      scene = _emptyScene;
    const frontFaceCW = object.isMesh && object.matrixWorld.determinant() < 0;
    const program = setProgram(camera, scene, geometry, material, object);
    state.setMaterial(material, frontFaceCW);
    let index = geometry.index;
    const position = geometry.attributes.position;
    if (index === null) {
      if (position === void 0 || position.count === 0)
        return;
    } else if (index.count === 0) {
      return;
    }
    let rangeFactor = 1;
    if (material.wireframe === true) {
      index = geometries.getWireframeAttribute(geometry);
      rangeFactor = 2;
    }
    bindingStates.setup(object, material, program, geometry, index);
    let attribute;
    let renderer = bufferRenderer;
    if (index !== null) {
      attribute = attributes.get(index);
      renderer = indexedBufferRenderer;
      renderer.setIndex(attribute);
    }
    const dataCount = index !== null ? index.count : position.count;
    const rangeStart = geometry.drawRange.start * rangeFactor;
    const rangeCount = geometry.drawRange.count * rangeFactor;
    const groupStart = group !== null ? group.start * rangeFactor : 0;
    const groupCount = group !== null ? group.count * rangeFactor : Infinity;
    const drawStart = Math.max(rangeStart, groupStart);
    const drawEnd = Math.min(dataCount, rangeStart + rangeCount, groupStart + groupCount) - 1;
    const drawCount = Math.max(0, drawEnd - drawStart + 1);
    if (drawCount === 0)
      return;
    if (object.isMesh) {
      if (material.wireframe === true) {
        state.setLineWidth(material.wireframeLinewidth * getTargetPixelRatio());
        renderer.setMode(1);
      } else {
        renderer.setMode(4);
      }
    } else if (object.isLine) {
      let lineWidth = material.linewidth;
      if (lineWidth === void 0)
        lineWidth = 1;
      state.setLineWidth(lineWidth * getTargetPixelRatio());
      if (object.isLineSegments) {
        renderer.setMode(1);
      } else if (object.isLineLoop) {
        renderer.setMode(2);
      } else {
        renderer.setMode(3);
      }
    } else if (object.isPoints) {
      renderer.setMode(0);
    } else if (object.isSprite) {
      renderer.setMode(4);
    }
    if (object.isInstancedMesh) {
      renderer.renderInstances(drawStart, drawCount, object.count);
    } else if (geometry.isInstancedBufferGeometry) {
      const instanceCount = Math.min(geometry.instanceCount, geometry._maxInstanceCount);
      renderer.renderInstances(drawStart, drawCount, instanceCount);
    } else {
      renderer.render(drawStart, drawCount);
    }
  };
  this.compile = function(scene, camera) {
    currentRenderState = renderStates.get(scene);
    currentRenderState.init();
    renderStateStack.push(currentRenderState);
    scene.traverseVisible(function(object) {
      if (object.isLight && object.layers.test(camera.layers)) {
        currentRenderState.pushLight(object);
        if (object.castShadow) {
          currentRenderState.pushShadow(object);
        }
      }
    });
    currentRenderState.setupLights(_this.physicallyCorrectLights);
    scene.traverse(function(object) {
      const material = object.material;
      if (material) {
        if (Array.isArray(material)) {
          for (let i2 = 0; i2 < material.length; i2++) {
            const material2 = material[i2];
            getProgram(material2, scene, object);
          }
        } else {
          getProgram(material, scene, object);
        }
      }
    });
    renderStateStack.pop();
    currentRenderState = null;
  };
  let onAnimationFrameCallback = null;
  function onAnimationFrame(time) {
    if (onAnimationFrameCallback)
      onAnimationFrameCallback(time);
  }
  function onXRSessionStart() {
    animation.stop();
  }
  function onXRSessionEnd() {
    animation.start();
  }
  const animation = new WebGLAnimation();
  animation.setAnimationLoop(onAnimationFrame);
  if (typeof self !== "undefined")
    animation.setContext(self);
  this.setAnimationLoop = function(callback) {
    onAnimationFrameCallback = callback;
    xr.setAnimationLoop(callback);
    callback === null ? animation.stop() : animation.start();
  };
  xr.addEventListener("sessionstart", onXRSessionStart);
  xr.addEventListener("sessionend", onXRSessionEnd);
  this.render = function(scene, camera) {
    if (camera !== void 0 && camera.isCamera !== true) {
      console.error("THREE.WebGLRenderer.render: camera is not an instance of THREE.Camera.");
      return;
    }
    if (_isContextLost === true)
      return;
    if (scene.autoUpdate === true)
      scene.updateMatrixWorld();
    if (camera.parent === null)
      camera.updateMatrixWorld();
    if (xr.enabled === true && xr.isPresenting === true) {
      if (xr.cameraAutoUpdate === true)
        xr.updateCamera(camera);
      camera = xr.getCamera();
    }
    if (scene.isScene === true)
      scene.onBeforeRender(_this, scene, camera, _currentRenderTarget);
    currentRenderState = renderStates.get(scene, renderStateStack.length);
    currentRenderState.init();
    renderStateStack.push(currentRenderState);
    _projScreenMatrix.multiplyMatrices(camera.projectionMatrix, camera.matrixWorldInverse);
    _frustum.setFromProjectionMatrix(_projScreenMatrix);
    _localClippingEnabled = this.localClippingEnabled;
    _clippingEnabled = clipping.init(this.clippingPlanes, _localClippingEnabled, camera);
    currentRenderList = renderLists.get(scene, renderListStack.length);
    currentRenderList.init();
    renderListStack.push(currentRenderList);
    projectObject(scene, camera, 0, _this.sortObjects);
    currentRenderList.finish();
    if (_this.sortObjects === true) {
      currentRenderList.sort(_opaqueSort, _transparentSort);
    }
    if (_clippingEnabled === true)
      clipping.beginShadows();
    const shadowsArray = currentRenderState.state.shadowsArray;
    shadowMap.render(shadowsArray, scene, camera);
    if (_clippingEnabled === true)
      clipping.endShadows();
    if (this.info.autoReset === true)
      this.info.reset();
    background.render(currentRenderList, scene);
    currentRenderState.setupLights(_this.physicallyCorrectLights);
    if (camera.isArrayCamera) {
      const cameras = camera.cameras;
      for (let i2 = 0, l = cameras.length; i2 < l; i2++) {
        const camera2 = cameras[i2];
        renderScene(currentRenderList, scene, camera2, camera2.viewport);
      }
    } else {
      renderScene(currentRenderList, scene, camera);
    }
    if (_currentRenderTarget !== null) {
      textures.updateMultisampleRenderTarget(_currentRenderTarget);
      textures.updateRenderTargetMipmap(_currentRenderTarget);
    }
    if (scene.isScene === true)
      scene.onAfterRender(_this, scene, camera);
    bindingStates.resetDefaultState();
    _currentMaterialId = -1;
    _currentCamera = null;
    renderStateStack.pop();
    if (renderStateStack.length > 0) {
      currentRenderState = renderStateStack[renderStateStack.length - 1];
    } else {
      currentRenderState = null;
    }
    renderListStack.pop();
    if (renderListStack.length > 0) {
      currentRenderList = renderListStack[renderListStack.length - 1];
    } else {
      currentRenderList = null;
    }
  };
  function projectObject(object, camera, groupOrder, sortObjects) {
    if (object.visible === false)
      return;
    const visible = object.layers.test(camera.layers);
    if (visible) {
      if (object.isGroup) {
        groupOrder = object.renderOrder;
      } else if (object.isLOD) {
        if (object.autoUpdate === true)
          object.update(camera);
      } else if (object.isLight) {
        currentRenderState.pushLight(object);
        if (object.castShadow) {
          currentRenderState.pushShadow(object);
        }
      } else if (object.isSprite) {
        if (!object.frustumCulled || _frustum.intersectsSprite(object)) {
          if (sortObjects) {
            _vector3.setFromMatrixPosition(object.matrixWorld).applyMatrix4(_projScreenMatrix);
          }
          const geometry = objects.update(object);
          const material = object.material;
          if (material.visible) {
            currentRenderList.push(object, geometry, material, groupOrder, _vector3.z, null);
          }
        }
      } else if (object.isMesh || object.isLine || object.isPoints) {
        if (object.isSkinnedMesh) {
          if (object.skeleton.frame !== info.render.frame) {
            object.skeleton.update();
            object.skeleton.frame = info.render.frame;
          }
        }
        if (!object.frustumCulled || _frustum.intersectsObject(object)) {
          if (sortObjects) {
            _vector3.setFromMatrixPosition(object.matrixWorld).applyMatrix4(_projScreenMatrix);
          }
          const geometry = objects.update(object);
          const material = object.material;
          if (Array.isArray(material)) {
            const groups = geometry.groups;
            for (let i2 = 0, l = groups.length; i2 < l; i2++) {
              const group = groups[i2];
              const groupMaterial = material[group.materialIndex];
              if (groupMaterial && groupMaterial.visible) {
                currentRenderList.push(object, geometry, groupMaterial, groupOrder, _vector3.z, group);
              }
            }
          } else if (material.visible) {
            currentRenderList.push(object, geometry, material, groupOrder, _vector3.z, null);
          }
        }
      }
    }
    const children = object.children;
    for (let i2 = 0, l = children.length; i2 < l; i2++) {
      projectObject(children[i2], camera, groupOrder, sortObjects);
    }
  }
  function renderScene(currentRenderList2, scene, camera, viewport) {
    const opaqueObjects = currentRenderList2.opaque;
    const transmissiveObjects = currentRenderList2.transmissive;
    const transparentObjects = currentRenderList2.transparent;
    currentRenderState.setupLightsView(camera);
    if (transmissiveObjects.length > 0)
      renderTransmissionPass(opaqueObjects, scene, camera);
    if (viewport)
      state.viewport(_currentViewport.copy(viewport));
    if (opaqueObjects.length > 0)
      renderObjects(opaqueObjects, scene, camera);
    if (transmissiveObjects.length > 0)
      renderObjects(transmissiveObjects, scene, camera);
    if (transparentObjects.length > 0)
      renderObjects(transparentObjects, scene, camera);
    state.buffers.depth.setTest(true);
    state.buffers.depth.setMask(true);
    state.buffers.color.setMask(true);
    state.setPolygonOffset(false);
  }
  function renderTransmissionPass(opaqueObjects, scene, camera) {
    const isWebGL2 = capabilities.isWebGL2;
    if (_transmissionRenderTarget === null) {
      _transmissionRenderTarget = new WebGLRenderTarget(1, 1, {
        generateMipmaps: true,
        type: extensions.has("EXT_color_buffer_half_float") ? HalfFloatType : UnsignedByteType,
        minFilter: LinearMipmapLinearFilter,
        samples: isWebGL2 && _antialias === true ? 4 : 0
      });
    }
    _this.getDrawingBufferSize(_vector22);
    if (isWebGL2) {
      _transmissionRenderTarget.setSize(_vector22.x, _vector22.y);
    } else {
      _transmissionRenderTarget.setSize(floorPowerOfTwo(_vector22.x), floorPowerOfTwo(_vector22.y));
    }
    const currentRenderTarget = _this.getRenderTarget();
    _this.setRenderTarget(_transmissionRenderTarget);
    _this.clear();
    const currentToneMapping = _this.toneMapping;
    _this.toneMapping = NoToneMapping;
    renderObjects(opaqueObjects, scene, camera);
    _this.toneMapping = currentToneMapping;
    textures.updateMultisampleRenderTarget(_transmissionRenderTarget);
    textures.updateRenderTargetMipmap(_transmissionRenderTarget);
    _this.setRenderTarget(currentRenderTarget);
  }
  function renderObjects(renderList, scene, camera) {
    const overrideMaterial = scene.isScene === true ? scene.overrideMaterial : null;
    for (let i2 = 0, l = renderList.length; i2 < l; i2++) {
      const renderItem = renderList[i2];
      const object = renderItem.object;
      const geometry = renderItem.geometry;
      const material = overrideMaterial === null ? renderItem.material : overrideMaterial;
      const group = renderItem.group;
      if (object.layers.test(camera.layers)) {
        renderObject(object, scene, camera, geometry, material, group);
      }
    }
  }
  function renderObject(object, scene, camera, geometry, material, group) {
    object.onBeforeRender(_this, scene, camera, geometry, material, group);
    object.modelViewMatrix.multiplyMatrices(camera.matrixWorldInverse, object.matrixWorld);
    object.normalMatrix.getNormalMatrix(object.modelViewMatrix);
    material.onBeforeRender(_this, scene, camera, geometry, object, group);
    if (material.transparent === true && material.side === DoubleSide) {
      material.side = BackSide;
      material.needsUpdate = true;
      _this.renderBufferDirect(camera, scene, geometry, material, object, group);
      material.side = FrontSide;
      material.needsUpdate = true;
      _this.renderBufferDirect(camera, scene, geometry, material, object, group);
      material.side = DoubleSide;
    } else {
      _this.renderBufferDirect(camera, scene, geometry, material, object, group);
    }
    object.onAfterRender(_this, scene, camera, geometry, material, group);
  }
  function getProgram(material, scene, object) {
    if (scene.isScene !== true)
      scene = _emptyScene;
    const materialProperties = properties.get(material);
    const lights = currentRenderState.state.lights;
    const shadowsArray = currentRenderState.state.shadowsArray;
    const lightsStateVersion = lights.state.version;
    const parameters2 = programCache.getParameters(material, lights.state, shadowsArray, scene, object);
    const programCacheKey = programCache.getProgramCacheKey(parameters2);
    let programs = materialProperties.programs;
    materialProperties.environment = material.isMeshStandardMaterial ? scene.environment : null;
    materialProperties.fog = scene.fog;
    materialProperties.envMap = (material.isMeshStandardMaterial ? cubeuvmaps : cubemaps).get(material.envMap || materialProperties.environment);
    if (programs === void 0) {
      material.addEventListener("dispose", onMaterialDispose);
      programs = /* @__PURE__ */ new Map();
      materialProperties.programs = programs;
    }
    let program = programs.get(programCacheKey);
    if (program !== void 0) {
      if (materialProperties.currentProgram === program && materialProperties.lightsStateVersion === lightsStateVersion) {
        updateCommonMaterialProperties(material, parameters2);
        return program;
      }
    } else {
      parameters2.uniforms = programCache.getUniforms(material);
      material.onBuild(object, parameters2, _this);
      material.onBeforeCompile(parameters2, _this);
      program = programCache.acquireProgram(parameters2, programCacheKey);
      programs.set(programCacheKey, program);
      materialProperties.uniforms = parameters2.uniforms;
    }
    const uniforms = materialProperties.uniforms;
    if (!material.isShaderMaterial && !material.isRawShaderMaterial || material.clipping === true) {
      uniforms.clippingPlanes = clipping.uniform;
    }
    updateCommonMaterialProperties(material, parameters2);
    materialProperties.needsLights = materialNeedsLights(material);
    materialProperties.lightsStateVersion = lightsStateVersion;
    if (materialProperties.needsLights) {
      uniforms.ambientLightColor.value = lights.state.ambient;
      uniforms.lightProbe.value = lights.state.probe;
      uniforms.directionalLights.value = lights.state.directional;
      uniforms.directionalLightShadows.value = lights.state.directionalShadow;
      uniforms.spotLights.value = lights.state.spot;
      uniforms.spotLightShadows.value = lights.state.spotShadow;
      uniforms.rectAreaLights.value = lights.state.rectArea;
      uniforms.ltc_1.value = lights.state.rectAreaLTC1;
      uniforms.ltc_2.value = lights.state.rectAreaLTC2;
      uniforms.pointLights.value = lights.state.point;
      uniforms.pointLightShadows.value = lights.state.pointShadow;
      uniforms.hemisphereLights.value = lights.state.hemi;
      uniforms.directionalShadowMap.value = lights.state.directionalShadowMap;
      uniforms.directionalShadowMatrix.value = lights.state.directionalShadowMatrix;
      uniforms.spotShadowMap.value = lights.state.spotShadowMap;
      uniforms.spotShadowMatrix.value = lights.state.spotShadowMatrix;
      uniforms.pointShadowMap.value = lights.state.pointShadowMap;
      uniforms.pointShadowMatrix.value = lights.state.pointShadowMatrix;
    }
    const progUniforms = program.getUniforms();
    const uniformsList = WebGLUniforms.seqWithValue(progUniforms.seq, uniforms);
    materialProperties.currentProgram = program;
    materialProperties.uniformsList = uniformsList;
    return program;
  }
  function updateCommonMaterialProperties(material, parameters2) {
    const materialProperties = properties.get(material);
    materialProperties.outputEncoding = parameters2.outputEncoding;
    materialProperties.instancing = parameters2.instancing;
    materialProperties.skinning = parameters2.skinning;
    materialProperties.morphTargets = parameters2.morphTargets;
    materialProperties.morphNormals = parameters2.morphNormals;
    materialProperties.morphColors = parameters2.morphColors;
    materialProperties.morphTargetsCount = parameters2.morphTargetsCount;
    materialProperties.numClippingPlanes = parameters2.numClippingPlanes;
    materialProperties.numIntersection = parameters2.numClipIntersection;
    materialProperties.vertexAlphas = parameters2.vertexAlphas;
    materialProperties.vertexTangents = parameters2.vertexTangents;
    materialProperties.toneMapping = parameters2.toneMapping;
  }
  function setProgram(camera, scene, geometry, material, object) {
    if (scene.isScene !== true)
      scene = _emptyScene;
    textures.resetTextureUnits();
    const fog = scene.fog;
    const environment = material.isMeshStandardMaterial ? scene.environment : null;
    const encoding = _currentRenderTarget === null ? _this.outputEncoding : _currentRenderTarget.isXRRenderTarget === true ? _currentRenderTarget.texture.encoding : LinearEncoding;
    const envMap = (material.isMeshStandardMaterial ? cubeuvmaps : cubemaps).get(material.envMap || environment);
    const vertexAlphas = material.vertexColors === true && !!geometry.attributes.color && geometry.attributes.color.itemSize === 4;
    const vertexTangents = !!material.normalMap && !!geometry.attributes.tangent;
    const morphTargets = !!geometry.morphAttributes.position;
    const morphNormals = !!geometry.morphAttributes.normal;
    const morphColors = !!geometry.morphAttributes.color;
    const toneMapping = material.toneMapped ? _this.toneMapping : NoToneMapping;
    const morphAttribute = geometry.morphAttributes.position || geometry.morphAttributes.normal || geometry.morphAttributes.color;
    const morphTargetsCount = morphAttribute !== void 0 ? morphAttribute.length : 0;
    const materialProperties = properties.get(material);
    const lights = currentRenderState.state.lights;
    if (_clippingEnabled === true) {
      if (_localClippingEnabled === true || camera !== _currentCamera) {
        const useCache = camera === _currentCamera && material.id === _currentMaterialId;
        clipping.setState(material, camera, useCache);
      }
    }
    let needsProgramChange = false;
    if (material.version === materialProperties.__version) {
      if (materialProperties.needsLights && materialProperties.lightsStateVersion !== lights.state.version) {
        needsProgramChange = true;
      } else if (materialProperties.outputEncoding !== encoding) {
        needsProgramChange = true;
      } else if (object.isInstancedMesh && materialProperties.instancing === false) {
        needsProgramChange = true;
      } else if (!object.isInstancedMesh && materialProperties.instancing === true) {
        needsProgramChange = true;
      } else if (object.isSkinnedMesh && materialProperties.skinning === false) {
        needsProgramChange = true;
      } else if (!object.isSkinnedMesh && materialProperties.skinning === true) {
        needsProgramChange = true;
      } else if (materialProperties.envMap !== envMap) {
        needsProgramChange = true;
      } else if (material.fog === true && materialProperties.fog !== fog) {
        needsProgramChange = true;
      } else if (materialProperties.numClippingPlanes !== void 0 && (materialProperties.numClippingPlanes !== clipping.numPlanes || materialProperties.numIntersection !== clipping.numIntersection)) {
        needsProgramChange = true;
      } else if (materialProperties.vertexAlphas !== vertexAlphas) {
        needsProgramChange = true;
      } else if (materialProperties.vertexTangents !== vertexTangents) {
        needsProgramChange = true;
      } else if (materialProperties.morphTargets !== morphTargets) {
        needsProgramChange = true;
      } else if (materialProperties.morphNormals !== morphNormals) {
        needsProgramChange = true;
      } else if (materialProperties.morphColors !== morphColors) {
        needsProgramChange = true;
      } else if (materialProperties.toneMapping !== toneMapping) {
        needsProgramChange = true;
      } else if (capabilities.isWebGL2 === true && materialProperties.morphTargetsCount !== morphTargetsCount) {
        needsProgramChange = true;
      }
    } else {
      needsProgramChange = true;
      materialProperties.__version = material.version;
    }
    let program = materialProperties.currentProgram;
    if (needsProgramChange === true) {
      program = getProgram(material, scene, object);
    }
    let refreshProgram = false;
    let refreshMaterial = false;
    let refreshLights = false;
    const p_uniforms = program.getUniforms(), m_uniforms = materialProperties.uniforms;
    if (state.useProgram(program.program)) {
      refreshProgram = true;
      refreshMaterial = true;
      refreshLights = true;
    }
    if (material.id !== _currentMaterialId) {
      _currentMaterialId = material.id;
      refreshMaterial = true;
    }
    if (refreshProgram || _currentCamera !== camera) {
      p_uniforms.setValue(_gl, "projectionMatrix", camera.projectionMatrix);
      if (capabilities.logarithmicDepthBuffer) {
        p_uniforms.setValue(
          _gl,
          "logDepthBufFC",
          2 / (Math.log(camera.far + 1) / Math.LN2)
        );
      }
      if (_currentCamera !== camera) {
        _currentCamera = camera;
        refreshMaterial = true;
        refreshLights = true;
      }
      if (material.isShaderMaterial || material.isMeshPhongMaterial || material.isMeshToonMaterial || material.isMeshStandardMaterial || material.envMap) {
        const uCamPos = p_uniforms.map.cameraPosition;
        if (uCamPos !== void 0) {
          uCamPos.setValue(
            _gl,
            _vector3.setFromMatrixPosition(camera.matrixWorld)
          );
        }
      }
      if (material.isMeshPhongMaterial || material.isMeshToonMaterial || material.isMeshLambertMaterial || material.isMeshBasicMaterial || material.isMeshStandardMaterial || material.isShaderMaterial) {
        p_uniforms.setValue(_gl, "isOrthographic", camera.isOrthographicCamera === true);
      }
      if (material.isMeshPhongMaterial || material.isMeshToonMaterial || material.isMeshLambertMaterial || material.isMeshBasicMaterial || material.isMeshStandardMaterial || material.isShaderMaterial || material.isShadowMaterial || object.isSkinnedMesh) {
        p_uniforms.setValue(_gl, "viewMatrix", camera.matrixWorldInverse);
      }
    }
    if (object.isSkinnedMesh) {
      p_uniforms.setOptional(_gl, object, "bindMatrix");
      p_uniforms.setOptional(_gl, object, "bindMatrixInverse");
      const skeleton = object.skeleton;
      if (skeleton) {
        if (capabilities.floatVertexTextures) {
          if (skeleton.boneTexture === null)
            skeleton.computeBoneTexture();
          p_uniforms.setValue(_gl, "boneTexture", skeleton.boneTexture, textures);
          p_uniforms.setValue(_gl, "boneTextureSize", skeleton.boneTextureSize);
        } else {
          console.warn("THREE.WebGLRenderer: SkinnedMesh can only be used with WebGL 2. With WebGL 1 OES_texture_float and vertex textures support is required.");
        }
      }
    }
    const morphAttributes = geometry.morphAttributes;
    if (morphAttributes.position !== void 0 || morphAttributes.normal !== void 0 || morphAttributes.color !== void 0 && capabilities.isWebGL2 === true) {
      morphtargets.update(object, geometry, material, program);
    }
    if (refreshMaterial || materialProperties.receiveShadow !== object.receiveShadow) {
      materialProperties.receiveShadow = object.receiveShadow;
      p_uniforms.setValue(_gl, "receiveShadow", object.receiveShadow);
    }
    if (refreshMaterial) {
      p_uniforms.setValue(_gl, "toneMappingExposure", _this.toneMappingExposure);
      if (materialProperties.needsLights) {
        markUniformsLightsNeedsUpdate(m_uniforms, refreshLights);
      }
      if (fog && material.fog === true) {
        materials.refreshFogUniforms(m_uniforms, fog);
      }
      materials.refreshMaterialUniforms(m_uniforms, material, _pixelRatio, _height, _transmissionRenderTarget);
      WebGLUniforms.upload(_gl, materialProperties.uniformsList, m_uniforms, textures);
    }
    if (material.isShaderMaterial && material.uniformsNeedUpdate === true) {
      WebGLUniforms.upload(_gl, materialProperties.uniformsList, m_uniforms, textures);
      material.uniformsNeedUpdate = false;
    }
    if (material.isSpriteMaterial) {
      p_uniforms.setValue(_gl, "center", object.center);
    }
    p_uniforms.setValue(_gl, "modelViewMatrix", object.modelViewMatrix);
    p_uniforms.setValue(_gl, "normalMatrix", object.normalMatrix);
    p_uniforms.setValue(_gl, "modelMatrix", object.matrixWorld);
    if (material.isShaderMaterial || material.isRawShaderMaterial) {
      const groups = material.uniformsGroups;
      for (let i2 = 0, l = groups.length; i2 < l; i2++) {
        if (capabilities.isWebGL2) {
          const group = groups[i2];
          uniformsGroups.update(group, program);
          uniformsGroups.bind(group, program);
        } else {
          console.warn("THREE.WebGLRenderer: Uniform Buffer Objects can only be used with WebGL 2.");
        }
      }
    }
    return program;
  }
  function markUniformsLightsNeedsUpdate(uniforms, value) {
    uniforms.ambientLightColor.needsUpdate = value;
    uniforms.lightProbe.needsUpdate = value;
    uniforms.directionalLights.needsUpdate = value;
    uniforms.directionalLightShadows.needsUpdate = value;
    uniforms.pointLights.needsUpdate = value;
    uniforms.pointLightShadows.needsUpdate = value;
    uniforms.spotLights.needsUpdate = value;
    uniforms.spotLightShadows.needsUpdate = value;
    uniforms.rectAreaLights.needsUpdate = value;
    uniforms.hemisphereLights.needsUpdate = value;
  }
  function materialNeedsLights(material) {
    return material.isMeshLambertMaterial || material.isMeshToonMaterial || material.isMeshPhongMaterial || material.isMeshStandardMaterial || material.isShadowMaterial || material.isShaderMaterial && material.lights === true;
  }
  this.getActiveCubeFace = function() {
    return _currentActiveCubeFace;
  };
  this.getActiveMipmapLevel = function() {
    return _currentActiveMipmapLevel;
  };
  this.getRenderTarget = function() {
    return _currentRenderTarget;
  };
  this.setRenderTargetTextures = function(renderTarget, colorTexture, depthTexture) {
    properties.get(renderTarget.texture).__webglTexture = colorTexture;
    properties.get(renderTarget.depthTexture).__webglTexture = depthTexture;
    const renderTargetProperties = properties.get(renderTarget);
    renderTargetProperties.__hasExternalTextures = true;
    if (renderTargetProperties.__hasExternalTextures) {
      renderTargetProperties.__autoAllocateDepthBuffer = depthTexture === void 0;
      if (!renderTargetProperties.__autoAllocateDepthBuffer) {
        if (extensions.has("WEBGL_multisampled_render_to_texture") === true) {
          console.warn("THREE.WebGLRenderer: Render-to-texture extension was disabled because an external texture was provided");
          renderTargetProperties.__useRenderToTexture = false;
        }
      }
    }
  };
  this.setRenderTargetFramebuffer = function(renderTarget, defaultFramebuffer) {
    const renderTargetProperties = properties.get(renderTarget);
    renderTargetProperties.__webglFramebuffer = defaultFramebuffer;
    renderTargetProperties.__useDefaultFramebuffer = defaultFramebuffer === void 0;
  };
  this.setRenderTarget = function(renderTarget, activeCubeFace = 0, activeMipmapLevel = 0) {
    _currentRenderTarget = renderTarget;
    _currentActiveCubeFace = activeCubeFace;
    _currentActiveMipmapLevel = activeMipmapLevel;
    let useDefaultFramebuffer = true;
    if (renderTarget) {
      const renderTargetProperties = properties.get(renderTarget);
      if (renderTargetProperties.__useDefaultFramebuffer !== void 0) {
        state.bindFramebuffer(36160, null);
        useDefaultFramebuffer = false;
      } else if (renderTargetProperties.__webglFramebuffer === void 0) {
        textures.setupRenderTarget(renderTarget);
      } else if (renderTargetProperties.__hasExternalTextures) {
        textures.rebindTextures(renderTarget, properties.get(renderTarget.texture).__webglTexture, properties.get(renderTarget.depthTexture).__webglTexture);
      }
    }
    let framebuffer = null;
    let isCube = false;
    let isRenderTarget3D = false;
    if (renderTarget) {
      const texture = renderTarget.texture;
      if (texture.isData3DTexture || texture.isDataArrayTexture) {
        isRenderTarget3D = true;
      }
      const __webglFramebuffer = properties.get(renderTarget).__webglFramebuffer;
      if (renderTarget.isWebGLCubeRenderTarget) {
        framebuffer = __webglFramebuffer[activeCubeFace];
        isCube = true;
      } else if (capabilities.isWebGL2 && renderTarget.samples > 0 && textures.useMultisampledRTT(renderTarget) === false) {
        framebuffer = properties.get(renderTarget).__webglMultisampledFramebuffer;
      } else {
        framebuffer = __webglFramebuffer;
      }
      _currentViewport.copy(renderTarget.viewport);
      _currentScissor.copy(renderTarget.scissor);
      _currentScissorTest = renderTarget.scissorTest;
    } else {
      _currentViewport.copy(_viewport).multiplyScalar(_pixelRatio).floor();
      _currentScissor.copy(_scissor).multiplyScalar(_pixelRatio).floor();
      _currentScissorTest = _scissorTest;
    }
    const framebufferBound = state.bindFramebuffer(36160, framebuffer);
    if (framebufferBound && capabilities.drawBuffers && useDefaultFramebuffer) {
      state.drawBuffers(renderTarget, framebuffer);
    }
    state.viewport(_currentViewport);
    state.scissor(_currentScissor);
    state.setScissorTest(_currentScissorTest);
    if (isCube) {
      const textureProperties = properties.get(renderTarget.texture);
      _gl.framebufferTexture2D(36160, 36064, 34069 + activeCubeFace, textureProperties.__webglTexture, activeMipmapLevel);
    } else if (isRenderTarget3D) {
      const textureProperties = properties.get(renderTarget.texture);
      const layer = activeCubeFace || 0;
      _gl.framebufferTextureLayer(36160, 36064, textureProperties.__webglTexture, activeMipmapLevel || 0, layer);
    }
    _currentMaterialId = -1;
  };
  this.readRenderTargetPixels = function(renderTarget, x, y, width, height, buffer, activeCubeFaceIndex) {
    if (!(renderTarget && renderTarget.isWebGLRenderTarget)) {
      console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not THREE.WebGLRenderTarget.");
      return;
    }
    let framebuffer = properties.get(renderTarget).__webglFramebuffer;
    if (renderTarget.isWebGLCubeRenderTarget && activeCubeFaceIndex !== void 0) {
      framebuffer = framebuffer[activeCubeFaceIndex];
    }
    if (framebuffer) {
      state.bindFramebuffer(36160, framebuffer);
      try {
        const texture = renderTarget.texture;
        const textureFormat = texture.format;
        const textureType = texture.type;
        if (textureFormat !== RGBAFormat && utils.convert(textureFormat) !== _gl.getParameter(35739)) {
          console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in RGBA or implementation defined format.");
          return;
        }
        const halfFloatSupportedByExt = textureType === HalfFloatType && (extensions.has("EXT_color_buffer_half_float") || capabilities.isWebGL2 && extensions.has("EXT_color_buffer_float"));
        if (textureType !== UnsignedByteType && utils.convert(textureType) !== _gl.getParameter(35738) && !(textureType === FloatType && (capabilities.isWebGL2 || extensions.has("OES_texture_float") || extensions.has("WEBGL_color_buffer_float"))) && !halfFloatSupportedByExt) {
          console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in UnsignedByteType or implementation defined type.");
          return;
        }
        if (x >= 0 && x <= renderTarget.width - width && (y >= 0 && y <= renderTarget.height - height)) {
          _gl.readPixels(x, y, width, height, utils.convert(textureFormat), utils.convert(textureType), buffer);
        }
      } finally {
        const framebuffer2 = _currentRenderTarget !== null ? properties.get(_currentRenderTarget).__webglFramebuffer : null;
        state.bindFramebuffer(36160, framebuffer2);
      }
    }
  };
  this.copyFramebufferToTexture = function(position, texture, level = 0) {
    const levelScale = Math.pow(2, -level);
    const width = Math.floor(texture.image.width * levelScale);
    const height = Math.floor(texture.image.height * levelScale);
    textures.setTexture2D(texture, 0);
    _gl.copyTexSubImage2D(3553, level, 0, 0, position.x, position.y, width, height);
    state.unbindTexture();
  };
  this.copyTextureToTexture = function(position, srcTexture, dstTexture, level = 0) {
    const width = srcTexture.image.width;
    const height = srcTexture.image.height;
    const glFormat = utils.convert(dstTexture.format);
    const glType = utils.convert(dstTexture.type);
    textures.setTexture2D(dstTexture, 0);
    _gl.pixelStorei(37440, dstTexture.flipY);
    _gl.pixelStorei(37441, dstTexture.premultiplyAlpha);
    _gl.pixelStorei(3317, dstTexture.unpackAlignment);
    if (srcTexture.isDataTexture) {
      _gl.texSubImage2D(3553, level, position.x, position.y, width, height, glFormat, glType, srcTexture.image.data);
    } else {
      if (srcTexture.isCompressedTexture) {
        _gl.compressedTexSubImage2D(3553, level, position.x, position.y, srcTexture.mipmaps[0].width, srcTexture.mipmaps[0].height, glFormat, srcTexture.mipmaps[0].data);
      } else {
        _gl.texSubImage2D(3553, level, position.x, position.y, glFormat, glType, srcTexture.image);
      }
    }
    if (level === 0 && dstTexture.generateMipmaps)
      _gl.generateMipmap(3553);
    state.unbindTexture();
  };
  this.copyTextureToTexture3D = function(sourceBox, position, srcTexture, dstTexture, level = 0) {
    if (_this.isWebGL1Renderer) {
      console.warn("THREE.WebGLRenderer.copyTextureToTexture3D: can only be used with WebGL2.");
      return;
    }
    const width = sourceBox.max.x - sourceBox.min.x + 1;
    const height = sourceBox.max.y - sourceBox.min.y + 1;
    const depth = sourceBox.max.z - sourceBox.min.z + 1;
    const glFormat = utils.convert(dstTexture.format);
    const glType = utils.convert(dstTexture.type);
    let glTarget;
    if (dstTexture.isData3DTexture) {
      textures.setTexture3D(dstTexture, 0);
      glTarget = 32879;
    } else if (dstTexture.isDataArrayTexture) {
      textures.setTexture2DArray(dstTexture, 0);
      glTarget = 35866;
    } else {
      console.warn("THREE.WebGLRenderer.copyTextureToTexture3D: only supports THREE.DataTexture3D and THREE.DataTexture2DArray.");
      return;
    }
    _gl.pixelStorei(37440, dstTexture.flipY);
    _gl.pixelStorei(37441, dstTexture.premultiplyAlpha);
    _gl.pixelStorei(3317, dstTexture.unpackAlignment);
    const unpackRowLen = _gl.getParameter(3314);
    const unpackImageHeight = _gl.getParameter(32878);
    const unpackSkipPixels = _gl.getParameter(3316);
    const unpackSkipRows = _gl.getParameter(3315);
    const unpackSkipImages = _gl.getParameter(32877);
    const image = srcTexture.isCompressedTexture ? srcTexture.mipmaps[0] : srcTexture.image;
    _gl.pixelStorei(3314, image.width);
    _gl.pixelStorei(32878, image.height);
    _gl.pixelStorei(3316, sourceBox.min.x);
    _gl.pixelStorei(3315, sourceBox.min.y);
    _gl.pixelStorei(32877, sourceBox.min.z);
    if (srcTexture.isDataTexture || srcTexture.isData3DTexture) {
      _gl.texSubImage3D(glTarget, level, position.x, position.y, position.z, width, height, depth, glFormat, glType, image.data);
    } else {
      if (srcTexture.isCompressedTexture) {
        console.warn("THREE.WebGLRenderer.copyTextureToTexture3D: untested support for compressed srcTexture.");
        _gl.compressedTexSubImage3D(glTarget, level, position.x, position.y, position.z, width, height, depth, glFormat, image.data);
      } else {
        _gl.texSubImage3D(glTarget, level, position.x, position.y, position.z, width, height, depth, glFormat, glType, image);
      }
    }
    _gl.pixelStorei(3314, unpackRowLen);
    _gl.pixelStorei(32878, unpackImageHeight);
    _gl.pixelStorei(3316, unpackSkipPixels);
    _gl.pixelStorei(3315, unpackSkipRows);
    _gl.pixelStorei(32877, unpackSkipImages);
    if (level === 0 && dstTexture.generateMipmaps)
      _gl.generateMipmap(glTarget);
    state.unbindTexture();
  };
  this.initTexture = function(texture) {
    if (texture.isCubeTexture) {
      textures.setTextureCube(texture, 0);
    } else if (texture.isData3DTexture) {
      textures.setTexture3D(texture, 0);
    } else if (texture.isDataArrayTexture) {
      textures.setTexture2DArray(texture, 0);
    } else {
      textures.setTexture2D(texture, 0);
    }
    state.unbindTexture();
  };
  this.resetState = function() {
    _currentActiveCubeFace = 0;
    _currentActiveMipmapLevel = 0;
    _currentRenderTarget = null;
    state.reset();
    bindingStates.reset();
  };
  if (typeof __THREE_DEVTOOLS__ !== "undefined") {
    __THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("observe", { detail: this }));
  }
}
var WebGL1Renderer = class extends WebGLRenderer {
};
WebGL1Renderer.prototype.isWebGL1Renderer = true;
var Scene = class extends Object3D {
  constructor() {
    super();
    this.isScene = true;
    this.type = "Scene";
    this.background = null;
    this.environment = null;
    this.fog = null;
    this.overrideMaterial = null;
    this.autoUpdate = true;
    if (typeof __THREE_DEVTOOLS__ !== "undefined") {
      __THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("observe", { detail: this }));
    }
  }
  copy(source, recursive) {
    super.copy(source, recursive);
    if (source.background !== null)
      this.background = source.background.clone();
    if (source.environment !== null)
      this.environment = source.environment.clone();
    if (source.fog !== null)
      this.fog = source.fog.clone();
    if (source.overrideMaterial !== null)
      this.overrideMaterial = source.overrideMaterial.clone();
    this.autoUpdate = source.autoUpdate;
    this.matrixAutoUpdate = source.matrixAutoUpdate;
    return this;
  }
  toJSON(meta) {
    const data = super.toJSON(meta);
    if (this.fog !== null)
      data.object.fog = this.fog.toJSON();
    return data;
  }
};
var SphereGeometry = class extends BufferGeometry {
  constructor(radius = 1, widthSegments = 32, heightSegments = 16, phiStart = 0, phiLength = Math.PI * 2, thetaStart = 0, thetaLength = Math.PI) {
    super();
    this.type = "SphereGeometry";
    this.parameters = {
      radius,
      widthSegments,
      heightSegments,
      phiStart,
      phiLength,
      thetaStart,
      thetaLength
    };
    widthSegments = Math.max(3, Math.floor(widthSegments));
    heightSegments = Math.max(2, Math.floor(heightSegments));
    const thetaEnd = Math.min(thetaStart + thetaLength, Math.PI);
    let index = 0;
    const grid = [];
    const vertex2 = new Vector3();
    const normal = new Vector3();
    const indices = [];
    const vertices = [];
    const normals = [];
    const uvs = [];
    for (let iy = 0; iy <= heightSegments; iy++) {
      const verticesRow = [];
      const v = iy / heightSegments;
      let uOffset = 0;
      if (iy == 0 && thetaStart == 0) {
        uOffset = 0.5 / widthSegments;
      } else if (iy == heightSegments && thetaEnd == Math.PI) {
        uOffset = -0.5 / widthSegments;
      }
      for (let ix = 0; ix <= widthSegments; ix++) {
        const u = ix / widthSegments;
        vertex2.x = -radius * Math.cos(phiStart + u * phiLength) * Math.sin(thetaStart + v * thetaLength);
        vertex2.y = radius * Math.cos(thetaStart + v * thetaLength);
        vertex2.z = radius * Math.sin(phiStart + u * phiLength) * Math.sin(thetaStart + v * thetaLength);
        vertices.push(vertex2.x, vertex2.y, vertex2.z);
        normal.copy(vertex2).normalize();
        normals.push(normal.x, normal.y, normal.z);
        uvs.push(u + uOffset, 1 - v);
        verticesRow.push(index++);
      }
      grid.push(verticesRow);
    }
    for (let iy = 0; iy < heightSegments; iy++) {
      for (let ix = 0; ix < widthSegments; ix++) {
        const a = grid[iy][ix + 1];
        const b = grid[iy][ix];
        const c = grid[iy + 1][ix];
        const d = grid[iy + 1][ix + 1];
        if (iy !== 0 || thetaStart > 0)
          indices.push(a, b, d);
        if (iy !== heightSegments - 1 || thetaEnd < Math.PI)
          indices.push(b, c, d);
      }
    }
    this.setIndex(indices);
    this.setAttribute("position", new Float32BufferAttribute(vertices, 3));
    this.setAttribute("normal", new Float32BufferAttribute(normals, 3));
    this.setAttribute("uv", new Float32BufferAttribute(uvs, 2));
  }
  static fromJSON(data) {
    return new SphereGeometry(data.radius, data.widthSegments, data.heightSegments, data.phiStart, data.phiLength, data.thetaStart, data.thetaLength);
  }
};
function arraySlice(array, from, to) {
  if (isTypedArray(array)) {
    return new array.constructor(array.subarray(from, to !== void 0 ? to : array.length));
  }
  return array.slice(from, to);
}
function convertArray(array, type, forceClone) {
  if (!array || !forceClone && array.constructor === type)
    return array;
  if (typeof type.BYTES_PER_ELEMENT === "number") {
    return new type(array);
  }
  return Array.prototype.slice.call(array);
}
function isTypedArray(object) {
  return ArrayBuffer.isView(object) && !(object instanceof DataView);
}
var Interpolant = class {
  constructor(parameterPositions, sampleValues, sampleSize, resultBuffer) {
    this.parameterPositions = parameterPositions;
    this._cachedIndex = 0;
    this.resultBuffer = resultBuffer !== void 0 ? resultBuffer : new sampleValues.constructor(sampleSize);
    this.sampleValues = sampleValues;
    this.valueSize = sampleSize;
    this.settings = null;
    this.DefaultSettings_ = {};
  }
  evaluate(t) {
    const pp = this.parameterPositions;
    let i1 = this._cachedIndex, t1 = pp[i1], t0 = pp[i1 - 1];
    validate_interval: {
      seek: {
        let right;
        linear_scan: {
          forward_scan:
            if (!(t < t1)) {
              for (let giveUpAt = i1 + 2; ; ) {
                if (t1 === void 0) {
                  if (t < t0)
                    break forward_scan;
                  i1 = pp.length;
                  this._cachedIndex = i1;
                  return this.copySampleValue_(i1 - 1);
                }
                if (i1 === giveUpAt)
                  break;
                t0 = t1;
                t1 = pp[++i1];
                if (t < t1) {
                  break seek;
                }
              }
              right = pp.length;
              break linear_scan;
            }
          if (!(t >= t0)) {
            const t1global = pp[1];
            if (t < t1global) {
              i1 = 2;
              t0 = t1global;
            }
            for (let giveUpAt = i1 - 2; ; ) {
              if (t0 === void 0) {
                this._cachedIndex = 0;
                return this.copySampleValue_(0);
              }
              if (i1 === giveUpAt)
                break;
              t1 = t0;
              t0 = pp[--i1 - 1];
              if (t >= t0) {
                break seek;
              }
            }
            right = i1;
            i1 = 0;
            break linear_scan;
          }
          break validate_interval;
        }
        while (i1 < right) {
          const mid = i1 + right >>> 1;
          if (t < pp[mid]) {
            right = mid;
          } else {
            i1 = mid + 1;
          }
        }
        t1 = pp[i1];
        t0 = pp[i1 - 1];
        if (t0 === void 0) {
          this._cachedIndex = 0;
          return this.copySampleValue_(0);
        }
        if (t1 === void 0) {
          i1 = pp.length;
          this._cachedIndex = i1;
          return this.copySampleValue_(i1 - 1);
        }
      }
      this._cachedIndex = i1;
      this.intervalChanged_(i1, t0, t1);
    }
    return this.interpolate_(i1, t0, t, t1);
  }
  getSettings_() {
    return this.settings || this.DefaultSettings_;
  }
  copySampleValue_(index) {
    const result = this.resultBuffer, values = this.sampleValues, stride = this.valueSize, offset = index * stride;
    for (let i2 = 0; i2 !== stride; ++i2) {
      result[i2] = values[offset + i2];
    }
    return result;
  }
  interpolate_() {
    throw new Error("call to abstract method");
  }
  intervalChanged_() {
  }
};
var CubicInterpolant = class extends Interpolant {
  constructor(parameterPositions, sampleValues, sampleSize, resultBuffer) {
    super(parameterPositions, sampleValues, sampleSize, resultBuffer);
    this._weightPrev = -0;
    this._offsetPrev = -0;
    this._weightNext = -0;
    this._offsetNext = -0;
    this.DefaultSettings_ = {
      endingStart: ZeroCurvatureEnding,
      endingEnd: ZeroCurvatureEnding
    };
  }
  intervalChanged_(i1, t0, t1) {
    const pp = this.parameterPositions;
    let iPrev = i1 - 2, iNext = i1 + 1, tPrev = pp[iPrev], tNext = pp[iNext];
    if (tPrev === void 0) {
      switch (this.getSettings_().endingStart) {
        case ZeroSlopeEnding:
          iPrev = i1;
          tPrev = 2 * t0 - t1;
          break;
        case WrapAroundEnding:
          iPrev = pp.length - 2;
          tPrev = t0 + pp[iPrev] - pp[iPrev + 1];
          break;
        default:
          iPrev = i1;
          tPrev = t1;
      }
    }
    if (tNext === void 0) {
      switch (this.getSettings_().endingEnd) {
        case ZeroSlopeEnding:
          iNext = i1;
          tNext = 2 * t1 - t0;
          break;
        case WrapAroundEnding:
          iNext = 1;
          tNext = t1 + pp[1] - pp[0];
          break;
        default:
          iNext = i1 - 1;
          tNext = t0;
      }
    }
    const halfDt = (t1 - t0) * 0.5, stride = this.valueSize;
    this._weightPrev = halfDt / (t0 - tPrev);
    this._weightNext = halfDt / (tNext - t1);
    this._offsetPrev = iPrev * stride;
    this._offsetNext = iNext * stride;
  }
  interpolate_(i1, t0, t, t1) {
    const result = this.resultBuffer, values = this.sampleValues, stride = this.valueSize, o1 = i1 * stride, o0 = o1 - stride, oP = this._offsetPrev, oN = this._offsetNext, wP = this._weightPrev, wN = this._weightNext, p = (t - t0) / (t1 - t0), pp = p * p, ppp = pp * p;
    const sP = -wP * ppp + 2 * wP * pp - wP * p;
    const s0 = (1 + wP) * ppp + (-1.5 - 2 * wP) * pp + (-0.5 + wP) * p + 1;
    const s1 = (-1 - wN) * ppp + (1.5 + wN) * pp + 0.5 * p;
    const sN = wN * ppp - wN * pp;
    for (let i2 = 0; i2 !== stride; ++i2) {
      result[i2] = sP * values[oP + i2] + s0 * values[o0 + i2] + s1 * values[o1 + i2] + sN * values[oN + i2];
    }
    return result;
  }
};
var LinearInterpolant = class extends Interpolant {
  constructor(parameterPositions, sampleValues, sampleSize, resultBuffer) {
    super(parameterPositions, sampleValues, sampleSize, resultBuffer);
  }
  interpolate_(i1, t0, t, t1) {
    const result = this.resultBuffer, values = this.sampleValues, stride = this.valueSize, offset1 = i1 * stride, offset0 = offset1 - stride, weight1 = (t - t0) / (t1 - t0), weight0 = 1 - weight1;
    for (let i2 = 0; i2 !== stride; ++i2) {
      result[i2] = values[offset0 + i2] * weight0 + values[offset1 + i2] * weight1;
    }
    return result;
  }
};
var DiscreteInterpolant = class extends Interpolant {
  constructor(parameterPositions, sampleValues, sampleSize, resultBuffer) {
    super(parameterPositions, sampleValues, sampleSize, resultBuffer);
  }
  interpolate_(i1) {
    return this.copySampleValue_(i1 - 1);
  }
};
var KeyframeTrack = class {
  constructor(name, times, values, interpolation) {
    if (name === void 0)
      throw new Error("THREE.KeyframeTrack: track name is undefined");
    if (times === void 0 || times.length === 0)
      throw new Error("THREE.KeyframeTrack: no keyframes in track named " + name);
    this.name = name;
    this.times = convertArray(times, this.TimeBufferType);
    this.values = convertArray(values, this.ValueBufferType);
    this.setInterpolation(interpolation || this.DefaultInterpolation);
  }
  static toJSON(track) {
    const trackType = track.constructor;
    let json;
    if (trackType.toJSON !== this.toJSON) {
      json = trackType.toJSON(track);
    } else {
      json = {
        "name": track.name,
        "times": convertArray(track.times, Array),
        "values": convertArray(track.values, Array)
      };
      const interpolation = track.getInterpolation();
      if (interpolation !== track.DefaultInterpolation) {
        json.interpolation = interpolation;
      }
    }
    json.type = track.ValueTypeName;
    return json;
  }
  InterpolantFactoryMethodDiscrete(result) {
    return new DiscreteInterpolant(this.times, this.values, this.getValueSize(), result);
  }
  InterpolantFactoryMethodLinear(result) {
    return new LinearInterpolant(this.times, this.values, this.getValueSize(), result);
  }
  InterpolantFactoryMethodSmooth(result) {
    return new CubicInterpolant(this.times, this.values, this.getValueSize(), result);
  }
  setInterpolation(interpolation) {
    let factoryMethod;
    switch (interpolation) {
      case InterpolateDiscrete:
        factoryMethod = this.InterpolantFactoryMethodDiscrete;
        break;
      case InterpolateLinear:
        factoryMethod = this.InterpolantFactoryMethodLinear;
        break;
      case InterpolateSmooth:
        factoryMethod = this.InterpolantFactoryMethodSmooth;
        break;
    }
    if (factoryMethod === void 0) {
      const message = "unsupported interpolation for " + this.ValueTypeName + " keyframe track named " + this.name;
      if (this.createInterpolant === void 0) {
        if (interpolation !== this.DefaultInterpolation) {
          this.setInterpolation(this.DefaultInterpolation);
        } else {
          throw new Error(message);
        }
      }
      console.warn("THREE.KeyframeTrack:", message);
      return this;
    }
    this.createInterpolant = factoryMethod;
    return this;
  }
  getInterpolation() {
    switch (this.createInterpolant) {
      case this.InterpolantFactoryMethodDiscrete:
        return InterpolateDiscrete;
      case this.InterpolantFactoryMethodLinear:
        return InterpolateLinear;
      case this.InterpolantFactoryMethodSmooth:
        return InterpolateSmooth;
    }
  }
  getValueSize() {
    return this.values.length / this.times.length;
  }
  shift(timeOffset) {
    if (timeOffset !== 0) {
      const times = this.times;
      for (let i2 = 0, n = times.length; i2 !== n; ++i2) {
        times[i2] += timeOffset;
      }
    }
    return this;
  }
  scale(timeScale) {
    if (timeScale !== 1) {
      const times = this.times;
      for (let i2 = 0, n = times.length; i2 !== n; ++i2) {
        times[i2] *= timeScale;
      }
    }
    return this;
  }
  trim(startTime, endTime) {
    const times = this.times, nKeys = times.length;
    let from = 0, to = nKeys - 1;
    while (from !== nKeys && times[from] < startTime) {
      ++from;
    }
    while (to !== -1 && times[to] > endTime) {
      --to;
    }
    ++to;
    if (from !== 0 || to !== nKeys) {
      if (from >= to) {
        to = Math.max(to, 1);
        from = to - 1;
      }
      const stride = this.getValueSize();
      this.times = arraySlice(times, from, to);
      this.values = arraySlice(this.values, from * stride, to * stride);
    }
    return this;
  }
  validate() {
    let valid = true;
    const valueSize = this.getValueSize();
    if (valueSize - Math.floor(valueSize) !== 0) {
      console.error("THREE.KeyframeTrack: Invalid value size in track.", this);
      valid = false;
    }
    const times = this.times, values = this.values, nKeys = times.length;
    if (nKeys === 0) {
      console.error("THREE.KeyframeTrack: Track is empty.", this);
      valid = false;
    }
    let prevTime = null;
    for (let i2 = 0; i2 !== nKeys; i2++) {
      const currTime = times[i2];
      if (typeof currTime === "number" && isNaN(currTime)) {
        console.error("THREE.KeyframeTrack: Time is not a valid number.", this, i2, currTime);
        valid = false;
        break;
      }
      if (prevTime !== null && prevTime > currTime) {
        console.error("THREE.KeyframeTrack: Out of order keys.", this, i2, currTime, prevTime);
        valid = false;
        break;
      }
      prevTime = currTime;
    }
    if (values !== void 0) {
      if (isTypedArray(values)) {
        for (let i2 = 0, n = values.length; i2 !== n; ++i2) {
          const value = values[i2];
          if (isNaN(value)) {
            console.error("THREE.KeyframeTrack: Value is not a valid number.", this, i2, value);
            valid = false;
            break;
          }
        }
      }
    }
    return valid;
  }
  optimize() {
    const times = arraySlice(this.times), values = arraySlice(this.values), stride = this.getValueSize(), smoothInterpolation = this.getInterpolation() === InterpolateSmooth, lastIndex = times.length - 1;
    let writeIndex = 1;
    for (let i2 = 1; i2 < lastIndex; ++i2) {
      let keep = false;
      const time = times[i2];
      const timeNext = times[i2 + 1];
      if (time !== timeNext && (i2 !== 1 || time !== times[0])) {
        if (!smoothInterpolation) {
          const offset = i2 * stride, offsetP = offset - stride, offsetN = offset + stride;
          for (let j = 0; j !== stride; ++j) {
            const value = values[offset + j];
            if (value !== values[offsetP + j] || value !== values[offsetN + j]) {
              keep = true;
              break;
            }
          }
        } else {
          keep = true;
        }
      }
      if (keep) {
        if (i2 !== writeIndex) {
          times[writeIndex] = times[i2];
          const readOffset = i2 * stride, writeOffset = writeIndex * stride;
          for (let j = 0; j !== stride; ++j) {
            values[writeOffset + j] = values[readOffset + j];
          }
        }
        ++writeIndex;
      }
    }
    if (lastIndex > 0) {
      times[writeIndex] = times[lastIndex];
      for (let readOffset = lastIndex * stride, writeOffset = writeIndex * stride, j = 0; j !== stride; ++j) {
        values[writeOffset + j] = values[readOffset + j];
      }
      ++writeIndex;
    }
    if (writeIndex !== times.length) {
      this.times = arraySlice(times, 0, writeIndex);
      this.values = arraySlice(values, 0, writeIndex * stride);
    } else {
      this.times = times;
      this.values = values;
    }
    return this;
  }
  clone() {
    const times = arraySlice(this.times, 0);
    const values = arraySlice(this.values, 0);
    const TypedKeyframeTrack = this.constructor;
    const track = new TypedKeyframeTrack(this.name, times, values);
    track.createInterpolant = this.createInterpolant;
    return track;
  }
};
KeyframeTrack.prototype.TimeBufferType = Float32Array;
KeyframeTrack.prototype.ValueBufferType = Float32Array;
KeyframeTrack.prototype.DefaultInterpolation = InterpolateLinear;
var BooleanKeyframeTrack = class extends KeyframeTrack {
};
BooleanKeyframeTrack.prototype.ValueTypeName = "bool";
BooleanKeyframeTrack.prototype.ValueBufferType = Array;
BooleanKeyframeTrack.prototype.DefaultInterpolation = InterpolateDiscrete;
BooleanKeyframeTrack.prototype.InterpolantFactoryMethodLinear = void 0;
BooleanKeyframeTrack.prototype.InterpolantFactoryMethodSmooth = void 0;
var ColorKeyframeTrack = class extends KeyframeTrack {
};
ColorKeyframeTrack.prototype.ValueTypeName = "color";
var NumberKeyframeTrack = class extends KeyframeTrack {
};
NumberKeyframeTrack.prototype.ValueTypeName = "number";
var QuaternionLinearInterpolant = class extends Interpolant {
  constructor(parameterPositions, sampleValues, sampleSize, resultBuffer) {
    super(parameterPositions, sampleValues, sampleSize, resultBuffer);
  }
  interpolate_(i1, t0, t, t1) {
    const result = this.resultBuffer, values = this.sampleValues, stride = this.valueSize, alpha = (t - t0) / (t1 - t0);
    let offset = i1 * stride;
    for (let end = offset + stride; offset !== end; offset += 4) {
      Quaternion.slerpFlat(result, 0, values, offset - stride, values, offset, alpha);
    }
    return result;
  }
};
var QuaternionKeyframeTrack = class extends KeyframeTrack {
  InterpolantFactoryMethodLinear(result) {
    return new QuaternionLinearInterpolant(this.times, this.values, this.getValueSize(), result);
  }
};
QuaternionKeyframeTrack.prototype.ValueTypeName = "quaternion";
QuaternionKeyframeTrack.prototype.DefaultInterpolation = InterpolateLinear;
QuaternionKeyframeTrack.prototype.InterpolantFactoryMethodSmooth = void 0;
var StringKeyframeTrack = class extends KeyframeTrack {
};
StringKeyframeTrack.prototype.ValueTypeName = "string";
StringKeyframeTrack.prototype.ValueBufferType = Array;
StringKeyframeTrack.prototype.DefaultInterpolation = InterpolateDiscrete;
StringKeyframeTrack.prototype.InterpolantFactoryMethodLinear = void 0;
StringKeyframeTrack.prototype.InterpolantFactoryMethodSmooth = void 0;
var VectorKeyframeTrack = class extends KeyframeTrack {
};
VectorKeyframeTrack.prototype.ValueTypeName = "vector";
var _RESERVED_CHARS_RE = "\\[\\]\\.:\\/";
var _reservedRe = new RegExp("[" + _RESERVED_CHARS_RE + "]", "g");
var _wordChar = "[^" + _RESERVED_CHARS_RE + "]";
var _wordCharOrDot = "[^" + _RESERVED_CHARS_RE.replace("\\.", "") + "]";
var _directoryRe = /* @__PURE__ */ /((?:WC+[\/:])*)/.source.replace("WC", _wordChar);
var _nodeRe = /* @__PURE__ */ /(WCOD+)?/.source.replace("WCOD", _wordCharOrDot);
var _objectRe = /* @__PURE__ */ /(?:\.(WC+)(?:\[(.+)\])?)?/.source.replace("WC", _wordChar);
var _propertyRe = /* @__PURE__ */ /\.(WC+)(?:\[(.+)\])?/.source.replace("WC", _wordChar);
var _trackRe = new RegExp(
  "^" + _directoryRe + _nodeRe + _objectRe + _propertyRe + "$"
);
var _supportedObjectNames = ["material", "materials", "bones"];
var Composite = class {
  constructor(targetGroup, path, optionalParsedPath) {
    const parsedPath = optionalParsedPath || PropertyBinding.parseTrackName(path);
    this._targetGroup = targetGroup;
    this._bindings = targetGroup.subscribe_(path, parsedPath);
  }
  getValue(array, offset) {
    this.bind();
    const firstValidIndex = this._targetGroup.nCachedObjects_, binding = this._bindings[firstValidIndex];
    if (binding !== void 0)
      binding.getValue(array, offset);
  }
  setValue(array, offset) {
    const bindings = this._bindings;
    for (let i2 = this._targetGroup.nCachedObjects_, n = bindings.length; i2 !== n; ++i2) {
      bindings[i2].setValue(array, offset);
    }
  }
  bind() {
    const bindings = this._bindings;
    for (let i2 = this._targetGroup.nCachedObjects_, n = bindings.length; i2 !== n; ++i2) {
      bindings[i2].bind();
    }
  }
  unbind() {
    const bindings = this._bindings;
    for (let i2 = this._targetGroup.nCachedObjects_, n = bindings.length; i2 !== n; ++i2) {
      bindings[i2].unbind();
    }
  }
};
var PropertyBinding = class {
  constructor(rootNode, path, parsedPath) {
    this.path = path;
    this.parsedPath = parsedPath || PropertyBinding.parseTrackName(path);
    this.node = PropertyBinding.findNode(rootNode, this.parsedPath.nodeName) || rootNode;
    this.rootNode = rootNode;
    this.getValue = this._getValue_unbound;
    this.setValue = this._setValue_unbound;
  }
  static create(root, path, parsedPath) {
    if (!(root && root.isAnimationObjectGroup)) {
      return new PropertyBinding(root, path, parsedPath);
    } else {
      return new PropertyBinding.Composite(root, path, parsedPath);
    }
  }
  static sanitizeNodeName(name) {
    return name.replace(/\s/g, "_").replace(_reservedRe, "");
  }
  static parseTrackName(trackName) {
    const matches = _trackRe.exec(trackName);
    if (matches === null) {
      throw new Error("PropertyBinding: Cannot parse trackName: " + trackName);
    }
    const results = {
      nodeName: matches[2],
      objectName: matches[3],
      objectIndex: matches[4],
      propertyName: matches[5],
      propertyIndex: matches[6]
    };
    const lastDot = results.nodeName && results.nodeName.lastIndexOf(".");
    if (lastDot !== void 0 && lastDot !== -1) {
      const objectName = results.nodeName.substring(lastDot + 1);
      if (_supportedObjectNames.indexOf(objectName) !== -1) {
        results.nodeName = results.nodeName.substring(0, lastDot);
        results.objectName = objectName;
      }
    }
    if (results.propertyName === null || results.propertyName.length === 0) {
      throw new Error("PropertyBinding: can not parse propertyName from trackName: " + trackName);
    }
    return results;
  }
  static findNode(root, nodeName) {
    if (nodeName === void 0 || nodeName === "" || nodeName === "." || nodeName === -1 || nodeName === root.name || nodeName === root.uuid) {
      return root;
    }
    if (root.skeleton) {
      const bone = root.skeleton.getBoneByName(nodeName);
      if (bone !== void 0) {
        return bone;
      }
    }
    if (root.children) {
      const searchNodeSubtree = function(children) {
        for (let i2 = 0; i2 < children.length; i2++) {
          const childNode = children[i2];
          if (childNode.name === nodeName || childNode.uuid === nodeName) {
            return childNode;
          }
          const result = searchNodeSubtree(childNode.children);
          if (result)
            return result;
        }
        return null;
      };
      const subTreeNode = searchNodeSubtree(root.children);
      if (subTreeNode) {
        return subTreeNode;
      }
    }
    return null;
  }
  _getValue_unavailable() {
  }
  _setValue_unavailable() {
  }
  _getValue_direct(buffer, offset) {
    buffer[offset] = this.targetObject[this.propertyName];
  }
  _getValue_array(buffer, offset) {
    const source = this.resolvedProperty;
    for (let i2 = 0, n = source.length; i2 !== n; ++i2) {
      buffer[offset++] = source[i2];
    }
  }
  _getValue_arrayElement(buffer, offset) {
    buffer[offset] = this.resolvedProperty[this.propertyIndex];
  }
  _getValue_toArray(buffer, offset) {
    this.resolvedProperty.toArray(buffer, offset);
  }
  _setValue_direct(buffer, offset) {
    this.targetObject[this.propertyName] = buffer[offset];
  }
  _setValue_direct_setNeedsUpdate(buffer, offset) {
    this.targetObject[this.propertyName] = buffer[offset];
    this.targetObject.needsUpdate = true;
  }
  _setValue_direct_setMatrixWorldNeedsUpdate(buffer, offset) {
    this.targetObject[this.propertyName] = buffer[offset];
    this.targetObject.matrixWorldNeedsUpdate = true;
  }
  _setValue_array(buffer, offset) {
    const dest = this.resolvedProperty;
    for (let i2 = 0, n = dest.length; i2 !== n; ++i2) {
      dest[i2] = buffer[offset++];
    }
  }
  _setValue_array_setNeedsUpdate(buffer, offset) {
    const dest = this.resolvedProperty;
    for (let i2 = 0, n = dest.length; i2 !== n; ++i2) {
      dest[i2] = buffer[offset++];
    }
    this.targetObject.needsUpdate = true;
  }
  _setValue_array_setMatrixWorldNeedsUpdate(buffer, offset) {
    const dest = this.resolvedProperty;
    for (let i2 = 0, n = dest.length; i2 !== n; ++i2) {
      dest[i2] = buffer[offset++];
    }
    this.targetObject.matrixWorldNeedsUpdate = true;
  }
  _setValue_arrayElement(buffer, offset) {
    this.resolvedProperty[this.propertyIndex] = buffer[offset];
  }
  _setValue_arrayElement_setNeedsUpdate(buffer, offset) {
    this.resolvedProperty[this.propertyIndex] = buffer[offset];
    this.targetObject.needsUpdate = true;
  }
  _setValue_arrayElement_setMatrixWorldNeedsUpdate(buffer, offset) {
    this.resolvedProperty[this.propertyIndex] = buffer[offset];
    this.targetObject.matrixWorldNeedsUpdate = true;
  }
  _setValue_fromArray(buffer, offset) {
    this.resolvedProperty.fromArray(buffer, offset);
  }
  _setValue_fromArray_setNeedsUpdate(buffer, offset) {
    this.resolvedProperty.fromArray(buffer, offset);
    this.targetObject.needsUpdate = true;
  }
  _setValue_fromArray_setMatrixWorldNeedsUpdate(buffer, offset) {
    this.resolvedProperty.fromArray(buffer, offset);
    this.targetObject.matrixWorldNeedsUpdate = true;
  }
  _getValue_unbound(targetArray, offset) {
    this.bind();
    this.getValue(targetArray, offset);
  }
  _setValue_unbound(sourceArray, offset) {
    this.bind();
    this.setValue(sourceArray, offset);
  }
  bind() {
    let targetObject = this.node;
    const parsedPath = this.parsedPath;
    const objectName = parsedPath.objectName;
    const propertyName = parsedPath.propertyName;
    let propertyIndex = parsedPath.propertyIndex;
    if (!targetObject) {
      targetObject = PropertyBinding.findNode(this.rootNode, parsedPath.nodeName) || this.rootNode;
      this.node = targetObject;
    }
    this.getValue = this._getValue_unavailable;
    this.setValue = this._setValue_unavailable;
    if (!targetObject) {
      console.error("THREE.PropertyBinding: Trying to update node for track: " + this.path + " but it wasn't found.");
      return;
    }
    if (objectName) {
      let objectIndex = parsedPath.objectIndex;
      switch (objectName) {
        case "materials":
          if (!targetObject.material) {
            console.error("THREE.PropertyBinding: Can not bind to material as node does not have a material.", this);
            return;
          }
          if (!targetObject.material.materials) {
            console.error("THREE.PropertyBinding: Can not bind to material.materials as node.material does not have a materials array.", this);
            return;
          }
          targetObject = targetObject.material.materials;
          break;
        case "bones":
          if (!targetObject.skeleton) {
            console.error("THREE.PropertyBinding: Can not bind to bones as node does not have a skeleton.", this);
            return;
          }
          targetObject = targetObject.skeleton.bones;
          for (let i2 = 0; i2 < targetObject.length; i2++) {
            if (targetObject[i2].name === objectIndex) {
              objectIndex = i2;
              break;
            }
          }
          break;
        default:
          if (targetObject[objectName] === void 0) {
            console.error("THREE.PropertyBinding: Can not bind to objectName of node undefined.", this);
            return;
          }
          targetObject = targetObject[objectName];
      }
      if (objectIndex !== void 0) {
        if (targetObject[objectIndex] === void 0) {
          console.error("THREE.PropertyBinding: Trying to bind to objectIndex of objectName, but is undefined.", this, targetObject);
          return;
        }
        targetObject = targetObject[objectIndex];
      }
    }
    const nodeProperty = targetObject[propertyName];
    if (nodeProperty === void 0) {
      const nodeName = parsedPath.nodeName;
      console.error("THREE.PropertyBinding: Trying to update property for track: " + nodeName + "." + propertyName + " but it wasn't found.", targetObject);
      return;
    }
    let versioning = this.Versioning.None;
    this.targetObject = targetObject;
    if (targetObject.needsUpdate !== void 0) {
      versioning = this.Versioning.NeedsUpdate;
    } else if (targetObject.matrixWorldNeedsUpdate !== void 0) {
      versioning = this.Versioning.MatrixWorldNeedsUpdate;
    }
    let bindingType = this.BindingType.Direct;
    if (propertyIndex !== void 0) {
      if (propertyName === "morphTargetInfluences") {
        if (!targetObject.geometry) {
          console.error("THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.", this);
          return;
        }
        if (!targetObject.geometry.morphAttributes) {
          console.error("THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.morphAttributes.", this);
          return;
        }
        if (targetObject.morphTargetDictionary[propertyIndex] !== void 0) {
          propertyIndex = targetObject.morphTargetDictionary[propertyIndex];
        }
      }
      bindingType = this.BindingType.ArrayElement;
      this.resolvedProperty = nodeProperty;
      this.propertyIndex = propertyIndex;
    } else if (nodeProperty.fromArray !== void 0 && nodeProperty.toArray !== void 0) {
      bindingType = this.BindingType.HasFromToArray;
      this.resolvedProperty = nodeProperty;
    } else if (Array.isArray(nodeProperty)) {
      bindingType = this.BindingType.EntireArray;
      this.resolvedProperty = nodeProperty;
    } else {
      this.propertyName = propertyName;
    }
    this.getValue = this.GetterByBindingType[bindingType];
    this.setValue = this.SetterByBindingTypeAndVersioning[bindingType][versioning];
  }
  unbind() {
    this.node = null;
    this.getValue = this._getValue_unbound;
    this.setValue = this._setValue_unbound;
  }
};
PropertyBinding.Composite = Composite;
PropertyBinding.prototype.BindingType = {
  Direct: 0,
  EntireArray: 1,
  ArrayElement: 2,
  HasFromToArray: 3
};
PropertyBinding.prototype.Versioning = {
  None: 0,
  NeedsUpdate: 1,
  MatrixWorldNeedsUpdate: 2
};
PropertyBinding.prototype.GetterByBindingType = [
  PropertyBinding.prototype._getValue_direct,
  PropertyBinding.prototype._getValue_array,
  PropertyBinding.prototype._getValue_arrayElement,
  PropertyBinding.prototype._getValue_toArray
];
PropertyBinding.prototype.SetterByBindingTypeAndVersioning = [
  [
    PropertyBinding.prototype._setValue_direct,
    PropertyBinding.prototype._setValue_direct_setNeedsUpdate,
    PropertyBinding.prototype._setValue_direct_setMatrixWorldNeedsUpdate
  ],
  [
    PropertyBinding.prototype._setValue_array,
    PropertyBinding.prototype._setValue_array_setNeedsUpdate,
    PropertyBinding.prototype._setValue_array_setMatrixWorldNeedsUpdate
  ],
  [
    PropertyBinding.prototype._setValue_arrayElement,
    PropertyBinding.prototype._setValue_arrayElement_setNeedsUpdate,
    PropertyBinding.prototype._setValue_arrayElement_setMatrixWorldNeedsUpdate
  ],
  [
    PropertyBinding.prototype._setValue_fromArray,
    PropertyBinding.prototype._setValue_fromArray_setNeedsUpdate,
    PropertyBinding.prototype._setValue_fromArray_setMatrixWorldNeedsUpdate
  ]
];
var _controlInterpolantsResultBuffer = new Float32Array(1);
var Spherical = class {
  constructor(radius = 1, phi = 0, theta = 0) {
    this.radius = radius;
    this.phi = phi;
    this.theta = theta;
    return this;
  }
  set(radius, phi, theta) {
    this.radius = radius;
    this.phi = phi;
    this.theta = theta;
    return this;
  }
  copy(other) {
    this.radius = other.radius;
    this.phi = other.phi;
    this.theta = other.theta;
    return this;
  }
  makeSafe() {
    const EPS = 1e-6;
    this.phi = Math.max(EPS, Math.min(Math.PI - EPS, this.phi));
    return this;
  }
  setFromVector3(v) {
    return this.setFromCartesianCoords(v.x, v.y, v.z);
  }
  setFromCartesianCoords(x, y, z) {
    this.radius = Math.sqrt(x * x + y * y + z * z);
    if (this.radius === 0) {
      this.theta = 0;
      this.phi = 0;
    } else {
      this.theta = Math.atan2(x, z);
      this.phi = Math.acos(clamp(y / this.radius, -1, 1));
    }
    return this;
  }
  clone() {
    return new this.constructor().copy(this);
  }
};
if (typeof __THREE_DEVTOOLS__ !== "undefined") {
  __THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("register", { detail: {
    revision: REVISION
  } }));
}
if (typeof window !== "undefined") {
  if (window.__THREE__) {
    console.warn("WARNING: Multiple instances of Three.js being imported.");
  } else {
    window.__THREE__ = REVISION;
  }
}

// node_modules/three/examples/jsm/controls/OrbitControls.js
var _changeEvent = { type: "change" };
var _startEvent = { type: "start" };
var _endEvent = { type: "end" };
var OrbitControls = class extends EventDispatcher {
  constructor(object, domElement) {
    super();
    if (domElement === void 0)
      console.warn('THREE.OrbitControls: The second parameter "domElement" is now mandatory.');
    if (domElement === document)
      console.error('THREE.OrbitControls: "document" should not be used as the target "domElement". Please use "renderer.domElement" instead.');
    this.object = object;
    this.domElement = domElement;
    this.domElement.style.touchAction = "none";
    this.enabled = true;
    this.target = new Vector3();
    this.minDistance = 0;
    this.maxDistance = Infinity;
    this.minZoom = 0;
    this.maxZoom = Infinity;
    this.minPolarAngle = 0;
    this.maxPolarAngle = Math.PI;
    this.minAzimuthAngle = -Infinity;
    this.maxAzimuthAngle = Infinity;
    this.enableDamping = false;
    this.dampingFactor = 0.05;
    this.enableZoom = true;
    this.zoomSpeed = 1;
    this.enableRotate = true;
    this.rotateSpeed = 1;
    this.enablePan = true;
    this.panSpeed = 1;
    this.screenSpacePanning = true;
    this.keyPanSpeed = 7;
    this.autoRotate = false;
    this.autoRotateSpeed = 2;
    this.keys = { LEFT: "ArrowLeft", UP: "ArrowUp", RIGHT: "ArrowRight", BOTTOM: "ArrowDown" };
    this.mouseButtons = { LEFT: MOUSE.ROTATE, MIDDLE: MOUSE.DOLLY, RIGHT: MOUSE.PAN };
    this.touches = { ONE: TOUCH.ROTATE, TWO: TOUCH.DOLLY_PAN };
    this.target0 = this.target.clone();
    this.position0 = this.object.position.clone();
    this.zoom0 = this.object.zoom;
    this._domElementKeyEvents = null;
    this.getPolarAngle = function() {
      return spherical.phi;
    };
    this.getAzimuthalAngle = function() {
      return spherical.theta;
    };
    this.getDistance = function() {
      return this.object.position.distanceTo(this.target);
    };
    this.listenToKeyEvents = function(domElement2) {
      domElement2.addEventListener("keydown", onKeyDown);
      this._domElementKeyEvents = domElement2;
    };
    this.saveState = function() {
      scope.target0.copy(scope.target);
      scope.position0.copy(scope.object.position);
      scope.zoom0 = scope.object.zoom;
    };
    this.reset = function() {
      scope.target.copy(scope.target0);
      scope.object.position.copy(scope.position0);
      scope.object.zoom = scope.zoom0;
      scope.object.updateProjectionMatrix();
      scope.dispatchEvent(_changeEvent);
      scope.update();
      state = STATE.NONE;
    };
    this.update = function() {
      const offset = new Vector3();
      const quat = new Quaternion().setFromUnitVectors(object.up, new Vector3(0, 1, 0));
      const quatInverse = quat.clone().invert();
      const lastPosition = new Vector3();
      const lastQuaternion = new Quaternion();
      const twoPI = 2 * Math.PI;
      return function update() {
        const position = scope.object.position;
        offset.copy(position).sub(scope.target);
        offset.applyQuaternion(quat);
        spherical.setFromVector3(offset);
        if (scope.autoRotate && state === STATE.NONE) {
          rotateLeft(getAutoRotationAngle());
        }
        if (scope.enableDamping) {
          spherical.theta += sphericalDelta.theta * scope.dampingFactor;
          spherical.phi += sphericalDelta.phi * scope.dampingFactor;
        } else {
          spherical.theta += sphericalDelta.theta;
          spherical.phi += sphericalDelta.phi;
        }
        let min = scope.minAzimuthAngle;
        let max = scope.maxAzimuthAngle;
        if (isFinite(min) && isFinite(max)) {
          if (min < -Math.PI)
            min += twoPI;
          else if (min > Math.PI)
            min -= twoPI;
          if (max < -Math.PI)
            max += twoPI;
          else if (max > Math.PI)
            max -= twoPI;
          if (min <= max) {
            spherical.theta = Math.max(min, Math.min(max, spherical.theta));
          } else {
            spherical.theta = spherical.theta > (min + max) / 2 ? Math.max(min, spherical.theta) : Math.min(max, spherical.theta);
          }
        }
        spherical.phi = Math.max(scope.minPolarAngle, Math.min(scope.maxPolarAngle, spherical.phi));
        spherical.makeSafe();
        spherical.radius *= scale;
        spherical.radius = Math.max(scope.minDistance, Math.min(scope.maxDistance, spherical.radius));
        if (scope.enableDamping === true) {
          scope.target.addScaledVector(panOffset, scope.dampingFactor);
        } else {
          scope.target.add(panOffset);
        }
        offset.setFromSpherical(spherical);
        offset.applyQuaternion(quatInverse);
        position.copy(scope.target).add(offset);
        scope.object.lookAt(scope.target);
        if (scope.enableDamping === true) {
          sphericalDelta.theta *= 1 - scope.dampingFactor;
          sphericalDelta.phi *= 1 - scope.dampingFactor;
          panOffset.multiplyScalar(1 - scope.dampingFactor);
        } else {
          sphericalDelta.set(0, 0, 0);
          panOffset.set(0, 0, 0);
        }
        scale = 1;
        if (zoomChanged || lastPosition.distanceToSquared(scope.object.position) > EPS || 8 * (1 - lastQuaternion.dot(scope.object.quaternion)) > EPS) {
          scope.dispatchEvent(_changeEvent);
          lastPosition.copy(scope.object.position);
          lastQuaternion.copy(scope.object.quaternion);
          zoomChanged = false;
          return true;
        }
        return false;
      };
    }();
    this.dispose = function() {
      scope.domElement.removeEventListener("contextmenu", onContextMenu);
      scope.domElement.removeEventListener("pointerdown", onPointerDown);
      scope.domElement.removeEventListener("pointercancel", onPointerCancel);
      scope.domElement.removeEventListener("wheel", onMouseWheel);
      scope.domElement.removeEventListener("pointermove", onPointerMove);
      scope.domElement.removeEventListener("pointerup", onPointerUp);
      if (scope._domElementKeyEvents !== null) {
        scope._domElementKeyEvents.removeEventListener("keydown", onKeyDown);
      }
    };
    const scope = this;
    const STATE = {
      NONE: -1,
      ROTATE: 0,
      DOLLY: 1,
      PAN: 2,
      TOUCH_ROTATE: 3,
      TOUCH_PAN: 4,
      TOUCH_DOLLY_PAN: 5,
      TOUCH_DOLLY_ROTATE: 6
    };
    let state = STATE.NONE;
    const EPS = 1e-6;
    const spherical = new Spherical();
    const sphericalDelta = new Spherical();
    let scale = 1;
    const panOffset = new Vector3();
    let zoomChanged = false;
    const rotateStart = new Vector2();
    const rotateEnd = new Vector2();
    const rotateDelta = new Vector2();
    const panStart = new Vector2();
    const panEnd = new Vector2();
    const panDelta = new Vector2();
    const dollyStart = new Vector2();
    const dollyEnd = new Vector2();
    const dollyDelta = new Vector2();
    const pointers = [];
    const pointerPositions = {};
    function getAutoRotationAngle() {
      return 2 * Math.PI / 60 / 60 * scope.autoRotateSpeed;
    }
    function getZoomScale() {
      return Math.pow(0.95, scope.zoomSpeed);
    }
    function rotateLeft(angle) {
      sphericalDelta.theta -= angle;
    }
    function rotateUp(angle) {
      sphericalDelta.phi -= angle;
    }
    const panLeft = function() {
      const v = new Vector3();
      return function panLeft2(distance, objectMatrix) {
        v.setFromMatrixColumn(objectMatrix, 0);
        v.multiplyScalar(-distance);
        panOffset.add(v);
      };
    }();
    const panUp = function() {
      const v = new Vector3();
      return function panUp2(distance, objectMatrix) {
        if (scope.screenSpacePanning === true) {
          v.setFromMatrixColumn(objectMatrix, 1);
        } else {
          v.setFromMatrixColumn(objectMatrix, 0);
          v.crossVectors(scope.object.up, v);
        }
        v.multiplyScalar(distance);
        panOffset.add(v);
      };
    }();
    const pan = function() {
      const offset = new Vector3();
      return function pan2(deltaX, deltaY) {
        const element = scope.domElement;
        if (scope.object.isPerspectiveCamera) {
          const position = scope.object.position;
          offset.copy(position).sub(scope.target);
          let targetDistance = offset.length();
          targetDistance *= Math.tan(scope.object.fov / 2 * Math.PI / 180);
          panLeft(2 * deltaX * targetDistance / element.clientHeight, scope.object.matrix);
          panUp(2 * deltaY * targetDistance / element.clientHeight, scope.object.matrix);
        } else if (scope.object.isOrthographicCamera) {
          panLeft(deltaX * (scope.object.right - scope.object.left) / scope.object.zoom / element.clientWidth, scope.object.matrix);
          panUp(deltaY * (scope.object.top - scope.object.bottom) / scope.object.zoom / element.clientHeight, scope.object.matrix);
        } else {
          console.warn("WARNING: OrbitControls.js encountered an unknown camera type - pan disabled.");
          scope.enablePan = false;
        }
      };
    }();
    function dollyOut(dollyScale) {
      if (scope.object.isPerspectiveCamera) {
        scale /= dollyScale;
      } else if (scope.object.isOrthographicCamera) {
        scope.object.zoom = Math.max(scope.minZoom, Math.min(scope.maxZoom, scope.object.zoom * dollyScale));
        scope.object.updateProjectionMatrix();
        zoomChanged = true;
      } else {
        console.warn("WARNING: OrbitControls.js encountered an unknown camera type - dolly/zoom disabled.");
        scope.enableZoom = false;
      }
    }
    function dollyIn(dollyScale) {
      if (scope.object.isPerspectiveCamera) {
        scale *= dollyScale;
      } else if (scope.object.isOrthographicCamera) {
        scope.object.zoom = Math.max(scope.minZoom, Math.min(scope.maxZoom, scope.object.zoom / dollyScale));
        scope.object.updateProjectionMatrix();
        zoomChanged = true;
      } else {
        console.warn("WARNING: OrbitControls.js encountered an unknown camera type - dolly/zoom disabled.");
        scope.enableZoom = false;
      }
    }
    function handleMouseDownRotate(event) {
      rotateStart.set(event.clientX, event.clientY);
    }
    function handleMouseDownDolly(event) {
      dollyStart.set(event.clientX, event.clientY);
    }
    function handleMouseDownPan(event) {
      panStart.set(event.clientX, event.clientY);
    }
    function handleMouseMoveRotate(event) {
      rotateEnd.set(event.clientX, event.clientY);
      rotateDelta.subVectors(rotateEnd, rotateStart).multiplyScalar(scope.rotateSpeed);
      const element = scope.domElement;
      rotateLeft(2 * Math.PI * rotateDelta.x / element.clientHeight);
      rotateUp(2 * Math.PI * rotateDelta.y / element.clientHeight);
      rotateStart.copy(rotateEnd);
      scope.update();
    }
    function handleMouseMoveDolly(event) {
      dollyEnd.set(event.clientX, event.clientY);
      dollyDelta.subVectors(dollyEnd, dollyStart);
      if (dollyDelta.y > 0) {
        dollyOut(getZoomScale());
      } else if (dollyDelta.y < 0) {
        dollyIn(getZoomScale());
      }
      dollyStart.copy(dollyEnd);
      scope.update();
    }
    function handleMouseMovePan(event) {
      panEnd.set(event.clientX, event.clientY);
      panDelta.subVectors(panEnd, panStart).multiplyScalar(scope.panSpeed);
      pan(panDelta.x, panDelta.y);
      panStart.copy(panEnd);
      scope.update();
    }
    function handleMouseWheel(event) {
      if (event.deltaY < 0) {
        dollyIn(getZoomScale());
      } else if (event.deltaY > 0) {
        dollyOut(getZoomScale());
      }
      scope.update();
    }
    function handleKeyDown(event) {
      let needsUpdate = false;
      switch (event.code) {
        case scope.keys.UP:
          pan(0, scope.keyPanSpeed);
          needsUpdate = true;
          break;
        case scope.keys.BOTTOM:
          pan(0, -scope.keyPanSpeed);
          needsUpdate = true;
          break;
        case scope.keys.LEFT:
          pan(scope.keyPanSpeed, 0);
          needsUpdate = true;
          break;
        case scope.keys.RIGHT:
          pan(-scope.keyPanSpeed, 0);
          needsUpdate = true;
          break;
      }
      if (needsUpdate) {
        event.preventDefault();
        scope.update();
      }
    }
    function handleTouchStartRotate() {
      if (pointers.length === 1) {
        rotateStart.set(pointers[0].pageX, pointers[0].pageY);
      } else {
        const x = 0.5 * (pointers[0].pageX + pointers[1].pageX);
        const y = 0.5 * (pointers[0].pageY + pointers[1].pageY);
        rotateStart.set(x, y);
      }
    }
    function handleTouchStartPan() {
      if (pointers.length === 1) {
        panStart.set(pointers[0].pageX, pointers[0].pageY);
      } else {
        const x = 0.5 * (pointers[0].pageX + pointers[1].pageX);
        const y = 0.5 * (pointers[0].pageY + pointers[1].pageY);
        panStart.set(x, y);
      }
    }
    function handleTouchStartDolly() {
      const dx = pointers[0].pageX - pointers[1].pageX;
      const dy = pointers[0].pageY - pointers[1].pageY;
      const distance = Math.sqrt(dx * dx + dy * dy);
      dollyStart.set(0, distance);
    }
    function handleTouchStartDollyPan() {
      if (scope.enableZoom)
        handleTouchStartDolly();
      if (scope.enablePan)
        handleTouchStartPan();
    }
    function handleTouchStartDollyRotate() {
      if (scope.enableZoom)
        handleTouchStartDolly();
      if (scope.enableRotate)
        handleTouchStartRotate();
    }
    function handleTouchMoveRotate(event) {
      if (pointers.length == 1) {
        rotateEnd.set(event.pageX, event.pageY);
      } else {
        const position = getSecondPointerPosition(event);
        const x = 0.5 * (event.pageX + position.x);
        const y = 0.5 * (event.pageY + position.y);
        rotateEnd.set(x, y);
      }
      rotateDelta.subVectors(rotateEnd, rotateStart).multiplyScalar(scope.rotateSpeed);
      const element = scope.domElement;
      rotateLeft(2 * Math.PI * rotateDelta.x / element.clientHeight);
      rotateUp(2 * Math.PI * rotateDelta.y / element.clientHeight);
      rotateStart.copy(rotateEnd);
    }
    function handleTouchMovePan(event) {
      if (pointers.length === 1) {
        panEnd.set(event.pageX, event.pageY);
      } else {
        const position = getSecondPointerPosition(event);
        const x = 0.5 * (event.pageX + position.x);
        const y = 0.5 * (event.pageY + position.y);
        panEnd.set(x, y);
      }
      panDelta.subVectors(panEnd, panStart).multiplyScalar(scope.panSpeed);
      pan(panDelta.x, panDelta.y);
      panStart.copy(panEnd);
    }
    function handleTouchMoveDolly(event) {
      const position = getSecondPointerPosition(event);
      const dx = event.pageX - position.x;
      const dy = event.pageY - position.y;
      const distance = Math.sqrt(dx * dx + dy * dy);
      dollyEnd.set(0, distance);
      dollyDelta.set(0, Math.pow(dollyEnd.y / dollyStart.y, scope.zoomSpeed));
      dollyOut(dollyDelta.y);
      dollyStart.copy(dollyEnd);
    }
    function handleTouchMoveDollyPan(event) {
      if (scope.enableZoom)
        handleTouchMoveDolly(event);
      if (scope.enablePan)
        handleTouchMovePan(event);
    }
    function handleTouchMoveDollyRotate(event) {
      if (scope.enableZoom)
        handleTouchMoveDolly(event);
      if (scope.enableRotate)
        handleTouchMoveRotate(event);
    }
    function onPointerDown(event) {
      if (scope.enabled === false)
        return;
      if (pointers.length === 0) {
        scope.domElement.setPointerCapture(event.pointerId);
        scope.domElement.addEventListener("pointermove", onPointerMove);
        scope.domElement.addEventListener("pointerup", onPointerUp);
      }
      addPointer(event);
      if (event.pointerType === "touch") {
        onTouchStart(event);
      } else {
        onMouseDown(event);
      }
    }
    function onPointerMove(event) {
      if (scope.enabled === false)
        return;
      if (event.pointerType === "touch") {
        onTouchMove(event);
      } else {
        onMouseMove(event);
      }
    }
    function onPointerUp(event) {
      removePointer(event);
      if (pointers.length === 0) {
        scope.domElement.releasePointerCapture(event.pointerId);
        scope.domElement.removeEventListener("pointermove", onPointerMove);
        scope.domElement.removeEventListener("pointerup", onPointerUp);
      }
      scope.dispatchEvent(_endEvent);
      state = STATE.NONE;
    }
    function onPointerCancel(event) {
      removePointer(event);
    }
    function onMouseDown(event) {
      let mouseAction;
      switch (event.button) {
        case 0:
          mouseAction = scope.mouseButtons.LEFT;
          break;
        case 1:
          mouseAction = scope.mouseButtons.MIDDLE;
          break;
        case 2:
          mouseAction = scope.mouseButtons.RIGHT;
          break;
        default:
          mouseAction = -1;
      }
      switch (mouseAction) {
        case MOUSE.DOLLY:
          if (scope.enableZoom === false)
            return;
          handleMouseDownDolly(event);
          state = STATE.DOLLY;
          break;
        case MOUSE.ROTATE:
          if (event.ctrlKey || event.metaKey || event.shiftKey) {
            if (scope.enablePan === false)
              return;
            handleMouseDownPan(event);
            state = STATE.PAN;
          } else {
            if (scope.enableRotate === false)
              return;
            handleMouseDownRotate(event);
            state = STATE.ROTATE;
          }
          break;
        case MOUSE.PAN:
          if (event.ctrlKey || event.metaKey || event.shiftKey) {
            if (scope.enableRotate === false)
              return;
            handleMouseDownRotate(event);
            state = STATE.ROTATE;
          } else {
            if (scope.enablePan === false)
              return;
            handleMouseDownPan(event);
            state = STATE.PAN;
          }
          break;
        default:
          state = STATE.NONE;
      }
      if (state !== STATE.NONE) {
        scope.dispatchEvent(_startEvent);
      }
    }
    function onMouseMove(event) {
      switch (state) {
        case STATE.ROTATE:
          if (scope.enableRotate === false)
            return;
          handleMouseMoveRotate(event);
          break;
        case STATE.DOLLY:
          if (scope.enableZoom === false)
            return;
          handleMouseMoveDolly(event);
          break;
        case STATE.PAN:
          if (scope.enablePan === false)
            return;
          handleMouseMovePan(event);
          break;
      }
    }
    function onMouseWheel(event) {
      if (scope.enabled === false || scope.enableZoom === false || state !== STATE.NONE)
        return;
      event.preventDefault();
      scope.dispatchEvent(_startEvent);
      handleMouseWheel(event);
      scope.dispatchEvent(_endEvent);
    }
    function onKeyDown(event) {
      if (scope.enabled === false || scope.enablePan === false)
        return;
      handleKeyDown(event);
    }
    function onTouchStart(event) {
      trackPointer(event);
      switch (pointers.length) {
        case 1:
          switch (scope.touches.ONE) {
            case TOUCH.ROTATE:
              if (scope.enableRotate === false)
                return;
              handleTouchStartRotate();
              state = STATE.TOUCH_ROTATE;
              break;
            case TOUCH.PAN:
              if (scope.enablePan === false)
                return;
              handleTouchStartPan();
              state = STATE.TOUCH_PAN;
              break;
            default:
              state = STATE.NONE;
          }
          break;
        case 2:
          switch (scope.touches.TWO) {
            case TOUCH.DOLLY_PAN:
              if (scope.enableZoom === false && scope.enablePan === false)
                return;
              handleTouchStartDollyPan();
              state = STATE.TOUCH_DOLLY_PAN;
              break;
            case TOUCH.DOLLY_ROTATE:
              if (scope.enableZoom === false && scope.enableRotate === false)
                return;
              handleTouchStartDollyRotate();
              state = STATE.TOUCH_DOLLY_ROTATE;
              break;
            default:
              state = STATE.NONE;
          }
          break;
        default:
          state = STATE.NONE;
      }
      if (state !== STATE.NONE) {
        scope.dispatchEvent(_startEvent);
      }
    }
    function onTouchMove(event) {
      trackPointer(event);
      switch (state) {
        case STATE.TOUCH_ROTATE:
          if (scope.enableRotate === false)
            return;
          handleTouchMoveRotate(event);
          scope.update();
          break;
        case STATE.TOUCH_PAN:
          if (scope.enablePan === false)
            return;
          handleTouchMovePan(event);
          scope.update();
          break;
        case STATE.TOUCH_DOLLY_PAN:
          if (scope.enableZoom === false && scope.enablePan === false)
            return;
          handleTouchMoveDollyPan(event);
          scope.update();
          break;
        case STATE.TOUCH_DOLLY_ROTATE:
          if (scope.enableZoom === false && scope.enableRotate === false)
            return;
          handleTouchMoveDollyRotate(event);
          scope.update();
          break;
        default:
          state = STATE.NONE;
      }
    }
    function onContextMenu(event) {
      if (scope.enabled === false)
        return;
      event.preventDefault();
    }
    function addPointer(event) {
      pointers.push(event);
    }
    function removePointer(event) {
      delete pointerPositions[event.pointerId];
      for (let i2 = 0; i2 < pointers.length; i2++) {
        if (pointers[i2].pointerId == event.pointerId) {
          pointers.splice(i2, 1);
          return;
        }
      }
    }
    function trackPointer(event) {
      let position = pointerPositions[event.pointerId];
      if (position === void 0) {
        position = new Vector2();
        pointerPositions[event.pointerId] = position;
      }
      position.set(event.pageX, event.pageY);
    }
    function getSecondPointerPosition(event) {
      const pointer = event.pointerId === pointers[0].pointerId ? pointers[1] : pointers[0];
      return pointerPositions[pointer.pointerId];
    }
    scope.domElement.addEventListener("contextmenu", onContextMenu);
    scope.domElement.addEventListener("pointerdown", onPointerDown);
    scope.domElement.addEventListener("pointercancel", onPointerCancel);
    scope.domElement.addEventListener("wheel", onMouseWheel, { passive: false });
    this.update();
  }
};

// src/BetterStats.ts
var BetterStats = class {
  constructor(webglRenderer) {
    this.renderer = webglRenderer;
    const container = document.createElement("div");
    this.domElement = container;
    container.style.cssText = "width:80px;opacity:0.9;cursor:pointer;position:absolute;bottom:0";
    const msDiv = document.createElement("div");
    msDiv.style.cssText = "padding:0 0 3px 3px;text-align:left;background-color:#200;";
    container.appendChild(msDiv);
    const msText = document.createElement("div");
    msText.style.cssText = "color:#f00;font-family:Helvetica,Arial,sans-serif;font-size:9px;font-weight:bold;line-height:15px";
    msText.innerHTML = "WebGLRenderer";
    msDiv.appendChild(msText);
    this.msTexts = [];
    const nLines = 10;
    for (var i2 = 0; i2 < nLines; i2++) {
      this.msTexts[i2] = document.createElement("div");
      this.msTexts[i2].style.cssText = "color:#f00;background-color:#311;font-family:Helvetica,Arial,sans-serif;font-size:9px;font-weight:bold;line-height:15px";
      msDiv.appendChild(this.msTexts[i2]);
      this.msTexts[i2].innerHTML = "-";
    }
    this.lastTime = performance.now();
    this.fps = 0;
  }
  update() {
    const currentTime = performance.now();
    const elapsed = currentTime - this.lastTime;
    this.lastTime = currentTime;
    const currentFPS = Math.floor(1 / elapsed * 1e3);
    const alpha = 0.1;
    this.fps = (1 - alpha) * this.fps + alpha * currentFPS;
    var i2 = 0;
    this.msTexts[i2++].textContent = "=== Memory ===";
    this.msTexts[i2++].textContent = "Programs: " + this.renderer.info.programs?.length;
    this.msTexts[i2++].textContent = "Geometries: " + this.renderer.info.memory.geometries;
    this.msTexts[i2++].textContent = "Textures: " + this.renderer.info.memory.textures;
    this.msTexts[i2++].textContent = "=== Render ===";
    this.msTexts[i2++].textContent = "Calls: " + this.renderer.info.render.calls;
    this.msTexts[i2++].textContent = "FPS: " + Math.floor(this.fps);
    this.msTexts[i2++].textContent = "Triangles: " + Math.floor(this.renderer.info.render.triangles);
    this.msTexts[i2++].textContent = "Points: " + this.renderer.info.render.points;
    this.msTexts[i2++].textContent = "Lines: " + this.renderer.info.render.lines;
  }
};

// src/Meshlet.ts
function hash(co) {
  function fract(n) {
    return n % 1;
  }
  return fract(Math.sin((co + 1) * 12.9898) * 43758.5453);
}
var seed = 0;
function seedRandom() {
  return Math.abs(hash(seed += 1));
}
var Vertex = class {
  constructor(x, y, z) {
    this.x = x;
    this.y = y;
    this.z = z;
  }
};
var Triangle2 = class {
  constructor(a, b, c) {
    this.a = a;
    this.b = b;
    this.c = c;
  }
};
var Edge = class {
  constructor(fromIndex, toIndex) {
    this.fromIndex = fromIndex;
    this.toIndex = toIndex;
  }
  equal(other) {
    return this.fromIndex === other.fromIndex && this.toIndex === other.toIndex;
  }
  isAdjacent(other) {
    return this.fromIndex === other.fromIndex || this.fromIndex === other.toIndex || this.toIndex === other.fromIndex || this.toIndex === other.toIndex;
  }
};
var Meshlet = class {
  constructor(vertices, indices) {
    this.vertices_raw = vertices;
    this.indices_raw = indices;
    this.vertices = this.buildVertexMap(vertices);
    this.triangles = this.buildTriangleMap(indices);
    this.edges = this.buildEdgeMap(this.triangles);
    this.boundaryEdges = this.getBoundary(this.edges);
    this.id = Math.floor(seedRandom() * 1e7);
  }
  buildVertexMap(vertices) {
    let vertex2 = [];
    for (let i2 = 0; i2 < vertices.length; i2 += 3) {
      vertex2.push(new Vertex(vertices[i2 + 0], vertices[i2 + 1], vertices[i2 + 2]));
    }
    return vertex2;
  }
  buildTriangleMap(indices) {
    let triangles = [];
    for (let i2 = 0; i2 < indices.length; i2 += 3) {
      triangles.push(new Triangle2(indices[i2 + 0], indices[i2 + 1], indices[i2 + 2]));
    }
    return triangles;
  }
  buildEdgeMap(triangles) {
    let edges = [];
    for (let i2 = 0; i2 < triangles.length; i2++) {
      const triangle = triangles[i2];
      const face = [triangle.a, triangle.b, triangle.c];
      for (let i3 = 0; i3 < 3; i3++) {
        const startIndex = face[i3];
        const endIndex = face[(i3 + 1) % 3];
        edges.push(new Edge(
          Math.min(startIndex, endIndex),
          Math.max(startIndex, endIndex)
        ));
      }
    }
    return edges;
  }
  getBoundary(edges) {
    let counts = new Array(edges.length).fill(0);
    for (let i2 = 0; i2 < edges.length; i2++) {
      const a = edges[i2];
      for (let j = 0; j < edges.length; j++) {
        const b = edges[j];
        if (a.fromIndex === b.fromIndex && a.toIndex === b.toIndex) {
          counts[i2]++;
        }
      }
    }
    let boundaryEdges = [];
    for (let i2 = 0; i2 < counts.length; i2++) {
      if (counts[i2] == 1) {
        boundaryEdges.push(edges[i2]);
      }
    }
    return boundaryEdges;
  }
  getEdgeVertices(edge) {
    const from = edge.fromIndex;
    const to = edge.toIndex;
    return [this.vertices[from], this.vertices[to]];
  }
  getEdgeHash(edge) {
    function hashVertex(vertex2) {
      return `${vertex2.x},${vertex2.y},${vertex2.z}`;
    }
    const edgeVertices = this.getEdgeVertices(edge);
    const fromVertexHash = hashVertex(edgeVertices[0]);
    const toVertexHash = hashVertex(edgeVertices[1]);
    const edgeHash = `${fromVertexHash}:${toVertexHash}`;
    return edgeHash;
  }
};

// src/MeshletGrouper.ts
var MeshletGrouper = class {
  static buildFacesFromIndices(indices) {
    const faces = [];
    for (let j = 0; j < indices.length; j += 3) {
      const f0 = indices[j];
      const f1 = indices[j + 1];
      const f2 = indices[j + 2];
      faces.push([f0, f1, f2]);
    }
    return faces;
  }
  static getFacesFromIndices(faceIndices, faces) {
    return faceIndices.map((faceIndex) => faces[faceIndex]);
  }
  static buildFaceAdjacencyMatrix(faces) {
    const edgeToFaceMap = /* @__PURE__ */ new Map();
    for (let faceIndex = 0; faceIndex < faces.length; faceIndex++) {
      const face = faces[faceIndex];
      for (let i2 = 0; i2 < 3; i2++) {
        const startIndex = face[i2];
        const endIndex = face[(i2 + 1) % 3];
        const edgeKey = `${Math.min(startIndex, endIndex)}:${Math.max(startIndex, endIndex)}`;
        let edgeArray = edgeToFaceMap.get(edgeKey);
        if (!edgeArray)
          edgeArray = [];
        edgeArray.push(faceIndex);
        edgeToFaceMap.set(edgeKey, edgeArray);
      }
    }
    const faceAdjacencyList = faces.map(() => []);
    for (let [_, connectedFaces] of edgeToFaceMap) {
      if (connectedFaces.length !== 2)
        continue;
      const [faceA, faceB] = connectedFaces;
      faceAdjacencyList[faceA].push(faceB);
      faceAdjacencyList[faceB].push(faceA);
    }
    return faceAdjacencyList;
  }
  static cleanOrphanedVertices(_vertices, _faces) {
    const vertices = MeshletGrouper.buildFacesFromIndices(_vertices);
    const faces = MeshletGrouper.buildFacesFromIndices(_faces);
    const vertexMap = /* @__PURE__ */ new Map();
    let cleanedVertices = [];
    let cleanedFaces = faces.map((face) => {
      return face.map((vertexIndex) => {
        if (vertexMap.has(vertexIndex)) {
          return vertexMap.get(vertexIndex);
        } else {
          const newVertexIndex = cleanedVertices.length;
          if (vertices[vertexIndex]) {
            cleanedVertices.push(vertices[vertexIndex]);
            vertexMap.set(vertexIndex, newVertexIndex);
            return newVertexIndex;
          }
        }
      });
    });
    return {
      cleanedVertices: cleanedVertices.flat(),
      cleanedFaces: cleanedFaces.flat()
    };
  }
  static rebuildMeshletsFromGroupIndices(vertices, faces, groups) {
    let groupsByFaces = new Array(groups.length);
    for (let i2 = 0; i2 < groups.length; i2++) {
      groupsByFaces[i2] = MeshletGrouper.getFacesFromIndices(groups[i2], faces).flat();
    }
    let groupedMeshlets = [];
    for (let i2 = 0; i2 < groupsByFaces.length; i2++) {
      const { cleanedVertices, cleanedFaces } = MeshletGrouper.cleanOrphanedVertices(vertices, groupsByFaces[i2]);
      const meshlet = new Meshlet(Float32Array.from(cleanedVertices), Uint32Array.from(cleanedFaces));
      groupedMeshlets.push(meshlet);
    }
    return groupedMeshlets;
  }
};

// src/OBJLoaderIndexed.ts
var OBJLoaderIndexed = class {
  static *triangulate(elements) {
    if (elements.length <= 3) {
      yield elements;
    } else if (elements.length === 4) {
      yield [elements[0], elements[1], elements[2]];
      yield [elements[2], elements[3], elements[0]];
    } else {
      for (let i2 = 1; i2 < elements.length - 1; i2++) {
        yield [elements[0], elements[i2], elements[i2 + 1]];
      }
    }
  }
  static load(url, callback) {
    fetch(url).then((response) => response.text()).then((contents) => callback(OBJLoaderIndexed.parse(contents)));
  }
  static parse(contents) {
    const indices = [];
    const verts = [];
    let currentMaterialIndex = -1;
    let currentObjectByMaterialIndex = 0;
    const unpacked = {
      verts: [],
      hashindices: {},
      indices: [[]],
      index: 0
    };
    const VERTEX_RE = /^v\s/;
    const FACE_RE = /^f\s/;
    const WHITESPACE_RE = /\s+/;
    const lines = contents.split("\n");
    for (let line of lines) {
      line = line.trim();
      if (!line || line.startsWith("#")) {
        continue;
      }
      const elements = line.split(WHITESPACE_RE);
      elements.shift();
      if (VERTEX_RE.test(line)) {
        verts.push(...elements);
      } else if (FACE_RE.test(line)) {
        const triangles = OBJLoaderIndexed.triangulate(elements);
        for (const triangle of triangles) {
          for (let j = 0, eleLen = triangle.length; j < eleLen; j++) {
            const hash2 = triangle[j] + "," + currentMaterialIndex;
            if (hash2 in unpacked.hashindices) {
              unpacked.indices[currentObjectByMaterialIndex].push(unpacked.hashindices[hash2]);
            } else {
              const vertex2 = triangle[j].split("/");
              unpacked.verts.push(+verts[(+vertex2[0] - 1) * 3 + 0]);
              unpacked.verts.push(+verts[(+vertex2[0] - 1) * 3 + 1]);
              unpacked.verts.push(+verts[(+vertex2[0] - 1) * 3 + 2]);
              unpacked.hashindices[hash2] = unpacked.index;
              unpacked.indices[currentObjectByMaterialIndex].push(unpacked.hashindices[hash2]);
              unpacked.index += 1;
            }
          }
        }
      }
    }
    return {
      vertices: new Float32Array(unpacked.verts),
      indices: new Uint32Array(unpacked.indices[currentObjectByMaterialIndex])
    };
  }
};

// src/MeshletMerger.ts
var MeshletMerger = class {
  static merge(meshlets) {
    const vertices = [];
    const indices = [];
    let indexOffset = 0;
    const mergedIndices = [];
    for (let i2 = 0; i2 < meshlets.length; ++i2) {
      const indices2 = meshlets[i2].indices_raw;
      for (let j = 0; j < indices2.length; j++) {
        mergedIndices.push(indices2[j] + indexOffset);
      }
      indexOffset += meshlets[i2].vertices.length;
    }
    indices.push(...mergedIndices);
    for (let i2 = 0; i2 < meshlets.length; ++i2) {
      vertices.push(...meshlets[i2].vertices_raw);
    }
    const merged = new Meshlet(vertices, indices);
    return merged;
  }
};

// src/metis-js/metis-5.1.0/metis.js
var Module = (() => {
  var _scriptDir = import.meta.url;
  return function(Module3) {
    Module3 = Module3 || {};
    var Module3 = typeof Module3 != "undefined" ? Module3 : {};
    var readyPromiseResolve, readyPromiseReject;
    Module3["ready"] = new Promise(function(resolve, reject) {
      readyPromiseResolve = resolve;
      readyPromiseReject = reject;
    });
    var moduleOverrides = Object.assign({}, Module3);
    var arguments_ = [];
    var thisProgram = "./this.program";
    var quit_ = (status, toThrow) => {
      throw toThrow;
    };
    var ENVIRONMENT_IS_WEB = true;
    var ENVIRONMENT_IS_WORKER2 = false;
    var scriptDirectory = "";
    function locateFile(path) {
      if (Module3["locateFile"]) {
        return Module3["locateFile"](path, scriptDirectory);
      }
      return scriptDirectory + path;
    }
    var read_2, readAsync2, readBinary, setWindowTitle;
    if (ENVIRONMENT_IS_WEB || ENVIRONMENT_IS_WORKER2) {
      if (ENVIRONMENT_IS_WORKER2) {
        scriptDirectory = self.location.href;
      } else if (typeof document != "undefined" && document.currentScript) {
        scriptDirectory = document.currentScript.src;
      }
      if (_scriptDir) {
        scriptDirectory = _scriptDir;
      }
      if (scriptDirectory.indexOf("blob:") !== 0) {
        scriptDirectory = scriptDirectory.substr(0, scriptDirectory.replace(/[?#].*/, "").lastIndexOf("/") + 1);
      } else {
        scriptDirectory = "";
      }
      {
        read_2 = (url) => {
          var xhr = new XMLHttpRequest();
          xhr.open("GET", url, false);
          xhr.send(null);
          return xhr.responseText;
        };
        if (ENVIRONMENT_IS_WORKER2) {
          readBinary = (url) => {
            var xhr = new XMLHttpRequest();
            xhr.open("GET", url, false);
            xhr.responseType = "arraybuffer";
            xhr.send(null);
            return new Uint8Array(xhr.response);
          };
        }
        readAsync2 = (url, onload, onerror) => {
          var xhr = new XMLHttpRequest();
          xhr.open("GET", url, true);
          xhr.responseType = "arraybuffer";
          xhr.onload = () => {
            if (xhr.status == 200 || xhr.status == 0 && xhr.response) {
              onload(xhr.response);
              return;
            }
            onerror();
          };
          xhr.onerror = onerror;
          xhr.send(null);
        };
      }
      setWindowTitle = (title) => document.title = title;
    } else {
    }
    var out = Module3["print"] || console.log.bind(console);
    var err = Module3["printErr"] || console.warn.bind(console);
    Object.assign(Module3, moduleOverrides);
    moduleOverrides = null;
    if (Module3["arguments"])
      arguments_ = Module3["arguments"];
    if (Module3["thisProgram"])
      thisProgram = Module3["thisProgram"];
    if (Module3["quit"])
      quit_ = Module3["quit"];
    var wasmBinary;
    if (Module3["wasmBinary"])
      wasmBinary = Module3["wasmBinary"];
    var noExitRuntime = Module3["noExitRuntime"] || true;
    if (typeof WebAssembly != "object") {
      abort("no native wasm support detected");
    }
    var wasmMemory;
    var ABORT = false;
    var EXITSTATUS;
    var UTF8Decoder = typeof TextDecoder != "undefined" ? new TextDecoder("utf8") : void 0;
    function UTF8ArrayToString(heapOrArray, idx, maxBytesToRead) {
      var endIdx = idx + maxBytesToRead;
      var endPtr = idx;
      while (heapOrArray[endPtr] && !(endPtr >= endIdx))
        ++endPtr;
      if (endPtr - idx > 16 && heapOrArray.buffer && UTF8Decoder) {
        return UTF8Decoder.decode(heapOrArray.subarray(idx, endPtr));
      }
      var str = "";
      while (idx < endPtr) {
        var u0 = heapOrArray[idx++];
        if (!(u0 & 128)) {
          str += String.fromCharCode(u0);
          continue;
        }
        var u1 = heapOrArray[idx++] & 63;
        if ((u0 & 224) == 192) {
          str += String.fromCharCode((u0 & 31) << 6 | u1);
          continue;
        }
        var u2 = heapOrArray[idx++] & 63;
        if ((u0 & 240) == 224) {
          u0 = (u0 & 15) << 12 | u1 << 6 | u2;
        } else {
          u0 = (u0 & 7) << 18 | u1 << 12 | u2 << 6 | heapOrArray[idx++] & 63;
        }
        if (u0 < 65536) {
          str += String.fromCharCode(u0);
        } else {
          var ch = u0 - 65536;
          str += String.fromCharCode(55296 | ch >> 10, 56320 | ch & 1023);
        }
      }
      return str;
    }
    function UTF8ToString(ptr, maxBytesToRead) {
      return ptr ? UTF8ArrayToString(HEAPU8, ptr, maxBytesToRead) : "";
    }
    function stringToUTF8Array(str, heap, outIdx, maxBytesToWrite) {
      if (!(maxBytesToWrite > 0))
        return 0;
      var startIdx = outIdx;
      var endIdx = outIdx + maxBytesToWrite - 1;
      for (var i2 = 0; i2 < str.length; ++i2) {
        var u = str.charCodeAt(i2);
        if (u >= 55296 && u <= 57343) {
          var u1 = str.charCodeAt(++i2);
          u = 65536 + ((u & 1023) << 10) | u1 & 1023;
        }
        if (u <= 127) {
          if (outIdx >= endIdx)
            break;
          heap[outIdx++] = u;
        } else if (u <= 2047) {
          if (outIdx + 1 >= endIdx)
            break;
          heap[outIdx++] = 192 | u >> 6;
          heap[outIdx++] = 128 | u & 63;
        } else if (u <= 65535) {
          if (outIdx + 2 >= endIdx)
            break;
          heap[outIdx++] = 224 | u >> 12;
          heap[outIdx++] = 128 | u >> 6 & 63;
          heap[outIdx++] = 128 | u & 63;
        } else {
          if (outIdx + 3 >= endIdx)
            break;
          heap[outIdx++] = 240 | u >> 18;
          heap[outIdx++] = 128 | u >> 12 & 63;
          heap[outIdx++] = 128 | u >> 6 & 63;
          heap[outIdx++] = 128 | u & 63;
        }
      }
      heap[outIdx] = 0;
      return outIdx - startIdx;
    }
    function stringToUTF8(str, outPtr, maxBytesToWrite) {
      return stringToUTF8Array(str, HEAPU8, outPtr, maxBytesToWrite);
    }
    var buffer, HEAP8, HEAPU8, HEAP16, HEAPU16, HEAP32, HEAPU32, HEAPF32, HEAPF64;
    function updateGlobalBufferAndViews(buf) {
      buffer = buf;
      Module3["HEAP8"] = HEAP8 = new Int8Array(buf);
      Module3["HEAP16"] = HEAP16 = new Int16Array(buf);
      Module3["HEAP32"] = HEAP32 = new Int32Array(buf);
      Module3["HEAPU8"] = HEAPU8 = new Uint8Array(buf);
      Module3["HEAPU16"] = HEAPU16 = new Uint16Array(buf);
      Module3["HEAPU32"] = HEAPU32 = new Uint32Array(buf);
      Module3["HEAPF32"] = HEAPF32 = new Float32Array(buf);
      Module3["HEAPF64"] = HEAPF64 = new Float64Array(buf);
    }
    var INITIAL_MEMORY = Module3["INITIAL_MEMORY"] || 16777216;
    var wasmTable;
    var __ATPRERUN__ = [];
    var __ATINIT__ = [];
    var __ATPOSTRUN__ = [];
    var runtimeInitialized = false;
    function keepRuntimeAlive() {
      return noExitRuntime;
    }
    function preRun() {
      if (Module3["preRun"]) {
        if (typeof Module3["preRun"] == "function")
          Module3["preRun"] = [Module3["preRun"]];
        while (Module3["preRun"].length) {
          addOnPreRun(Module3["preRun"].shift());
        }
      }
      callRuntimeCallbacks(__ATPRERUN__);
    }
    function initRuntime() {
      runtimeInitialized = true;
      callRuntimeCallbacks(__ATINIT__);
    }
    function postRun() {
      if (Module3["postRun"]) {
        if (typeof Module3["postRun"] == "function")
          Module3["postRun"] = [Module3["postRun"]];
        while (Module3["postRun"].length) {
          addOnPostRun(Module3["postRun"].shift());
        }
      }
      callRuntimeCallbacks(__ATPOSTRUN__);
    }
    function addOnPreRun(cb) {
      __ATPRERUN__.unshift(cb);
    }
    function addOnInit(cb) {
      __ATINIT__.unshift(cb);
    }
    function addOnPostRun(cb) {
      __ATPOSTRUN__.unshift(cb);
    }
    var runDependencies = 0;
    var runDependencyWatcher = null;
    var dependenciesFulfilled = null;
    function addRunDependency2(id) {
      runDependencies++;
      if (Module3["monitorRunDependencies"]) {
        Module3["monitorRunDependencies"](runDependencies);
      }
    }
    function removeRunDependency2(id) {
      runDependencies--;
      if (Module3["monitorRunDependencies"]) {
        Module3["monitorRunDependencies"](runDependencies);
      }
      if (runDependencies == 0) {
        if (runDependencyWatcher !== null) {
          clearInterval(runDependencyWatcher);
          runDependencyWatcher = null;
        }
        if (dependenciesFulfilled) {
          var callback = dependenciesFulfilled;
          dependenciesFulfilled = null;
          callback();
        }
      }
    }
    function abort(what) {
      {
        if (Module3["onAbort"]) {
          Module3["onAbort"](what);
        }
      }
      what = "Aborted(" + what + ")";
      err(what);
      ABORT = true;
      EXITSTATUS = 1;
      what += ". Build with -sASSERTIONS for more info.";
      var e = new WebAssembly.RuntimeError(what);
      readyPromiseReject(e);
      throw e;
    }
    var dataURIPrefix = "data:application/octet-stream;base64,";
    function isDataURI(filename) {
      return filename.startsWith(dataURIPrefix);
    }
    var wasmBinaryFile;
    if (Module3["locateFile"]) {
      wasmBinaryFile = "metis.wasm";
      if (!isDataURI(wasmBinaryFile)) {
        wasmBinaryFile = locateFile(wasmBinaryFile);
      }
    } else {
      wasmBinaryFile = new URL("metis.wasm", import.meta.url).toString();
    }
    function getBinary(file) {
      try {
        if (file == wasmBinaryFile && wasmBinary) {
          return new Uint8Array(wasmBinary);
        }
        if (readBinary) {
          return readBinary(file);
        }
        throw "both async and sync fetching of the wasm failed";
      } catch (err2) {
        abort(err2);
      }
    }
    function getBinaryPromise() {
      if (!wasmBinary && (ENVIRONMENT_IS_WEB || ENVIRONMENT_IS_WORKER2)) {
        if (typeof fetch == "function") {
          return fetch(wasmBinaryFile, { credentials: "same-origin" }).then(function(response) {
            if (!response["ok"]) {
              throw "failed to load wasm binary file at '" + wasmBinaryFile + "'";
            }
            return response["arrayBuffer"]();
          }).catch(function() {
            return getBinary(wasmBinaryFile);
          });
        }
      }
      return Promise.resolve().then(function() {
        return getBinary(wasmBinaryFile);
      });
    }
    function createWasm() {
      var info = { "a": asmLibraryArg };
      function receiveInstance(instance, module) {
        var exports2 = instance.exports;
        Module3["asm"] = exports2;
        wasmMemory = Module3["asm"]["r"];
        updateGlobalBufferAndViews(wasmMemory.buffer);
        wasmTable = Module3["asm"]["z"];
        addOnInit(Module3["asm"]["s"]);
        removeRunDependency2("wasm-instantiate");
      }
      addRunDependency2("wasm-instantiate");
      function receiveInstantiationResult(result) {
        receiveInstance(result["instance"]);
      }
      function instantiateArrayBuffer(receiver) {
        return getBinaryPromise().then(function(binary) {
          return WebAssembly.instantiate(binary, info);
        }).then(function(instance) {
          return instance;
        }).then(receiver, function(reason) {
          err("failed to asynchronously prepare wasm: " + reason);
          abort(reason);
        });
      }
      function instantiateAsync() {
        if (!wasmBinary && typeof WebAssembly.instantiateStreaming == "function" && !isDataURI(wasmBinaryFile) && typeof fetch == "function") {
          return fetch(wasmBinaryFile, { credentials: "same-origin" }).then(function(response) {
            var result = WebAssembly.instantiateStreaming(response, info);
            return result.then(receiveInstantiationResult, function(reason) {
              err("wasm streaming compile failed: " + reason);
              err("falling back to ArrayBuffer instantiation");
              return instantiateArrayBuffer(receiveInstantiationResult);
            });
          });
        } else {
          return instantiateArrayBuffer(receiveInstantiationResult);
        }
      }
      if (Module3["instantiateWasm"]) {
        try {
          var exports = Module3["instantiateWasm"](info, receiveInstance);
          return exports;
        } catch (e) {
          err("Module.instantiateWasm callback failed with error: " + e);
          readyPromiseReject(e);
        }
      }
      instantiateAsync().catch(readyPromiseReject);
      return {};
    }
    function ExitStatus(status) {
      this.name = "ExitStatus";
      this.message = "Program terminated with exit(" + status + ")";
      this.status = status;
    }
    function callRuntimeCallbacks(callbacks) {
      while (callbacks.length > 0) {
        callbacks.shift()(Module3);
      }
    }
    function writeArrayToMemory(array, buffer2) {
      HEAP8.set(array, buffer2);
    }
    var wasmTableMirror = [];
    function getWasmTableEntry(funcPtr) {
      var func = wasmTableMirror[funcPtr];
      if (!func) {
        if (funcPtr >= wasmTableMirror.length)
          wasmTableMirror.length = funcPtr + 1;
        wasmTableMirror[funcPtr] = func = wasmTable.get(funcPtr);
      }
      return func;
    }
    function ___call_sighandler(fp, sig) {
      getWasmTableEntry(fp)(sig);
    }
    function __emscripten_throw_longjmp() {
      throw Infinity;
    }
    function _emscripten_memcpy_big(dest, src, num) {
      HEAPU8.copyWithin(dest, src, src + num);
    }
    function getHeapMax() {
      return 2147483648;
    }
    function emscripten_realloc_buffer(size) {
      try {
        wasmMemory.grow(size - buffer.byteLength + 65535 >>> 16);
        updateGlobalBufferAndViews(wasmMemory.buffer);
        return 1;
      } catch (e) {
      }
    }
    function _emscripten_resize_heap(requestedSize) {
      var oldSize = HEAPU8.length;
      requestedSize = requestedSize >>> 0;
      var maxHeapSize = getHeapMax();
      if (requestedSize > maxHeapSize) {
        return false;
      }
      let alignUp = (x, multiple) => x + (multiple - x % multiple) % multiple;
      for (var cutDown = 1; cutDown <= 4; cutDown *= 2) {
        var overGrownHeapSize = oldSize * (1 + 0.2 / cutDown);
        overGrownHeapSize = Math.min(overGrownHeapSize, requestedSize + 100663296);
        var newSize = Math.min(maxHeapSize, alignUp(Math.max(requestedSize, overGrownHeapSize), 65536));
        var replacement = emscripten_realloc_buffer(newSize);
        if (replacement) {
          return true;
        }
      }
      return false;
    }
    var SYSCALLS = { varargs: void 0, get: function() {
      SYSCALLS.varargs += 4;
      var ret = HEAP32[SYSCALLS.varargs - 4 >> 2];
      return ret;
    }, getStr: function(ptr) {
      var ret = UTF8ToString(ptr);
      return ret;
    } };
    function _proc_exit(code) {
      EXITSTATUS = code;
      if (!keepRuntimeAlive()) {
        if (Module3["onExit"])
          Module3["onExit"](code);
        ABORT = true;
      }
      quit_(code, new ExitStatus(code));
    }
    function exitJS(status, implicit) {
      EXITSTATUS = status;
      _proc_exit(status);
    }
    var _exit = exitJS;
    function _fd_close(fd) {
      return 52;
    }
    function _fd_seek(fd, offset_low, offset_high, whence, newOffset) {
      return 70;
    }
    var printCharBuffers = [null, [], []];
    function printChar(stream, curr) {
      var buffer2 = printCharBuffers[stream];
      if (curr === 0 || curr === 10) {
        (stream === 1 ? out : err)(UTF8ArrayToString(buffer2, 0));
        buffer2.length = 0;
      } else {
        buffer2.push(curr);
      }
    }
    function _fd_write(fd, iov, iovcnt, pnum) {
      var num = 0;
      for (var i2 = 0; i2 < iovcnt; i2++) {
        var ptr = HEAPU32[iov >> 2];
        var len = HEAPU32[iov + 4 >> 2];
        iov += 8;
        for (var j = 0; j < len; j++) {
          printChar(fd, HEAPU8[ptr + j]);
        }
        num += len;
      }
      HEAPU32[pnum >> 2] = num;
      return 0;
    }
    function getCFunc(ident) {
      var func = Module3["_" + ident];
      return func;
    }
    function ccall(ident, returnType, argTypes, args, opts) {
      var toC = { "string": (str) => {
        var ret2 = 0;
        if (str !== null && str !== void 0 && str !== 0) {
          var len = (str.length << 2) + 1;
          ret2 = stackAlloc(len);
          stringToUTF8(str, ret2, len);
        }
        return ret2;
      }, "array": (arr) => {
        var ret2 = stackAlloc(arr.length);
        writeArrayToMemory(arr, ret2);
        return ret2;
      } };
      function convertReturnValue(ret2) {
        if (returnType === "string") {
          return UTF8ToString(ret2);
        }
        if (returnType === "boolean")
          return Boolean(ret2);
        return ret2;
      }
      var func = getCFunc(ident);
      var cArgs = [];
      var stack = 0;
      if (args) {
        for (var i2 = 0; i2 < args.length; i2++) {
          var converter = toC[argTypes[i2]];
          if (converter) {
            if (stack === 0)
              stack = stackSave();
            cArgs[i2] = converter(args[i2]);
          } else {
            cArgs[i2] = args[i2];
          }
        }
      }
      var ret = func.apply(null, cArgs);
      function onDone(ret2) {
        if (stack !== 0)
          stackRestore(stack);
        return convertReturnValue(ret2);
      }
      ret = onDone(ret);
      return ret;
    }
    function cwrap(ident, returnType, argTypes, opts) {
      argTypes = argTypes || [];
      var numericArgs = argTypes.every((type) => type === "number" || type === "boolean");
      var numericRet = returnType !== "string";
      if (numericRet && numericArgs && !opts) {
        return getCFunc(ident);
      }
      return function() {
        return ccall(ident, returnType, argTypes, arguments, opts);
      };
    }
    var asmLibraryArg = { "n": ___call_sighandler, "l": __emscripten_throw_longjmp, "p": _emscripten_memcpy_big, "m": _emscripten_resize_heap, "q": _exit, "o": _fd_close, "k": _fd_seek, "g": _fd_write, "c": invoke_d, "a": invoke_i, "i": invoke_iii, "h": invoke_iiii, "d": invoke_iiiiiii, "f": invoke_iiiiiiiii, "b": invoke_vi, "e": invoke_vii, "j": invoke_viii };
    var asm = createWasm();
    var ___wasm_call_ctors = Module3["___wasm_call_ctors"] = function() {
      return (___wasm_call_ctors = Module3["___wasm_call_ctors"] = Module3["asm"]["s"]).apply(null, arguments);
    };
    var _metis_part_graph_kway = Module3["_metis_part_graph_kway"] = function() {
      return (_metis_part_graph_kway = Module3["_metis_part_graph_kway"] = Module3["asm"]["t"]).apply(null, arguments);
    };
    var _metis_part_graph_kway_v2 = Module3["_metis_part_graph_kway_v2"] = function() {
      return (_metis_part_graph_kway_v2 = Module3["_metis_part_graph_kway_v2"] = Module3["asm"]["u"]).apply(null, arguments);
    };
    var _metis_part_graph_recursive = Module3["_metis_part_graph_recursive"] = function() {
      return (_metis_part_graph_recursive = Module3["_metis_part_graph_recursive"] = Module3["asm"]["v"]).apply(null, arguments);
    };
    var _create_buffer = Module3["_create_buffer"] = function() {
      return (_create_buffer = Module3["_create_buffer"] = Module3["asm"]["w"]).apply(null, arguments);
    };
    var _malloc = Module3["_malloc"] = function() {
      return (_malloc = Module3["_malloc"] = Module3["asm"]["x"]).apply(null, arguments);
    };
    var _destroy_buffer = Module3["_destroy_buffer"] = function() {
      return (_destroy_buffer = Module3["_destroy_buffer"] = Module3["asm"]["y"]).apply(null, arguments);
    };
    var _setThrew = Module3["_setThrew"] = function() {
      return (_setThrew = Module3["_setThrew"] = Module3["asm"]["A"]).apply(null, arguments);
    };
    var stackSave = Module3["stackSave"] = function() {
      return (stackSave = Module3["stackSave"] = Module3["asm"]["B"]).apply(null, arguments);
    };
    var stackRestore = Module3["stackRestore"] = function() {
      return (stackRestore = Module3["stackRestore"] = Module3["asm"]["C"]).apply(null, arguments);
    };
    var stackAlloc = Module3["stackAlloc"] = function() {
      return (stackAlloc = Module3["stackAlloc"] = Module3["asm"]["D"]).apply(null, arguments);
    };
    function invoke_i(index) {
      var sp = stackSave();
      try {
        return getWasmTableEntry(index)();
      } catch (e) {
        stackRestore(sp);
        if (e !== e + 0)
          throw e;
        _setThrew(1, 0);
      }
    }
    function invoke_iiiiiii(index, a1, a2, a3, a4, a5, a6) {
      var sp = stackSave();
      try {
        return getWasmTableEntry(index)(a1, a2, a3, a4, a5, a6);
      } catch (e) {
        stackRestore(sp);
        if (e !== e + 0)
          throw e;
        _setThrew(1, 0);
      }
    }
    function invoke_viii(index, a1, a2, a3) {
      var sp = stackSave();
      try {
        getWasmTableEntry(index)(a1, a2, a3);
      } catch (e) {
        stackRestore(sp);
        if (e !== e + 0)
          throw e;
        _setThrew(1, 0);
      }
    }
    function invoke_iiiiiiiii(index, a1, a2, a3, a4, a5, a6, a7, a8) {
      var sp = stackSave();
      try {
        return getWasmTableEntry(index)(a1, a2, a3, a4, a5, a6, a7, a8);
      } catch (e) {
        stackRestore(sp);
        if (e !== e + 0)
          throw e;
        _setThrew(1, 0);
      }
    }
    function invoke_vii(index, a1, a2) {
      var sp = stackSave();
      try {
        getWasmTableEntry(index)(a1, a2);
      } catch (e) {
        stackRestore(sp);
        if (e !== e + 0)
          throw e;
        _setThrew(1, 0);
      }
    }
    function invoke_iii(index, a1, a2) {
      var sp = stackSave();
      try {
        return getWasmTableEntry(index)(a1, a2);
      } catch (e) {
        stackRestore(sp);
        if (e !== e + 0)
          throw e;
        _setThrew(1, 0);
      }
    }
    function invoke_vi(index, a1) {
      var sp = stackSave();
      try {
        getWasmTableEntry(index)(a1);
      } catch (e) {
        stackRestore(sp);
        if (e !== e + 0)
          throw e;
        _setThrew(1, 0);
      }
    }
    function invoke_d(index) {
      var sp = stackSave();
      try {
        return getWasmTableEntry(index)();
      } catch (e) {
        stackRestore(sp);
        if (e !== e + 0)
          throw e;
        _setThrew(1, 0);
      }
    }
    function invoke_iiii(index, a1, a2, a3) {
      var sp = stackSave();
      try {
        return getWasmTableEntry(index)(a1, a2, a3);
      } catch (e) {
        stackRestore(sp);
        if (e !== e + 0)
          throw e;
        _setThrew(1, 0);
      }
    }
    Module3["ccall"] = ccall;
    Module3["cwrap"] = cwrap;
    var calledRun;
    dependenciesFulfilled = function runCaller() {
      if (!calledRun)
        run();
      if (!calledRun)
        dependenciesFulfilled = runCaller;
    };
    function run(args) {
      args = args || arguments_;
      if (runDependencies > 0) {
        return;
      }
      preRun();
      if (runDependencies > 0) {
        return;
      }
      function doRun() {
        if (calledRun)
          return;
        calledRun = true;
        Module3["calledRun"] = true;
        if (ABORT)
          return;
        initRuntime();
        readyPromiseResolve(Module3);
        if (Module3["onRuntimeInitialized"])
          Module3["onRuntimeInitialized"]();
        postRun();
      }
      if (Module3["setStatus"]) {
        Module3["setStatus"]("Running...");
        setTimeout(function() {
          setTimeout(function() {
            Module3["setStatus"]("");
          }, 1);
          doRun();
        }, 1);
      } else {
        doRun();
      }
    }
    if (Module3["preInit"]) {
      if (typeof Module3["preInit"] == "function")
        Module3["preInit"] = [Module3["preInit"]];
      while (Module3["preInit"].length > 0) {
        Module3["preInit"].pop()();
      }
    }
    run();
    return Module3.ready;
  };
})();
var metis_default = Module;

// src/utils/WasmHelper.ts
var WASMPointer = class {
  constructor(data, type = "in") {
    this.data = data;
    this.ptr = null;
    this.type = type;
  }
};
var _WASMHelper = class {
  static getTypeForArray(array) {
    if (array instanceof Int8Array)
      return this.TYPES.i8;
    else if (array instanceof Int16Array)
      return this.TYPES.i16;
    else if (array instanceof Int32Array)
      return this.TYPES.i32;
    else if (array instanceof Uint8Array)
      return this.TYPES.u8;
    else if (array instanceof Uint16Array)
      return this.TYPES.u16;
    else if (array instanceof Uint32Array)
      return this.TYPES.u32;
    else if (array instanceof Float32Array)
      return this.TYPES.f32;
    else if (array instanceof Float64Array)
      return this.TYPES.f64;
    console.log(array);
    throw Error("Array has no type");
  }
  static transferNumberArrayToHeap(module, array) {
    const type = this.getTypeForArray(array);
    const typedArray = type.array.from(array);
    const heapPointer = module._malloc(
      typedArray.length * typedArray.BYTES_PER_ELEMENT
    );
    module[type.heap].set(typedArray, heapPointer >> 2);
    return heapPointer;
  }
  static getDataFromHeapU8(module, address, type, length) {
    return module[type.heap].slice(address, address + length);
  }
  static getDataFromHeap(module, address, type, length) {
    return module[type.heap].slice(address >> 2, (address >> 2) + length);
  }
  static getArgumentTypes(args) {
    let argTypes = [];
    for (let i2 = 0; i2 < args.length; i2++) {
      const arg = args[i2];
      if (arg instanceof Uint8Array)
        argTypes.push("number");
      else if (arg instanceof Uint16Array)
        argTypes.push("number");
      else if (arg instanceof Uint32Array)
        argTypes.push("number");
      else if (arg instanceof Int8Array)
        argTypes.push("number");
      else if (arg instanceof Int16Array)
        argTypes.push("number");
      else if (arg instanceof Int32Array)
        argTypes.push("number");
      else if (arg instanceof Float32Array)
        argTypes.push("number");
      else if (arg instanceof Float64Array)
        argTypes.push("number");
      else if (typeof arg === "string")
        argTypes.push("string");
      else
        argTypes.push("number");
    }
    return argTypes;
  }
  static transferArguments(module, args) {
    let method_args = [];
    for (let i2 = 0; i2 < args.length; i2++) {
      const arg = args[i2];
      if (arg instanceof WASMPointer) {
        arg.ptr = _WASMHelper.transferNumberArrayToHeap(module, arg.data);
        method_args.push(arg.ptr);
      } else
        method_args.push(args[i2]);
    }
    return method_args;
  }
  static getOutputArguments(module, args) {
    for (let i2 = 0; i2 < args.length; i2++) {
      const arg = args[i2];
      if (!(arg instanceof WASMPointer))
        continue;
      if (arg.ptr === null)
        continue;
      if (arg.type === "in")
        continue;
      const type = _WASMHelper.getTypeForArray(arg.data);
      if (type === this.TYPES.u8) {
        arg.data = _WASMHelper.getDataFromHeapU8(module, arg.ptr, type, arg.data.length);
      } else {
        arg.data = _WASMHelper.getDataFromHeap(module, arg.ptr, type, arg.data.length);
      }
    }
  }
  static call(module, method, returnType, ...args) {
    let method_args = _WASMHelper.transferArguments(module, args);
    const method_arg_types = _WASMHelper.getArgumentTypes(args);
    const ret = module.ccall(
      method,
      returnType,
      method_arg_types,
      method_args
    );
    _WASMHelper.getOutputArguments(module, args);
    return ret;
  }
};
var WASMHelper = _WASMHelper;
WASMHelper.TYPES = {
  i8: { array: Int8Array, heap: "HEAP8" },
  i16: { array: Int16Array, heap: "HEAP16" },
  i32: { array: Int32Array, heap: "HEAP32" },
  f32: { array: Float32Array, heap: "HEAPF32" },
  f64: { array: Float64Array, heap: "HEAPF64" },
  u8: { array: Uint8Array, heap: "HEAPU8" },
  u16: { array: Uint16Array, heap: "HEAPU16" },
  u32: { array: Uint32Array, heap: "HEAPU32" }
};

// src/METISWrapper.ts
var METISWrapper = class {
  static async load() {
    if (!METISWrapper.METIS) {
      METISWrapper.METIS = await metis_default();
    }
  }
  static async partition(groups, nparts) {
    await METISWrapper.load();
    function _prepare_graph(adjacency) {
      function assert2(condition) {
        if (!condition)
          throw Error("assert");
      }
      let xadj = [0];
      let adjncy = [];
      for (let i2 = 0; i2 < adjacency.length; i2++) {
        let adj = adjacency[i2];
        if (adj !== null && adj.length) {
          assert2(Math.max(...adj) < adjacency.length);
        }
        adjncy.push(...adj);
        xadj.push(adjncy.length);
      }
      return [xadj, adjncy];
    }
    const [_xadj, _adjncy] = _prepare_graph(groups);
    const objval = new WASMPointer(new Uint32Array(1), "out");
    const parts = new WASMPointer(new Uint32Array(_xadj.length - 1), "out");
    const options_array = new Int32Array(40);
    options_array.fill(-1);
    WASMHelper.call(
      METISWrapper.METIS,
      "metis_part_graph_kway",
      "number",
      _xadj.length - 1,
      1,
      new WASMPointer(new Uint32Array(_xadj)),
      new WASMPointer(new Uint32Array(_adjncy)),
      null,
      null,
      null,
      nparts,
      null,
      null,
      new WASMPointer(options_array),
      objval,
      parts
    );
    const part_num = Math.max(...parts.data);
    const parts_out = [];
    for (let i2 = 0; i2 <= part_num; i2++) {
      const part = [];
      for (let j = 0; j < parts.data.length; j++) {
        if (parts.data[j] === i2) {
          part.push(j);
        }
      }
      if (part.length > 0)
        parts_out.push(part);
    }
    return parts_out;
  }
  static async partition2(count, xadj, adjncy, nparts) {
    await METISWrapper.load();
    const objval = new WASMPointer(new Int32Array(1), "out");
    const parts = new WASMPointer(new Int32Array(xadj.length - 1), "out");
    WASMHelper.call(
      METISWrapper.METIS,
      "metis_part_graph_kway",
      "number",
      count,
      1,
      new WASMPointer(new Int32Array(xadj)),
      new WASMPointer(new Int32Array(adjncy)),
      null,
      null,
      null,
      nparts,
      null,
      null,
      null,
      objval,
      parts
    );
    return parts.data;
  }
};

// src/DAG.ts
var DAG = class {
  constructor() {
    this.nodes = {};
    this.parentToChild = {};
    this.childToParent = {};
    this.tagToNode = {};
  }
  addRelationship(map, queryKey, from, to) {
    let mapArray = map[queryKey] ? map[queryKey] : [];
    if (mapArray.indexOf(to) === -1)
      mapArray.push(to);
    map[queryKey] = mapArray;
  }
  addNode(node) {
    if (!this.nodes[node.id])
      this.nodes[node.id] = node;
  }
  add(parent, child) {
    this.addNode(parent);
    this.addNode(child);
    this.addRelationship(this.parentToChild, parent.id, parent.id, child.id);
    this.addRelationship(this.childToParent, child.id, child.id, parent.id);
    this.addRelationship(this.tagToNode, parent.tag, parent.id, parent.id);
    this.addRelationship(this.tagToNode, child.tag, child.id, child.id);
  }
  toDot() {
    let dotviz = `digraph G {
`;
    for (let child in this.childToParent) {
      for (let parentNode of this.childToParent[child]) {
        dotviz += `	"${parentNode}
${this.nodes[parentNode].tag}" -> "${child}
${this.nodes[child].tag}"
`;
      }
    }
    dotviz += "}";
    return dotviz;
  }
};

// node_modules/@viz-js/viz/lib/viz-standalone.mjs
var A = function() {
  let A2 = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {};
  var I2, g2 = A2;
  g2.ready = new Promise((A3, g3) => {
    I2 = A3;
  });
  var Q2, B2, C2, E2, D2, w2, i2, o2, G2, M2, R = (A3) => console.log(A3);
  function F(A3) {
    throw A3;
  }
  function y() {
    var A3 = M2.buffer;
    B2 = new Int8Array(A3), C2 = new Int16Array(A3), D2 = new Uint8Array(A3), E2 = new Int32Array(A3), w2 = new Uint32Array(A3), i2 = new Float32Array(A3), o2 = new Float64Array(A3), G2 = new BigInt64Array(A3), new BigUint64Array(A3);
  }
  g2.agerrMessages = [], g2.stderrMessages = [], Q2 = (A3) => g2.stderrMessages.push(A3);
  var K2 = "undefined" != typeof TextDecoder ? new TextDecoder("utf8") : void 0, h = (A3, I3, g3) => {
    for (var Q3 = I3 + g3, B3 = I3; A3[B3] && !(B3 >= Q3); )
      ++B3;
    if (B3 - I3 > 16 && A3.buffer && K2)
      return K2.decode(A3.subarray(I3, B3));
    for (var C3 = ""; I3 < B3; ) {
      var E3 = A3[I3++];
      if (128 & E3) {
        var D3 = 63 & A3[I3++];
        if (192 != (224 & E3)) {
          var w3 = 63 & A3[I3++];
          if ((E3 = 224 == (240 & E3) ? (15 & E3) << 12 | D3 << 6 | w3 : (7 & E3) << 18 | D3 << 12 | w3 << 6 | 63 & A3[I3++]) < 65536)
            C3 += String.fromCharCode(E3);
          else {
            var i3 = E3 - 65536;
            C3 += String.fromCharCode(55296 | i3 >> 10, 56320 | 1023 & i3);
          }
        } else
          C3 += String.fromCharCode((31 & E3) << 6 | D3);
      } else
        C3 += String.fromCharCode(E3);
    }
    return C3;
  }, s = (A3, I3) => A3 ? h(D2, A3, I3) : "";
  function N(A3) {
    this.excPtr = A3, this.ptr = A3 - 24, this.set_type = function(A4) {
      w2[this.ptr + 4 >> 2] = A4;
    }, this.get_type = function() {
      return w2[this.ptr + 4 >> 2];
    }, this.set_destructor = function(A4) {
      w2[this.ptr + 8 >> 2] = A4;
    }, this.get_destructor = function() {
      return w2[this.ptr + 8 >> 2];
    }, this.set_caught = function(A4) {
      A4 = A4 ? 1 : 0, B2[this.ptr + 12 >> 0] = A4;
    }, this.get_caught = function() {
      return 0 != B2[this.ptr + 12 >> 0];
    }, this.set_rethrown = function(A4) {
      A4 = A4 ? 1 : 0, B2[this.ptr + 13 >> 0] = A4;
    }, this.get_rethrown = function() {
      return 0 != B2[this.ptr + 13 >> 0];
    }, this.init = function(A4, I3) {
      this.set_adjusted_ptr(0), this.set_type(A4), this.set_destructor(I3);
    }, this.set_adjusted_ptr = function(A4) {
      w2[this.ptr + 16 >> 2] = A4;
    }, this.get_adjusted_ptr = function() {
      return w2[this.ptr + 16 >> 2];
    }, this.get_exception_ptr = function() {
      if (_(this.get_type()))
        return w2[this.excPtr >> 2];
      var A4 = this.get_adjusted_ptr();
      return 0 !== A4 ? A4 : this.excPtr;
    };
  }
  var k = { isAbs: (A3) => "/" === A3.charAt(0), splitPath: (A3) => /^(\/?|)([\s\S]*?)((?:\.{1,2}|[^\/]+?|)(\.[^.\/]*|))(?:[\/]*)$/.exec(A3).slice(1), normalizeArray: (A3, I3) => {
    for (var g3 = 0, Q3 = A3.length - 1; Q3 >= 0; Q3--) {
      var B3 = A3[Q3];
      "." === B3 ? A3.splice(Q3, 1) : ".." === B3 ? (A3.splice(Q3, 1), g3++) : g3 && (A3.splice(Q3, 1), g3--);
    }
    if (I3)
      for (; g3; g3--)
        A3.unshift("..");
    return A3;
  }, normalize: (A3) => {
    var I3 = k.isAbs(A3), g3 = "/" === A3.substr(-1);
    return (A3 = k.normalizeArray(A3.split("/").filter((A4) => !!A4), !I3).join("/")) || I3 || (A3 = "."), A3 && g3 && (A3 += "/"), (I3 ? "/" : "") + A3;
  }, dirname: (A3) => {
    var I3 = k.splitPath(A3), g3 = I3[0], Q3 = I3[1];
    return g3 || Q3 ? (Q3 && (Q3 = Q3.substr(0, Q3.length - 1)), g3 + Q3) : ".";
  }, basename: (A3) => {
    if ("/" === A3)
      return "/";
    var I3 = (A3 = (A3 = k.normalize(A3)).replace(/\/$/, "")).lastIndexOf("/");
    return -1 === I3 ? A3 : A3.substr(I3 + 1);
  }, join: function() {
    var A3 = Array.prototype.slice.call(arguments);
    return k.normalize(A3.join("/"));
  }, join2: (A3, I3) => k.normalize(A3 + "/" + I3) }, L = (A3) => (L = (() => {
    if ("object" == typeof crypto && "function" == typeof crypto.getRandomValues)
      return (A4) => crypto.getRandomValues(A4);
    F("initRandomDevice");
  })())(A3), U = { resolve: function() {
    for (var A3 = "", I3 = false, g3 = arguments.length - 1; g3 >= -1 && !I3; g3--) {
      var Q3 = g3 >= 0 ? arguments[g3] : r.cwd();
      if ("string" != typeof Q3)
        throw new TypeError("Arguments to path.resolve must be strings");
      if (!Q3)
        return "";
      A3 = Q3 + "/" + A3, I3 = k.isAbs(Q3);
    }
    return (I3 ? "/" : "") + (A3 = k.normalizeArray(A3.split("/").filter((A4) => !!A4), !I3).join("/")) || ".";
  }, relative: (A3, I3) => {
    function g3(A4) {
      for (var I4 = 0; I4 < A4.length && "" === A4[I4]; I4++)
        ;
      for (var g4 = A4.length - 1; g4 >= 0 && "" === A4[g4]; g4--)
        ;
      return I4 > g4 ? [] : A4.slice(I4, g4 - I4 + 1);
    }
    A3 = U.resolve(A3).substr(1), I3 = U.resolve(I3).substr(1);
    for (var Q3 = g3(A3.split("/")), B3 = g3(I3.split("/")), C3 = Math.min(Q3.length, B3.length), E3 = C3, D3 = 0; D3 < C3; D3++)
      if (Q3[D3] !== B3[D3]) {
        E3 = D3;
        break;
      }
    var w3 = [];
    for (D3 = E3; D3 < Q3.length; D3++)
      w3.push("..");
    return (w3 = w3.concat(B3.slice(E3))).join("/");
  } }, S = [], Y = (A3) => {
    for (var I3 = 0, g3 = 0; g3 < A3.length; ++g3) {
      var Q3 = A3.charCodeAt(g3);
      Q3 <= 127 ? I3++ : Q3 <= 2047 ? I3 += 2 : Q3 >= 55296 && Q3 <= 57343 ? (I3 += 4, ++g3) : I3 += 3;
    }
    return I3;
  }, J = (A3, I3, g3, Q3) => {
    if (!(Q3 > 0))
      return 0;
    for (var B3 = g3, C3 = g3 + Q3 - 1, E3 = 0; E3 < A3.length; ++E3) {
      var D3 = A3.charCodeAt(E3);
      if (D3 >= 55296 && D3 <= 57343)
        D3 = 65536 + ((1023 & D3) << 10) | 1023 & A3.charCodeAt(++E3);
      if (D3 <= 127) {
        if (g3 >= C3)
          break;
        I3[g3++] = D3;
      } else if (D3 <= 2047) {
        if (g3 + 1 >= C3)
          break;
        I3[g3++] = 192 | D3 >> 6, I3[g3++] = 128 | 63 & D3;
      } else if (D3 <= 65535) {
        if (g3 + 2 >= C3)
          break;
        I3[g3++] = 224 | D3 >> 12, I3[g3++] = 128 | D3 >> 6 & 63, I3[g3++] = 128 | 63 & D3;
      } else {
        if (g3 + 3 >= C3)
          break;
        I3[g3++] = 240 | D3 >> 18, I3[g3++] = 128 | D3 >> 12 & 63, I3[g3++] = 128 | D3 >> 6 & 63, I3[g3++] = 128 | 63 & D3;
      }
    }
    return I3[g3] = 0, g3 - B3;
  };
  function c(A3, I3, g3) {
    var Q3 = g3 > 0 ? g3 : Y(A3) + 1, B3 = new Array(Q3), C3 = J(A3, B3, 0, B3.length);
    return I3 && (B3.length = C3), B3;
  }
  var a = { ttys: [], init() {
  }, shutdown() {
  }, register(A3, I3) {
    a.ttys[A3] = { input: [], output: [], ops: I3 }, r.registerDevice(A3, a.stream_ops);
  }, stream_ops: { open(A3) {
    var I3 = a.ttys[A3.node.rdev];
    if (!I3)
      throw new r.ErrnoError(43);
    A3.tty = I3, A3.seekable = false;
  }, close(A3) {
    A3.tty.ops.fsync(A3.tty);
  }, fsync(A3) {
    A3.tty.ops.fsync(A3.tty);
  }, read(A3, I3, g3, Q3, B3) {
    if (!A3.tty || !A3.tty.ops.get_char)
      throw new r.ErrnoError(60);
    for (var C3 = 0, E3 = 0; E3 < Q3; E3++) {
      var D3;
      try {
        D3 = A3.tty.ops.get_char(A3.tty);
      } catch (A4) {
        throw new r.ErrnoError(29);
      }
      if (void 0 === D3 && 0 === C3)
        throw new r.ErrnoError(6);
      if (null == D3)
        break;
      C3++, I3[g3 + E3] = D3;
    }
    return C3 && (A3.node.timestamp = Date.now()), C3;
  }, write(A3, I3, g3, Q3, B3) {
    if (!A3.tty || !A3.tty.ops.put_char)
      throw new r.ErrnoError(60);
    try {
      for (var C3 = 0; C3 < Q3; C3++)
        A3.tty.ops.put_char(A3.tty, I3[g3 + C3]);
    } catch (A4) {
      throw new r.ErrnoError(29);
    }
    return Q3 && (A3.node.timestamp = Date.now()), C3;
  } }, default_tty_ops: { get_char: (A3) => (() => {
    if (!S.length) {
      var A4 = null;
      if ("undefined" != typeof window && "function" == typeof window.prompt ? null !== (A4 = window.prompt("Input: ")) && (A4 += "\n") : "function" == typeof readline && null !== (A4 = readline()) && (A4 += "\n"), !A4)
        return null;
      S = c(A4, true);
    }
    return S.shift();
  })(), put_char(A3, I3) {
    null === I3 || 10 === I3 ? (R(h(A3.output, 0)), A3.output = []) : 0 != I3 && A3.output.push(I3);
  }, fsync(A3) {
    A3.output && A3.output.length > 0 && (R(h(A3.output, 0)), A3.output = []);
  }, ioctl_tcgets: (A3) => ({ c_iflag: 25856, c_oflag: 5, c_cflag: 191, c_lflag: 35387, c_cc: [3, 28, 127, 21, 4, 0, 1, 0, 17, 19, 26, 0, 18, 15, 23, 22, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0] }), ioctl_tcsets: (A3, I3, g3) => 0, ioctl_tiocgwinsz: (A3) => [24, 80] }, default_tty1_ops: { put_char(A3, I3) {
    null === I3 || 10 === I3 ? (Q2(h(A3.output, 0)), A3.output = []) : 0 != I3 && A3.output.push(I3);
  }, fsync(A3) {
    A3.output && A3.output.length > 0 && (Q2(h(A3.output, 0)), A3.output = []);
  } } }, H = (A3) => {
    A3 = ((A4, I4) => Math.ceil(A4 / I4) * I4)(A3, 65536);
    var I3 = T(65536, A3);
    return I3 ? ((A4, I4) => (D2.fill(0, A4, A4 + I4), A4))(I3, A3) : 0;
  }, Z = { ops_table: null, mount: (A3) => Z.createNode(null, "/", 16895, 0), createNode(A3, I3, g3, Q3) {
    if (r.isBlkdev(g3) || r.isFIFO(g3))
      throw new r.ErrnoError(63);
    Z.ops_table || (Z.ops_table = { dir: { node: { getattr: Z.node_ops.getattr, setattr: Z.node_ops.setattr, lookup: Z.node_ops.lookup, mknod: Z.node_ops.mknod, rename: Z.node_ops.rename, unlink: Z.node_ops.unlink, rmdir: Z.node_ops.rmdir, readdir: Z.node_ops.readdir, symlink: Z.node_ops.symlink }, stream: { llseek: Z.stream_ops.llseek } }, file: { node: { getattr: Z.node_ops.getattr, setattr: Z.node_ops.setattr }, stream: { llseek: Z.stream_ops.llseek, read: Z.stream_ops.read, write: Z.stream_ops.write, allocate: Z.stream_ops.allocate, mmap: Z.stream_ops.mmap, msync: Z.stream_ops.msync } }, link: { node: { getattr: Z.node_ops.getattr, setattr: Z.node_ops.setattr, readlink: Z.node_ops.readlink }, stream: {} }, chrdev: { node: { getattr: Z.node_ops.getattr, setattr: Z.node_ops.setattr }, stream: r.chrdev_stream_ops } });
    var B3 = r.createNode(A3, I3, g3, Q3);
    return r.isDir(B3.mode) ? (B3.node_ops = Z.ops_table.dir.node, B3.stream_ops = Z.ops_table.dir.stream, B3.contents = {}) : r.isFile(B3.mode) ? (B3.node_ops = Z.ops_table.file.node, B3.stream_ops = Z.ops_table.file.stream, B3.usedBytes = 0, B3.contents = null) : r.isLink(B3.mode) ? (B3.node_ops = Z.ops_table.link.node, B3.stream_ops = Z.ops_table.link.stream) : r.isChrdev(B3.mode) && (B3.node_ops = Z.ops_table.chrdev.node, B3.stream_ops = Z.ops_table.chrdev.stream), B3.timestamp = Date.now(), A3 && (A3.contents[I3] = B3, A3.timestamp = B3.timestamp), B3;
  }, getFileDataAsTypedArray: (A3) => A3.contents ? A3.contents.subarray ? A3.contents.subarray(0, A3.usedBytes) : new Uint8Array(A3.contents) : new Uint8Array(0), expandFileStorage(A3, I3) {
    var g3 = A3.contents ? A3.contents.length : 0;
    if (!(g3 >= I3)) {
      I3 = Math.max(I3, g3 * (g3 < 1048576 ? 2 : 1.125) >>> 0), 0 != g3 && (I3 = Math.max(I3, 256));
      var Q3 = A3.contents;
      A3.contents = new Uint8Array(I3), A3.usedBytes > 0 && A3.contents.set(Q3.subarray(0, A3.usedBytes), 0);
    }
  }, resizeFileStorage(A3, I3) {
    if (A3.usedBytes != I3)
      if (0 == I3)
        A3.contents = null, A3.usedBytes = 0;
      else {
        var g3 = A3.contents;
        A3.contents = new Uint8Array(I3), g3 && A3.contents.set(g3.subarray(0, Math.min(I3, A3.usedBytes))), A3.usedBytes = I3;
      }
  }, node_ops: { getattr(A3) {
    var I3 = {};
    return I3.dev = r.isChrdev(A3.mode) ? A3.id : 1, I3.ino = A3.id, I3.mode = A3.mode, I3.nlink = 1, I3.uid = 0, I3.gid = 0, I3.rdev = A3.rdev, r.isDir(A3.mode) ? I3.size = 4096 : r.isFile(A3.mode) ? I3.size = A3.usedBytes : r.isLink(A3.mode) ? I3.size = A3.link.length : I3.size = 0, I3.atime = new Date(A3.timestamp), I3.mtime = new Date(A3.timestamp), I3.ctime = new Date(A3.timestamp), I3.blksize = 4096, I3.blocks = Math.ceil(I3.size / I3.blksize), I3;
  }, setattr(A3, I3) {
    void 0 !== I3.mode && (A3.mode = I3.mode), void 0 !== I3.timestamp && (A3.timestamp = I3.timestamp), void 0 !== I3.size && Z.resizeFileStorage(A3, I3.size);
  }, lookup(A3, I3) {
    throw r.genericErrors[44];
  }, mknod: (A3, I3, g3, Q3) => Z.createNode(A3, I3, g3, Q3), rename(A3, I3, g3) {
    if (r.isDir(A3.mode)) {
      var Q3;
      try {
        Q3 = r.lookupNode(I3, g3);
      } catch (A4) {
      }
      if (Q3)
        for (var B3 in Q3.contents)
          throw new r.ErrnoError(55);
    }
    delete A3.parent.contents[A3.name], A3.parent.timestamp = Date.now(), A3.name = g3, I3.contents[g3] = A3, I3.timestamp = A3.parent.timestamp, A3.parent = I3;
  }, unlink(A3, I3) {
    delete A3.contents[I3], A3.timestamp = Date.now();
  }, rmdir(A3, I3) {
    var g3 = r.lookupNode(A3, I3);
    for (var Q3 in g3.contents)
      throw new r.ErrnoError(55);
    delete A3.contents[I3], A3.timestamp = Date.now();
  }, readdir(A3) {
    var I3 = [".", ".."];
    for (var g3 of Object.keys(A3.contents))
      I3.push(g3);
    return I3;
  }, symlink(A3, I3, g3) {
    var Q3 = Z.createNode(A3, I3, 41471, 0);
    return Q3.link = g3, Q3;
  }, readlink(A3) {
    if (!r.isLink(A3.mode))
      throw new r.ErrnoError(28);
    return A3.link;
  } }, stream_ops: { read(A3, I3, g3, Q3, B3) {
    var C3 = A3.node.contents;
    if (B3 >= A3.node.usedBytes)
      return 0;
    var E3 = Math.min(A3.node.usedBytes - B3, Q3);
    if (E3 > 8 && C3.subarray)
      I3.set(C3.subarray(B3, B3 + E3), g3);
    else
      for (var D3 = 0; D3 < E3; D3++)
        I3[g3 + D3] = C3[B3 + D3];
    return E3;
  }, write(A3, I3, g3, Q3, C3, E3) {
    if (I3.buffer === B2.buffer && (E3 = false), !Q3)
      return 0;
    var D3 = A3.node;
    if (D3.timestamp = Date.now(), I3.subarray && (!D3.contents || D3.contents.subarray)) {
      if (E3)
        return D3.contents = I3.subarray(g3, g3 + Q3), D3.usedBytes = Q3, Q3;
      if (0 === D3.usedBytes && 0 === C3)
        return D3.contents = I3.slice(g3, g3 + Q3), D3.usedBytes = Q3, Q3;
      if (C3 + Q3 <= D3.usedBytes)
        return D3.contents.set(I3.subarray(g3, g3 + Q3), C3), Q3;
    }
    if (Z.expandFileStorage(D3, C3 + Q3), D3.contents.subarray && I3.subarray)
      D3.contents.set(I3.subarray(g3, g3 + Q3), C3);
    else
      for (var w3 = 0; w3 < Q3; w3++)
        D3.contents[C3 + w3] = I3[g3 + w3];
    return D3.usedBytes = Math.max(D3.usedBytes, C3 + Q3), Q3;
  }, llseek(A3, I3, g3) {
    var Q3 = I3;
    if (1 === g3 ? Q3 += A3.position : 2 === g3 && r.isFile(A3.node.mode) && (Q3 += A3.node.usedBytes), Q3 < 0)
      throw new r.ErrnoError(28);
    return Q3;
  }, allocate(A3, I3, g3) {
    Z.expandFileStorage(A3.node, I3 + g3), A3.node.usedBytes = Math.max(A3.node.usedBytes, I3 + g3);
  }, mmap(A3, I3, g3, Q3, C3) {
    if (!r.isFile(A3.node.mode))
      throw new r.ErrnoError(43);
    var E3, D3, w3 = A3.node.contents;
    if (2 & C3 || w3.buffer !== B2.buffer) {
      if ((g3 > 0 || g3 + I3 < w3.length) && (w3 = w3.subarray ? w3.subarray(g3, g3 + I3) : Array.prototype.slice.call(w3, g3, g3 + I3)), D3 = true, !(E3 = H(I3)))
        throw new r.ErrnoError(48);
      B2.set(w3, E3);
    } else
      D3 = false, E3 = w3.byteOffset;
    return { ptr: E3, allocated: D3 };
  }, msync: (A3, I3, g3, Q3, B3) => (Z.stream_ops.write(A3, I3, 0, Q3, g3, false), 0) } }, q = (A3, I3) => {
    var g3 = 0;
    return A3 && (g3 |= 365), I3 && (g3 |= 146), g3;
  }, r = { root: null, mounts: [], devices: {}, streams: [], nextInode: 1, nameTable: null, currentPath: "/", initialized: false, ignorePermissions: true, ErrnoError: null, genericErrors: {}, filesystems: null, syncFSRequests: 0, lookupPath(A3) {
    let I3 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {};
    if (!(A3 = U.resolve(A3)))
      return { path: "", node: null };
    if (I3 = Object.assign({ follow_mount: true, recurse_count: 0 }, I3), I3.recurse_count > 8)
      throw new r.ErrnoError(32);
    for (var g3 = A3.split("/").filter((A4) => !!A4), Q3 = r.root, B3 = "/", C3 = 0; C3 < g3.length; C3++) {
      var E3 = C3 === g3.length - 1;
      if (E3 && I3.parent)
        break;
      if (Q3 = r.lookupNode(Q3, g3[C3]), B3 = k.join2(B3, g3[C3]), r.isMountpoint(Q3) && (!E3 || E3 && I3.follow_mount) && (Q3 = Q3.mounted.root), !E3 || I3.follow)
        for (var D3 = 0; r.isLink(Q3.mode); ) {
          var w3 = r.readlink(B3);
          if (B3 = U.resolve(k.dirname(B3), w3), Q3 = r.lookupPath(B3, { recurse_count: I3.recurse_count + 1 }).node, D3++ > 40)
            throw new r.ErrnoError(32);
        }
    }
    return { path: B3, node: Q3 };
  }, getPath(A3) {
    for (var I3; ; ) {
      if (r.isRoot(A3)) {
        var g3 = A3.mount.mountpoint;
        return I3 ? "/" !== g3[g3.length - 1] ? `${g3}/${I3}` : g3 + I3 : g3;
      }
      I3 = I3 ? `${A3.name}/${I3}` : A3.name, A3 = A3.parent;
    }
  }, hashName(A3, I3) {
    for (var g3 = 0, Q3 = 0; Q3 < I3.length; Q3++)
      g3 = (g3 << 5) - g3 + I3.charCodeAt(Q3) | 0;
    return (A3 + g3 >>> 0) % r.nameTable.length;
  }, hashAddNode(A3) {
    var I3 = r.hashName(A3.parent.id, A3.name);
    A3.name_next = r.nameTable[I3], r.nameTable[I3] = A3;
  }, hashRemoveNode(A3) {
    var I3 = r.hashName(A3.parent.id, A3.name);
    if (r.nameTable[I3] === A3)
      r.nameTable[I3] = A3.name_next;
    else
      for (var g3 = r.nameTable[I3]; g3; ) {
        if (g3.name_next === A3) {
          g3.name_next = A3.name_next;
          break;
        }
        g3 = g3.name_next;
      }
  }, lookupNode(A3, I3) {
    var g3 = r.mayLookup(A3);
    if (g3)
      throw new r.ErrnoError(g3, A3);
    for (var Q3 = r.hashName(A3.id, I3), B3 = r.nameTable[Q3]; B3; B3 = B3.name_next) {
      var C3 = B3.name;
      if (B3.parent.id === A3.id && C3 === I3)
        return B3;
    }
    return r.lookup(A3, I3);
  }, createNode(A3, I3, g3, Q3) {
    var B3 = new r.FSNode(A3, I3, g3, Q3);
    return r.hashAddNode(B3), B3;
  }, destroyNode(A3) {
    r.hashRemoveNode(A3);
  }, isRoot: (A3) => A3 === A3.parent, isMountpoint: (A3) => !!A3.mounted, isFile: (A3) => 32768 == (61440 & A3), isDir: (A3) => 16384 == (61440 & A3), isLink: (A3) => 40960 == (61440 & A3), isChrdev: (A3) => 8192 == (61440 & A3), isBlkdev: (A3) => 24576 == (61440 & A3), isFIFO: (A3) => 4096 == (61440 & A3), isSocket: (A3) => 49152 == (49152 & A3), flagsToPermissionString(A3) {
    var I3 = ["r", "w", "rw"][3 & A3];
    return 512 & A3 && (I3 += "w"), I3;
  }, nodePermissions: (A3, I3) => r.ignorePermissions || (!I3.includes("r") || 292 & A3.mode) && (!I3.includes("w") || 146 & A3.mode) && (!I3.includes("x") || 73 & A3.mode) ? 0 : 2, mayLookup(A3) {
    var I3 = r.nodePermissions(A3, "x");
    return I3 || (A3.node_ops.lookup ? 0 : 2);
  }, mayCreate(A3, I3) {
    try {
      r.lookupNode(A3, I3);
      return 20;
    } catch (A4) {
    }
    return r.nodePermissions(A3, "wx");
  }, mayDelete(A3, I3, g3) {
    var Q3;
    try {
      Q3 = r.lookupNode(A3, I3);
    } catch (A4) {
      return A4.errno;
    }
    var B3 = r.nodePermissions(A3, "wx");
    if (B3)
      return B3;
    if (g3) {
      if (!r.isDir(Q3.mode))
        return 54;
      if (r.isRoot(Q3) || r.getPath(Q3) === r.cwd())
        return 10;
    } else if (r.isDir(Q3.mode))
      return 31;
    return 0;
  }, mayOpen: (A3, I3) => A3 ? r.isLink(A3.mode) ? 32 : r.isDir(A3.mode) && ("r" !== r.flagsToPermissionString(I3) || 512 & I3) ? 31 : r.nodePermissions(A3, r.flagsToPermissionString(I3)) : 44, MAX_OPEN_FDS: 4096, nextfd() {
    for (var A3 = 0; A3 <= r.MAX_OPEN_FDS; A3++)
      if (!r.streams[A3])
        return A3;
    throw new r.ErrnoError(33);
  }, getStreamChecked(A3) {
    var I3 = r.getStream(A3);
    if (!I3)
      throw new r.ErrnoError(8);
    return I3;
  }, getStream: (A3) => r.streams[A3], createStream(A3) {
    let I3 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : -1;
    return r.FSStream || (r.FSStream = function() {
      this.shared = {};
    }, r.FSStream.prototype = {}, Object.defineProperties(r.FSStream.prototype, { object: { get() {
      return this.node;
    }, set(A4) {
      this.node = A4;
    } }, isRead: { get() {
      return 1 != (2097155 & this.flags);
    } }, isWrite: { get() {
      return 0 != (2097155 & this.flags);
    } }, isAppend: { get() {
      return 1024 & this.flags;
    } }, flags: { get() {
      return this.shared.flags;
    }, set(A4) {
      this.shared.flags = A4;
    } }, position: { get() {
      return this.shared.position;
    }, set(A4) {
      this.shared.position = A4;
    } } })), A3 = Object.assign(new r.FSStream(), A3), -1 == I3 && (I3 = r.nextfd()), A3.fd = I3, r.streams[I3] = A3, A3;
  }, closeStream(A3) {
    r.streams[A3] = null;
  }, chrdev_stream_ops: { open(A3) {
    var I3 = r.getDevice(A3.node.rdev);
    A3.stream_ops = I3.stream_ops, A3.stream_ops.open?.(A3);
  }, llseek() {
    throw new r.ErrnoError(70);
  } }, major: (A3) => A3 >> 8, minor: (A3) => 255 & A3, makedev: (A3, I3) => A3 << 8 | I3, registerDevice(A3, I3) {
    r.devices[A3] = { stream_ops: I3 };
  }, getDevice: (A3) => r.devices[A3], getMounts(A3) {
    for (var I3 = [], g3 = [A3]; g3.length; ) {
      var Q3 = g3.pop();
      I3.push(Q3), g3.push.apply(g3, Q3.mounts);
    }
    return I3;
  }, syncfs(A3, I3) {
    "function" == typeof A3 && (I3 = A3, A3 = false), r.syncFSRequests++, r.syncFSRequests > 1 && Q2(`warning: ${r.syncFSRequests} FS.syncfs operations in flight at once, probably just doing extra work`);
    var g3 = r.getMounts(r.root.mount), B3 = 0;
    function C3(A4) {
      return r.syncFSRequests--, I3(A4);
    }
    function E3(A4) {
      if (A4)
        return E3.errored ? void 0 : (E3.errored = true, C3(A4));
      ++B3 >= g3.length && C3(null);
    }
    g3.forEach((I4) => {
      if (!I4.type.syncfs)
        return E3(null);
      I4.type.syncfs(I4, A3, E3);
    });
  }, mount(A3, I3, g3) {
    var Q3, B3 = "/" === g3, C3 = !g3;
    if (B3 && r.root)
      throw new r.ErrnoError(10);
    if (!B3 && !C3) {
      var E3 = r.lookupPath(g3, { follow_mount: false });
      if (g3 = E3.path, Q3 = E3.node, r.isMountpoint(Q3))
        throw new r.ErrnoError(10);
      if (!r.isDir(Q3.mode))
        throw new r.ErrnoError(54);
    }
    var D3 = { type: A3, opts: I3, mountpoint: g3, mounts: [] }, w3 = A3.mount(D3);
    return w3.mount = D3, D3.root = w3, B3 ? r.root = w3 : Q3 && (Q3.mounted = D3, Q3.mount && Q3.mount.mounts.push(D3)), w3;
  }, unmount(A3) {
    var I3 = r.lookupPath(A3, { follow_mount: false });
    if (!r.isMountpoint(I3.node))
      throw new r.ErrnoError(28);
    var g3 = I3.node, Q3 = g3.mounted, B3 = r.getMounts(Q3);
    Object.keys(r.nameTable).forEach((A4) => {
      for (var I4 = r.nameTable[A4]; I4; ) {
        var g4 = I4.name_next;
        B3.includes(I4.mount) && r.destroyNode(I4), I4 = g4;
      }
    }), g3.mounted = null;
    var C3 = g3.mount.mounts.indexOf(Q3);
    g3.mount.mounts.splice(C3, 1);
  }, lookup: (A3, I3) => A3.node_ops.lookup(A3, I3), mknod(A3, I3, g3) {
    var Q3 = r.lookupPath(A3, { parent: true }).node, B3 = k.basename(A3);
    if (!B3 || "." === B3 || ".." === B3)
      throw new r.ErrnoError(28);
    var C3 = r.mayCreate(Q3, B3);
    if (C3)
      throw new r.ErrnoError(C3);
    if (!Q3.node_ops.mknod)
      throw new r.ErrnoError(63);
    return Q3.node_ops.mknod(Q3, B3, I3, g3);
  }, create: (A3, I3) => (I3 = void 0 !== I3 ? I3 : 438, I3 &= 4095, I3 |= 32768, r.mknod(A3, I3, 0)), mkdir: (A3, I3) => (I3 = void 0 !== I3 ? I3 : 511, I3 &= 1023, I3 |= 16384, r.mknod(A3, I3, 0)), mkdirTree(A3, I3) {
    for (var g3 = A3.split("/"), Q3 = "", B3 = 0; B3 < g3.length; ++B3)
      if (g3[B3]) {
        Q3 += "/" + g3[B3];
        try {
          r.mkdir(Q3, I3);
        } catch (A4) {
          if (20 != A4.errno)
            throw A4;
        }
      }
  }, mkdev: (A3, I3, g3) => (void 0 === g3 && (g3 = I3, I3 = 438), I3 |= 8192, r.mknod(A3, I3, g3)), symlink(A3, I3) {
    if (!U.resolve(A3))
      throw new r.ErrnoError(44);
    var g3 = r.lookupPath(I3, { parent: true }).node;
    if (!g3)
      throw new r.ErrnoError(44);
    var Q3 = k.basename(I3), B3 = r.mayCreate(g3, Q3);
    if (B3)
      throw new r.ErrnoError(B3);
    if (!g3.node_ops.symlink)
      throw new r.ErrnoError(63);
    return g3.node_ops.symlink(g3, Q3, A3);
  }, rename(A3, I3) {
    var g3, Q3, B3 = k.dirname(A3), C3 = k.dirname(I3), E3 = k.basename(A3), D3 = k.basename(I3);
    if (g3 = r.lookupPath(A3, { parent: true }).node, Q3 = r.lookupPath(I3, { parent: true }).node, !g3 || !Q3)
      throw new r.ErrnoError(44);
    if (g3.mount !== Q3.mount)
      throw new r.ErrnoError(75);
    var w3, i3 = r.lookupNode(g3, E3), o3 = U.relative(A3, C3);
    if ("." !== o3.charAt(0))
      throw new r.ErrnoError(28);
    if ("." !== (o3 = U.relative(I3, B3)).charAt(0))
      throw new r.ErrnoError(55);
    try {
      w3 = r.lookupNode(Q3, D3);
    } catch (A4) {
    }
    if (i3 !== w3) {
      var G3 = r.isDir(i3.mode), M3 = r.mayDelete(g3, E3, G3);
      if (M3)
        throw new r.ErrnoError(M3);
      if (M3 = w3 ? r.mayDelete(Q3, D3, G3) : r.mayCreate(Q3, D3))
        throw new r.ErrnoError(M3);
      if (!g3.node_ops.rename)
        throw new r.ErrnoError(63);
      if (r.isMountpoint(i3) || w3 && r.isMountpoint(w3))
        throw new r.ErrnoError(10);
      if (Q3 !== g3 && (M3 = r.nodePermissions(g3, "w")))
        throw new r.ErrnoError(M3);
      r.hashRemoveNode(i3);
      try {
        g3.node_ops.rename(i3, Q3, D3);
      } catch (A4) {
        throw A4;
      } finally {
        r.hashAddNode(i3);
      }
    }
  }, rmdir(A3) {
    var I3 = r.lookupPath(A3, { parent: true }).node, g3 = k.basename(A3), Q3 = r.lookupNode(I3, g3), B3 = r.mayDelete(I3, g3, true);
    if (B3)
      throw new r.ErrnoError(B3);
    if (!I3.node_ops.rmdir)
      throw new r.ErrnoError(63);
    if (r.isMountpoint(Q3))
      throw new r.ErrnoError(10);
    I3.node_ops.rmdir(I3, g3), r.destroyNode(Q3);
  }, readdir(A3) {
    var I3 = r.lookupPath(A3, { follow: true }).node;
    if (!I3.node_ops.readdir)
      throw new r.ErrnoError(54);
    return I3.node_ops.readdir(I3);
  }, unlink(A3) {
    var I3 = r.lookupPath(A3, { parent: true }).node;
    if (!I3)
      throw new r.ErrnoError(44);
    var g3 = k.basename(A3), Q3 = r.lookupNode(I3, g3), B3 = r.mayDelete(I3, g3, false);
    if (B3)
      throw new r.ErrnoError(B3);
    if (!I3.node_ops.unlink)
      throw new r.ErrnoError(63);
    if (r.isMountpoint(Q3))
      throw new r.ErrnoError(10);
    I3.node_ops.unlink(I3, g3), r.destroyNode(Q3);
  }, readlink(A3) {
    var I3 = r.lookupPath(A3).node;
    if (!I3)
      throw new r.ErrnoError(44);
    if (!I3.node_ops.readlink)
      throw new r.ErrnoError(28);
    return U.resolve(r.getPath(I3.parent), I3.node_ops.readlink(I3));
  }, stat(A3, I3) {
    var g3 = r.lookupPath(A3, { follow: !I3 }).node;
    if (!g3)
      throw new r.ErrnoError(44);
    if (!g3.node_ops.getattr)
      throw new r.ErrnoError(63);
    return g3.node_ops.getattr(g3);
  }, lstat: (A3) => r.stat(A3, true), chmod(A3, I3, g3) {
    var Q3;
    "string" == typeof A3 ? Q3 = r.lookupPath(A3, { follow: !g3 }).node : Q3 = A3;
    if (!Q3.node_ops.setattr)
      throw new r.ErrnoError(63);
    Q3.node_ops.setattr(Q3, { mode: 4095 & I3 | -4096 & Q3.mode, timestamp: Date.now() });
  }, lchmod(A3, I3) {
    r.chmod(A3, I3, true);
  }, fchmod(A3, I3) {
    var g3 = r.getStreamChecked(A3);
    r.chmod(g3.node, I3);
  }, chown(A3, I3, g3, Q3) {
    var B3;
    "string" == typeof A3 ? B3 = r.lookupPath(A3, { follow: !Q3 }).node : B3 = A3;
    if (!B3.node_ops.setattr)
      throw new r.ErrnoError(63);
    B3.node_ops.setattr(B3, { timestamp: Date.now() });
  }, lchown(A3, I3, g3) {
    r.chown(A3, I3, g3, true);
  }, fchown(A3, I3, g3) {
    var Q3 = r.getStreamChecked(A3);
    r.chown(Q3.node, I3, g3);
  }, truncate(A3, I3) {
    if (I3 < 0)
      throw new r.ErrnoError(28);
    var g3;
    "string" == typeof A3 ? g3 = r.lookupPath(A3, { follow: true }).node : g3 = A3;
    if (!g3.node_ops.setattr)
      throw new r.ErrnoError(63);
    if (r.isDir(g3.mode))
      throw new r.ErrnoError(31);
    if (!r.isFile(g3.mode))
      throw new r.ErrnoError(28);
    var Q3 = r.nodePermissions(g3, "w");
    if (Q3)
      throw new r.ErrnoError(Q3);
    g3.node_ops.setattr(g3, { size: I3, timestamp: Date.now() });
  }, ftruncate(A3, I3) {
    var g3 = r.getStreamChecked(A3);
    if (0 == (2097155 & g3.flags))
      throw new r.ErrnoError(28);
    r.truncate(g3.node, I3);
  }, utime(A3, I3, g3) {
    var Q3 = r.lookupPath(A3, { follow: true }).node;
    Q3.node_ops.setattr(Q3, { timestamp: Math.max(I3, g3) });
  }, open(A3, I3, Q3) {
    if ("" === A3)
      throw new r.ErrnoError(44);
    var B3;
    if (Q3 = void 0 === Q3 ? 438 : Q3, Q3 = 64 & (I3 = "string" == typeof I3 ? ((A4) => {
      var I4 = { r: 0, "r+": 2, w: 577, "w+": 578, a: 1089, "a+": 1090 }[A4];
      if (void 0 === I4)
        throw new Error(`Unknown file open mode: ${A4}`);
      return I4;
    })(I3) : I3) ? 4095 & Q3 | 32768 : 0, "object" == typeof A3)
      B3 = A3;
    else {
      A3 = k.normalize(A3);
      try {
        B3 = r.lookupPath(A3, { follow: !(131072 & I3) }).node;
      } catch (A4) {
      }
    }
    var C3 = false;
    if (64 & I3)
      if (B3) {
        if (128 & I3)
          throw new r.ErrnoError(20);
      } else
        B3 = r.mknod(A3, Q3, 0), C3 = true;
    if (!B3)
      throw new r.ErrnoError(44);
    if (r.isChrdev(B3.mode) && (I3 &= -513), 65536 & I3 && !r.isDir(B3.mode))
      throw new r.ErrnoError(54);
    if (!C3) {
      var E3 = r.mayOpen(B3, I3);
      if (E3)
        throw new r.ErrnoError(E3);
    }
    512 & I3 && !C3 && r.truncate(B3, 0), I3 &= -131713;
    var D3 = r.createStream({ node: B3, path: r.getPath(B3), flags: I3, seekable: true, position: 0, stream_ops: B3.stream_ops, ungotten: [], error: false });
    return D3.stream_ops.open && D3.stream_ops.open(D3), !g2.logReadFiles || 1 & I3 || (r.readFiles || (r.readFiles = {}), A3 in r.readFiles || (r.readFiles[A3] = 1)), D3;
  }, close(A3) {
    if (r.isClosed(A3))
      throw new r.ErrnoError(8);
    A3.getdents && (A3.getdents = null);
    try {
      A3.stream_ops.close && A3.stream_ops.close(A3);
    } catch (A4) {
      throw A4;
    } finally {
      r.closeStream(A3.fd);
    }
    A3.fd = null;
  }, isClosed: (A3) => null === A3.fd, llseek(A3, I3, g3) {
    if (r.isClosed(A3))
      throw new r.ErrnoError(8);
    if (!A3.seekable || !A3.stream_ops.llseek)
      throw new r.ErrnoError(70);
    if (0 != g3 && 1 != g3 && 2 != g3)
      throw new r.ErrnoError(28);
    return A3.position = A3.stream_ops.llseek(A3, I3, g3), A3.ungotten = [], A3.position;
  }, read(A3, I3, g3, Q3, B3) {
    if (Q3 < 0 || B3 < 0)
      throw new r.ErrnoError(28);
    if (r.isClosed(A3))
      throw new r.ErrnoError(8);
    if (1 == (2097155 & A3.flags))
      throw new r.ErrnoError(8);
    if (r.isDir(A3.node.mode))
      throw new r.ErrnoError(31);
    if (!A3.stream_ops.read)
      throw new r.ErrnoError(28);
    var C3 = void 0 !== B3;
    if (C3) {
      if (!A3.seekable)
        throw new r.ErrnoError(70);
    } else
      B3 = A3.position;
    var E3 = A3.stream_ops.read(A3, I3, g3, Q3, B3);
    return C3 || (A3.position += E3), E3;
  }, write(A3, I3, g3, Q3, B3, C3) {
    if (Q3 < 0 || B3 < 0)
      throw new r.ErrnoError(28);
    if (r.isClosed(A3))
      throw new r.ErrnoError(8);
    if (0 == (2097155 & A3.flags))
      throw new r.ErrnoError(8);
    if (r.isDir(A3.node.mode))
      throw new r.ErrnoError(31);
    if (!A3.stream_ops.write)
      throw new r.ErrnoError(28);
    A3.seekable && 1024 & A3.flags && r.llseek(A3, 0, 2);
    var E3 = void 0 !== B3;
    if (E3) {
      if (!A3.seekable)
        throw new r.ErrnoError(70);
    } else
      B3 = A3.position;
    var D3 = A3.stream_ops.write(A3, I3, g3, Q3, B3, C3);
    return E3 || (A3.position += D3), D3;
  }, allocate(A3, I3, g3) {
    if (r.isClosed(A3))
      throw new r.ErrnoError(8);
    if (I3 < 0 || g3 <= 0)
      throw new r.ErrnoError(28);
    if (0 == (2097155 & A3.flags))
      throw new r.ErrnoError(8);
    if (!r.isFile(A3.node.mode) && !r.isDir(A3.node.mode))
      throw new r.ErrnoError(43);
    if (!A3.stream_ops.allocate)
      throw new r.ErrnoError(138);
    A3.stream_ops.allocate(A3, I3, g3);
  }, mmap(A3, I3, g3, Q3, B3) {
    if (0 != (2 & Q3) && 0 == (2 & B3) && 2 != (2097155 & A3.flags))
      throw new r.ErrnoError(2);
    if (1 == (2097155 & A3.flags))
      throw new r.ErrnoError(2);
    if (!A3.stream_ops.mmap)
      throw new r.ErrnoError(43);
    return A3.stream_ops.mmap(A3, I3, g3, Q3, B3);
  }, msync: (A3, I3, g3, Q3, B3) => A3.stream_ops.msync ? A3.stream_ops.msync(A3, I3, g3, Q3, B3) : 0, munmap: (A3) => 0, ioctl(A3, I3, g3) {
    if (!A3.stream_ops.ioctl)
      throw new r.ErrnoError(59);
    return A3.stream_ops.ioctl(A3, I3, g3);
  }, readFile(A3) {
    let I3 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {};
    if (I3.flags = I3.flags || 0, I3.encoding = I3.encoding || "binary", "utf8" !== I3.encoding && "binary" !== I3.encoding)
      throw new Error(`Invalid encoding type "${I3.encoding}"`);
    var g3, Q3 = r.open(A3, I3.flags), B3 = r.stat(A3).size, C3 = new Uint8Array(B3);
    return r.read(Q3, C3, 0, B3, 0), "utf8" === I3.encoding ? g3 = h(C3, 0) : "binary" === I3.encoding && (g3 = C3), r.close(Q3), g3;
  }, writeFile(A3, I3) {
    let g3 = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : {};
    g3.flags = g3.flags || 577;
    var Q3 = r.open(A3, g3.flags, g3.mode);
    if ("string" == typeof I3) {
      var B3 = new Uint8Array(Y(I3) + 1), C3 = J(I3, B3, 0, B3.length);
      r.write(Q3, B3, 0, C3, void 0, g3.canOwn);
    } else {
      if (!ArrayBuffer.isView(I3))
        throw new Error("Unsupported data type");
      r.write(Q3, I3, 0, I3.byteLength, void 0, g3.canOwn);
    }
    r.close(Q3);
  }, cwd: () => r.currentPath, chdir(A3) {
    var I3 = r.lookupPath(A3, { follow: true });
    if (null === I3.node)
      throw new r.ErrnoError(44);
    if (!r.isDir(I3.node.mode))
      throw new r.ErrnoError(54);
    var g3 = r.nodePermissions(I3.node, "x");
    if (g3)
      throw new r.ErrnoError(g3);
    r.currentPath = I3.path;
  }, createDefaultDirectories() {
    r.mkdir("/tmp"), r.mkdir("/home"), r.mkdir("/home/web_user");
  }, createDefaultDevices() {
    r.mkdir("/dev"), r.registerDevice(r.makedev(1, 3), { read: () => 0, write: (A4, I4, g4, Q3, B3) => Q3 }), r.mkdev("/dev/null", r.makedev(1, 3)), a.register(r.makedev(5, 0), a.default_tty_ops), a.register(r.makedev(6, 0), a.default_tty1_ops), r.mkdev("/dev/tty", r.makedev(5, 0)), r.mkdev("/dev/tty1", r.makedev(6, 0));
    var A3 = new Uint8Array(1024), I3 = 0, g3 = () => (0 === I3 && (I3 = L(A3).byteLength), A3[--I3]);
    r.createDevice("/dev", "random", g3), r.createDevice("/dev", "urandom", g3), r.mkdir("/dev/shm"), r.mkdir("/dev/shm/tmp");
  }, createSpecialDirectories() {
    r.mkdir("/proc");
    var A3 = r.mkdir("/proc/self");
    r.mkdir("/proc/self/fd"), r.mount({ mount() {
      var I3 = r.createNode(A3, "fd", 16895, 73);
      return I3.node_ops = { lookup(A4, I4) {
        var g3 = +I4, Q3 = r.getStreamChecked(g3), B3 = { parent: null, mount: { mountpoint: "fake" }, node_ops: { readlink: () => Q3.path } };
        return B3.parent = B3, B3;
      } }, I3;
    } }, {}, "/proc/self/fd");
  }, createStandardStreams() {
    g2.stdin ? r.createDevice("/dev", "stdin", g2.stdin) : r.symlink("/dev/tty", "/dev/stdin"), g2.stdout ? r.createDevice("/dev", "stdout", null, g2.stdout) : r.symlink("/dev/tty", "/dev/stdout"), g2.stderr ? r.createDevice("/dev", "stderr", null, g2.stderr) : r.symlink("/dev/tty1", "/dev/stderr"), r.open("/dev/stdin", 0), r.open("/dev/stdout", 1), r.open("/dev/stderr", 1);
  }, ensureErrnoError() {
    r.ErrnoError || (r.ErrnoError = function(A3, I3) {
      this.name = "ErrnoError", this.node = I3, this.setErrno = function(A4) {
        this.errno = A4;
      }, this.setErrno(A3), this.message = "FS error";
    }, r.ErrnoError.prototype = new Error(), r.ErrnoError.prototype.constructor = r.ErrnoError, [44].forEach((A3) => {
      r.genericErrors[A3] = new r.ErrnoError(A3), r.genericErrors[A3].stack = "<generic error, no stack>";
    }));
  }, staticInit() {
    r.ensureErrnoError(), r.nameTable = new Array(4096), r.mount(Z, {}, "/"), r.createDefaultDirectories(), r.createDefaultDevices(), r.createSpecialDirectories(), r.filesystems = { MEMFS: Z };
  }, init(A3, I3, Q3) {
    r.init.initialized = true, r.ensureErrnoError(), g2.stdin = A3 || g2.stdin, g2.stdout = I3 || g2.stdout, g2.stderr = Q3 || g2.stderr, r.createStandardStreams();
  }, quit() {
    r.init.initialized = false;
    for (var A3 = 0; A3 < r.streams.length; A3++) {
      var I3 = r.streams[A3];
      I3 && r.close(I3);
    }
  }, findObject(A3, I3) {
    var g3 = r.analyzePath(A3, I3);
    return g3.exists ? g3.object : null;
  }, analyzePath(A3, I3) {
    try {
      A3 = (Q3 = r.lookupPath(A3, { follow: !I3 })).path;
    } catch (A4) {
    }
    var g3 = { isRoot: false, exists: false, error: 0, name: null, path: null, object: null, parentExists: false, parentPath: null, parentObject: null };
    try {
      var Q3 = r.lookupPath(A3, { parent: true });
      g3.parentExists = true, g3.parentPath = Q3.path, g3.parentObject = Q3.node, g3.name = k.basename(A3), Q3 = r.lookupPath(A3, { follow: !I3 }), g3.exists = true, g3.path = Q3.path, g3.object = Q3.node, g3.name = Q3.node.name, g3.isRoot = "/" === Q3.path;
    } catch (A4) {
      g3.error = A4.errno;
    }
    return g3;
  }, createPath(A3, I3, g3, Q3) {
    A3 = "string" == typeof A3 ? A3 : r.getPath(A3);
    for (var B3 = I3.split("/").reverse(); B3.length; ) {
      var C3 = B3.pop();
      if (C3) {
        var E3 = k.join2(A3, C3);
        try {
          r.mkdir(E3);
        } catch (A4) {
        }
        A3 = E3;
      }
    }
    return E3;
  }, createFile(A3, I3, g3, Q3, B3) {
    var C3 = k.join2("string" == typeof A3 ? A3 : r.getPath(A3), I3), E3 = q(Q3, B3);
    return r.create(C3, E3);
  }, createDataFile(A3, I3, g3, Q3, B3, C3) {
    var E3 = I3;
    A3 && (A3 = "string" == typeof A3 ? A3 : r.getPath(A3), E3 = I3 ? k.join2(A3, I3) : A3);
    var D3 = q(Q3, B3), w3 = r.create(E3, D3);
    if (g3) {
      if ("string" == typeof g3) {
        for (var i3 = new Array(g3.length), o3 = 0, G3 = g3.length; o3 < G3; ++o3)
          i3[o3] = g3.charCodeAt(o3);
        g3 = i3;
      }
      r.chmod(w3, 146 | D3);
      var M3 = r.open(w3, 577);
      r.write(M3, g3, 0, g3.length, 0, C3), r.close(M3), r.chmod(w3, D3);
    }
  }, createDevice(A3, I3, g3, Q3) {
    var B3 = k.join2("string" == typeof A3 ? A3 : r.getPath(A3), I3), C3 = q(!!g3, !!Q3);
    r.createDevice.major || (r.createDevice.major = 64);
    var E3 = r.makedev(r.createDevice.major++, 0);
    return r.registerDevice(E3, { open(A4) {
      A4.seekable = false;
    }, close(A4) {
      Q3?.buffer?.length && Q3(10);
    }, read(A4, I4, Q4, B4, C4) {
      for (var E4 = 0, D3 = 0; D3 < B4; D3++) {
        var w3;
        try {
          w3 = g3();
        } catch (A5) {
          throw new r.ErrnoError(29);
        }
        if (void 0 === w3 && 0 === E4)
          throw new r.ErrnoError(6);
        if (null == w3)
          break;
        E4++, I4[Q4 + D3] = w3;
      }
      return E4 && (A4.node.timestamp = Date.now()), E4;
    }, write(A4, I4, g4, B4, C4) {
      for (var E4 = 0; E4 < B4; E4++)
        try {
          Q3(I4[g4 + E4]);
        } catch (A5) {
          throw new r.ErrnoError(29);
        }
      return B4 && (A4.node.timestamp = Date.now()), E4;
    } }), r.mkdev(B3, C3, E3);
  }, forceLoadFile(A3) {
    if (A3.isDevice || A3.isFolder || A3.link || A3.contents)
      return true;
    if ("undefined" != typeof XMLHttpRequest)
      throw new Error("Lazy loading should have been performed (contents set) in createLazyFile, but it was not. Lazy loading only works in web workers. Use --embed-file or --preload-file in emcc on the main thread.");
    if (!read_)
      throw new Error("Cannot load without read() or XMLHttpRequest.");
    try {
      A3.contents = c(read_(A3.url), true), A3.usedBytes = A3.contents.length;
    } catch (A4) {
      throw new r.ErrnoError(29);
    }
  }, createLazyFile(A3, I3, g3, Q3, C3) {
    function E3() {
      this.lengthKnown = false, this.chunks = [];
    }
    if (E3.prototype.get = function(A4) {
      if (!(A4 > this.length - 1 || A4 < 0)) {
        var I4 = A4 % this.chunkSize, g4 = A4 / this.chunkSize | 0;
        return this.getter(g4)[I4];
      }
    }, E3.prototype.setDataGetter = function(A4) {
      this.getter = A4;
    }, E3.prototype.cacheLength = function() {
      var A4 = new XMLHttpRequest();
      if (A4.open("HEAD", g3, false), A4.send(null), !(A4.status >= 200 && A4.status < 300 || 304 === A4.status))
        throw new Error("Couldn't load " + g3 + ". Status: " + A4.status);
      var I4, Q4 = Number(A4.getResponseHeader("Content-length")), B3 = (I4 = A4.getResponseHeader("Accept-Ranges")) && "bytes" === I4, C4 = (I4 = A4.getResponseHeader("Content-Encoding")) && "gzip" === I4, E4 = 1048576;
      B3 || (E4 = Q4);
      var D4 = this;
      D4.setDataGetter((A5) => {
        var I5 = A5 * E4, B4 = (A5 + 1) * E4 - 1;
        if (B4 = Math.min(B4, Q4 - 1), void 0 === D4.chunks[A5] && (D4.chunks[A5] = ((A6, I6) => {
          if (A6 > I6)
            throw new Error("invalid range (" + A6 + ", " + I6 + ") or no bytes requested!");
          if (I6 > Q4 - 1)
            throw new Error("only " + Q4 + " bytes available! programmer error!");
          var B5 = new XMLHttpRequest();
          if (B5.open("GET", g3, false), Q4 !== E4 && B5.setRequestHeader("Range", "bytes=" + A6 + "-" + I6), B5.responseType = "arraybuffer", B5.overrideMimeType && B5.overrideMimeType("text/plain; charset=x-user-defined"), B5.send(null), !(B5.status >= 200 && B5.status < 300 || 304 === B5.status))
            throw new Error("Couldn't load " + g3 + ". Status: " + B5.status);
          return void 0 !== B5.response ? new Uint8Array(B5.response || []) : c(B5.responseText || "", true);
        })(I5, B4)), void 0 === D4.chunks[A5])
          throw new Error("doXHR failed!");
        return D4.chunks[A5];
      }), !C4 && Q4 || (E4 = Q4 = 1, Q4 = this.getter(0).length, E4 = Q4, R("LazyFiles on gzip forces download of the whole file when length is accessed")), this._length = Q4, this._chunkSize = E4, this.lengthKnown = true;
    }, "undefined" != typeof XMLHttpRequest) {
      if (!ENVIRONMENT_IS_WORKER)
        throw "Cannot do synchronous binary XHRs outside webworkers in modern browsers. Use --embed-file or --preload-file in emcc";
      var D3 = new E3();
      Object.defineProperties(D3, { length: { get: function() {
        return this.lengthKnown || this.cacheLength(), this._length;
      } }, chunkSize: { get: function() {
        return this.lengthKnown || this.cacheLength(), this._chunkSize;
      } } });
      var w3 = { isDevice: false, contents: D3 };
    } else
      w3 = { isDevice: false, url: g3 };
    var i3 = r.createFile(A3, I3, w3, Q3, C3);
    w3.contents ? i3.contents = w3.contents : w3.url && (i3.contents = null, i3.url = w3.url), Object.defineProperties(i3, { usedBytes: { get: function() {
      return this.contents.length;
    } } });
    var o3 = {};
    function G3(A4, I4, g4, Q4, B3) {
      var C4 = A4.node.contents;
      if (B3 >= C4.length)
        return 0;
      var E4 = Math.min(C4.length - B3, Q4);
      if (C4.slice)
        for (var D4 = 0; D4 < E4; D4++)
          I4[g4 + D4] = C4[B3 + D4];
      else
        for (D4 = 0; D4 < E4; D4++)
          I4[g4 + D4] = C4.get(B3 + D4);
      return E4;
    }
    return Object.keys(i3.stream_ops).forEach((A4) => {
      var I4 = i3.stream_ops[A4];
      o3[A4] = function() {
        return r.forceLoadFile(i3), I4.apply(null, arguments);
      };
    }), o3.read = (A4, I4, g4, Q4, B3) => (r.forceLoadFile(i3), G3(A4, I4, g4, Q4, B3)), o3.mmap = (A4, I4, g4, Q4, C4) => {
      r.forceLoadFile(i3);
      var E4 = H(I4);
      if (!E4)
        throw new r.ErrnoError(48);
      return G3(A4, B2, E4, I4, g4), { ptr: E4, allocated: true };
    }, i3.stream_ops = o3, i3;
  } }, d = { DEFAULT_POLLMASK: 5, calculateAt(A3, I3, g3) {
    if (k.isAbs(I3))
      return I3;
    var Q3;
    -100 === A3 ? Q3 = r.cwd() : Q3 = d.getStreamFromFD(A3).path;
    if (0 == I3.length) {
      if (!g3)
        throw new r.ErrnoError(44);
      return Q3;
    }
    return k.join2(Q3, I3);
  }, doStat(A3, I3, g3) {
    try {
      var Q3 = A3(I3);
    } catch (A4) {
      if (A4 && A4.node && k.normalize(I3) !== k.normalize(r.getPath(A4.node)))
        return -54;
      throw A4;
    }
    E2[g3 >> 2] = Q3.dev, E2[g3 + 4 >> 2] = Q3.mode, w2[g3 + 8 >> 2] = Q3.nlink, E2[g3 + 12 >> 2] = Q3.uid, E2[g3 + 16 >> 2] = Q3.gid, E2[g3 + 20 >> 2] = Q3.rdev, G2[g3 + 24 >> 3] = BigInt(Q3.size), E2[g3 + 32 >> 2] = 4096, E2[g3 + 36 >> 2] = Q3.blocks;
    var B3 = Q3.atime.getTime(), C3 = Q3.mtime.getTime(), D3 = Q3.ctime.getTime();
    return G2[g3 + 40 >> 3] = BigInt(Math.floor(B3 / 1e3)), w2[g3 + 48 >> 2] = B3 % 1e3 * 1e3, G2[g3 + 56 >> 3] = BigInt(Math.floor(C3 / 1e3)), w2[g3 + 64 >> 2] = C3 % 1e3 * 1e3, G2[g3 + 72 >> 3] = BigInt(Math.floor(D3 / 1e3)), w2[g3 + 80 >> 2] = D3 % 1e3 * 1e3, G2[g3 + 88 >> 3] = BigInt(Q3.ino), 0;
  }, doMsync(A3, I3, g3, Q3, B3) {
    if (!r.isFile(I3.node.mode))
      throw new r.ErrnoError(43);
    if (2 & Q3)
      return 0;
    var C3 = D2.slice(A3, A3 + g3);
    r.msync(I3, C3, B3, g3, Q3);
  }, varargs: void 0, get() {
    var A3 = E2[+d.varargs >> 2];
    return d.varargs += 4, A3;
  }, getp: () => d.get(), getStr: (A3) => s(A3), getStreamFromFD: (A3) => r.getStreamChecked(A3) };
  var t = (A3) => A3 < -9007199254740992 || A3 > 9007199254740992 ? NaN : Number(A3);
  var W = (A3) => {
    var I3 = (A3 - M2.buffer.byteLength + 65535) / 65536;
    try {
      return M2.grow(I3), y(), 1;
    } catch (A4) {
    }
  }, b = {}, l = () => {
    if (!l.strings) {
      var A3 = { USER: "web_user", LOGNAME: "web_user", PATH: "/", PWD: "/", HOME: "/home/web_user", LANG: ("object" == typeof navigator && navigator.languages && navigator.languages[0] || "C").replace("-", "_") + ".UTF-8", _: "./this.program" };
      for (var I3 in b)
        void 0 === b[I3] ? delete A3[I3] : A3[I3] = b[I3];
      var g3 = [];
      for (var I3 in A3)
        g3.push(`${I3}=${A3[I3]}`);
      l.strings = g3;
    }
    return l.strings;
  }, x = (A3) => {
    throw `exit(${A3})`;
  };
  var m = (A3) => A3 % 4 == 0 && (A3 % 100 != 0 || A3 % 400 == 0), n = [31, 29, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31], O = [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31], V = (A3, I3) => {
    B2.set(A3, I3);
  }, f = (A3, I3, g3, Q3) => {
    var B3 = w2[Q3 + 40 >> 2], C3 = { tm_sec: E2[Q3 >> 2], tm_min: E2[Q3 + 4 >> 2], tm_hour: E2[Q3 + 8 >> 2], tm_mday: E2[Q3 + 12 >> 2], tm_mon: E2[Q3 + 16 >> 2], tm_year: E2[Q3 + 20 >> 2], tm_wday: E2[Q3 + 24 >> 2], tm_yday: E2[Q3 + 28 >> 2], tm_isdst: E2[Q3 + 32 >> 2], tm_gmtoff: E2[Q3 + 36 >> 2], tm_zone: B3 ? s(B3) : "" }, D3 = s(g3), i3 = { "%c": "%a %b %d %H:%M:%S %Y", "%D": "%m/%d/%y", "%F": "%Y-%m-%d", "%h": "%b", "%r": "%I:%M:%S %p", "%R": "%H:%M", "%T": "%H:%M:%S", "%x": "%m/%d/%y", "%X": "%H:%M:%S", "%Ec": "%c", "%EC": "%C", "%Ex": "%m/%d/%y", "%EX": "%H:%M:%S", "%Ey": "%y", "%EY": "%Y", "%Od": "%d", "%Oe": "%e", "%OH": "%H", "%OI": "%I", "%Om": "%m", "%OM": "%M", "%OS": "%S", "%Ou": "%u", "%OU": "%U", "%OV": "%V", "%Ow": "%w", "%OW": "%W", "%Oy": "%y" };
    for (var o3 in i3)
      D3 = D3.replace(new RegExp(o3, "g"), i3[o3]);
    var G3 = ["Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday"], M3 = ["January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December"];
    function R2(A4, I4, g4) {
      for (var Q4 = "number" == typeof A4 ? A4.toString() : A4 || ""; Q4.length < I4; )
        Q4 = g4[0] + Q4;
      return Q4;
    }
    function F2(A4, I4) {
      return R2(A4, I4, "0");
    }
    function y2(A4, I4) {
      function g4(A5) {
        return A5 < 0 ? -1 : A5 > 0 ? 1 : 0;
      }
      var Q4;
      return 0 === (Q4 = g4(A4.getFullYear() - I4.getFullYear())) && 0 === (Q4 = g4(A4.getMonth() - I4.getMonth())) && (Q4 = g4(A4.getDate() - I4.getDate())), Q4;
    }
    function K3(A4) {
      switch (A4.getDay()) {
        case 0:
          return new Date(A4.getFullYear() - 1, 11, 29);
        case 1:
          return A4;
        case 2:
          return new Date(A4.getFullYear(), 0, 3);
        case 3:
          return new Date(A4.getFullYear(), 0, 2);
        case 4:
          return new Date(A4.getFullYear(), 0, 1);
        case 5:
          return new Date(A4.getFullYear() - 1, 11, 31);
        case 6:
          return new Date(A4.getFullYear() - 1, 11, 30);
      }
    }
    function h2(A4) {
      var I4 = ((A5, I5) => {
        for (var g5 = new Date(A5.getTime()); I5 > 0; ) {
          var Q5 = m(g5.getFullYear()), B5 = g5.getMonth(), C5 = (Q5 ? n : O)[B5];
          if (!(I5 > C5 - g5.getDate()))
            return g5.setDate(g5.getDate() + I5), g5;
          I5 -= C5 - g5.getDate() + 1, g5.setDate(1), B5 < 11 ? g5.setMonth(B5 + 1) : (g5.setMonth(0), g5.setFullYear(g5.getFullYear() + 1));
        }
        return g5;
      })(new Date(A4.tm_year + 1900, 0, 1), A4.tm_yday), g4 = new Date(I4.getFullYear(), 0, 4), Q4 = new Date(I4.getFullYear() + 1, 0, 4), B4 = K3(g4), C4 = K3(Q4);
      return y2(B4, I4) <= 0 ? y2(C4, I4) <= 0 ? I4.getFullYear() + 1 : I4.getFullYear() : I4.getFullYear() - 1;
    }
    var N2 = { "%a": (A4) => G3[A4.tm_wday].substring(0, 3), "%A": (A4) => G3[A4.tm_wday], "%b": (A4) => M3[A4.tm_mon].substring(0, 3), "%B": (A4) => M3[A4.tm_mon], "%C": (A4) => F2((A4.tm_year + 1900) / 100 | 0, 2), "%d": (A4) => F2(A4.tm_mday, 2), "%e": (A4) => R2(A4.tm_mday, 2, " "), "%g": (A4) => h2(A4).toString().substring(2), "%G": (A4) => h2(A4), "%H": (A4) => F2(A4.tm_hour, 2), "%I": (A4) => {
      var I4 = A4.tm_hour;
      return 0 == I4 ? I4 = 12 : I4 > 12 && (I4 -= 12), F2(I4, 2);
    }, "%j": (A4) => F2(A4.tm_mday + ((A5, I4) => {
      for (var g4 = 0, Q4 = 0; Q4 <= I4; g4 += A5[Q4++])
        ;
      return g4;
    })(m(A4.tm_year + 1900) ? n : O, A4.tm_mon - 1), 3), "%m": (A4) => F2(A4.tm_mon + 1, 2), "%M": (A4) => F2(A4.tm_min, 2), "%n": () => "\n", "%p": (A4) => A4.tm_hour >= 0 && A4.tm_hour < 12 ? "AM" : "PM", "%S": (A4) => F2(A4.tm_sec, 2), "%t": () => "	", "%u": (A4) => A4.tm_wday || 7, "%U": (A4) => {
      var I4 = A4.tm_yday + 7 - A4.tm_wday;
      return F2(Math.floor(I4 / 7), 2);
    }, "%V": (A4) => {
      var I4 = Math.floor((A4.tm_yday + 7 - (A4.tm_wday + 6) % 7) / 7);
      if ((A4.tm_wday + 371 - A4.tm_yday - 2) % 7 <= 2 && I4++, I4) {
        if (53 == I4) {
          var g4 = (A4.tm_wday + 371 - A4.tm_yday) % 7;
          4 == g4 || 3 == g4 && m(A4.tm_year) || (I4 = 1);
        }
      } else {
        I4 = 52;
        var Q4 = (A4.tm_wday + 7 - A4.tm_yday - 1) % 7;
        (4 == Q4 || 5 == Q4 && m(A4.tm_year % 400 - 1)) && I4++;
      }
      return F2(I4, 2);
    }, "%w": (A4) => A4.tm_wday, "%W": (A4) => {
      var I4 = A4.tm_yday + 7 - (A4.tm_wday + 6) % 7;
      return F2(Math.floor(I4 / 7), 2);
    }, "%y": (A4) => (A4.tm_year + 1900).toString().substring(2), "%Y": (A4) => A4.tm_year + 1900, "%z": (A4) => {
      var I4 = A4.tm_gmtoff, g4 = I4 >= 0;
      return I4 = (I4 = Math.abs(I4) / 60) / 60 * 100 + I4 % 60, (g4 ? "+" : "-") + String("0000" + I4).slice(-4);
    }, "%Z": (A4) => A4.tm_zone, "%%": () => "%" };
    for (var o3 in D3 = D3.replace(/%%/g, "\0\0"), N2)
      D3.includes(o3) && (D3 = D3.replace(new RegExp(o3, "g"), N2[o3](C3)));
    var k2 = c(D3 = D3.replace(/\0\0/g, "%"), false);
    return k2.length > I3 ? 0 : (V(k2, A3), k2.length - 1);
  }, P = (A3, I3, g3) => J(A3, D2, I3, g3);
  var e = function(A3, I3, g3, Q3) {
    A3 || (A3 = this), this.parent = A3, this.mount = A3.mount, this.mounted = null, this.id = r.nextInode++, this.name = I3, this.mode = g3, this.node_ops = {}, this.stream_ops = {}, this.rdev = Q3;
  }, v = 365, z = 146;
  Object.defineProperties(e.prototype, { read: { get: function() {
    return (this.mode & v) === v;
  }, set: function(A3) {
    A3 ? this.mode |= v : this.mode &= -366;
  } }, write: { get: function() {
    return (this.mode & z) === z;
  }, set: function(A3) {
    A3 ? this.mode |= z : this.mode &= -147;
  } }, isFolder: { get: function() {
    return r.isDir(this.mode);
  } }, isDevice: { get: function() {
    return r.isChrdev(this.mode);
  } } }), r.FSNode = e, r.createPreloadedFile = (A3, I3, g3, Q3, B3, C3, E3, D3, w3, i3) => {
    var o3 = I3 ? U.resolve(k.join2(A3, I3)) : A3, G3 = getUniqueRunDependency(`cp ${o3}`);
    function M3(g4) {
      !function(g5) {
        i3?.(), D3 || ((A4, I4, g6, Q4, B4, C4) => {
          r.createDataFile(A4, I4, g6, Q4, B4, C4);
        })(A3, I3, g5, Q3, B3, w3), C3?.(), removeRunDependency(G3);
      }(g4);
    }
    addRunDependency(G3), "string" == typeof g3 ? ((A4, I4, g4, Q4) => {
      var B4 = Q4 ? "" : getUniqueRunDependency(`al ${A4}`);
      readAsync(A4, (g5) => {
        assert(g5, `Loading data file "${A4}" failed (no arrayBuffer).`), I4(new Uint8Array(g5)), B4 && removeRunDependency(B4);
      }, (I5) => {
        if (!g4)
          throw `Loading data file "${A4}" failed.`;
        g4();
      }), B4 && addRunDependency(B4);
    })(g3, (A4) => M3(A4), E3) : M3(g3);
  }, r.staticInit();
  var p = { a: (A3, I3, g3, Q3) => {
    F(`Assertion failed: ${s(A3)}, at: ` + [I3 ? s(I3) : "unknown filename", g3, Q3 ? s(Q3) : "unknown function"]);
  }, c: (A3, I3, g3) => {
    throw new N(A3).init(I3, g3), A3;
  }, l: function(A3, I3, g3, Q3) {
    try {
      if (I3 = d.getStr(I3), I3 = d.calculateAt(A3, I3), -8 & g3)
        return -28;
      var B3 = r.lookupPath(I3, { follow: true }).node;
      if (!B3)
        return -44;
      var C3 = "";
      return 4 & g3 && (C3 += "r"), 2 & g3 && (C3 += "w"), 1 & g3 && (C3 += "x"), C3 && r.nodePermissions(B3, C3) ? -2 : 0;
    } catch (A4) {
      if (void 0 === r || "ErrnoError" !== A4.name)
        throw A4;
      return -A4.errno;
    }
  }, j: function(A3, I3, g3) {
    d.varargs = g3;
    try {
      var Q3 = d.getStreamFromFD(A3);
      switch (I3) {
        case 0:
          if ((B3 = d.get()) < 0)
            return -28;
          for (; r.streams[B3]; )
            B3++;
          return r.createStream(Q3, B3).fd;
        case 1:
        case 2:
        case 6:
        case 7:
          return 0;
        case 3:
          return Q3.flags;
        case 4:
          var B3 = d.get();
          return Q3.flags |= B3, 0;
        case 5:
          B3 = d.getp();
          return C2[B3 + 0 >> 1] = 2, 0;
        case 16:
        case 8:
        default:
          return -28;
        case 9:
          return -1;
      }
    } catch (A4) {
      if (void 0 === r || "ErrnoError" !== A4.name)
        throw A4;
      return -A4.errno;
    }
  }, w: function(A3, I3) {
    try {
      var g3 = d.getStreamFromFD(A3);
      return d.doStat(r.stat, g3.path, I3);
    } catch (A4) {
      if (void 0 === r || "ErrnoError" !== A4.name)
        throw A4;
      return -A4.errno;
    }
  }, x: function(A3, I3, g3) {
    d.varargs = g3;
    try {
      var Q3 = d.getStreamFromFD(A3);
      switch (I3) {
        case 21509:
        case 21510:
        case 21511:
        case 21512:
        case 21524:
        case 21515:
          return Q3.tty ? 0 : -59;
        case 21505:
          if (!Q3.tty)
            return -59;
          if (Q3.tty.ops.ioctl_tcgets) {
            var D3 = Q3.tty.ops.ioctl_tcgets(Q3), w3 = d.getp();
            E2[w3 >> 2] = D3.c_iflag || 0, E2[w3 + 4 >> 2] = D3.c_oflag || 0, E2[w3 + 8 >> 2] = D3.c_cflag || 0, E2[w3 + 12 >> 2] = D3.c_lflag || 0;
            for (var i3 = 0; i3 < 32; i3++)
              B2[w3 + i3 + 17 >> 0] = D3.c_cc[i3] || 0;
            return 0;
          }
          return 0;
        case 21506:
        case 21507:
        case 21508:
          if (!Q3.tty)
            return -59;
          if (Q3.tty.ops.ioctl_tcsets) {
            w3 = d.getp();
            var o3 = E2[w3 >> 2], G3 = E2[w3 + 4 >> 2], M3 = E2[w3 + 8 >> 2], R2 = E2[w3 + 12 >> 2], F2 = [];
            for (i3 = 0; i3 < 32; i3++)
              F2.push(B2[w3 + i3 + 17 >> 0]);
            return Q3.tty.ops.ioctl_tcsets(Q3.tty, I3, { c_iflag: o3, c_oflag: G3, c_cflag: M3, c_lflag: R2, c_cc: F2 });
          }
          return 0;
        case 21519:
          if (!Q3.tty)
            return -59;
          w3 = d.getp();
          return E2[w3 >> 2] = 0, 0;
        case 21520:
          return Q3.tty ? -28 : -59;
        case 21531:
          w3 = d.getp();
          return r.ioctl(Q3, I3, w3);
        case 21523:
          if (!Q3.tty)
            return -59;
          if (Q3.tty.ops.ioctl_tiocgwinsz) {
            var y2 = Q3.tty.ops.ioctl_tiocgwinsz(Q3.tty);
            w3 = d.getp();
            C2[w3 >> 1] = y2[0], C2[w3 + 2 >> 1] = y2[1];
          }
          return 0;
        default:
          return -28;
      }
    } catch (A4) {
      if (void 0 === r || "ErrnoError" !== A4.name)
        throw A4;
      return -A4.errno;
    }
  }, u: function(A3, I3, g3, Q3) {
    try {
      I3 = d.getStr(I3);
      var B3 = 256 & Q3, C3 = 4096 & Q3;
      return Q3 &= -6401, I3 = d.calculateAt(A3, I3, C3), d.doStat(B3 ? r.lstat : r.stat, I3, g3);
    } catch (A4) {
      if (void 0 === r || "ErrnoError" !== A4.name)
        throw A4;
      return -A4.errno;
    }
  }, e: function(A3, I3, g3, Q3) {
    d.varargs = Q3;
    try {
      I3 = d.getStr(I3), I3 = d.calculateAt(A3, I3);
      var B3 = Q3 ? d.get() : 0;
      return r.open(I3, g3, B3).fd;
    } catch (A4) {
      if (void 0 === r || "ErrnoError" !== A4.name)
        throw A4;
      return -A4.errno;
    }
  }, v: function(A3, I3) {
    try {
      return A3 = d.getStr(A3), d.doStat(r.stat, A3, I3);
    } catch (A4) {
      if (void 0 === r || "ErrnoError" !== A4.name)
        throw A4;
      return -A4.errno;
    }
  }, o: function(A3, I3, g3) {
    try {
      return I3 = d.getStr(I3), I3 = d.calculateAt(A3, I3), 0 === g3 ? r.unlink(I3) : 512 === g3 ? r.rmdir(I3) : F("Invalid flags passed to unlinkat"), 0;
    } catch (A4) {
      if (void 0 === r || "ErrnoError" !== A4.name)
        throw A4;
      return -A4.errno;
    }
  }, k: () => 1, p: function(A3, I3, g3, Q3, B3, C3, D3) {
    B3 = t(B3);
    try {
      if (isNaN(B3))
        return 61;
      var i3 = d.getStreamFromFD(Q3), o3 = r.mmap(i3, A3, B3, I3, g3), G3 = o3.ptr;
      return E2[C3 >> 2] = o3.allocated, w2[D3 >> 2] = G3, 0;
    } catch (A4) {
      if (void 0 === r || "ErrnoError" !== A4.name)
        throw A4;
      return -A4.errno;
    }
  }, q: function(A3, I3, g3, Q3, B3, C3) {
    C3 = t(C3);
    try {
      if (isNaN(C3))
        return 61;
      var E3 = d.getStreamFromFD(B3);
      2 & g3 && d.doMsync(A3, E3, I3, Q3, C3), r.munmap(E3);
    } catch (A4) {
      if (void 0 === r || "ErrnoError" !== A4.name)
        throw A4;
      return -A4.errno;
    }
  }, b: () => {
    F("");
  }, f: () => Date.now(), n: (A3) => {
    var I3 = D2.length, g3 = 2147483648;
    if ((A3 >>>= 0) > g3)
      return false;
    for (var Q3, B3, C3 = 1; C3 <= 4; C3 *= 2) {
      var E3 = I3 * (1 + 0.2 / C3);
      E3 = Math.min(E3, A3 + 100663296);
      var w3 = Math.min(g3, (Q3 = Math.max(A3, E3)) + ((B3 = 65536) - Q3 % B3) % B3);
      if (W(w3))
        return true;
    }
    return false;
  }, s: (A3, I3) => {
    var g3 = 0;
    return l().forEach((Q3, C3) => {
      var E3 = I3 + g3;
      w2[A3 + 4 * C3 >> 2] = E3, ((A4, I4) => {
        for (var g4 = 0; g4 < A4.length; ++g4)
          B2[I4++ >> 0] = A4.charCodeAt(g4);
        B2[I4 >> 0] = 0;
      })(Q3, E3), g3 += Q3.length + 1;
    }), 0;
  }, t: (A3, I3) => {
    var g3 = l();
    w2[A3 >> 2] = g3.length;
    var Q3 = 0;
    return g3.forEach((A4) => Q3 += A4.length + 1), w2[I3 >> 2] = Q3, 0;
  }, g: x, d: function(A3) {
    try {
      var I3 = d.getStreamFromFD(A3);
      return r.close(I3), 0;
    } catch (A4) {
      if (void 0 === r || "ErrnoError" !== A4.name)
        throw A4;
      return A4.errno;
    }
  }, h: function(A3, I3, g3, Q3) {
    try {
      var C3 = ((A4, I4, g4, Q4) => {
        for (var C4 = 0, E3 = 0; E3 < g4; E3++) {
          var D3 = w2[I4 >> 2], i3 = w2[I4 + 4 >> 2];
          I4 += 8;
          var o3 = r.read(A4, B2, D3, i3, Q4);
          if (o3 < 0)
            return -1;
          if (C4 += o3, o3 < i3)
            break;
          void 0 !== Q4 && (Q4 += o3);
        }
        return C4;
      })(d.getStreamFromFD(A3), I3, g3);
      return w2[Q3 >> 2] = C3, 0;
    } catch (A4) {
      if (void 0 === r || "ErrnoError" !== A4.name)
        throw A4;
      return A4.errno;
    }
  }, r: function(A3, I3, g3, Q3) {
    I3 = t(I3);
    try {
      if (isNaN(I3))
        return 61;
      var B3 = d.getStreamFromFD(A3);
      return r.llseek(B3, I3, g3), G2[Q3 >> 3] = BigInt(B3.position), B3.getdents && 0 === I3 && 0 === g3 && (B3.getdents = null), 0;
    } catch (A4) {
      if (void 0 === r || "ErrnoError" !== A4.name)
        throw A4;
      return A4.errno;
    }
  }, i: function(A3, I3, g3, Q3) {
    try {
      var C3 = ((A4, I4, g4, Q4) => {
        for (var C4 = 0, E3 = 0; E3 < g4; E3++) {
          var D3 = w2[I4 >> 2], i3 = w2[I4 + 4 >> 2];
          I4 += 8;
          var o3 = r.write(A4, B2, D3, i3, Q4);
          if (o3 < 0)
            return -1;
          C4 += o3, void 0 !== Q4 && (Q4 += o3);
        }
        return C4;
      })(d.getStreamFromFD(A3), I3, g3);
      return w2[Q3 >> 2] = C3, 0;
    } catch (A4) {
      if (void 0 === r || "ErrnoError" !== A4.name)
        throw A4;
      return A4.errno;
    }
  }, m: (A3, I3, g3, Q3, B3) => f(A3, I3, g3, Q3), y: function(A3) {
    return g2.agerrMessages.push(s(A3)), 0;
  } };
  g2.ccall = (A3, I3, Q3, B3, C3) => {
    var E3 = { string: (A4) => {
      var I4 = 0;
      return null != A4 && 0 !== A4 && (I4 = ((A5) => {
        var I5 = Y(A5) + 1, g3 = u(I5);
        return P(A5, g3, I5), g3;
      })(A4)), I4;
    }, array: (A4) => {
      var I4 = u(A4.length);
      return V(A4, I4), I4;
    } };
    var D3 = ((A4) => g2["_" + A4])(A3), w3 = [], i3 = 0;
    if (B3)
      for (var o3 = 0; o3 < B3.length; o3++) {
        var G3 = E3[Q3[o3]];
        G3 ? (0 === i3 && (i3 = j()), w3[o3] = G3(B3[o3])) : w3[o3] = B3[o3];
      }
    var M3 = D3.apply(null, w3);
    return M3 = function(A4) {
      return 0 !== i3 && X(i3), function(A5) {
        return "string" === I3 ? s(A5) : "boolean" === I3 ? Boolean(A5) : A5;
      }(A4);
    }(M3);
  }, g2.getValue = function(A3) {
    let I3 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : "i8";
    switch (I3.endsWith("*") && (I3 = "*"), I3) {
      case "i1":
      case "i8":
        return B2[A3 >> 0];
      case "i16":
        return C2[A3 >> 1];
      case "i32":
        return E2[A3 >> 2];
      case "i64":
        return G2[A3 >> 3];
      case "float":
        return i2[A3 >> 2];
      case "double":
        return o2[A3 >> 3];
      case "*":
        return w2[A3 >> 2];
      default:
        F(`invalid type for getValue: ${I3}`);
    }
  }, g2.PATH = k, g2.UTF8ToString = s, g2.stringToUTF8 = P, g2.lengthBytesUTF8 = Y, g2.FS = r;
  var T, j, X, u, _, $ = { a: p };
  return WebAssembly.instantiate(g2.wasm, $).then((A3) => {
    var Q3 = A3.instance.exports;
    g2._viz_set_y_invert = Q3.B, g2._viz_set_reduce = Q3.C, g2._viz_get_graphviz_version = Q3.D, g2._viz_get_plugin_list = Q3.E, g2._viz_create_graph = Q3.F, g2._viz_read_one_graph = Q3.G, g2._viz_string_dup = Q3.H, g2._viz_string_dup_html = Q3.I, g2._viz_string_free = Q3.J, g2._viz_add_node = Q3.K, g2._viz_add_edge = Q3.L, g2._viz_add_subgraph = Q3.M, g2._viz_set_default_graph_attribute = Q3.N, g2._viz_set_default_node_attribute = Q3.O, g2._viz_set_default_edge_attribute = Q3.P, g2._viz_set_attribute = Q3.Q, g2._viz_free_graph = Q3.R, g2._viz_render_graph = Q3.S, g2._free = Q3.U, g2._malloc = Q3.V, T = Q3.W, j = Q3.X, X = Q3.Y, u = Q3.Z, _ = Q3._, M2 = Q3.z, y(), function(A4) {
      A4.A(), g2.noFSInit || r.init.initialized || r.init(), r.ignorePermissions = false;
    }(Q3), I2(g2);
  }), A2.ready;
};
var I = [[/^Error: (.*)/, "error"], [/^Warning: (.*)/, "warning"]];
function g(A2) {
  return function(A3) {
    const I2 = [];
    let g2;
    for (let Q2 = 0; Q2 < A3.length; Q2++)
      "Error" == A3[Q2] && ": " == A3[Q2 + 1] ? (g2 = "error", Q2 += 1) : "Warning" == A3[Q2] && ": " == A3[Q2 + 1] ? (g2 = "warning", Q2 += 1) : I2.push({ message: A3[Q2].trimEnd(), level: g2 });
    return I2;
  }(A2.agerrMessages).concat(A2.stderrMessages.map((A3) => {
    for (let g2 = 0; g2 < I.length; g2++) {
      const [Q2, B2] = I[g2];
      let C2;
      if (null !== (C2 = Q2.exec(A3)))
        return { message: C2[1].trimEnd(), level: B2 };
    }
    return { message: A3.trimEnd() };
  }));
}
function Q(A2, I2, g2, Q2) {
  let B2;
  if (B2 = "object" == typeof g2 && "html" in g2 ? A2.ccall("viz_string_dup_html", "number", ["number", "string"], [I2, String(g2.html)]) : A2.ccall("viz_string_dup", "number", ["number", "string"], [I2, String(g2)]), 0 == B2)
    throw new Error("couldn't dup string");
  Q2(B2), A2.ccall("viz_string_free", "number", ["number", "number"], [I2, B2]);
}
function B(A2, I2, g2) {
  if (g2.graphAttributes)
    for (const [B2, C2] of Object.entries(g2.graphAttributes))
      Q(A2, I2, C2, (g3) => {
        A2.ccall("viz_set_default_graph_attribute", "number", ["number", "string", "number"], [I2, B2, g3]);
      });
  if (g2.nodeAttributes)
    for (const [B2, C2] of Object.entries(g2.nodeAttributes))
      Q(A2, I2, C2, (g3) => {
        A2.ccall("viz_set_default_node_attribute", "number", ["number", "string", "number"], [I2, B2, g3]);
      });
  if (g2.edgeAttributes)
    for (const [B2, C2] of Object.entries(g2.edgeAttributes))
      Q(A2, I2, C2, (g3) => {
        A2.ccall("viz_set_default_edge_attribute", "number", ["number", "string", "number"], [I2, B2, g3]);
      });
}
function C(A2, I2, g2, B2) {
  for (const [C2, E2] of Object.entries(B2))
    Q(A2, I2, E2, (I3) => {
      A2.ccall("viz_set_attribute", "number", ["number", "string", "number"], [g2, C2, I3]);
    });
}
function E(A2, I2, g2) {
  B(A2, I2, g2), g2.nodes && g2.nodes.forEach((g3) => {
    const Q2 = A2.ccall("viz_add_node", "number", ["number", "string"], [I2, String(g3.name)]);
    g3.attributes && C(A2, I2, Q2, g3.attributes);
  }), g2.edges && g2.edges.forEach((g3) => {
    const Q2 = A2.ccall("viz_add_edge", "number", ["number", "string", "string"], [I2, String(g3.tail), String(g3.head)]);
    g3.attributes && C(A2, I2, Q2, g3.attributes);
  }), g2.subgraphs && g2.subgraphs.forEach((g3) => {
    const Q2 = A2.ccall("viz_add_subgraph", "number", ["number", "string"], [I2, String(g3.name)]);
    E(A2, Q2, g3);
  });
}
function D(A2, I2, g2) {
  const Q2 = A2.ccall("viz_create_graph", "number", ["string", "number", "number"], [I2.name, void 0 === I2.directed || I2.directed, void 0 !== I2.strict && I2.strict]);
  return E(A2, Q2, I2), Q2;
}
function w(A2, I2, Q2) {
  let C2, E2, w2;
  try {
    if (A2.agerrMessages = [], A2.stderrMessages = [], w2 = function(A3, I3) {
      return I3 ? I3.map((I4) => {
        if ("string" != typeof I4.name)
          throw new Error("image name must be a string");
        if ("number" != typeof I4.width && "string" != typeof I4.width)
          throw new Error("image width must be a number or string");
        if ("number" != typeof I4.height && "string" != typeof I4.height)
          throw new Error("image height must be a number or string");
        const g2 = A3.PATH.join("/", I4.name), Q3 = `<?xml version="1.0" encoding="UTF-8"?>
<svg xmlns="http://www.w3.org/2000/svg" width="${I4.width}" height="${I4.height}"></svg>
`;
        return A3.FS.createPath("/", A3.PATH.dirname(g2)), A3.FS.writeFile(g2, Q3), g2;
      }) : [];
    }(A2, Q2.images), "string" == typeof I2)
      C2 = function(A3, I3, g2) {
        let Q3;
        try {
          const g3 = A3.lengthBytesUTF8(I3);
          return Q3 = A3.ccall("malloc", "number", ["number"], [g3 + 1]), A3.stringToUTF8(I3, Q3, g3 + 1), A3.ccall("viz_read_one_graph", "number", ["number"], [Q3]);
        } finally {
          Q3 && A3.ccall("free", "number", ["number"], [Q3]);
        }
      }(A2, I2);
    else {
      if ("object" != typeof I2)
        throw new Error("input must be a string or object");
      C2 = D(A2, I2);
    }
    return 0 === C2 ? { status: "failure", output: void 0, errors: g(A2) } : (B(A2, C2, Q2), A2.ccall("viz_set_y_invert", "number", ["number"], [Q2.yInvert ? 1 : 0]), A2.ccall("viz_set_reduce", "number", ["number"], [Q2.reduce ? 1 : 0]), E2 = A2.ccall("viz_render_graph", "number", ["number", "string", "string"], [C2, Q2.format, Q2.engine]), 0 === E2 ? { status: "failure", output: void 0, errors: g(A2) } : { status: "success", output: A2.UTF8ToString(E2), errors: g(A2) });
  } catch (I3) {
    if (/^exit\(\d+\)/.test(I3))
      return { status: "failure", output: void 0, errors: g(A2) };
    throw I3;
  } finally {
    C2 && A2.ccall("viz_free_graph", "number", ["number"], [C2]), E2 && A2.ccall("free", "number", ["number"], [E2]), w2 && function(A3, I3) {
      for (const g2 of I3)
        A3.FS.analyzePath(g2).exists && A3.FS.unlink(g2);
    }(A2, w2);
  }
}
function i(A2, I2) {
  const g2 = A2.ccall("viz_get_plugin_list", "number", ["string"], [I2]);
  if (0 == g2)
    throw new Error(`couldn't get plugin list: ${I2}`);
  const Q2 = [];
  let B2, C2 = g2;
  for (; B2 = A2.getValue(C2, "*"); )
    Q2.push(A2.UTF8ToString(B2)), A2.ccall("free", "number", ["number"], [B2]), C2 += 4;
  return A2.ccall("free", "number", ["number"], [g2]), Q2;
}
var o = class {
  constructor(A2) {
    this.module = A2;
  }
  get graphvizVersion() {
    return function(A2) {
      const I2 = A2.ccall("viz_get_graphviz_version", "number", [], []);
      return A2.UTF8ToString(I2);
    }(this.module);
  }
  get formats() {
    return i(this.module, "device");
  }
  get engines() {
    return i(this.module, "layout");
  }
  render(A2) {
    let I2 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {};
    return w(this.module, A2, { format: "dot", engine: "dot", ...I2 });
  }
  renderString(A2) {
    let I2 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {};
    const g2 = this.render(A2, I2);
    if ("success" !== g2.status)
      throw new Error(g2.errors.find((A3) => "error" == A3.level)?.message || "render failed");
    return g2.output;
  }
  renderSVGElement(A2) {
    let I2 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {};
    const g2 = this.renderString(A2, { ...I2, format: "svg" });
    return new DOMParser().parseFromString(g2, "image/svg+xml").documentElement;
  }
  renderJSON(A2) {
    let I2 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {};
    const g2 = this.renderString(A2, { ...I2, format: "json" });
    return JSON.parse(g2);
  }
};
var G = "AGFzbQEAAAABkQdzYAJ/fwF/YAF/AGABfwF/YAN/f38Bf2ACf38AYAN/f38AYAR/f39/AX9gBX9/f39/AX9gBH9/f38AYAV/f39/fwBgBn9/f39/fwF/YAAAYAZ/f39/f38AYAABf2AIf39/f39/f38Bf2AHf39/f39/fwF/YAd/f39/f39/AGACf38BfGABfAF8YAd/f39/fHx/AGADf39/AXxgAX8BfGAEfHx8fwF8YAJ8fAF8YAV/fn5+fgBgAn98AGADf398AGADf39+AX9gCX9/f39/f39/fwBgA398fABgBH9/fX0Bf2AKf39/f39/f39/fwF/YAN/fn8BfmADfHx8AXxgA39/fgBgAAF8YAR/f39/AXxgBH9/f38BfmAFf39/f34Bf2AEf35+fwBgBH9/f3wBf2ABfwF+YAJ9fQF9YAh/f39/f39/fwBgAn98AX9gBX9/f398AX9gC39/f39/f39/f39/AX9gBX9/fn9/AGAEf398fwF/YAR/f3x/AGACf34AYAN/f3wBf2ACfH8BfGADfHx/AXxgA399fwBgAn9+AX9gAnx/AX9gA398fwBgBn98fHx8fAF8YAV/f3x/fwF/YAx/f39/f39/f39/f38Bf2ACf38BfmAGf39/fH9/AGAKf3x/f39/f39/fwBgBn9/f39+fwF/YA9/f39/f39/f39/f39/f38AYAp/f39/f39/f39/AGAGf3x/f39/AX9gB39/f39/fn4Bf2AGf39/f35+AX9gB39/f39+f38Bf2AGf39/f39+AX9gBH9+f38Bf2AEf398fAF8YAV/f3x/fwBgCX9/f39/f39/fwF/YAV/f39/fABgBH9/fHwAYAZ/f398f38Bf2AEf39/fQBgAn99AX9gBH5+fn4Bf2AIf39/f3x8fH8AYAJ+fwF/YAF8AX9gBnx8fH9/fwBgBH9/f3wAYAZ/fX9/f38AYAR/f31/AGACfn4BfWACf30AYAR/f39+AX5gA3x/fwBgBH98fHwAYAJ+fgF8YAV/f398fwBgBn9/f3x8fwBgB398fHx8fHwAYAd/f398fH9/AGAEf3x/fwBgBH98f38Bf2AFf398fHwAYAV/f39/fwF8YAN8fHwBf2AHf39/f3x/fwF/YAV/f31/fwBgA39/fwF9YAN+fn4Bf2ADf35/AX9gAAF+YAF/AX1gA39+fgF/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IAJBgIDA/wdPBEAgACAAoSEADAELIAAgARDIBSECIAErAwghACABKwMAIQMCQAJAAkACQCACQQNxDgMAAQIDCyADIABBARClAyEADAMLIAMgABCmAyEADAILIAMgAEEBEKUDmiEADAELIAMgABCmA5ohAAsgAUEQaiQAIAALKAEBfyMAQRBrIgIkACACIAE6AA8gACACQQ9qQQEQygIaIAJBEGokAAsGACAAEBkLIAAgAARAIAAoAhQQGSAAKAIYEBkgACgCHBAZIAAQGQsL7wIBBn9B0KELLQAABEBBzKELKAIADwsjAEEgayICJAACQAJAA0AgAkEIaiIEIABBAnQiA2oCf0EBIAB0Qf////8HcSIFQQFyRQRAIAMoAgAMAQsgAEGz0gFBw+UEIAUbEL8HCyIDNgIAIANBf0YNASAAQQFqIgBBBkcNAAtBABCLDEUEQEGY2wYhASAEQZjbBkEYELwBRQ0CQbDbBiEBIARBsNsGQRgQvAFFDQJBACEAQaSgCy0AAEUEQANAIABBAnRB9J8LaiAAQcPlBBC/BzYCACAAQQFqIgBBBkcNAAtBpKALQQE6AABBjKALQfSfCygCADYCAAtB9J8LIQEgAkEIaiIAQfSfC0EYELwBRQ0CQYygCyEBIABBjKALQRgQvAFFDQJBGBA6IgFFDQELIAEgAikCCDcCACABIAIpAhg3AhAgASACKQIQNwIIDAELQQAhAQsgAkEgaiQAQdChC0EBOgAAQcyhCyABNgIAIAELxwoCBX8RfiMAQeAAayIFJAAgBEL///////8/gyEMIAIgBIVCgICAgICAgICAf4MhCiACQv///////z+DIg1CIIghDiAEQjCIp0H//wFxIQcCQAJAIAJCMIinQf//AXEiCUH//wFrQYKAfk8EQCAHQf//AWtBgYB+Sw0BCyABUCACQv///////////wCDIgtCgICAgICAwP//AFQgC0KAgICAgIDA//8AURtFBEAgAkKAgICAgIAghCEKDAILIANQIARC////////////AIMiAkKAgICAgIDA//8AVCACQoCAgICAgMD//wBRG0UEQCAEQoCAgICAgCCEIQogAyEBDAILIAEgC0KAgICAgIDA//8AhYRQBEAgAiADhFAEQEKAgICAgIDg//8AIQpCACEBDAMLIApCgICAgICAwP//AIQhCkIAIQEMAgsgAyACQoCAgICAgMD//wCFhFAEQCABIAuEIRlCACEBIBlQBEBCgICAgICA4P//ACEKDAMLIApCgICAgICAwP//AIQhCgwCCyABIAuEUARAQgAhAQwCCyACIAOEUARAQgAhAQwCCyALQv///////z9YBEAgBUHQAGogASANIAEgDSANUCIGG3kgBkEGdK18pyIGQQ9rEKoBQRAgBmshBiAFKQNYIg1CIIghDiAFKQNQIQELIAJC////////P1YNACAFQUBrIAMgDCADIAwgDFAiCBt5IAhBBnStfKciCEEPaxCqASAGIAhrQRBqIQYgBSkDSCEMIAUpA0AhAwsgA0IPhiILQoCA/v8PgyICIAFCIIgiBH4iECALQiCIIhMgAUL/////D4MiAX58Ig9CIIYiESABIAJ+fCILIBFUrSACIA1C/////w+DIg1+IhUgBCATfnwiESAMQg+GIhIgA0IxiIRC/////w+DIgMgAX58IhQgDyAQVK1CIIYgD0IgiIR8Ig8gAiAOQoCABIQiDH4iFiANIBN+fCIOIBJCIIhCgICAgAiEIgIgAX58IhAgAyAEfnwiEkIghnwiF3whASAHIAlqIAZqQf//AGshBgJAIAIgBH4iGCAMIBN+fCIEIBhUrSAEIAQgAyANfnwiBFatfCACIAx+fCAEIAQgESAVVK0gESAUVq18fCIEVq18IAMgDH4iAyACIA1+fCICIANUrUIghiACQiCIhHwgBCACQiCGfCICIARUrXwgAiACIBAgElatIA4gFlStIA4gEFatfHxCIIYgEkIgiIR8IgJWrXwgAiACIA8gFFStIA8gF1atfHwiAlatfCIEQoCAgICAgMAAg1BFBEAgBkEBaiEGDAELIAtCP4ghGiAEQgGGIAJCP4iEIQQgAkIBhiABQj+IhCECIAtCAYYhCyAaIAFCAYaEIQELIAZB//8BTgRAIApCgICAgICAwP//AIQhCkIAIQEMAQsCfiAGQQBMBEBBASAGayIHQf8ATQRAIAVBMGogCyABIAZB/wBqIgYQqgEgBUEgaiACIAQgBhCqASAFQRBqIAsgASAHEKADIAUgAiAEIAcQoAMgBSkDMCAFKQM4hEIAUq0gBSkDICAFKQMQhIQhCyAFKQMoIAUpAxiEIQEgBSkDACECIAUpAwgMAgtCACEBDAILIARC////////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AEMu5j+iIgMgAiAAIAGhoUTvOfr+Qi7mP6IgAEQ5bKgMYVwgvqKgIgKgIgAgACAAIAAgAKIiASABIAEgASABRNCkvnJpN2Y+okTxa9LFQb27vqCiRCzeJa9qVhE/oKJEk72+FmzBZr+gokQ+VVVVVVXFP6CioSIBoiABRAAAAAAAAADAoKMgACACIAAgA6GhIgCiIACgoaFEAAAAAAAA8D+gIgC9IhFCIIinIAlBFHRqIgpB//8/TARAIAAgCRDqAgwBCyARQv////8PgyAKrUIghoS/C6IhAwsgAw8LIANEnHUAiDzkN36iRJx1AIg85Dd+og8LIANEWfP4wh9upQGiRFnz+MIfbqUBogsLACAAIAFBABDHDQvRAQIBfgF/AkAgABAyIAEQMkcNAAJAAkACQCABKAIAQQNxDgIAAQILA0AgACABRiIDDQMgASgCRCIBDQALDAILAn8gACABKQMIIgIQ5wMiAUEBckUEQAJAIAAQMiIBIABGDQAgASACEOcDIgFFDQAgACABQQEQehogAQwCC0EAIAAoAkwiASgCCEEBIAIgASgCACgCCBEbAEUNARogACAAIAIgAEEBEPIHENMNIgEQ0g0gACABENENCyABC0EARw8LIAAgAUEAEMQCQQBHIQMLIAMLPwECfwNAIAAoAhAiAigC8AEiAUUgACABRnJFBEAgASIAKAIQKALwASIBRQ0BIAIgATYC8AEgASEADAELCyAAC14BAX8jAEEgayICJAAgAiAAKAIANgIIIAIgACgCBDYCDCACIAAoAgg2AhAgAEIANwIEIAIgACsDEDkDGCAAIAEQkgEgASACQQhqIgAQkgEgAEEEchC/ASACQSBqJAALoQEBAn8CQCAAECVFIAIgAWtBBUhyDQAgASACEKQFIAJBBGshBCAAEEEiAiAAECVqIQUCQANAAkAgAiwAACEAIAEgBE8NACAAQQBMIABB/wBOckUEQCABKAIAIAIsAABHDQMLIAFBBGohASACIAUgAmtBAUpqIQIMAQsLIABBAEwgAEH/AE5yDQEgAiwAACAEKAIAQQFrSw0BCyADQQQ2AgALC1cBAX8jAEEQayICJAAgABDFAQRAIAAgACgCACAAEOUCEK0FCyAAIAEoAgg2AgggACABKQIANwIAIAFBABDEASACQQA6AA8gASACQQ9qEMMBIAJBEGokAAtQAQF+AkAgA0HAAHEEQCABIANBQGqthiECQgAhAQwBCyADRQ0AIAIgA60iBIYgAUHAACADa62IhCECIAEgBIYhAQsgACABNwMAIAAgAjcDCAvJCQIEfwV+IwBB8ABrIgYkACAEQv///////////wCDIQkCQAJAIAFQIgUgAkL///////////8AgyIKQoCAgICAgMD//wB9QoCAgICAgMCAgH9UIApQG0UEQCADQgBSIAlCgICAgICAwP//AH0iC0KAgICAgIDAgIB/ViALQoCAgICAgMCAgH9RGw0BCyAFIApCgICAgICAwP//AFQgCkKAgICAgIDA//8AURtFBEAgAkKAgICAgIAghCEEIAEhAwwCCyADUCAJQoCAgICAgMD//wBUIAlCgICAgICAwP//AFEbRQRAIARCgICAgICAIIQhBAwCCyABIApCgICAgICAwP//AIWEUARAQoCAgICAgOD//wAgAiABIAOFIAIgBIVCgICAgICAgICAf4WEUCIFGyEEQgAgASAFGyEDDAILIAMgCUKAgICAgIDA//8AhYRQDQEgASAKhFAEQCADIAmEQgBSDQIgASADgyEDIAIgBIMhBAwCCyADIAmEUEUNACABIQMgAiEEDAELIAMgASABIANUIAkgClYgCSAKURsiCBshCiAEIAIgCBsiDEL///////8/gyEJIAIgBCAIGyILQjCIp0H//wFxIQcgDEIwiKdB//8BcSIFRQRAIAZB4ABqIAogCSAKIAkgCVAiBRt5IAVBBnStfKciBUEPaxCqASAGKQNoIQkgBikDYCEKQRAgBWshBQsgASADIAgbIQMgC0L///////8/gyEBIAcEfiABBSAGQdAAaiADIAEgAyABIAFQIgcbeSAHQQZ0rXynIgdBD2sQqgFBECAHayEHIAYpA1AhAyAGKQNYC0IDhiADQj2IhEKAgICAgICABIQhASAJQgOGIApCPYiEIQ0gAiAEhSEEAn4gA0IDhiICIAUgB0YNABogBSAHayIHQf8ASwRAQgAhAUIBDAELIAZBQGsgAiABQYABIAdrEKoBIAZBMGogAiABIAcQoAMgBikDOCEBIAYpAzAgBikDQCAGKQNIhEIAUq2ECyEJIA1CgICAgICAgASEIQsgCkIDhiEKAkAgBEIAUwRAQgAhA0IAIQQgCSAKhSABIAuFhFANAiAK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BSQAQcgAELgCIgYCfyACRQRAQai3CiEEQYC4CgwBCyACKAIAIgRBqLcKIAQbIQQgAigCBCIDQYC4CiADGws2AgQgBiAENgIAQdAAELgCIgMgBjYCTCADIAMoAgBBfHE2AgAgAyABKAIAIgE2AhggAyABQQhyOgAYIAMgAzYCSCADIAIgBCgCABEAACEBIAMoAkwgATYCCCADQQAgACAFQQhqQQEQqAMEQCADIAUpAwg3AwgLIAMQ7A0iAEEAIAAQ2QUgBUEQaiQAIAALUQECfEECQQFBAyAAKwMIIAErAwgiA6EgAisDACABKwMAIgShoiAAKwMAIAShIAIrAwggA6GioSIDRAAAAAAAAAAAYxsgA0QAAAAAAAAAAGQbCxAAIAAgAUECdGooAgAoAgALDgAgACABIAIQlAYQ7QgLGwAgACABIAJBBEECQYCAgIAEQf////8DEPwKC3MBAX8gABAkIAAQPU8EQCAAQQEQhQILIAAQJCECAkAgABAnBEAgACACaiABOgAAIAAgAC0AD0EBajoADyAAECRBEEkNAUG4owNB7vsAQZkCQamvARAAAAsgACgCACACaiABOgAAIAAgACgCBEEBajYCBAsLEgAgACABQY8hQRVBtvoAEIULC5ACAQR/IwBBIGsiBCQAIAAQPSIDIAFqIgEgA0EBdEGACCADGyICIAEgAksbIQEgABAkIQUCQAJAAkACQCAALQAPQf8BRgRAIANBf0YNAiAAKAIAIQIgAUUEQCACEBlBACECDAILIAIgARA/IgJFDQMgASADTQ0BIAIgA2pBACABIANrEDUaDAELQQAgASABQQEQTSICGw0DIAIgACAFECMaIAAgBTYCBAsgAEH/AToADyAAIAE2AgggACACNgIAIARBIGokAA8LQdeoA0Gk/ABBzABBh7ABEAAACyAEIAE2AgBBmNwGKAIAQfvPAyAEECAQKQALIAQgATYCEEGY3AYoAgBB+88DIARBEGoQIBApAAsMACAAIAEoAgA2AgALRwECfyMAQRBrIgUkACAFIAI2AgwgBSAENgIIIAVBBGogBUEMahCJAiEGIAAgASADIAUoAggQWiEAIAYQiAIgBUEQaiQAIAALCQAgABBBEJ8HCwYAEIwBAAt/AgJ/AX4jAEEQayIDJAAgAAJ+IAFFBEBCAAwBCyADIAEgAUEfdSICcyAC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ayIBJAAgASADNgIMIAEgAzYCCEF/IQUCQEEAQQAgAiADEFoiA0EASA0AIAAgA0EBaiIDEDoiADYCACAARQ0AIAAgAyACIAEoAgwQWiEFCyABQRBqJAAgBxCIAiAEQRBqJAAgBQtjACACKAIEQbABcSICQSBGBEAgAQ8LAkAgAkEQRw0AAkACQCAALQAAIgJBK2sOAwABAAELIABBAWoPCyACQTBHIAEgAGtBAkhyDQAgAC0AAUEgckH4AEcNACAAQQJqIQALIAALLgACQCAAKAIEQcoAcSIABEAgAEHAAEYEQEEIDwsgAEEIRw0BQRAPC0EADwtBCgtGAQF/IAAoAgAhAiABEGchACACQQhqIgEQhwIgAEsEfyABIAAQlwMoAgBBAEcFQQALRQRAEIwBAAsgAkEIaiAAEJcDKAIAC4EBAQJ/IwBBEGsiBCQAIwBBIGsiAyQAIANBGGogASABIAJqELAFIANBEGogA0EMaiICIAMoAhggAygCHCAAEJYMIAMgASADKAIQEK8FNgIMIAMgACADKAIUEJ4DNgIIIARBCGogAiADQQhqEPQBIANBIGokACAEKAIMGiAEQRBqJAAL+gECA34CfyMAQRBrIgUkAAJ+IAG9IgRC////////////AIMiAkKAgICAgICACH1C/////////+//AFgEQCACQjyGIQMgAkIEiEKAgICAgICAgDx8DAELIAJCgICAgICAgPj/AFoEQCAEQjyGIQMgBEIEiEKAgICAgIDA//8AhAwBCyACUARAQgAMAQsgBSACQgAgAqdnQSBqIAJCIIinZyACQoCAgIAQVBsiBkExahCqASAFKQMAIQMgBSkDCEKAgICAgIDAAIVBjPgAIAZrrUIwhoQLIQIgACADNwMAIAAgAiAEQoCAgICAgICAgH+DhDcDCCAFQRBqJAALCQAgAEEAENYBC64CAwF8AX4BfyAAvSICQiCIp0H/////B3EiA0GAgMD/A08EQCACpyADQYCAwP8Da3JFBEBEAAAAAAAAAABEGC1EVPshCUAgAkIAWRsPC0QAAAAAAAAAACAAIAChow8LAnwgA0H////+A00EQEQYLURU+yH5PyADQYGAgOMDSQ0BGkQHXBQzJqaRPCAAIAAgAKIQrQSioSAAoUQYLURU+yH5P6APCyACQgBTBEBEGC1EVPsh+T8gAEQAAAAA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QQA2AgggAUGMAzYCFCABQYACEDoiAjYChAMgAkUNASABQYAIIAEoAgwRAgAiCjYCLCAKRQRAIAEoAoQDIAEoAhQRAQAgASABKAIUEQEADAELIAFBDGohAiABIApBgAhqNgIwAkBBAEUEQEG8ASABKAIMEQIAIgZFDQEgBkIANwJQIAZCADcCaCAGQgA3AgggBkEAOgAEIAYgAjYCECAGQQA2AgAgBkEANgIUIAZBADYCYCAGQgA3AlggBiACNgJkIAZCADcCcCAGQQA2AnggBiACNgJ8IAZCADcCHCAGQQA6ABggBkIANwIwIAZBADoALCAGIAI2AiQgBkIANwJEIAZBQGtBADoAACAGIAI2AjggBkEANgIoIAZBADYCPCAGIAI2AkwgBkIANwKMASAGQQA6AIgBIAZCATcCgAEgBiACNgKUASAGQgA3ApgBIAZBADoAoAEgBkIANwKkASAGQgA3AqwBIAZCADcCtAELIAFBADYC9AIgASAGNgLgAiABQQA2AuwCIAFBADYCrAIgAUIANwLMAyABQSE6ANQDIAFBADYC9AEgAUEANgJ8IAFBADsB6AEgAUIANwKcAyABQQA2AuQBIAFCADcDiAMgAUIANwK0AyABQgA3AqQDIAFBADYCrAMgAUEAOgCQAyABIAI2ArADIAFBADYCxAMgAUIANwK8AyABIAI2AsgDQQAhBiABQY0DNgKUAiABQZwDNgL8ASABQQA2ApACIAFCgICAgBA3AogCIAQEQANAIAQgBmohHyAGQQFqIQYgHy0AAA0ACyAGIAEoAgwRAgAiAgRAIAIgBCAGECMaCyABIAI2AuQBCyABQQA2AuQCIAFBlAFqIAFBkAFqQQAQzAcaIAFCADcDACABQTRqQQBBwAAQNRogAUIANwOAASABQQA2AnggAUIANwOIASABQgA3ApQDIAFCADcCJCABQgA3A5gCIAFCADcDoAIgAUEANgKoAiABIAEoAggiAjYCHCABIAI2AhggASABNgJ0IAFBuAJqQQBBJhA1GiABQQA2AvwCIAFBADYC8AIgAUEANgLoAiABQQA2ArQCIAFBAToAsAIgAUEANgL4ASABQQA7AeQDIAFCADcD2AMgAUIANwLsASABQegDakEAQSgQNRpBic4BEN0HIQIgAUIANwOQBCABQoCAgAQ3A4gEIAFBgICglgQ2AoQE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tQFBnQFByu8AEAAACyABIABBABCEDyEAAn8gBEEBRgRAIAAQvwQMAQsgACATEIgICyEBIAAQGSAJIAE2AgAgEygCECgCkAEgCRCFDwsgDkEwaiQAIAkLjAICA38BfCMAQSBrIgEkAEEIEEohA0GkgQsoAgAoAgAhAiABIAApAxg3AxggASAAKQMQNwMQIAEgACkDCDcDCCABIAApAwA3AwACQCACRQ0AAkAgASgCBA0AIAIoAgQiAEUNACABIAA2AgQLAkAgASsDEEQAAAAAAAAAAGNFDQAgAisDECIERAAAAAAAAAAAZkUNACABIAQ5AxALAkAgASgCAA0AIAIoAgAiAEUNACABIAA2AgALIAIoAhhB/wBxIgBFDQAgASABKAIYIAByNgIYCyADQaiBCygCACgChAEiACABQQEgACgCABEDADYCACADQaSBCygCADYCBEGkgQsgAzYCACABQSBqJAALbgECfyMAQSBrIgMkACADQgA3AxggA0IANwMIIANCgICAgICAgPi/fzcDECADIAI2AhggA0IANwMAIAEEQCADQeD5CUEDIAFB5tMBEMwECyAAKAKEASIAIANBASAAKAIAEQMAIQQgA0EgaiQAIAQLaQEBf0Hk/AooAgAhAQJAIAAEQEHk/AogAUEBajYCACABDQFB4PwKQQAQvgcQZTYCAEGz0gEQvgcaDwsgAUEATA0AQeT8CiABQQFrIgA2AgAgAA0AQeD8CigCABC+BxpB4PwKKAIAEBkLC3cBAn8gASAAED0iAWoiAiABQQF0QYAIIAEbIgMgAiADSxshAiAAECQhAwJAIAAtAA9B/wFGBEAgACgCACABIAJBARCHASEBDAELIAJBARAaIgEgACADECMaIAAgAzYCBAsgAEH/AToADyAAIAI2AgggACABNgIAC8MBAQJ/AkACQCABIAAoAhAiAigCsAEiA0cEQCAAIAEoAhAiACgCsAFHDQELQQBB1PoDQQAQHwwBCyADRQRAIAIgATYCsAEgAigCrAEiAyAAKAKsAUoEQCAAIAM2AqwBCwNAIAFFDQIgASgCECIAIAAvAagBIAIvAagBajsBqAEgACAALwGaASACLwGaAWo7AZoBIAAgACgCnAEgAigCnAFqNgKcASAAKAKwASEBDAALAAtBv8kBQYu2AUGqAkGYDxAAAAsLCQBBn/oKEIgL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BCgCDCEGIAIgAWtBAnUiCEEASgRAIAAgASAIENoDIAhHDQELIAYgAyABa0ECdSIBa0EAIAEgBkgbIgFBAEoEQCAAIAdBBGogASAFEOwLIgUQQSABENoDIQYgBRByGiABIAZHDQELIAMgAmtBAnUiAUEASgRAIAAgAiABENoDIAFHDQELIAQQ8AsgACEJCyAHQRBqJAAgCQujAQEEfyMAQRBrIgckAAJAIABFDQAgBCgCDCEGIAIgAWsiCEEASgRAIAAgASAIENoDIAhHDQELIAYgAyABayIBa0EAIAEgBkgbIgFBAEoEQCAAIAdBBGogASAFEPELIgUQQSABENoDIQYgBRAvGiABIAZHDQELIAMgAmsiAUEASgRAIAAgAiABENoDIAFHDQELIAQQ8AsgACEJCyAHQRBqJAAgCQsOACAAIAEoAgA2AgAgAAupAQEEfyMAQRBrIgUkACABEDghAiMAQRBrIgMkAAJAIAJB7////wdNBEACQCACEKwFBEAgACACEMQBIAAhBAwBCyADQQhqIAAgAhDYA0EBahDXAyADKAIMGiAAIAMoAggiBBDzASAAIAMoAgwQ8gEgACACELEBCyAEIAEgAhCkAiADQQA6AAcgAiAEaiADQQdqEMMBIANBEGokAAwBCxDTAQALIAVBEGokAAsKACAAIAEgAGtqCwgAIABB/wFxC1ABAX4CQCADQcAAcQRAIAIgA0FAaq2IIQFCACECDAELIANFDQAgAkHAACADa62GIAEgA60iBIiEIQEgAiAEiCECCyAAIAE3AwAgACACNwMIC9sBAgF/An5BASEEAkAgAEIAUiABQv///////////wCDIgVCgICAgICAwP//AFYgBUKAgICAgIDA//8AURsNACACQgBSIANC////////////AIMiBkKAgICAgIDA//8AViAGQoCAgICAgMD//wBRGw0AIAAgAoQgBSAGhIRQBEBBAA8LIAEgA4NCAFkEQEF/IQQgACACVCABIANTIAEgA1EbDQEgACAChSABIAOFhEIAUg8LQX8hBCAAIAJWIAEgA1UgASADURsNACAAIAKFIAEgA4WEQgBSIQQLIAQLKAAgAEEYdCAAQYD+A3FBCHRyIABBCHZBgP4DcSAAQRh2cnIgACABGwsLACAAIAEgAhEAAAveAQECfyACQQBHIQMCQAJAAkAgAEED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NwNIIAEgAykDODcDWCABIAMpAzA3A1AgE0EBaiETIBRBBmohFAwBCwALAAsgACABIAIgBBBCQQAhEQNAIAIgEUYNGSAPIBAgEUEwbGoiASkDKDcDCCAPIAEpAyA3AwAgDyABKQNINwMYIA8gAUFAaykDADcDECAAIA9BAhA2IBFBAWohEQwACwALQQEgAiACQQFNGyEUIAJBAWoiE0EQEBohA0EBIREDQCARIBRGBEAgAyAQIAJBMGxqIgFBGGopAwA3AwggAyABKQMQNwMAIAMgAkEEdGoiESABQRBrIgJBCGopAwA3AwggESACKQMANwMAIAAgAyATIAQQQiADEBkgDyACKQMINwMIIA8gAikDADcDACAPIAEpAxg3AxggDyABKQMQNwMQIA8gDysDECAPKwMAIAErAwChoDkDICAPIA8rAxggDysDCCABKwMIoaA5AyggACAPQRBqQQIQNiAPIA8pAyg3AxggDyAPKQMgNwMQIAAgD0ECEDYMGQUgAyARQQR0IhJqIhUgASASaiISKQMANwMAIBUgEikDCDcDCCARQQFqIREMAQsACwALIAJBAmoiA0EQEBoiAiABKQMINwMIIAIgASkDADcDACACIBApAyA3AxAgAiAQKQMoNwMYIAIgECsDICAQKwMwIgYgECsDQKFEAAAAAAAACECjIgegOQMgIBArAyghCCAQKwNIIQkgECsDOCEFIAIgBiAHoDkDMCACIAUgBSAJoUQAAAAAAAAIQKMiBaA5AzggAiAIIAWgOQMoQQQgAyADQQRNGyEUIAFBIGshAUEEIREDQCARIBRGBEAgACACIAMgBBBCIAIQGSAPIBApAzg3AwggDyAQKQMwNwMAIA8gECkDKDcDGCAPIBApAyA3AxAgACAPQQIQNgwYBSACIBFBBHQiE2oiEiABIBNqIhMpAwA3AwAgEiATKQMINwMIIBFBAWohEQwBCwALAAsgAkEDaiIDQRAQGiICIAEpAwg3AwggAiABKQMANwMAIAIgASsDACIFIAUgECsDEKEiBkQAAAAAAADQv6KgOQMQIAErAwghCCAQKwNIIQkgAiAQKwM4Igc5AzggAiAFIAZEAAAAAAAAAsCioDkDMCACIAUgBiAGoKE5AyAgAiAIIAcgCaFEAAAAAAAACECjoCIFOQMoIAIgBTkDGCAQKwMwIQUgAiAHOQNIIAIgBTkDQEEEIAMgA0EETRshFCABQTBrIQFBBCERA0AgESAURgRAIAAgAiADIAQQQiACEBkMFwUgAiARQQR0IhNqIhIgASATaiITKQMANwMAIBIgEykDCDcDCCARQQFqIREMAQsACwALIAJBBEcNFUEGQRAQGiICIAEpAwg3AwggAiABKQMANwMAIAIgECkDKDcDGCACIBApAyA3AxAgAiAQKQNINwMoIAIgECkDQDcDICACIAEpAyg3AzggAiABKQMgNwMwIAIgECkDgAE3A0AgAiAQKQOIATcDSCACIBApA6ABNwNQIAIgECkDqAE3A1ggACACQQYgBBBCIAIQGSAPIBArAxAgECsDsAEgECsDAKGgOQMAIA8gECsDGCAQKwO4ASAQKwMIoaA5AwggDyAQKQNINwMYIA8gECkDQDcDECAAIA9BAhA2IA8gECkDiAE3AxggDyAQKQOAATcDECAAIA9BAhA2IA8gECkDCDcDGCAPIBApAwA3AxAgACAPQQIQNgwUCyACQQRHDRdBDEEQEBoiAiABKQMINwMIIAIgASkDADcDACACIAEpAxA3AxAgAiABKQMYNwMYIAIgECsDMCIFIBArA0AgBaEiCaAiBjkDICACIBArAzgiByAQKwNIIAehIgqgIgg5AyggAiAGIAUgECsDIKGgIgU5AzAgECsDKCELIAIgCSAFoCIJIAYgBaGgOQNQIAIgCTkDQCACIAggByALoaAiBTkDOCACIAogBaAiBjkDSCACIAYgCCAFoaA5A1ggAiAQKwNgIgUgECsDUCAFoSIJoCIGOQOQASACIBArA2giByAQKwNYIAehIgqgIgg5A5gBIAIgBiAFIBArA3ChoCIFOQOAASAQKwN4IQsgAiAJIAWgIgk5A3AgAiAJIAYgBaGgOQNgIAIgCCAHIAuhoCIFOQOIASACIAogBaAiBjkDeCACIAYgCCAFoaA5A2ggAiABKQMgNwOgASACIAEpAyg3A6gBIAIgASkDMDcDsAEgAiABKQM4NwO4ASAAIAJBDCAEEEIgDyACKQMoNwMIIA8gAikDIDcDACAPIAIrAyAiBSACKwMwIgYgBaGhIgU5AxAgDyACKwMoIgcgAisDOCIIIAehoSIHOQMYIA8gBSACKwNAIAahoDkDICAPIAcgAisDSCAIoaA5AyggDyACKQNYNwM4IA8gAikD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NgIAIAAoAigiBARAIAAoAhwgBCAFbGogAyAEECMaCyABIAAoAgBOBEAgACABQQFqNgIACyACIAAoAgROBEAgACACQQFqNgIECyAAIAAoAghBAWo2AggPC0Ht0AFBjrMBQYIKQbwLEAAAC6MBAQJ/IABFBEBBAA8LIAAoAgAgACgCBCAAKAIIIAAoAhAgACgCKCAAKAIgEPgJIgEoAhQgACgCFCAAKAIAQQJ0QQRqECMaIAAoAhQgACgCAEECdGooAgAiAgRAIAEoAhggACgCGCACQQJ0ECMaCyAAKAIcIgIEQCABKAIcIAIgACgCCCAAKAIobBAjGgsgASAAKAIkNgIkIAEgACgCCDYCCCABC3IBAn8jAEEgayICJAACQCAArSABrX5CIIhQBEAgACABEE0iA0UNASACQSBqJAAgAw8LIAIgATYCBCACIAA2AgBBmNwGKAIAQazQAyACECAQKQALIAIgACABbDYCEEGY3AYoAgBB+88DIAJBEGoQIBApAAtBAQF/IAEgACgCBCICTwRAQcegA0H/+QBBwQBBgiEQAAALIAFBA3YgACAAKAIAIAJBIUkbai0AACABQQdxdkEBcQtbAQF/IAEgACgCBCIDSQRAIANBIU8EfyAAKAIABSAACyABQQN2aiIAIAAtAAAiAEEBIAFBB3EiAXRyIABBfiABd3EgAhs6AAAPC0GVoANB//kAQdAAQfYfEAAAC20CAX8CfCMAQSBrIgMkAAJAIAAgAhAmIgBFDQAgAyADQRBqNgIEIAMgA0EYajYCACAAQZmDASADEEhBAkcNACADKwMQIQQgAysDGCEFIAFBAToAUSABIAU5AzggAUFAayAEOQMACyADQSBqJAALRAEBfyAAQYolQcACQQEQLhogABDsBSAAECooAhAvAbABQQgQGiEBIAAoAhAgATYClAEgACAAECooAhAoAnRBAXEQvgQL/QMDCX8BfQJ8IANBBBAaIQUgA0EEEBohBiADQQQQGiEIIANBBBAaIQogAyABENUCIAMgAhDVAiAAIAMgASAKENQCIAMgChDVAiADQQAgA0EAShshCQNAIAcgCUcEQCAFIAdBAnQiC2ogAiALaioCACAKIAtqKgIAkzgCACAHQQFqIQcMAQsLIAMgBSAGEM8KIARBACAEQQBKGyEHIARBAWshCyADIAUgBRC7AiEPQQAh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BkECRhs2AlAgAUHn0AQgBEHQAGoQHiABIAIoAgAQPCABIANBCGoQsAYMCgsgBEHCAEHiACAGQQRGGzYCYCABQefQBCAEQeAAahAeIAEgAigCABA8IAEgA0EIahCwBgwJCyABQZzRBEEAEB4gASACKAIAEDwgASADQQhqELAGDAgLIAFBhNEEQQAQHiABIAIoAgAQPCADKwMIIQsgBCADKwMQOQOYASAEIAs5A5ABIAFB784EIARBkAFqEB4gASACKAIAEDwgBEHjAEHyACADKAIYIgZBAUYbQewAIAYbNgKAASABQfTQBCAEQYABahAeIAEgAigCABA8IAQgAysDIDkDcCABQbPOBCAEQfAAahAeIAEgAigCABA8IAFBubMDEBsaIAMoAiggAiABEJQCIAFBChBeDAcLIARBwwBB4wAgBkEIRhs2AqABIAFB59AEIARBoAFqEB4gASACKAIAEDwgAUGb0ARBABAeIAEgAigCABA8IAFB0rMDEBsaIAMoAgggAiABEJQCIAFBChBeDAYLIARBwwBB4wAgBkENRhs2ApACIAFB59AEIARBkAJqEB4gASACKAIAEDwCQAJAAkAgAygCCA4CAAECCyABQZvQBEEAEB4gASACKAIAEDwgAUHSswMQGxogAygCECACIAEQlAIgAUEKEF4MBwsgAUH1zwRBABAeIAEgAigCABA8IAEgAigCABA8IAMrAxAhCyAEIAMrAxg5A4gCIAQgCzkDgAIgAUGbzwQgBEGAAmoQHiABIAIoAgAQPCADKwMgIQsgBCADKwMoOQP4ASAEIAs5A/ABIAFBhc8EIARB8AFqEB4gASACKAIAEDwgASADKAIwIAMoAjQgAhCKCQwGCyABQYjQBEEAEB4gASACKAIAEDwgASACKAIAEDwgAysDECELIAMrAxghDCAEIAMrAyA5A+ABIAQgDDkD2AEgBCALOQPQASABQc3PBCAEQdABahAeIAEgAigCABA8IAMrAyghCyADKwMwIQwgBCADKwM4OQPAASAEIAw5A7gBIAQgCzkDsAEgAUGxzwQgBEGwAWoQHiABIAIoAgAQPCABIANBQGsoAgAgAygCRCACEIoJDAULIAFBqNEEQQAQHiABIAIoAgAQPCAEIAMrAwg5A6ACIAFBxM4EIARBoAJqEB4gASACKAIAEDwgAUHvswMQGxogAygC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ahCuBSADQRBqJAALHAEBfyAAKAIAIQIgACABKAIANgIAIAEgAjYCAAsIACAAKAIARQuNAQEBfwJAIAAoAgQiASABKAIAQQxrKAIAaigCGEUNACAAKAIEIgEgASgCAEEMaygCAGoQrQxFDQAgACgCBCIBIAEoAgBBDGsoAgBqKAIEQYDAAHFFDQAgACgCBCIBIAEoAgBBDGsoAgBqKAIYEKwMQX9HDQAgACgCBCIAIAAoAgBBDGsoAgBqQQEQtQULC7MBAQF/IAAgATYCBCAAQQA6AAAgASABKAIAQQxrKAIAahCtDARAIAEgASgCAEEMaygCAGooAkgiAQRAIwBBEGsiAiQAIAEgASgCAEEMaygCAGooAhgEQCACQQhqIAEQtAUaAkAgAi0ACEUNACABIAEoAgBBDGsoAgBqKAIYEKwMQX9HDQAgASABKAIAQQxrKAIAakEBELUFCyACQQhqELMFCyACQRBqJAALIABBAToAAAsgAAsJACAAIAEQwwkLtgMCA38BfiMAQSBrIgMkAAJAIAFC////////////AIMiBUKAgICAgIDAwD99IAVCgICAgICAwL/AAH1UBEAgAUIZiKchBCAAUCABQv///w+DIgVCgICACFQgBUKAgIAIURtFBEAgBEGBgICABGohAgwCCyAEQYCAgIAEaiECIAAgBUKAgIAIhYRCAFINASACIARBAXFqIQIMAQsgAFAgBUKAgICAgIDA//8AVCAFQoCAgICAgMD//wBRG0UEQCABQhmIp0H///8BcUGAgID+B3IhAgwBC0GAgID8ByECIAVC////////v7/AAFYNAEEAIQIgBUIwiKciBEGR/gBJDQAgA0EQaiAAIAFC////////P4NCgICAgICAwACEIgUgBEGB/gBrEKoBIAMgACAFQYH/ACAEaxCgAyADKQMIIgBCGYinIQIgAykDACADKQMQIAMpAxiEQgBSrYQiBVAgAEL///8PgyIAQoCAgAhUIABCgICACFEbRQRAIAJBAWohAgwBCyAFIABCgICACIWEQgBSDQAgAkEBcSACaiECCyADQSBqJAAgAiABQiCIp0GAgICAeHFyvgvHAQIDfwJ+IwBBEGsiAyQAAn4gAbwiBEH/////B3EiAkGAgIAEa0H////3B00EQCACrUIZhkKAgICAgICAwD98DAELIAJBgICA/AdP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BCgCFEECIANB0AFqEI8CRQ0KIAQoAhRBAiADQfAJahCPAg0BDAoLIAFBA0EBEMcBDQkgBCgCFEECIANB0AFqEI8CRQ0JIAQoAhRBAiADQfAJahCPAkUNCQsgBCADKALQATYCLCAEIAMoAvAJNgIoDAgLIAFBAiADQfABahCPAkUNByAEKAIUIAMoAvABQQJrQQEQxwEaDAALAAsgBEHIADYCMCAEKAIUQQBBABDHARoDQCADQYAKaiIBQYAIIAQoAhQQqwRFDQYgAUHb1QEQpwQiAUUNACADIANByAFqNgIsIAMgA0HwCWo2AiggAyADQdABajYCJCADIANB8AFqNgIgIAFB4a4BIANBIGoQSEEERw0ACyAEIAMoAvABIgE2AiAgBCADKALQASICNgIkIAQgAygC8AkgAWs2AiggBCADKALIASACazYCLAwFCyABQRpBABDHARogBCgCFEECIANBgApqEJACRQ0EIAQoAhRBAiADQfABahCQAkUNBAsgBCADKAKACjYCKCAEIAMoAvABNgIsDAMLIANBiApqQgA3AwAgA0IANwOACiAEKAIUQQBBABDHARpBACEBA0ACQCAMIAEgBnFyRQRAAn8DQCAEKAIUEOIDIgJBf0cEQEEAIAJBCkYNAhogA0GACmogAsAQ4wgMAQsLQQELIQwgA0GACmoiAkEAEOMIAkAgAhAnBEAgA0EAOgCPCgwBCyADQQA2AoQKCyADQYAKaiICECchBSACIAMoAoAKIAUbIQcgASEFA0AgB0ECaiENQQAhAgNAIAIgB2oiDi0AACIIRQ0DQQEhAQJAIAhB4QBrQf8BcUEZTQRAA0AgASIPQQFqIQEgByACIghBAWoiAmotAAAiCUHfAXFBwQBrQf8BcUEaSQ0ACyAJQT1HDQIgCCANai0AAEEiRw0CQQAhASAIQQNqIgghAgNAIAIgB2otAAAiCUUNAyAJQSJGDQIgAUEBaiEBIAJBAWohAgwACwALIAJBAWohAgwBCwsgAyAPNgL0ASADIA42AvABIAMgAykC8AE3A5gBIAMgByAIaiICNgL4ASADIAE2AvwBIAEgAmpBAWohByADQZgBakH79gAQmgYEQCADIAMpAvgBNwNIIANByABqEJkGIQEgAyADQdABaiICNgJEIAMgA0HwCWo2AkACQCABQfAwIANBQGsQSEECRgRA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AQsgAyABKQMINwMYIAMgASkDADcDECADQSBqIAAgA0EQahCmBgsgBEUNACAEKAJYIgFFDQAgAyADKQMoNwMIIAMgAykDIDcDACAAIAMgAiABEQUACyADQTBqJAALIgEBfwJAIAAoAjwiAUUNACABKAIwIgFFDQAgACABEQEACwsiAQF/AkAgACgCPCIBRQ0AIAEoAiwiAUUNACAAIAERAQALCyIBAX8CQCAAKAI8IgFFDQAgASgCKCIBRQ0AIAAgAREBAAsLfgEGfCABKwOQBCEHIAErA4AEIQMgASsDiAQhCCABKwPgAiEFIAErA/gDIQQCQCABKALoAgRAIAMgAisDCKCaIQYMAQsgBCACKwMAoCEGIAJBCGohAiADIQQLIAIrAwAhAyAAIAUgCKIgBqI5AwAgACAFIAeiIAQgA6CiOQMICywBAn8CQCAAKAIkIgJFDQAgAC0AkAENACAAKAIAKAJoDQAgAhDjAyEBCyABC2cBAn8jAEEQayIDJAADQAJAIAEtAAAiAkHcAEcEQCACBEAgAsAiAkEATgRAIAAgAhBeDAMLIAMgAjYCACAAQfHdACADEB4MAgsgA0EQaiQADwsgAEHLwQEQGxoLIAFBAWohAQwACwALtgICBH8DfCMAQfAAayIBJABBzPkKQcz5CigCACIEQQFqNgIAAnwgACgCECIDKAKIASICRQRARAAAAAAAAElAIQVEAAAAAAAASUAMAQsgArdEGC1EVPshCUCiRAAAAAAAgGZAoyIFEEkhB0QAAAAAAADwPyAFEF2hRAAAAAAAAElAohDrAiEFIAdEAAAAAAAA8D+gRAAAAAAAAElAohDrAgshBiAAQfCsAxAbGiADKALUASICBEAgACACEH8gAEHfABBeCyABIAU5A2AgASAGOQNYIAEgBDYCUCAAQYK6BCABQdAAahAeIAFBKGoiAiADQThqQSgQIxogAEQAAAAAAAAAACACEOkEIABEAAAAAAAA8D8gASADQeAAakEoECMiARDpBCAAQfu2BBAbGiABQfAAaiQAIAQL+QICBH8BfSMAQYABayIDJABByPkKQcj5CigCACIFQQFqNgIAIAAoAhAiBCgCiAEhBiADQgA3A3ggA0IANwNwIANCADcDaCADQgA3A2AgASADQeAAaiACIAa3RBgtRFT7IQlAokQAAAAAAIBmQKNBABCG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IgVBAnRqKAIAIgYgCigCAEgEQCAQIAJBAnRqIAU2AgAgBCACQQN0aiADIABBA3RqKwMAOQMAIAJBAWohAgwBCyAEIAZBA3RqIgUgAyAAQQN0aisDACAFKwMAoDkDAAsgAEEBaiEADAELCyAIIAtqIAI2AgAgASEADAALAAsgBEEAIARBAEobIQwgDSgCHCEEIAEoAhwhCCAAKAIcIRFBACEAA0AgACAMRg0DIA8gAEEBaiIBQQJ0IgVqIQogDyAAQQJ0IgNqKAIAIQADQCAAIAooAgBORQRAIAkgFCAAQQJ0aigCACIHQQJ0aiACNgIAIBAgAkECdGogBzYCACAEIAJBBHRqIgcgESAAQQR0aiIGKwMAOQMAIAcgBisDCDkDCCAAQQFqIQAgAkEBaiECDAELCyADIAtqIQogBSAOaiEHIAMgDmooAgAhAANAIAAgBygCAE5FBEACQCAJIBMgAEECdGooAgAiA0ECdGooAgAiBiAKKAIASARAIBAgAkECdGogAzYCACAEIAJBBHRqIgMgCCAAQQR0aiIGKwMAOQMAIAMgBisDCDkDCCACQQFqIQIMAQsgBCAGQQR0aiIDIAggAEEEdGoiBisDACADKwMAoDkDACADIAYrAwggAysDCKA5AwgLIABBAWohAAwBCwsgBSALaiACNgIAIAEhAAwACwALIARBACAEQQBKGyEMIA0oAhwhBCABKAIcIQMgACgCHCERQQAhAANAIAAgDEYNAiAPIABBAWoiAUECdCIIaiEKIA8gAEECdCIFaigCACEAA0AgACAKKAIATkUEQCAJIBQgAEECdCIHaigCACIGQQJ0aiACNgIAIBAgAkECdCISaiAGNgIAIAQgEmogByARaigCADYCACAAQQFqIQAgAkEBaiECDAELCyAFIAtqIQogCCAOaiEHIAUgDmooAgAhAANAIAAgBygCAE5FBEACQCAJIBMgAEECdCIFaigCACIGQQJ0aigCACISIAooAgBIBEAgECACQQJ0IhJqIAY2AgAgBCASaiADIAVqKAIANgIAIAJBAWohAgwBCyAEIBJBAnRqIgYgBigCACADIAVqKAIAajYCAAsgAEEBaiEADAELCyAIIAtqIAI2AgAgASEADAALAAsgBEEAIARBAEobIQhBACEAA0AgACAIRg0BIA8gAEEBaiIBQQJ0IgRqIQUgDyAAQQJ0IgNqKAIAIQADQCAAIAUoAgBORQRAIAkgFCAAQQJ0aigCACIMQQJ0aiACNgIAIBAgAkECdGogDDYCACAAQQFqIQAgAkEBaiECDAELCyADIAtqIQUgBCAOaiEMIAMgDmooAgAhAANAIAAgDCgCAE5FBEAgCSATIABBAnRqKAIAIgNBAnRqKAIAIAUoAgBIBEAgECACQQJ0aiADNgIAIAJBAWohAgsgAEEBaiEADAELCyAEIAtqIAI2AgAgASEADAALAAsgDSACNgIICyAJEBkLIA0PC0Hq0gFBjrMBQcYFQfSsARAAAAtBg8cBQY6zAUHHBUH0rAEQAAALQb6SAUGOswFByAVB9KwBEAAAC8wIAhB/AXwCQCAARQ0AIAAoAiBFBEAgACgCGCENIAAoAhQhByAAKAIEIgggACgCACICIAAoAggiASAAKAIQQQAQmgIiCSABNgIIIAkoAhghDiAJKAIUIQNBfyAIIAhBAEgbQQFqIQpBACEBA0AgASAKRgRAQQAhASACQQAgAkEAShshCiADQQRqIQYDQAJAIAEgCkYEQEEAIQEgCEEAIAhBAEobIQIDQCABIAJGDQIgAUECdCEGIAMgAUEBaiIBQQJ0aiIEIAQoAgAgAyAGaigCAGo2AgAMAAsACyAHIAFBAWoiAkECdGohBCAHIAFBAnRqKAIAIQEDQCAEKAIAIAFMBEAgAiEBDAMFIAYgDSABQQJ0aigCAEECdGoiCyALKAIAQQFqNgIAIAFBAWohAQwBCwALAAsLQQAhAgJAAkACQAJAAkACQCAAKAIQQQFrDggAAQQCBAQEAwQLIAkoAhwhBiAAKAIcIQQDQCACIApGDQUgByACQQFqIgBBAnRqIQsgByACQQJ0aigCACEBA0AgCygCACABTARAIAAhAgwCBSAOIAMgDSABQQJ0aiIFKAIAQQJ0aigCAEECdGogAjYCACAEIAFBA3RqKwMAIREgAyAFKAIAQQJ0aiIFIAUoAgAiBUEBajYCACAGIAVBA3RqIBE5AwAgAUEBaiEBDAELAAsACwALIAkoAhwhBiAAKAIcIQRBACEAA0AgACAKRg0EIAcgAEEBaiICQQJ0aiELIAcgAEECdGooAgAhAQNAIAsoAgAgAUwEQCACIQAMAgUgDiADIA0gAUECdGoiBSgCAEECdGooAgBBAnRqIAA2AgAgBiADIAUoAgBBAnRqIgUoAgAiDEEEdGoiDyAEIAFBBHRqIhArAwA5AwAgDyAQKwMIOQMIIAUgDEEBajYCACABQQFqIQEMAQsACwALAAsgCSgCHCEGIAAoAhwhBEEAIQADQCAAIApGDQMgByAAQQFqIgJBAnRqIQsgByAAQQJ0aigCACEBA0AgCygCACABTARAIAIhAAwCBSAOIAMgDSABQQJ0IgVqIgwoAgBBAnRqKAIAQQJ0aiAANgIAIAQgBWooAgAhBSADIAwoAgBBAnRqIgwgDCgCACIMQQFqNgIAIAYgDEECdGogBTYCACABQQFqIQEMAQsACwALAAsDQCACIApGDQIgByACQQFqIgBBAnRqIQYgByACQQJ0aigCACEBA0AgBigCACABTARAIAAhAgwCBSADIA0gAUECdGooAgBBAnRqIgQgBCgCACIEQQFqNgIAIA4gBEECdGogAjYCACABQQFqIQEMAQsACwALAAsgCRBgDAQLA0AgCEEATEUEQCADIAhBAnRqIAMgCEEBayIIQQJ0aigCADYCAAwBCwsgA0EANgIAIAkPBSADIAFBAnRqQQA2AgAgAUEBaiEBDAELAAsAC0GdxwFBjrMBQcYAQayQARAAAAtBAAuhAgIFfAJ/IAAoAhAiBygClAEiACsDCCEFIAEoAhAiASgClAEiCCsDCCEGIAgrAwAgACsDAKGZIQQgASsDICECIAcrAyAhA0EAIQACQCAGIAWhmQJ8QeDeCi0AAEUEQCAEIANB2N4KKgIAuyIDokQAAAAAAADgP6IgAiADokQAAAAAAADgP6KgZUUNAiABKwMoQdzeCioCALsiAqJEAAAAAAAA4D+iIQQgBysDKCACokQAAAAAAADgP6IMAQsgBCADRAAAAAAAAOA/okHY3goqAgC7IgOgIAJEAAAAAAAA4D+iIAOgoGVFDQEgASsDKEQAAAAAAADgP6JB3N4KKgIAuyICoCEEIAcrAyhEAAAAAAAA4D+iIAKgCyAEoGUhAAsgAAtGAQF/IAAgAUEBEG8iAUGKJUHAAkEBEC4aQSAQSiECIAEoAhAgAjYCgAEgACgCEC8BsAFBCBAaIQAgASgCECAANgKUASABCz4BAX8gAEEAIAJBABAiIgMEQCAAIAMQNyEAIAFBACACQQAQIiIDBEAgASADIAAQYw8LIAFBACACIAAQIhoLC/ACAQV/IwBBEGsiBCQAIARBADYCCCAEQgA3AwAgASIFRQRAIARBABCFCiAEIQULIAAQbiEDAkACQANAIAMEQCADECEiBkUNAgJAIAZBkjZBBxDGAUUEQCADQfAkQaACQQEQLhpBOBBKIQYgAygCECAGNgKMASACEDIhBiADKAIQIgcgBigCEC8BsAE7AbABIAIoAhAoAowBKAIsIQYgBygCjAEiByACNgIwIAcgBkEBajYCLCAFIAMQhQogA0EAIAMQ2wYMAQsgAyAFIAIQ2wYLIAMQbSEDDAELCwJAIAENACAEKAIEIgFBAWsiBUEASA0CIAAoAhAiAiAFNgK0ASABQQJPBEAgBCgCACEFIAEgBCgCCCIDSQR/IAUgAyABEMwBIQUgACgCEAUgAgsgBTYCuAEMAQsgBEEANgIEIAQoAgAQGQsgBEEQaiQADwtBqMoBQdD7AEEKQaH2ABAAAAtB2sMBQdezAUH1B0G3KBAAAAsIAEEBQTgQGgs4AAJAIAAEQCAAKAIERQ0BIAAoAgAPC0GKygFB9bUBQSFBsSQQAAALQeehA0H1tQFBIUGxJBAAAAvsFwIRfwV8IAAgAEEAQc2RAUEAECJBf0EBEE4hBSAAQQoQjQIjAEEgayIDJAAgA0EFNgIUAkAgAEHeIhAmIgJFDQAgAyADQRRqNgIEIAMgA0EYajYCACACQYKuASADEEhBAEwNAEEAQavJBEEAEB8LIANBIGokACAAIAAQ/AkgABCuCiAAEP8MIAVBAUYEQCAAQQEQ1QYPCyAAEKEPIAVBAkYEQCAAQQIQ1QYPCyAAENoNIAVBA0YEQCAAQQIQ1QYPCwJAIAAoAhAtAIgBQRBxRQ0AIABBmfMAQQAQjgEiDUUNACANEBwhBwNAIAcEQCANIAcQHSERIAAgBxDYBEEAIQMgACgCECgCxAEiCSAHKAIQKAL0AUEGdCIKaiILKAIAIgxBACAMQQBKGyEFAkADQCADIAVHBEAgByALKAIEIANBAnRqKAIARgRAA0AgA0EBaiIFIAxODQQgCSAKaigCBCILIANBAnRqIAsgBUECdGooAgA2AgAgACgCECgCxAEiCSAKaigCACEMIAUhAwwACwAFIANBAWohAwwCCwALC0G76QBBxLQBQewBQbPzABAAAAsgCSAKaiAMQQFrNgIAIAcQoQogACAHELgEIBEhBwwBCwsgACANELoNCyAAEL8MIABBARDMCSAAQcKgARAmEIQBBEAjAEHQAmsiASQAIAAQsQ4hECAAEBwhDgNAIA4EQCAAIA4QKyEGA0ACQAJAAkACQAJAIAYEQCAGQbutARAmIBAQygoiCSAGQentABAmIBAQygoiCnJFDQUgBigCECgCCCIFRQ0FIAUoAgRBAk8EQCAGIAYoAgBBA3FBA0dBMGxqKAIoECEhAiABIAZBUEEAIAYoAgBBA3FBAkcbaigCKBAhNgIEIAEgAjYCAEEAQbeaBCABEB8MBgsgBiAGQTBqIgMgBigCAEEDcSICQQNGGygCKCEPIAYgBkEwayIMIAJBAkYbKAIoIQsgBSgCACIEKAIEIQcgAUGgAmpBAEEwEDUaIAEgBCgCDDYCrAIgASAEKAIIIgU2AqgCAkACQAJAAkACQAJAIAlFDQACQAJAIAkoAhAiCSsDECIVIAsoAhAiAisAECISZUUNACASIAkrAyAiFmVFDQAgCSsDGCITIAIrABgiEmVFDQAgEiAJKwMoIhRlDQELIA8QISEFIAYgDCAGKAIAQQNxQQJGGygCKBAhIQIgASAGQbutARAmNgKIASABIAI2AoQBIAEgBTYCgAFBAEHT2gMgAUGAAWoQHwwBCyAJQRBqIQ0CQAJAIBUgBCgCACIJKwAAIhJlRSASIBZlRXINACATIAkrAAgiEmVFDQAgEiAUZQ0BCyAHQQFrIQVBACEIA0AgBSAITQ0EIAQoAgAgCEEEdGogDRDDCg0EIAhBA2ohCAwACwALIBUgDygCECICKwAQIhJlRSASIBZlRXINASATIAIrABgiEmVFIBIgFGVFcg0BIA8QISEFIAYgDCAGKAIAQQNxQQJGGygCKBAhIQIgASAGQbutARAmNgLYASABIAI2AtQBIAEgBTYC0AFBAEH+2gMgAUHQAWoQHwsgB0EBayEFIAQoAgxFDQIgASAEKQMgNwPAAiABIAQpAyg3A8gCDAILIAVFDQMgASAJKQMINwPIASABIAkpAwA3A8ABIAEgBCkDGDcDuAEgASAEKQMQNwOwASABQeABaiABQcABaiABQbABaiANEI8FIAQoAgAiAiABKQPgATcDMCACIAEpA+gBNwM4IAQrABAhEiABKwPgASETIAQoAgAiAiAEKwAYIAErA+gBIhSgRAAAAAAAAOA/ojkDGCACIBIgE6BEAAAAAAAA4D+iOQMQIAQrABghEiAEKAIAIgIgBCsAECACKwAQoEQAAAAAAADgP6I5AwAgAiASIAIrABigRAAAAAAAAOA/ojkDCCAEKAIAIgIgEyACKwAQoEQAAAAAAADgP6I5AyAgAiAUIAIrABigRAAAAAAAAOA/ojkDKCAEKAIMIgIEfyAGIAQoAgBBAEEAIAFBoAJqIAIQjgYFQQALQQNqIQUMAQsgBCgCDCECIAUgCEYEQCACRQ0CIAQoAgAhAiABIAQpAyg3A6gBIAEgBCkDIDcDoAEgASACIAVBBHRqIgIpAwg3A5gBIAEgAikDADcDkAEgAUHgAWogAUGgAWogAUGQAWogDRCPBSABIAEpA+gBNwPIAiABIAEpA+ABNwPAAgwBCyACBH8gBiAEKAIAQQAgCCABQaACaiACEI4GBSAIC0EDaiEFCyAKRQ0EQbHZAyEIIAooAhAiBysDECIVIA8oAhAiAisAECISZUUNAyASIAcrAyAiFmVFDQMgBysDGCITIAIrABgiEmVFDQMgEiAHKwMoIhRlRQ0DIAdBEGohCQJAAkAgFSAFIgJBBHQiCiAEKAIAaiIHKwAAIhJlRSASIBZlRXINACATIAcrAAgiEmVFIBIgFGVFcg0AAkAgFSALKAIQIgIrABAiEmVFIBIgFmVFcg0AIBMgAisAGCISZUUNAEHc2QMhCCASIBRlDQYLIAQoAgxFDQEgASAHKQMINwN4IAEgBykDADcDcCABIAEpA8gCNwNoIAEgASkDwAI3A2AgAUHgAWogAUHwAGogAUHgAGogCRCPBSAEKAIAIAVBA2siAkEEdGoiAyABKQPgATcDACADIAEpA+gBNwMIIAErA8ACIRIgASsD4AEhEyAKQRBrIgsgBCgCAGoiAyABKwPIAiABKwPoASIUoEQAAAAAAADgP6I5AwggAyASIBOgRAAAAAAAAOA/ojkDACABKwPIAiESIAQoAgAiAyAKaiIHIAErA8ACIAMgC2oiAysAAKBEAAAAAAAA4D+iOQMAIAcgEiADKwAIoEQAAAAAAADgP6I5AwggBCgCACIDIApqQSBrIgcgEyADIAtqIgMrAACgRAAAAAAAAOA/ojkDACAHIBQgAysACKBEAAAAAAAA4D+iOQMIIAQoAggiA0UNCCAGIAQoAgAgAiACIAFBoAJqIAMQjQYhAgwICwNAIAJFDQdBACEIA0AgCEEERgRAIAFB4AFqIAkQwwpFBEAgAkEDayECDAMLQQAhCANAIAhBBEcEQCAEKAIAIAIgCGtBBHRqIgcgAUHgAWogCEEEdGoiAykDADcDACAHIAMpAwg3AwggCEEBaiEIDAELCyACQQNrIQIgBCgCCCIDRQ0KIAYgBCgCACACIAVBA2sgAUGgAmogAxCNBiECDAoFIAFB4AFqIAhBBHRqIgcgBCgCACACIAhrQQR0aiIDKQMANwMAIAcgAykDCDcDCCAIQQFqIQgMAQsACwALAAtBiIIBQZW6AUGUA0HJmgEQAAALQYiCAUGVugFB6gJByZoBEAAAC0H9gQFBlboBQdgCQcmaARAAAAsgACAOEB0hDgwHCyAGIAMgBigCAEEDcUEDRhsoAigQISEDIAYgDCAGKAIAQQNxQQJGGygCKBAhIQIgASAGQentABAmNgI4IAEgAjYCNCABIAM2AjBBACAIIAFBMGoQHwtBACECIAQoAghFDQEgASAEKQMQNwOwAiABIAQpAxg3A7gCDAELQQAhAiAEKAIIRQ0AIAQoAgAhAyABIAQpAxg3A1ggASAEKQMQNwNQIAEgAykDCDcDSCABIAMpAwA3A0AgAUHgAWogAUHQAGogAUFAayAJEI8FIAEgASkD6AE3A7gCIAEgASkD4AE3A7ACCyABIAUgAmtBAWoiBTYCpAIgBUGAgICAAUkEQEEAIAUgBUEQEE0iAxtFBEAgASADNgKgAkEAIQgDQCAFIAhNBEAgBCgCABAZIAYoAhAoAggoAgAgAUGgAmpBMBAjGgwEBSABKAKgAiAIQQR0aiIDIAQoAgAgAkEEdGoiBSkDADcDACADIAUpAwg3AwggAkEBaiECIAhBAWohCCABKAKkAiEFDAELAAsACyABIAVBBHQ2AiBBmNwGKAIAQfvPAyABQSBqECAQKQALIAFBEDYCFCABIAU2AhBBmNwGKAIAQazQAyABQRBqECAQKQALIAAgBhAtIQYMAAsACwsgEBBzGiABQdACaiQACwvsAgEEfyMAQSBrIgMkACADQQA2AhggA0IANwMQIAEiBEUEQCADQRBqIgRBABCOCgsgABBuIQICQAJAAkACQANAIAIEQCACECEiBUUNAgJAIAVBkjZBBxDGAUUEQCACQfAkQaACQQEQLhogAhCDBiAEIAIQjgogAkEAEN8GDAELIAIgBBDfBgsgAhBtIQIMAQsLAkAgAQ0AIAMoAhQiAUEBayICQQBIDQIgACgCECIEIAI2ArQBIAFBAk8EQAJAIAEgAygCGCICTwRAIAMoAhAhAgwBCyACQf////8DTw0FIAMoAhAgAUECdCIBED8iAkUNBiAAKAIQIQQLIAQgAjYCuAEMAQsgA0EANgIUIAMoAhAQGQsgA0EgaiQADwtBqMoBQdD7AEEKQaH2ABAAAAtB2sMBQeq0AUHAAkG3KBAAAAtB16gDQaT8AEHMAEGHsAEQAAALIAMgATYCAEGY3AYoAgBB+88DIAMQIBApAAvnAgEEfyMAQSBrIgMkACADQQA2AhggA0IANwMQIAEiBEUEQCADQRBqIgRBABCSCgsgABBuIQICQAJAAkACQANAIAIEQCACECEiBUUNAgJAIAVBkjZBBxDGAUUEQCACQfAkQaACQQEQLhogBCACEJIKIAJBABDgBgwBCyACIAQQ4AYLIAIQbSECDAELCwJAIAENACADKAIUIgFBAWsiAkEASA0CIAAoAhAiBCACNgK0ASABQQJPBEACQCABIAMoAhgiAk8EQCADKAIQIQIMAQsgAkH/////A08NBSADKAIQIAFBAnQiARA/IgJFDQYgACgCECEECyAEIAI2ArgBDAELIANBADYCFCADKAIQEBkLIANBIGokAA8LQajKAUHQ+wBBCkGh9gAQAAALQdrDAUHatAFBwQBBtygQAAALQdeoA0Gk/ABBzABBh7ABEAAACyADIAE2AgBBmNwGKAIAQfvPAyADECAQKQAL0AEBAn8gABBuIQEDQCABBEAgARDhBiABEG0hAQwBCwsCQCAAQfAkQQBBARAuRQ0AIAAoAhAoArgBEBkgACgCECgCkAIQGSAAKAIQKALYARAZAkAgACgCECICKALEAUUNACACKALsASEBA0AgASACKALwAUpFBEAgAigCxAEgAUEGdGooAgwQGSABQQFqIQEgACgCECECDAELCyACKALEASEBIAIoAuwBQX9GBEAgAUFAahAZDAELIAEQGQsgABAyIABGDQAgACgCECgCDBCzAQsLCwAgACABQQIQ4wYLPgECfCABtyEDA0BBxP0KKAIAIAJKBEAQuwEhBCAAKAIQKAKUASACQQN0aiAEIAOiOQMAIAJBAWohAgwBCwsL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IAcoAmAiAUUNACABLQBRRQ0AIAEgDyABKwM4ojkDOCABQUBrIgEgDSABKwMAojkDAAsCQCAHKAJkIgFFDQAgAS0AUUUNACABIBMgASsDOKA5AzggAUFAayIBIBIgASsDAKA5AwALIAcoAmgiAUUNAyABLQBRRQ0DIAEgESABKwM4oDkDOCABQUBrIgEgECABKwMAoDkDAAwDCyACKAIEIgpBAWshCyACKAIAIQFBACEFIAQgCUchDANAIAUgCkYEQCACKAIIBEAgAiARIAIrAxCgOQMQIAJBGGogECACKwMYoDkDAAsgAigCDARAIAIgEyACKwMgoDkDICACQShqIBIgAisDKKA5AwALIARBAWohBCACQTBqIQIMAgUgAQJ8IAQgBXJFBEAgASARIAErAwCgOQMAIBAgASsDCKAMAQsgASsDACEOIAwgBSALR3JFBEAgASATIA6gOQMAIBIgASsDCKAMAQsgASAPIA6iOQMAIA0gASsDCKILOQMIIAVBAWohBSABQRBqIQEMAQsACwALAAsgACAGEB0hBgwCCyAAIAMQLSEDDAALAAsACyAAEBwhAQNAIAEEQCABKAIQKAKUASICIA8gAisDAKI5AwAgAiANIAIrAwiiOQMIIAAgARAdIQEMAQsLIAAgDyANELgKQQEhAwsgABAcIQEDQCABBEAgASgCECICIAIoApQBIgQrAwBEAAAAAAAAUkCiOQMQIAIgBCsDCEQAAAAAAABSQKI5AxggACABEB0hAQwBCwsgAwsOACAAEMYCIABBARCNBQurrAEENn8HfAh9AX4jAEGwAWsiEyQAAkAgAUHDNhAmIgUEQCAFEIsCIQUMAQtByAEhBQJAAkAgAkEBaw4EAgEBAAELQR4hBQwBCyABEDNB5ABsIQULQcD9CiAFNgIAAkACQCABIAIQqAoiCEECSA0AQcD9CigCAEEASA0AAkACQAJAAkAgAg4FAAICAgECCwJAAkACQAJAIANBAWsOAwEAAwILQQAhACABIAggE0H4AGpBAEECQQAQxwoiAigCCCEFIAIgCBD7BiACIAgQ3wohBCACIAggBRD6BgNAIAAgCEcEQCAEIABBAnQiB2ohBkEAIQUDQCAFIAhHBEAgASgCECgCoAEgB2ooAgAgBUEDdGogBigCACAFQQJ0aigCALc5AwAgBUEBaiEFDAELCyAAQQFqIQAMAQsLIAQoAgAQGSAEEBkgAhDbCgwFCyAIIAhEAAAAAAAAAAAQ0gIhBCAIIAhEAAAAAAAAAAAQ0gIhBSABEBwhAgNAIAIEQCABIAIQaiEAA0AgAARAIAAgACgCAEEDcSIGQQNHQTBsaigCKCgCAEEEdiIHIABBUEEAIAZBAkcbaigCKCgCAEEEdiIGRwRAIAQgBkECdGooAgAgB0EDdGpEAAAAAAAA8L8gACgCECsDiAGjIjs5AwAgBCAHQQJ0aigCACAGQQN0aiA7OQMACyABIAAgAhBwIQAMAQsLIAEgAhAdIQIMAQsLAkAgCCAEIAUQ2goiBkUNAEEAIQIgCEEAIAhBAEobIQsDQCACIAtGDQEgBSACQQJ0IglqIQ1BACEAA0AgACAIRwRAIABBA3QiByABKAIQKAKgASAJaigCAGogDSgCACIMIAJBA3RqKwMAIAUgAEECdGooAgAgB2orAwCgIAcgDGorAwAiOyA7oKE5AwAgAEEBaiEADAELCyACQQFqIQIMAAsACyAEENECIAUQ0QIgBg0EIBMgARAhNgJgQQBB+fMDIBNB4ABqEB9BA0H4xQRBABAfQQNB8PsDQQAQH0EDQfHDBEEAEB8LIAEgCBCgCgwDCyABIAgQoAogARAcIQcDQCAHRQ0DIAEgBxArIQUDQCAFBEAgBSAFKAIAQQNxIgJBA0dBMGxqKAIoKAIAQQR2IgAgBUFQQQAgAkECRxtqKAIoKAIAQQR2IgJHBEAgASgCECgCoAEiBCACQQJ0aigCACAAQQN0aiAFKAIQKwOIASI7OQMAIAQgAEECdGooAgAgAkEDdGogOzkDAAsgASAFEC0hBQwBCwsgASAHEB0hBwwACwALIAEhCEEAIQVBACEEIwBB4ABrIgskAEGd9QMhAAJAAkACQCADQQFrDgMBAgACC0Hp9QMhAAtBACEDQQAgAEEAEB8LIAgQMyENQYj9Ci0AAARAQerVAUE3QQFBmNwGKAIAEEUaQYyECxCiAQsgDUEAIA1BAEobIQxBACEAA0AgACAMRwRAIAUgBUEBaiIBIAgoAhAoApgBIABBAnRqKAIAKAIQLQCHAUEBSyICGyEFQQAgDSABayACGyAEaiEEIABBAWohAAwBCwsgBEEQEBohCSAIEBwhAUEAIQUCQAJAAkADQCABBEAgASgCECgCiAEgBkcNAiAIIAEQaiEAA0AgAARAIAUgACAAKAIAQQNxIgJBA0dBMGxqKAIoIABBUEEAIAJBAkcbaigCKEdqIQUgCCAAIAEQcCEADAELCyAGQQFqIQYgCCABEB0hAQwBCwtBAUEYEBoiAiAGQQFqQQQQGiIANgIEIAtB0ABqIAYQ7AYgAiALKQNQNwIIIAIgBUEEEBo2AhAgBUEEEBohASACIAY2AgAgAiABNgIUIAVBAE4EQCACQQhqIQogACAGQQJ0aiAFNgIAIAgQHCEGQQAhAQJAAkADQCAGBEAgAUEASA0DIAIoAgQgB0ECdGogATYCACAKIAcgBigCEC0AhwFBAUsQlQQgCCAGEGohAANAIAAEQCAAIAAoAgBBA3EiEkEDR0EwbGooAigiBSAAQVBBACASQQJHG2ooAigiEkcEQCABQQJ0Ig4gAigCEGogEiAFIAUgBkYbKAIQKAKIATYCACACKAIUIA5qIAAoAhArA4gBtiJCOAIAIEJDAAAAAF5FDQUgAUEBaiEBCyAIIAAgBhBwIQAMAQsLIAdBAWohByAIIAYQHSEGDAELCyACKAIAIAdGBEAgAUEATgRAIAIoAgQiEiAHQQJ0aiIAKAIAIAFGBEAgACABNgIAAkAgAw4DCQgACAsgC0HQAGogBxDsBiALQcgAaiAHEOwGQQAhAANAIAAgB0YEQCALQdAAahDrBiALQcgAahDrBkEAIQMMCgsgEiAAQQFqIgFBAnRqIQ4gEiAAQQJ0aiIRKAIAIQVBACEPA0AgDigCACIAIAVNBEAgESgCACEDA0AgACADTQRAIBEoAgAhBQNAIAAgBU0EQCABIQAMBgUgC0HQAGogAigCECAFQQJ0aigCAEEAEJUEIAVBAWohBSAOKAIAIQAMAQsACwALIBIgAigCECIUIANBAnQiFmooAgBBAnRqIhAoAgAhAEEAIQZBACEVA0AgECgCBCIFIABNBEACQCACKAIUIBZqIA8gFWogBkEBdGsiALI4AgAgAEEASg0AQdqKA0GsugFB9gBBhg8QAAALBSAUIABBAnRqKAIAIQUgCyALKQJINwNAIAtBQGsgBRCUBEUEQCALQcgAaiAFQQEQlQQgCyALKQJQNwM4IBVBAWohFSALQThqIAUQlAQgBmohBgsgAEEBaiEADAELCyAQKAIAIQADQCAAIAVPBEAgA0EBaiEDIA4oAgAhAAwCBSALQcgAaiAUIABBAnRqKAIAQQAQlQQgAEEBaiEAIBAoAgQhBQwBCwALAAsABSACKAIQIAVBAnRqKAIAIQAgCyALKQJQNwMwIAtBMGogABCUBEUEQCALQdAAaiAAQQEQlQQgD0EBaiEPCyAFQQFqIQUMAQsACwALAAtBrr8BQay6AUHTAEGGDxAAAAtB88IBQay6AUHSAEGGDxAAAAtB6OgAQay6AUHRAEGGDxAAAAtB8IoDQay6AUHMAEGGDxAAAAtB88IBQay6AUHCAEGGDxAAAAtB88IBQay6AUE9QYYPEAAAC0GAMEGsugFBLkGGDxAAAAtB/ZABQay6AUGGAUGGDxAAAAsgAyEAA0AgACAMRwRAIAgoAhAoApgBIABBAnRqKAIAKAIQLQCHAUEBTQRAAn8gCSADQQR0aiEVQQAhASMAQSBrIgUkACACKAIAELABIRIgAigCABCwASEHIAIoAgAhBgNAIAEgBkYEQCAHIABBAnQiAWpBADYCACACKAIEIAFqIg4oAgAiASAOKAIEIg4gASAOSxshDgJAA0AgASAORgRAIAZBAE4EQCAFQRBqIAAgEiAHIAYQ4wpBACEGIAVBADYCDANAAkAgBUEQaiAFQQxqIBIgBxDiCkUNACAHIAUoAgwiAUECdCIQaioCACJCQ///f39bDQAgBSACKQAIIko3AxggASBKQiCIpyIOTw0PAkAgACABTARAIAFBA3YgBUEYaiBKpyAOQSFJG2otAABBASABQQdxdHFFDQELIBUgBkEEdGoiDkMAAIA/IEIgQpSVOAIMIA4gQjgCCCAOIAE2AgQgDiAANgIAIAZBAWohBgsgAigCBCIPIBBqKAIAIQEDQCABIA8gEGooAgRPDQIgAUECdCIOIAIoAhBqKAIAIg9BAEgNBiAFQRBqIA8gQiACKAIUIA5qKgIAkiASIAcQ4QogAUEBaiEBIAIoAgQhDwwACwALCyAFKAIQEBkgEhAZIAcQGSAFQSBqJAAgBgwGCwUgByABQQJ0Ig8gAigCEGooAgBBAnRqIAIoAhQgD2oqAgA4AgAgAUEBaiEBDAELC0GfwwFByroBQbQCQdilARAAAAtBmcIBQcq6AUHKAkHYpQEQAAAFIAcgAUECdGpB////+wc2AgAgAUEBaiEBDAELAAsACyADaiEDCyAAQQFqIQAMAQsLAkAgAyAERgRAIAIoAgQQGSAKEOsGIAIoAhAQGSACKAIUEBkgAhAZQYj9Ci0AAARAIAsQiQE5AyBBmNwGKAIAQdiuBCALQSBqEDALQQEgBCAEQQFMGyEBQQEhACAJKgIMIkIhQwNAIAAgAUcEQCAJIABBBHRqKgIMIkQgQiBCIERdGyFCIEQgQyBDIEReGyFDIABBAWohAAwBCwtBACEAQcD9CigCACEFQbj9CisDACE7IAggDRClCgJ8AkACQAJAAkBDAACAPyBDlSJDIDsgQrujtpW7Iju9IkpCAFkEQCBKQiCIpyIBQf//P0sNAQtEAAAAAAAA8L8gOyA7oqMgO71C////////////AINQDQQaIEpCAFkNASA7IDuhRAAAAAAAAAAAowwECyABQf//v/8HSw0CQYCAwP8DIQJBgXghAyABQYCAwP8DRwRAIAEhAgwCCyBKpw0BRAAAAAAAAAAADAMLIDtEAAAAAAAAUEOivSJKQiCIpyECQct3IQMLIAMgAkHiviVqIgFBFHZqtyI8RAAA4P5CLuY/oiBKQv////8PgyABQf//P3FBnsGa/wNqrUIghoS/RAAAAAAAAPC/oCI7IDsgO0QAAAAAAAAAQKCjIj0gOyA7RAAAAAAAAOA/oqIiPiA9ID2iIj0gPaIiOyA7IDtEn8Z40Amawz+iRK94jh3Fccw/oKJEBPqXmZmZ2T+goiA9IDsgOyA7RERSPt8S8cI/okTeA8uWZEbHP6CiRFmTIpQkSdI/oKJEk1VVVVVV5T+goqCgoiA8RHY8eTXvOeo9oqAgPqGgoCE7CyA7CyAFQQFrt6MhQSANQQF0QQQQGiECIA1BARAaIQcDQCAAIAxHBEAgAiAAQQN0aiIBIAgoAhAoApgBIABBAnRqKAIAKAIQIgMoApQBIgUrAwC2OAIAIAEgBSsDCLY4AgQgACAHaiADLQCHAUECSToAACAAQQFqIQAMAQsLQZjcBigCACEGQYj9Ci0AAARAQZLXAUEOQQEgBhBFGkGMhAsQogELQQAhAEEAIQEDQCABQfAERwRAIAFBAnRBvMAKaiAANgIAIAFBAWoiASAAQR52IABzQeWSnuAGbGohAAwBCwtB/NMKQfAENgIAIARBACAEQQBKGyESIEG2jCFEIEO7ITtBACEFA0ACQCAEIQAgBUHA/QooAgBODQADQCAAQQJOBEAgAEEBayIABH8gAEEBdiAAciIBQQJ2IAFyIgFBBHYgAXIiAUEIdiABciIBQRB2IAFyIQ0DQEEAIQMCQEH80wooAgAiAUHwBEYEQANAQeMBIQEgA0HjAUYEQANAIAFB7wRHBEAgAUECdEG8wApqIgMgA0GMB2soAgAgAUEBaiIBQQJ0QbzACmooAgAiDkH+////B3EgAygCAEGAgICAeHFyQQF2c0EAIA5BAXFrQd/hosh5cXM2AgAMAQsLQQEhA0H40wpB7MwKKAIAQbzACigCACIBQf7///8HcUH40wooAgBBgICAgHhxckEBdnNBACABQQFxa0Hf4aLIeXFzNgIADAMFIANBAnRBvMAKaiIBIAFBtAxqKAIAIANBAWoiA0ECdEG8wApqKAIAIg5B/v///wdxIAEoAgBBgICAgHhxckEBdnNBACAOQQFxa0Hf4aLIeXFzNgIADAELAAsACyABQQFqIQMgAUECdEG8wApqKAIAIQELQfzTCiADNgIAIA0gAUELdiABcyIBQQd0QYCtsel5cSABcyIBQQ90QYCAmP5+cSABcyIBQRJ2IAFzcSIBIABLDQALIAEFQQALIQMgCyAJIABBBHRqIgEpAgg3A1ggCyABKQIANwNQIAEgCSADQQR0aiIDKQIINwIIIAEgAykCADcCACADIAspA1g3AgggAyALKQNQNwIADAELCyBEIAWylLsQ2gwgO6K2IUZBACEAA0AgACASRwRAIAIgCSAAQQR0aiIDKAIAIg5BA3RqIg0qAgQiRyACIAMoAgQiD0EDdGoiASoCBJMiQkMAAIA/IAMqAgwgRpQiQyBDQwAAgD9eGyANKgIAIkUgASoCAJMiQyBCEM0MIkIgAyoCCJOUIEIgQpKVIkiUIUIgQyBIlCFDIAcgDmotAAAEQCANIEUgQ5M4AgAgDSBHIEKTOAIECyAHIA9qLQAABEAgASBDIAEqAgCSOAIAIAEgQiABKgIEkjgCBAsgAEEBaiEADAELC0EAIQBBiP0KLQAABEBDAAAAACFCA0AgACASRwRAIAkgAEEEdGoiASoCDCACIAEoAgBBA3RqIgMqAgAgAiABKAIEQQN0aiINKgIAkyADKgIEIA0qAgSTEM0MIAEqAgiTIkMgQ5SUIEKSIUIgAEEBaiEADAELCyALIEK7OQMAIAZBg4UBIAsQMAsgBUEBaiEFDAELC0EAIQBBiP0KLQAABEAgCxCJATkDECAGQcCuBCALQRBqEDALIAkQGQNAIAAgDEcEQCAIKAIQKAKYASAAQQJ0aigCACgCECgClAEiASACIABBA3RqIgMqAgC7OQMAIAEgAyoCBLs5AwggAEEBaiEADAELCyACEBkgBxAZIAtB4ABqJAAMAQtBhStBrLoBQbUBQeGlARAAAAsMAgtBxP0KKAIAIQUgASAIIAJBAkdBAXQQyQohByABIAFBAEGuF0EAECJBAkEAEE4iBkEAIAZBA0gbRQRAIBNBrhc2AkBBAEHf/QMgE0FAaxAfQQIhBgsgBUEEEBoiEiAFIAhsQQgQGiILNgIAQQFBxP0KKAIAIgUgBUEBTBshCUEBIQUCQAJAA0AgBSAJRgRAAkAgBiAGQQRyIAcbIQVBiP0KLQAABEAgE0G4/QorAwA5AzAgEyADNgIgIBMgB0U2AiQgEyAFQQNxNgIoIBNBwP0KKAIANgIsQZjcBigCACIHQfGNBCATQSBqEDBBoLMDQQ9BASAHEEUaQYyECxCiAUGe8gNBDUEBIAcQRRoLIAEgCCATQawBaiACIAMgE0GoAWoQxwohDkGI/QotAAAEQCATEIkBOQMYIBMgCDYCEEGY3AYoAgBBha4EIBNBEGoQMAsCQCACQQFHBEAgASABQQBBn9sAQQAQIkQAAAAAAAAAAET////////v/xBUIT0gAkECRgRAIAghBCATKAKoASEAQcT9CigCACENQcD9CigCACErQQAhAkEAIQhBACEJIwBBMGsiESQAIBFBADYCLCARQQA2AigCQAJAIA4oAhBFDQAgBEEAIARBAEobIR4DQCAWIB5HBEBBASEKQQEgDiAWQRRsaiIHKAIAIgYgBkEBTBshBgNAIAYgCkcEQCACIAcoAhAgCkECdGoqAgBDAAAAAFxyIQIgCkEBaiEKDAELCyAWQQFqIRYMAQsLIAJBAXFFDQACQAJAIAVBBHEiGgRAAkAgDUEDSA0AQX8hG0EAIQogDiAEIBJBBGogACANQQFrIgIgBSADQQ8Q5QZBAEgNBSASIAJBAnRqIQIDQCAKIB5GDQEgCkEDdCIHIAIoAgBqIBIoAgQgB2orAwA5AwAgCkEBaiEKDAALAAsgEigCACEHQX8hGyAOIAQgEigCBCIMIAQQtQoNAiAOIAQgDCARQSxqIBFBKGogEUEkahD4Bg0CIBEoAiQiBkEATARAIBEoAigQGQwECwJAID1EAAAAAAAAAABkRQ0AIAZBAWshC0EAIQUgESgCKCEPIBEoAiwhAANAIAUgBkYNASAEIQIgO0QAAAAAAAAAACA9IDsgDCAAIA8gBUECdGoiECgCACIKQQJ0aiIVKAIAQQN0aisDAKAgDCAVQQRrKAIAQQN0aisDAKGhIjsgO0QAAAAAAAAAAGMboCE7IAUgC0gEQCAQKAIEIQILIAIgCiACIApKGyECA0AgAiAKRwRAIAwgACAKQQJ0aigCAEEDdGoiECA7IBArAwCgOQMAIApBAWohCgwBCwsgBUEBaiEFDAALAAsgDUECRw0BAn9BuP0KKwMAIUAgBEEAIARBAEobIQUgBEEEEBohDyAEQQgQGiEKQQAhC0EAIQYCQCAOKAIIBEAgDiAEEN8KIQIMAQsgBEEAIARBAEobIQAgBCAEbBCwASEQIAQQsAEhAgNAIAAgBkYEQANAIAAgC0YNAyALIA4gBCACIAtBAnRqKAIAEMoDIAtBAWohCwwACwAFIAIgBkECdGogECAEIAZsQQJ0ajYCACAGQQFqIQYMAQsACwALA0AgBSAIRwRAIAIgCEECdGohBkEAIQADQCAAIARHBEAgBigCACAAQQJ0aiILIAsoAgBBCHQ2AgAgAEEBaiEADAELCyAIQQFqIQgMAQsLIAwEQEEBIAQgBEEBTBshF0EBIQgDQCAIIBdHBEAgDCAIQQN0aisDACE/IAIgCEECdGooAgAhC0EAIQADQCAAIAhHBEBEAAAAAAAA8D8gCyAAQQJ0aigCACIGt6MgPyAMIABBA3RqKwMAoZkiO6IgPKAhPEQAAAAAAADwPyAGIAZst6MgO6IgO6IgPqAhPiAAQQFqIQAMAQsLIAhBAWohCAwBCwtEAAAAAAAAAAAgPCA+oyA+vUL///////////8Ag0KAgICAgICA+P8AURshO0EAIQADQCAAIAVHBEAgDCAAQQN0aiIIIDsgCCsDAKI5AwAgAEEBaiEADAELC0EAIQAgBCAEbCIYQQQQGiEIIARBBBAaIQsDQCAAIAVHBEAgCyAAQQJ0aiAIIAAgBGxBAnRqNgIAIABBAWohAAwBCwsgBLIhQkQAAAAAAAAAACE+QQAhCCAEQQQQGiEGA0AgBSAIRwRAIAIgCEECdCIQaiEVRAAAAAAAAAAAITxBACEAA0AgACAERwRAIBUoAgAgAEECdGooAgC3Ij8gP6IiPyA8oCE8ID8gPqAhPiAAQQFqIQAMAQsLIAYgEGogPLYgQpU4AgAgCEEBaiEIDAELCyA+tiAYspUhQkEBIQgDQCAFIAlHBEAgCyAJQQJ0IhBqKAIAIRQgBiAQaioCACFDIAIgEGooAgAhFkEAIQADQCAAIAhHBEAgFCAAQQJ0IhVqIAYgFWoqAgAgQyAVIBZqKAIAsiJEIESUk5IgQpMiRDgCACALIBVqKAIAIBBqIEQ4AgAgAEEBaiEADAELCyAIQQFqIQggCUEBaiEJDAELCyAGEBlBACEAQQFBCBAaIRQgBEEIEBohBkEAIQgDQCAFIAhGBEBEAAAAAAAAAAAhPANAIAAgBUcEQCA8IAYgAEEDdGorAwCgITwgAEEBaiEADAELCyA8IAS3oyE8QQAhAANAIAAgBUcEQCAGIABBA3RqIgggCCsDACA8oTkDACAAQQFqIQAMAQsLIAYgBEEBayIQEJMDIjyZRAAAAAAAALA8Y0UEQCAEIAZEAAAAAAAA8D8gPKMgBhDjAQtBASAEIARBAEobIRlEAAAAAAAA8D8gQKEhPkEAIQkgBEEIEBohFSAEQQgQGiEWAkADQAJAQQAhACAJIBlODQADQCAAIARHBEAgByAAQQN0ahCgAUHkAG+3OQMAIABBAWohAAwBCyAGRQ0DIAcgECAEIAYgBxCdAZogBhCaBEEAIQAgByAQEJMDIjxEu73X2d982z1jDQALIAQgB0QAAAAAAADwPyA8oyAHEOMBA0AgBCAHIBYQhgJBACEIA0AgBSAIRwRAIAsgCEECdGohHEQAAAAAAAAAACE8QQAhAANAIAAgBUcEQCAcKAIAIABBAnRqKgIAuyAHIABBA3RqKwMAoiA8oCE8IABBAWohAAwBCwsgFSAIQQN0aiA8OQMAIAhBAWohCAwBCwsgFSAQIAQgFSAGEJ0BmiAGEJoEIAQgFSAHEIYCIAcgEBCTAyI8RLu919nffNs9Yw0BIAQgB0QAAAAAAADwPyA8oyAHEOMBIAQgByAWEJ0BIj+ZID5jDQALIBQgPCA/ojkDAEEBIQkMAQsLA0BBACEAAkAgCSAZSARAA0AgACAERg0CIAcgAEEDdGoQoAFB5ABvtzkDACAAQQFqIQAMAAsACyAVEBkgFhAZA0AgACAFRwRAIAcgAEEDdGoiCCAIKwMAIBQrAwCZn6I5AwAgAEEBaiEADAELCyALKAIAEBkgCxAZIBQQGSAGEBlBACEIIBhBBBAaIRBBASEJA0AgBSAIRgRAQQAhBgNAIAkgF0YEQANAIAUgBkYEQEEAIQBBACEJA0ACQCAAQQFxRSAJQccBTXFFBEBBACEGIDuZRAAAAAAAALA8Yw0BQQAhAANAIAAgBUYNAiAMIABBA3QiCGoiCyALKwMAIDujOQMAIAcgCGoiCCAIKwMAIDujOQMAIABBAWohAAwACwALQQAhCEEBIQYgDyAHIAogBCBAIARBARDNCkEASA0AA0AgBSAIRwRAIA8gCEECdCIAaiELIAAgAmohECAHIAhBA3QiFWorAwAhP0QAAAAAAAAAACE8QQAhAANAIAAgBEcEQAJAIAAgCEYNACAAQQJ0IhQgECgCAGooAgCyIAsoAgAgFGoqAgCMlLshPiAHIABBA3RqKwMAID9lBEAgPCA+oCE8DAELIDwgPqEhPAsgAEEBaiEADAELCyA8IAogFWoiACsDACI+YUQAAAAAAADwPyA8ID6joZlE8WjjiLX45D5kRXJFBEAgACA8OQMAQQAhBgsgCEEBaiEIDAELCyAGQQFxIQAgCUEBaiEJDAELCyACKAIAEBkgAhAZIA8oAgAQGSAPEBkgChAZIAYMDAUgByAGQQN0IgBqKwMAIT4gACAKaiIIQgA3AwAgDyAGQQJ0IgBqIQsgACACaiEJQQAhAEQAAAAAAAAAACE8A0AgACAERwRAIAAgBkcEQCAIIDwgAEECdCIQIAkoAgBqKAIAsiALKAIAIBBqKgIAjJS7Ij+gIDwgP6EgPiAHIABBA3RqKwMAZhsiPDkDAAsgAEEBaiEADAELCyAGQQFqIQYMAQsACwAFIAIgCUECdCIIaigCACELIAwgCUEDdGorAwAhPEEAIQADQCAAIAlHBEAgCyAAQQJ0IhBqIhUoAgC3Ij4gPqIgPCAMIABBA3RqKwMAoSI+ID6ioSI+RAAAAAAAAAAAZCEUIAIgEGooAgAgCGoCfyA+nyI+mUQAAAAAAADgQWMEQCA+qgwBC0GAgICAeAtBACAUGyIQNgIAIBUgEDYCACAAQQFqIQAMAQsLIAlBAWohCQwBCwALAAUgDyAIQQJ0IgZqIBAgBCAIbEECdGoiCzYCACACIAZqIRVBACEAQwAAAAAhQgNAIAAgBEcEQCAAIAhHBEAgCyAAQQJ0IhRqQwAAgL8gFSgCACAUaigCALIiQyBDlJUiQzgCACBCIEOTIUILIABBAWohAAwBCwsgBiALaiBCOAIAIAhBAWohCAwBCwALAAsgBCAHRAAAAAAAAPA/IAcgEBCTA6MgBxDjASAUQgA3AwBBASEJDAALAAtBzsoBQa+zAUHiAEGn/QAQAAAFIAYgCEEDdCIJaiAJIAxqKwMAOQMAIAhBAWohCAwBCwALAAtBnskBQa+zAUGYAkHm6gAQAAALRQ0BDAILIAQgDSASIAAQ6gYaQX8hGyAOIARBACARQSxqIBFBKGogEUEkahD4Bg0BCyAEQQFGBEAgESgCKBAZQQAhGwwDCyArRQRAIBEoAigQGUEAIRsMAwtBiP0KLQAABEBBjIQLEKIBCwJAAkACfwJAAkACQCADQQFrDgMBAAIEC0GI/QotAAAEQEGA7wBBGEEBQZjcBigCABBFGgsgDiAEEOYGDAILIA4gBBDpBiIZDQNBAEGt9ANBABAfQQNB+MUEQQAQHwwCC0GI/QotAAAEQEGZ7wBBFUEBQZjcBigCABBFGgsgDiAEEOgGCyIZDQELQYj9Ci0AAARAQfIsQRpBAUGY3AYoAgAQRRoLIA4gBBCFBSEZC0GI/QotAAAEQCAREIkBOQMQQZjcBigCACIAQdeuBCARQRBqEDBBnCpBGUEBIAAQRRpBjIQLEKIBCyAEQQFrIg8gBGxBAm0hBQJAIBoNAEEAIQAgDUEAIA1BAEobIQJEAAAAAAAA8D8hOwNAIAAgAkcEQCASIABBAnRqIQNBACEKA0AgCiAeRwRAIDsgAygCACAKQQN0aisDAJkQMSE7IApBAWohCgwBCwsgAEEBaiEADAELC0QAAAAAAAAkQCA7oyE7QQAhAANAIAAgAkYNASASIABBAnRqIQNBACEKA0AgCiAeRwRAIAMoAgAgCkEDdGoiCCA7IAgrAwCiOQMAIApBAWohCgwBCwsgAEEBaiEADAALAAsgBCAFaiEmRAAAAAAAAAAAITsCQCA9RAAAAAAAAAAAZEUNAEEAIQAgD0EAIA9BAEobIQggBbIhQkEAIQIDQCAAIAhHBEAgAEEBaiIDIQoDQCACQQFqIQIgBCAKTARAIAMhAAwDBSA7IBIgDSAAIAoQ3gogGSACQQJ0aioCALujoCE7IApBAWohCgwBCwALAAsLQQAhCiAmQQAgJkEAShshACA7IEK7o7YhQgNAIAAgCkYNASAZIApBAnRqIgIgAioCACBClDgCACAKQQFqIQoMAAsAC0EAIQogDUEAIA1BAEobIR8DQCAKIB9HBEAgBCASIApBAnRqKAIAELwCIApBAWohCgwBCwsgEigCBCIAKwMAITtBACEKA0AgCiAeRwRAIAAgCkEDdGoiAiACKwMAIDuhOQMAIApBAWohCgwBCwtBACEAIA1BBBAaIRogBCANbCIIQQQQGiECA0AgACAfRwRAIBogAEECdCIDaiACIAAgBGxBAnRqIgc2AgAgAyASaiEDQQAhCgNAIAogHkcEQCAHIApBAnRqIAMoAgAgCkEDdGorAwC2OAIAIApBAWohCgwBCwsgAEEBaiEADAELC0EAIQBBiP0KLQAABEAgERCJATkDAEGY3AYoAgBBrLIBIBEQMAsgBbIhSSAmIBkQmQQgJiAZEPcGIAQgBEEIEBoiIBCQBSAPQQAgD0EAShshMCAEIQVBACECA0AgACAwRgRAAkBBACEKIAQhAkEAIQADQCAKIB5GDQEgGSAAQQJ0aiAgIApBA3RqKwMAtjgCACAAIAJqIQAgCkEBaiEKIAJBAWshAgwACwALBUEBIAUgBUEBTBshByAgIABBA3RqIQNBASEKRAAAAAAAAAAAITsDQCACQQFqIQIgByAKRwRAIAMgCkEDdGoiBiAGKwMAIBkgAkECdGoqAgC7IjyhOQMAIApBAWohCiA7IDygITsMAQsLIAMgAysDACA7oTkDACAFQQFrIQUgAEEBaiEADAELCyANQQQQGiIhIAhBBBAaIgA2AgBBASANIA1BAUwbIQJBASEKA0AgAiAKRwRAICEgCkECdGogACAEIApsQQJ0ajYCACAKQQFqIQoMAQsLICBBCGohMyA9tiFGIEm7ITxE////////738hPSAEQQQQGiEjIARBBBAaISQgJkEEEBohJSARKAIsIQAgESgCKCECIBEoAiQhA0EBQSwQGiIMIAM2AiggDCACNgIkIAwgADYCICAMIAQ2AgQgDCAZIAQQsQo2AgAgDCAEQQQQGjYCECAMIARBBBAaNgIUIAwgBEEEEBo2AhggDCAEQQQQGjYCHCAMIARBBBAaNgIIIAwgBEEEEBo2AgxBACEWQQAhGwJAA0AgFkEBcSAbICtOckUEQCAEICAQkAUgJiAZICUQ9gZBACEGIA8hAEEAIQdBACEWA0AgByAwRgRAIAQhAEEAIRYDQEEAIQogBiAeRgRAQQAhAANAIAAgH0YEQAJARAAAAAAAAAAAITsDQCAKIB9GDQEgOyAEIBogCkECdCIAaigCACAAICFqKAIAELsCoCE7IApBAWohCgwACwALBSAlIAQgGiAAQQJ0IgJqKAIAIAIgIWooAgAQ1AIgAEEBaiEADAELCyA7IDugIDygITtBACEKA0AgCiAfRwRAIBkgBCAaIApBAnRqIgAoAgAgIxDUAiAKQQFqIQogOyAEIAAoAgAgIxC7AqEhOwwBCwtBACEKIBtBAUsgOyA9ZHFBuP0KKwMAIDsgPaEgPUS7vdfZ33zbPaCjmWRyIRYDQAJAIAogH0cEQCAKQQFGBEAgISgCBCE0QQAhBkEAIQdBACEsIBooAgQhGCAMKAIoIRAgDCgCJCEtIAwoAgAhLiAMKAIEIglBACAJQQBKGyEvIAwoAiAiFEEEayECQyhrbs4hQkF/IQtBACEAA0AgBiAvRwRAIAAgBkwEQCAJIQAgECALQQFqIgtHBEAgLSALQQJ0aigCACEACyAGBH0gGCACIAZBAnRqKAIAQQJ0aioCACBGkgVDKGtuzgshQiAAQQFrIgMgBkoEQCAUIAZBAnRqIAMgBmtBAWpBKiAYEN0KCwsgQiAYIBQgBkECdGooAgBBAnRqIgMqAgBeBEAgAyBCOAIACyAGQQFqIQYMAQsLIAwoAgwhHCAMKAIIIRcgDCgCGCEpIAwoAhQhMSAMKAIQISdBfyEAQQAhBgNAIAYgL0cEQAJAIAYgB0gNACAAQQFqIQIgCSEHIAIgECIARg0AIC0gAkECdGooAgAhByACIQALIBwgFCAGQQJ0aigCAEECdGogADYCACAGQQFqIQYMAQsLIDFBBGsiMiAJQQJ0aiE1IAlBAWshFSAMKAIcISJBACEGA0ACQCAsQQ9ODQBDKGtuziFHQQAhC0EBIQIgBkEBcQ0AA0AgCSALIgNKBEBDAAAAACFCIBggFCADIgVBAnRqKAIAIgZBAnRqKgIAIkQhQwNAICIgBkECdGogQjgCACAFQQFqIQ0CQAJ/IAUgFUYEQCAVIQUgCQwBCyAYIBQgDUECdCIAaigCACIGQQJ0aioCACJCIEMgRkMAAACAIAAgHGooAgAgHCAFQQJ0aigCAEobkiJDk4u7RJXWJugLLhE+ZEUNASANCyELIAMhCANAIAUgCEgEQEEAIQYgAyEAA0ACQCAAIAVKBEBBACEHIAZBACAGQQBKGyEoQwAAAAAhRUMAAAAAIUMMAQsgCyEIIBAgHCAUIABBAnRqKAIAQQJ0aigCACIHRwRAIAggLSAHQQJ0aigCACIIIAggC0obIQgLIAggACAAIAhIGyEdIAAhBwNAIAcgHUYEQAJAIAAhBwNAIAcgHUYNASBEICcgFCAHQQJ0aigCACIoQQJ0aioCAFsEQCAXIAZBAnRqICg2AgAgBkEBaiEGCyAHQQFqIQcMAAsACwUgRCAnIBQgB0ECdGooAgAiKEECdGoqAgBeBEAgFyAGQQJ0aiAoNgIAIAZBAWohBgsgB0EBaiEHDAELCwNAIAAgHUYEQCAIIQAMAwUgRCAnIBQgAEECdGooAgAiB0ECdGoqAgBdBEAgFyAGQQJ0aiAHNgIAIAZBAWohBgsgAEEBaiEADAELAAsACwsDQAJAIAcgKEcEQCAuIBcgB0ECdCIqaigCAEECdCIIaigCACEdQQAhAEMAAAAAIUIDQCAAIAdGDQIgQiAdIBcgAEECdGooAgBBAnRqKgIAkyFCIABBAWohAAwACwALIAYgCUciNkUEQCA1IEQ4AgALQwAAAAAhRUMAAAAAIUMgBkEBayIdIQgDQCAIQQBOBEAgLiAXIAhBAnQiN2ooAgBBAnQiB2ooAgAhKkMAAAAAIUIgCCEAA0AgBiAAQQFqIgBKBEAgQiAqIBcgAEECdGooAgBBAnRqKgIAkyFCDAELCyApIDdqIEIgQpIiQiBElCBDIEWUIAcgJ2oqAgAgByAqaiIAKgIAIkWUk5IgQiBDIEWTkpUiRTgCACAIQQFrIQggQyBCIAAqAgCTkiFDDAELCyA2RQRAICkgRDgCAAtBACEARAAAAAAAAAAAIT1BfyEHA0AgACAoRwRAICkgAEECdCIIaioCACFCAkAgAARAIEIgCCAyaioCACJDXUUNASBCIERdBEAgRCBDIEMgRF4bIkMhQgwCCyBDIEReRQ0BCyBCIUMLIAYgAGu3IEIgRJOLu6IgALcgQyBEk4u7oqAiPiA9ID0gPmMiCBshPSAAIAcgCBshByAAQQFqIQAMAQsLIAdBAE4EQCApIAdBAnQiAGoqAgAiRSFCIAcEQCAAIDJqKgIAIUILQyhrbk4hQyAJIA1MIghFBEAgGCAUIAtBAnRqKAIAQQJ0IgBqKgIAIEZDAAAAACAAIBxqKAIAIBwgFCAFQQJ0aigCAEECdGooAgBKG5MgIiAXIB1BAnRqKAIAQQJ0aioCAJMhQwsCQCBFIEMgQyBFXhsiQyBCIEcgQiBHXhsiQl1FDQAgQyBEXQRAIEQgQiBCIEReGyJCIUMMAQsgQiBEXkUNACBDIUILQQAhAANAIAAgB0YEQCAGIAcgBiAHShshAANAIAAgB0cEQCAYIBcgB0ECdGooAgBBAnQiBmogQyAGICJqKgIAkjgCACAHQQFqIQcMAQsLAn0CQCAIDQAgHCAUIAtBAnRqKAIAQQJ0aigCACAcIBQgBUECdGooAgBBAnRqKAIATA0AIBggFyAdQQJ0aigCAEECdGoqAgAgRpIMAQsgGCAXIB1BAnRqKAIAQQJ0aioCAAshRyADIQYDQCAFIAZOBEAgFCAGQQJ0aiAXIAYgA2tBAnRqKAIANgIAIAZBAWohBgwBCwsgAiE4QQAhAiA4RSBCIESTi7tEexSuR+F6hD9jRXINCiBDIESTi7tEexSuR+F6hD9jIQIMCgUgGCAXIABBAnRqKAIAQQJ0Ig1qIEIgDSAiaioCAJI4AgAgAEEBaiEADAELAAsACwJAIAkgDUwNACAcIBQgC0ECdGooAgBBAnRqKAIAIBwgFCAFQQJ0aigCAEECdGooAgBMDQAgGCAXIB1BAnRqKAIAQQJ0aioCACBGkiFHDAgLIBggFyAdQQJ0aigCAEECdGoqAgAhRwwHCyAqIDFqIEIgQpIiQiBElCBDIEWUIAggJ2oqAgAgCCAdaiIAKgIAIkWUk5IgQiBDIEWTkpUiRTgCACAHQQFqIQcgQyBCIAAqAgCTkiFDDAALAAUgLiAUIAhBAnRqKAIAIh1BAnQiAGooAgAhByAAIDRqKgIAjCFCQQAhBgNAIAYgL0cEQCAGIB1HBEAgByAGQQJ0IihqKgIAIBggKGoqAgCUIEKSIUILIAZBAWohBgwBCwsgACAnaiBCIAAgB2oqAgCMlSAAICJqKgIAkzgCACAIQQFqIQgMAQsACwALIEIgRJMhQiANIQUMAAsACwsgCSAYENUCICxBAWohLCACIQYMAQsLDAILIBkgGiAKQQJ0IgBqKAIAIAAgIWooAgAgBCAEEJgERQ0BQX8hGwwJCyAbQQFqIRsgOyE9DAcLIApBAWohCgwACwAFICUgFkECdGogICAGQQN0aisDALY4AgAgACAWaiEWIAZBAWohBiAAQQFrIQAMAQsACwAFIABBACAAQQBKGyEDIARDAAAAACAkEMkDIAdBf3MgBGohAkEAIQoDQCAKIB9HBEAgAiAHQQJ0IgUgGiAKQQJ0aiIIKAIAaioCACAjEMkDIAIgI0MAAIC/IAgoAgAgBWpBBGoQkQUgAiAjEJkEIAIgIyAkICQQ0AogCkEBaiEKDAELCyACICQQ9QZBACEKA0ACQCADIApGBEAgMyAHQQN0IgJqIQVBACEKRAAAAAAAAAAAITsDQCAWQQFqIRYgAyAKRg0CICUgFkECdGoiCCAkIApBAnRqKgIAIAgqAgCUIkI4AgAgBSAKQQN0aiIIIAgrAwAgQrsiPqE5AwAgOyA+oCE7IApBAWohCgwACwALICQgCkECdGoiAioCACJCQ///f39gIEJDAAAAAF1yBEAgAkEANgIACyAKQQFqIQoMAQsLIAIgIGoiAiACKwMAIDuhOQMAIABBAWshACAHQQFqIQcMAQsACwALCyAaBEBBACEAA0AgACAfRwRAIBIgAEECdCICaiEDIAIgGmohAkEAIQoDQCAKIB5HBEAgAygCACAKQQN0aiACKAIAIApBAnRqKgIAuzkDACAKQQFqIQoMAQsLIABBAWohAAwBCwsgGigCABAZIBoQGQsgIxAZICQQGSAgEBkgGRAZICUQGQsgDARAIAwoAgAoAgAQGSAMKAIAEBkgDCgCEBAZIAwoAhQQGSAMKAIYEBkgDCgCHBAZIAwoAggQGSAMKAIMEBkgDBAZCyAhKAIAEBkgIRAZCyARKAIsEBkgESgCKBAZDAELIA4gBCASIAAgDSAFIAMgKxDlBiEbCyARQTBqJAAgGyEFDAILIBMgARAzIgI2AmwgE0EANgJoIAJBIU8EQCATIAJBA3YgAkEHcUEAR2pBARAaNgJoC0EBQRwQGiINIAEQMzYCEEEAIQYgABBuIQUDQCAFBEAgBRAhQZI2EOIBIAZqIQYgBRBtIQUMAQsLIA0gBjYCBCANQQA2AgAgDSAGQQQQGiILNgIMIA0gBkEEEBoiCTYCCCAAEG4hAANAIAAEQAJAIAAQIUGSNhDiAUUNACAJIAAQMyICNgIAIA0gAiANKAIAaiIPNgIAIAsgCSgCAEEEEBoiBzYCACALQQRqIQsgCUEEaiEJIAAQHCECA0AgAkUNAUEAIQYgARAcIQUDQAJAIAVFDQAgAigCACAFKAIAc0EQSQ0AIAZBAWohBiABIAUQHSEFDAELCyAHIAY2AgAgEygCbCIFIAZNDQYgBkEDdiATQegAaiATKAJoIAVBIUkbaiIFIAUtAABBASAGQQdxdHI6AAAgDSANKAIQQQFrNgIQIAdBBGohByAAIAIQHSECDAALAAsgABBtIQAMAQsLIA0gDSgCBEEgEBo2AhggDSANKAIQIgJBBBAaIgc2AhQgE0H4AGogEykDaCJKpyILIEpCIIinIgBBIUkbIQlBACEFQQAhBgNAIAEQMyAFSgRAIBMgSjcDeCAAIAVGDQsgCSAFQQN2ai0AACAFQQdxdkEBcUUEQCAHIAZBAnRqIAU2AgAgBkEBaiEGCyAFQQFqIQUMAQsLIAIgARAzIA9rRw0FIABBIU8EQCALEBkLIAhBEBAaIR4gEyANNgKkASATIB42AqABIBMgPTkDgAECQCABQdolECYiABCEAQRAIBNBATYCeEGI/QotAABFDQFB/8sEQR9BAUGY3AYoAgAQRRoMAQsCQCAARQ0AIABB2jdBBBD3AQ0AIBNBAjYCeEGI/QotAABFDQFBn8wEQShBAUGY3AYoAgAQRRoMAQsgE0EANgJ4CwJAAkACQAJAIAQoAgBBEGsOAgEAAgsgE0EBNgKIAUGI/QotAABFDQJB2MsEQSZBAUGY3AYoAgAQRRoMAgsgE0ECNgKIAUGI/QotAABFDQFByMwEQSRBAUGY3AYoAgAQRRoMAQsgE0EANgKIAQsgE0HoAGogARDWAkQcx3Ecx3G8PyE7RBzHcRzHcbw/IT0gEy0AcEEBcQRAIBMqAmi7RAAAAAAAAFJAoyI7IDugIT0gEyoCbLtEAAAAAAAAUkCjIjsgO6AhOwsgEyA7OQOYASATID05A5ABQQAhBkGI/QotAAAEQCATIDs5AwggEyA9OQMAQZjcBigCAEG/jQQgExAwCyABEBwhBQNAIAUEQCAeIAZBBHRqIgAgBSgCECICKwMgOQMAIAAgAisDKDkDCCAGQQFqIQYgASAFEB0hBQwBCwsgEygCqAEhAEHE/QooAgAhEUHA/QooAgAhHyATQfgAaiEQQQAhBEEAIQsjAEHgAGsiDyQAIAggESASIAAQ6gYaAkAgCEEBRg0AIAhBACAIQQBKGyEXA0AgBCAXRwRAQQEhCUEBIA4gBEEUbGoiACgCACICIAJBAUwbIQIDQCACIAlHBEAgACgCCCAJQQJ0aioCACJDIEIgQiBDXRshQiAJQQFqIQkMAQsLIARBAWohBAwBCwsgH0UNAEGI/QotAAAEQEGMhAsQogELAkACQAJ/AkACQAJAIANBAWsOAwEAAgQLQYj9Ci0AAARAQYDvAEEYQQFBmNwGKAIAEEUaCyAOIAgQ5gYMAgsgDiAIEOkGIgUNA0EAQa30A0EAEB9BA0H4xQRBABAfDAILQYj9Ci0AAARAQZnvAEEVQQFBmNwGKAIAEEUaCyAOIAgQ6AYLIgUNAQtBiP0KLQAABEBB8ixBGkEBQZjcBigCABBFGgsgDiAIEIUFIQULQQAhAkGI/QotAAAEQCAPEIkBOQNQQZjcBigCACIAQdeuBCAPQdAAahAwQZwqQRlBASAAEEUaQYyECxCiAQsgEUEAIBFBAEobIRUgCEEBayIHIAhsQQJtITlEAAAAAAAA8D8hOwNAIAIgFUcEQCASIAJBAnRqIQNBACEJA0AgCSAXRwRAIAMoAgAgCUEDdGorAwCZIj0gOyA7ID1jGyE7IAlBAWohCQwBCwsgAkEBaiECDAELC0QAAAAAAAAkQCA7oyE7QQAhBEEAIQIDQCACIBVGBEADQCAEIBVHBEAgCCASIARBAnRqKAIAELwCIARBAWohBAwBCwsFIBIgAkECdGohA0EAIQkDQCAJIBdHBEAgAygCACAJQQN0aiIGIDsgBisDAKI5AwAgCUEBaiEJDAELCyACQQFqIQIMAQsLIBIoAgQiAisDACE7QQAhCQNAIAkgF0cEQCACIAlBA3RqIgMgAysDACA7oTkDACAJQQFqIQkMAQsLIDkgCGohGEGI/QotAAAEQCAPEIkBOQNAQZjcBigCAEGssgEgD0FAaxAwCyAYIAUQmQQgGCAFEPcGAkAgECgCLCgCBCIAQQBMBEAgBSEDIAghAAwBC0MAAIA/IEIgQpQiQpUgQiBCQwrXIzxeGyFDIABBAXQgCGoiAEEAIABBAEobIQwgAEEBayIHIABsQQJtIABqIhhBBBAaIQMgACEGQQAhBEEAIQIDQCAEIAxHBEAgBkEAIAZBAEobIQogBEEBcSEUIAggBGshFkEAIQkDQCAJIApHBEACQCAEIAhOIAkgFk5yRQRAIAUgAkECdGoqAgAhQiACQQFqIQIMAQtDAAAAACBDIAlBAUcbQwAAAAAgFBshQgsgAyALQQJ0aiBCOAIAIAlBAWohCSALQQFqIQsMAQsLIAZBAWshBiAEQQFqIQQMAQsLIAUQGQsgACAAQQgQGiIUEJAFQQAhCyAHQQAgB0EAShshIyAAIQJBACEEA0AgBCAjRwRAQQEgAiACQQFMGyEGIBQgBEEDdGohBUQAAAAAAAAAACE7QQEhCQNAIAtBAWohCyAGIAlHBEAgBSAJQQN0aiIMIAwrAwAgAyALQQJ0aioCALsiPaE5AwAgCUEBaiEJIDsgPaAhOwwBCwsgBSAFKwMAIDuhOQMAIAJBAWshAiAEQQFqIQQMAQsLQQAhCyAAQQAgAEEAShshICAAIQJBACEJA0AgCSAgRwRAIAMgC0ECdGogFCAJQQN0aisDALY4AgAgAiALaiELIAlBAWohCSACQQFrIQIMAQsLQQAhBCARQQQQGiEMIAAgEWwiAkEEEBohBQNAIAQgFUcEQCAMIARBAnQiBmogBSAAIARsQQJ0aiILNgIAIAYgEmohBkEAIQkDQCAJICBHBEAgCyAJQQJ0aiAIIAlKBH0gBigCACAJQQN0aisDALYFQwAAAAALOAIAIAlBAWohCQwBCwsgBEEBaiEEDAELCyARQQQQGiIKIAJBBBAaIgI2AgBBASARIBFBAUwbIQQgACAHbEECbSEFQQEhCQNAIAQgCUcEQCAKIAlBAnRqIAIgACAJbEECdGo2AgAgCUEBaiEJDAELC0F/IQsgAEEEEBohESAAQQQQGiEWAkACQAJAIAAgAyAOIBBBABDuBiIbRQ0AIAAgAyAOIBAgECgCABDuBiIaRQ0AIB9BAWshJiAUQQhqISdBmNwGKAIAIRwgBbK7IT5E////////738hPSAYQQQQGiEZRAAAAAAAAAAAITtBACEEQQAhCwNAIARBAXEgCyAfTnJFBEAgACAUEJAFIBggAyAZEPYGQQAhISAHIQVBACECQQAhBgNAIAYgI0YEQCAAIQJBACEEA0BBACEJIAQgIEYEQEEAIQQDQCAEIBVGBEACQEQAAAAAAAAAACE7A0AgCSAVRg0BIDsgACAMIAlBAnQiAmooAgAgAiAKaigCABC7AqAhOyAJQQFqIQkMAAsACwUgGSAAIAwgBEECdCICaigCACACIApqKAIAENQCIARBAWohBAwBCwsgOyA7oCA+oCE7QQAhCQNAIAkgFUcEQCADIAAgDCAJQQJ0aiICKAIAIBEQ1AIgCUEBaiEJIDsgACACKAIAIBEQuwKhITsMAQsLAkBBiP0KLQAARQ0AIA8gOzkDMCAcQfawAyAPQTBqEDAgC0EKbw0AIBwQqQQLQQAhBEEAIQIgECgCECEJIDsgPWMEQEG4/QorAwAgOyA9oSA9RLu919nffNs9oKOZZCECCwJAIAJFIAsgJkhxDQAgPEQrhxbZzvfvP2NFIAlBAUdyRQRAIDxEmpmZmZmZuT+gITxBiP0KLQAABH8gDyALNgIoIA8gPDkDICAcQaCiBCAPQSBqEDAgECgCEAVBAQshCUEAIQsMAQsgAiEECyA8RPyp8dJNYlA/ZEUgCUEBR3JFBEAgGyA8tiAMQQAgPEQAAAAAAADgP2YgEBCJBQsCQAJAAkACQCAbKAIUQQBKBEAgGyAKKAIAIAwoAgAQsAoaDAELIAMgDCgCACAKKAIAIAAgABCYBEEASA0BCyA8RPyp8dJNYlA/ZEUgECgCEEEBR3JFBEAgGiA8tiAMQQFBACAQEIkFCyAaKAIUQQBMDQEgGiAKKAIEIAwoAgQQsApBAE4NAgtBfyELDAkLIAMgDCgCBCAKKAIEIAAgABCYBBoLIAtBAWohCyA7IT0MBQUgGSAhQQJ0aiAUIARBA3RqKwMAtjgCACACICFqISEgBEEBaiEEIAJBAWshAgwBCwALAAUgBUEAIAVBAEobISQgAEMAAAAAIBYQyQMgACAGQX9zaiEJQQAhBANAIAQgFUcEQCAJIAZBAnQiJSAMIARBAnRqIiIoAgBqKgIAIBEQyQMgCSARQwAAgL8gIigCACAlakEEahCRBSAJIBEQmQQgCSARIBYgFhDQCiAEQQFqIQQMAQsLIAkgFhD1BkEAIQkDQAJAIAkgJEYEQCAnIAZBA3QiBGohJUQAAAAAAAAAACE7QQAhCQNAIAJBAWohAiAJICRGDQIgGSACQQJ0aiIiIBYgCUECdGoqAgAgIioCAJQiQjgCACAlIAlBA3RqIiIgIisDACBCuyJAoTkDACA7IECgITsgCUEBaiEJDAALAAsgFiAJQQJ0aiIEKgIAIkJD//9/f2AgQkMAAAAAXXIEQCAEQQA2AgALIAlBAWohCQwBCwsgBCAUaiIEIAQrAwAgO6E5AwAgBUEBayEFIAZBAWohBgwBCwALAAsLQYj9Ci0AAARAIA8QiQE5AxAgDyALNgIIIA8gOzkDACAcQbStBCAPEDALIBsQ7QYgGhDtBiAQKAIQQQJHDQAgCCAMIBAQrwoLIAxFDQELQQAhBANAIAQgFUcEQCASIARBAnQiAGohAiAAIAxqIQBBACEJA0AgCSAXRwRAIAIoAgAgCUEDdGogACgCACAJQQJ0aioCALs5AwAgCUEBaiEJDAELCyAEQQFqIQQMAQsLIAwoAgAQGSAMEBkLIAooAgAQGSAKEBkgERAZIBYQGSAUEBkgAxAZIBkQGQsgD0HgAGokACALIQUgDSgCBEEASgRAIA0oAgwoAgAQGSANKAIMEBkgDSgCCBAZIA0oAhQQGSANKAIYEBkLIA0QGSAeEBkMAQsgDiAIIBIgEygCqAFBxP0KKAIAIAUgA0HA/QooAgAQ5QYhBQsgBUEASARAQQNB4JoEQQAQHwwFCyABEBwhBwNAIAdFDQVBACEFQcT9CigCACIAQQAgAEEAShshACAHKAIQIgIoAogBQQN0IQMDQCAAIAVGBEAgASAHEB0hBwwCBSACKAKUASAFQQN0aiASIAVBAnRqKAIAIANqKwMAOQMAIAVBAWohBQwBCwALAAsACwUgEiAFQQJ0aiALIAUgCGxBA3RqNgIAIAVBAWohBQwBCwtBlaADQf/5AEHQAEH2HxAAAAtB3ihBzrQBQfABQYvaABAAAAsgDhDbCiASKAIAEBkgEhAZIBMoAqgBEBkMAQsgASAIEKUKQQAhAiMAQeAAayIEJABBiP0KLQAABEBBhrMDQRlBAUGY3AYoAgAQRRpBjIQLEKIBCyAIQQAgCEEAShshCyABKAIQIgAoAqABIQYgACgCpAEhBQNAIAIgC0cEQCAFIAJBAnQiB2ohCSAGIAdqIQ1BACEAA0AgACACRwRARAAAAAAAAPA/IABBA3QiDCANKAIAaisDACI7IDuioyE7IAEgASgCECgCmAEiEiAHaigCACASIABBAnQiDmooAgBBAEEAEFAiEgRAIDsgEigCECsDgAGiITsLIAUgDmooAgAgAkEDdGogOzkDACAJKAIAIAxqIDs5AwAgAEEBaiEADAELCyACQQFqIQIMAQsLQQAhAkHE/QooAgAiAEEAIABBAEobIQUDf0EAIQAgAiALRgR/IAEoAhAiBSgCmAEhCUEABQNAIAAgBUcEQCABKAIQKAKoASACQQJ0aigCACAAQQN0akIANwMAIABBAWohAAwBCwsgAkEBaiECDAELCyEGA0ACQAJAIAkgBkECdCIHaigCACIMBEBBACECQcT9CigCACIAQQAgAEEAShshEgNAIAIgC0YNAgJAIAIgBkYNAEEAIQAgDCgCECgClAEgCSACQQJ0Ig5qKAIAKAIQKAKUASAEQRBqEKQKITsDQCAAIBJGDQEgAEEDdCINIAUoAqwBIAdqKAIAIA5qKAIAaiACQQN0Ig8gBSgCpAEgB2ooAgBqKwMAIARBEGogDWorAwAiPSA9IAUoAqABIAdqKAIAIA9qKwMAoiA7o6GiIj05AwAgBSgCqAEgB2ooAgAgDWoiDSA9IA0rAwCgOQMAIABBAWohAAwACwALIAJBAWohAgwACwALQYj9Ci0AAARAIAQQiQE5AwBBmNwGKAIAQdmuBCAEEDALIARB4ABqJAAMAQsgBkEBaiEGDAELC0GI/QotAAAEQCATIAM2AlAgE0HA/QooAgA2AlQgE0G4/QorAwA5A1hBmNwGKAIAQaqOBCATQdAAahAwQYyECxCiAQsgASEEIwBBoAFrIgYkAEGg1ApBuP0KKwMAIjsgO6I5AwAgCEEAIAhBAEobIQxBmNwGKAIAIQ0DQAJAQbTUCkG01AooAgBBAWoiBzYCACAEKAIQIgMoApwBQcD9CigCAE4NAEEAIQVBxP0KKAIAIgBBACAAQQBKGyELRAAAAAAAAAAAIT1BACEBA0AgBSAMRwRAAkAgBUECdCIJIAMoApgBaigCACICKAIQLQCHAUEBSw0ARAAAAAAAAAAAITtBACEAA0AgACALRwRAIAMoAqgBIAlqKAIAIABBA3RqKwMAIjwgPKIgO6AhOyAAQQFqIQAMAQsLIDsgPWRFDQAgOyE9IAIhAQsgBUEBaiEFDAELCyA9QaDUCisDAGMNAAJAQYj9Ci0AAEUgB0HkAG9yDQAgBiA9nzkDQCANQfawAyAGQUBrEDBBtNQKKAIAQegHbw0AIA0QqQQLIAFFDQBBxP0KKAIAIgAgAGxBA3QhACABKAIQKAKIASESQQAhA0G41AoCf0G41AooAgAiAgRAIAIgABCyAQwBCyAAEP0BCyIFNgIAQcT9CigCACICQQAgAkEAShshCSAEKAIQIg4oApgBIhAgEkECdCILaigCACEVIA4oAqABITogDigCpAEhDwNAIAMgCUcEQCAFIAIgA2xBA3RqIQpBACEAA0AgACACRwRAIAogAEEDdGpCADcDACAAQQFqIQAMAQsLIANBAWohAwwBCwsgAkEBaiEKIDogC2ohESALIA9qIRRBACEHA38gByAMRgR/QQEgAiACQQFMGyEHQQEFAkAgByASRg0AIBAgB0ECdGooAgAhD0QAAAAAAAAAACE7QQAhAANAIAAgCUcEQCAAQQN0IgMgBkHQAGpqIBUoAhAoApQBIANqKwMAIA8oAhAoApQBIANqKwMAoSI9OQMAID0gPaIgO6AhOyAAQQFqIQAMAQsLRAAAAAAAAPA/IDufIj0gPSA9oqKjIT1BACEDA0AgAyAJRg0BIAdBA3QiACARKAIAaiEWIBQoAgAgAGohFyAFIANBA3QiAGohGCAGQdAAaiAAaiEPQQAhAANAIBYrAwAhPCAXKwMAIT4gACADRwRAIBggACACbEEDdGoiGSA+IDyiIA8rAwCiIAZB0ABqIABBA3RqKwMAoiA9oiAZKwMAoDkDACAAQQFqIQAMAQsLIAUgAyAKbEEDdGoiACA+RAAAAAAAAPA/IDsgDysDACI+ID6ioSA8oiA9oqGiIAArAwCgOQMAIANBAWohAwwACwALIAdBAWohBwwBCwshAwNAAkAgAyAHRwRAIAUgA0EDdGohDyAFIAIgA2xBA3RqIRBBACEAA0AgACADRg0CIBAgAEEDdGogDyAAIAJsQQN0aisDADkDACAAQQFqIQAMAAsAC0EAIQADQCAAIAlHBEAgAEEDdCIDQZDVCmogDigCqAEgC2ooAgAgA2orAwCaOQMAIABBAWohAAwBCwtBACEAQQAhB0EAIQkgAiIDQQAgAkEAShshDiACIAJsIg8QwQEhECACEMEBIRUCQANAIAcgDkYEQAJAA0AgACAPRwRAIBAgAEEDdCICaiACIAVqKwMAOQMAIABBAWohAAwBCwsgA0EBayIUQQAgFEEAShshFkEAIQIDQCACIBZHBEAgAyACIAIgA0gbIQcgBSACQQN0IgpqIRFEAAAAAAAAAAAhOyACIQADQCAAIAdHBEAgOyARIAAgA2xBA3RqKwMAmSI9IDsgPWQiFxshOyAJIAAgFxshCSAAQQFqIQAMAQsLIDtEu73X2d982z1jDQIgBSACIANsQQN0aiERIAUgAyAJbEEDdGohFyACIQADQCAAIAdHBEAgFyAAQQN0IhhqIhkrAwAhOyAZIBEgGGoiGCsDADkDACAYIDs5AwAgAEEBaiEADAELCyAJQQN0QZDVCmoiACsDACE7IAAgCkGQ1QpqIhcrAwA5AwAgFyA7OQMAIAogEWohGCACQQFqIgIhBwNAIAMgB0wNAiAHQQN0QZDVCmoiACAFIAMgB2xBA3RqIhkgCmorAwCaIBgrAwCjIjsgFysDAKIgACsDAKA5AwBBACEAA0AgACAORwRAIBkgAEEDdCIbaiIaIDsgESAbaisDAKIgGisDAKA5AwAgAEEBaiEADAELCyAHQQFqIQcMAAsACwsgBSAPQQN0akEIaysDACI7mUS7vdfZ33zbPWMNACAUQQN0IgBBwNQKaiAAQZDVCmorAwAgO6M5AwAgA0EBaiERQQAhAkEAIQcDQCAHIBZGBEADQCACIA5GBEBBACEAA0AgACAPRg0IIAUgAEEDdCICaiACIBBqKwMAOQMAIABBAWohAAwACwAFIAJBA3QiAEGQ1QpqIAAgFWorAwA5AwAgAkEBaiECDAELAAsABSADIAdrIgBBAmsiCUEDdCIUQcDUCmoiCiAUQZDVCmorAwAiOzkDACAAQQFrIQAgBSADIAlsQQN0aiEUA0AgACADSARAIAogOyAUIABBA3QiF2orAwAgF0HA1ApqKwMAoqEiOzkDACAAQQFqIQAMAQsLIAogOyAFIAkgEWxBA3RqKwMAozkDACAHQQFqIQcMAQsACwALBSAVIAdBA3QiAmogAkGQ1QpqKwMAOQMAIAdBAWohBwwBCwtBnLwKKAIAGgJAQe+pAUHQuwoQgAFBAEgNAAJAQaC8CigCAEEKRg0AQeS7CigCACIAQeC7CigCAEYNAEHkuwogAEEBajYCACAAQQo6AAAMAQtB0LsKEMMHCwsgEBAZIBUQGUEAIQADQEHE/QooAgAiAyAASgRAQdj9CisDACE7ELsBIT0gAEEDdCICQcDUCmoiAyADKwMAIDsgPUQAAAAAAADwPyA7oSI7IDugoqCiIjs5AwAgASgCECgClAEgAmoiAiA7IAIrAwCgOQMAIABBAWohAAwBCwsgBCgCECICIAIoApwBQQFqNgKcAUEAIQAgA0EAIANBAEobIQkgAigCmAEiDiALaigCACEPA0AgACAJRgRAQQAhAANAIAAgDEcEQAJAIAAgEkYNAEEAIQMgDygCECgClAEgDiAAQQJ0IgdqKAIAKAIQKAKUASAGQdAAahCkCiE7A0AgAyAJRg0BIANBA3QiBSACKAKsASIQIAtqKAIAIAdqKAIAaiIVIABBA3QiCiACKAKkASALaigCAGorAwAgBkHQAGogBWorAwAiPSA9IAIoAqABIAtqKAIAIApqKwMAoiA7o6GiIj05AwAgAigCqAEiCiALaigCACAFaiIRIBErAwAgPaA5AwAgByAQaigCACALaigCACAFaiIQKwMAIT0gECAVKwMAmiI8OQMAIAcgCmooAgAgBWoiBSA8ID2hIAUrAwCgOQMAIANBAWohAwwACwALIABBAWohAAwBCwtBqIQLKAIARQ0FQQAhAEHE/QooAgAiAkEAIAJBAEobIQJEAAAAAAAAAAAhOwNAIAAgAkcEQCA7IABBA3RBwNQKaisDAJmgITsgAEEBaiEADAELCyABECEhACAGIDufOQM4IAYgADYCMCANQfOKBCAGQTBqEDAMBQUgAigCqAEgC2ooAgAgAEEDdGpCADcDACAAQQFqIQAMAQsACwALIANBAWohAwwACwALC0EAIQBBiP0KLQAABEBBxP0KKAIAIgFBACABQQBKGyEHQQEgCCAIQQFMG0EBayELRAAAAAAAAAAAIT0DQCAAIAtHBEAgBCgCECICKAKYASIJIABBAnQiBWooAgAhDCAAQQFqIgEhAwNAIAMgCEYEQCABIQAMAwUgCSADQQJ0aigCACESQQAhAEQAAAAAAAAAACE7A0AgACAHRwRAIABBA3QiDiAMKAIQKAKUAWorAwAgEigCECgClAEgDmorAwChIjwgPKIgO6AhOyAAQQFqIQAMAQsLIANBA3QiACACKAKkASAFaigCAGorAwAgAigCoAEgBWooAgAgAGorAwAiPEQAAAAAAAAAwKIgO5+iIDwgPKIgO6CgoiA9oCE9IANBAWohAwwBCwALAAsLIAYgPTkDICANQcKFASAG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UQsgARDGAiANBEAgASgCECEJRAAAAAAAAAAAIRVEAAAAAAAAAAAhFkEAIQxBACEOQQAhDyMAQUBqIgYkACABKAIQIgAoApABIRAgBUHYAGoiAyAAKQMQNwMAIAMgACkDKDcDGCADIAApAyA3AxAgAyAAKQMYNwMIAkAgACgCCCgCWCIKRQ0AAkAgAysDACADKwMQYg0AIAMrAwggAysDGGINACADQv////////93NwMYIANC//////////f/ADcDACADQv/////////3/wA3AwggA0L/////////dzcDEAsgCigCCCEAA0AgDCAKKAIATw0BIAZCADcDOCAGQgA3AzAgBkIANwMoIAZCADcDIAJAAkACQAJAAkACQAJAAkAgACgCAA4QAAABAQICAwQHBwUHBwcHBgcLIAAgACsDECIXIAArAyAiGKAiEzkDaCAAIAArAwgiGyAAKwMYIhygIhQ5A2AgACAXIBihIhc5A1ggACAbIByhIhg5A1AgAyADKwMAIBgQQCAUEEA5AwAgAyADKwMYIBcQMSATEDE5AxggAyADKwMIIBcQQCATEEA5AwggAyADKwMQIBgQMSAUEDE5AxAMBgsgBiAAKAIMIAAoAgggAxDBCCAAIAYpAxg3A2ggACAGKQMQNwNgIAAgBikDCDcDWCAAIAYpAwA3A1AMBQsgBiAAKAIMIAAoAgggAxDBCCAAIAYpAxg3A2ggACAGKQMQNwNgIAAgBikDCDcDWCAAIAYpAwA3A1AMBAsgBiAAKAIMIAAoAgggAxDBCCAAIAYpAxg3A2ggACAGKQMQNwNgIAAgBikDCDcDWCAAIAYpAwA3A1AMAwsgAEE4ENMENgJwIAAoAigQZSELIAAoAnAiESALNgIAIBEgACgCGEHA8wRqLQAAOgAwIAYgGTkDMCAGIA42AiAgBiAGKAI4QYB/cSAPQf8AcXI2AjggECgChAEiCyAGQSBqQQEgCygCABEDACELIAAoAnAiESALNgIEIAYgECAREI8IIAArAxAhFyAAKAJwIgsrAyghGCAAKwMIIRMgCysDICEUAkACQAJAAkAgCywAMEHsAGsOBwADAQMDAwIDCyATIBSgIRYgEyEVDAILIBMgFEQAAAAAAADgP6IiFaAhFiATIBWhIRUMAQsgEyAUoSEVIBMhFgsgCysDECETIAAgFjkDYCAAIBU5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IAAgACgCAEEMaygCAGpBBRC1BQsgAkEIahCzBSACQRBqJAAgAAsMACAAQQRqELEMIAALKAECfyMAQRBrIgIkACABKAIAIAAoAgBIIQMgAkEQaiQAIAEgACADGwsQACAAIAE3AwggAEIANwMACwIACxQAIABBhPcGNgIAIABBBGoQRyAAC9MDAgJ+An8jAEEgayIEJAACQCABQv///////////wCDIgNCgICAgICAwIA8fSADQoCAgICAgMD/wwB9VARAIAFCBIYgAEI8iIQhAyAAQv//////////D4MiAEKBgICAgICAgAhaBEAgA0KBgICAgICAgMAAfCECDAILIANCgICAgICAgIBAfSECIABCgICAgICAgIAIUg0BIAIgA0IBg3whAgwBCyAAUCADQoCAgICAgMD//wBUIANCgICAgICAwP//AFEbRQRAIAFCBIYgAEI8iIRC/////////wODQoCAgICAgID8/wCEIQIMAQtCgICAgICAgPj/ACECIANC////////v//DAFYNAEIAIQIgA0IwiKciBUGR9wBJDQAgBEEQaiAAIAFC////////P4NCgICAgICAwACEIgIgBUGB9wBrEKoBIAQgACACQYH4ACAFaxCgAyAEKQMIQgSGIAQpAwAiAEI8iIQhAiAEKQMQIAQpAxiEQgBSrSAAQv//////////D4OEIgBCgYCAgICAgIAIWgRAIAJCAXwhAgwBCyAAQoCAgICAgICACFINACACQgGDIAJ8IQILIARBIGokACACIAFCgICAgICAgICAf4OEvwtUAAJAIAEEQCABKAIEIAJNDQEgACABKAIAIAJBBHRqIgEpAgA3AgAgACABKQIINwIIDwtBisoBQZi0AUEiQZwhEAAAC0HnoQNBmLQBQSJBnCEQAAALiQIAAkAgAAR/IAFB/wBNDQECQEH0iQsoAgAoAgBFBEAgAUGAf3FBgL8DRg0DDAELIAFB/w9NBEAgACABQT9xQYABcjoAASAAIAFBBnZBwAFyOgAAQQIPCyABQYBAcUGAwANHIAFBgLADT3FFBEAgACABQT9xQYABcjoAAiAAIAFBDHZB4AFyOgAAIAAgAUEGdkE/cUGAAXI6AAFBAw8LIAFBgIAEa0H//z9NBEAgACABQT9xQYABcjoAAyAAIAFBEnZB8AFyOgAAIAAgAUEGdkE/cUGA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IAMrAAAiBSAFoiADKwAIIgYgBqKgIgdEje21oPfGsD5kBEAgBiAHnyIHoyEGIAUgB6MhBQsgAigCBCEKIAIoAgAhAiADIAY5AwggAyAFOQMAIAMrABAiBSAFoiADKwAYIgYgBqKgIgdEje21oPfGsD5kBEAgBiAHnyIHoyEGIAUgB6MhBQsgAyAGOQMYIAMgBTkDEEGUhQtBADYCAAJ/QX9BBBD/B0EASA0AGkGUhQtBlIULKAIAIglBAWo2AgBBmIULKAIAIAlBBHRqIgkgAikDCDcDCCAJIAIpAwA3AwAgCCADKQMINwMYIAggAykDADcDECAIIANBEGopAwg3AwggCCADKQMQNwMAQX8gACABIAIgCiAIQRBqIAgQ/gdBf0YNABogBEGUhQsoAgA2AgQgBEGYhQsoAgA2AgBBAAshCyAIQSBqJAAgCwtEAQJ8An9BASAAKwMIIgIgASsDCCIDREivvJry13o+oGQNABpBACACIANESK+8mvLXer6gYw0AGiAAKwMAIAErAwBmCwtVAgJ8AX8gAUEAIAFBAEobIQEgALciAyECA0AgASAERkUEQCAEQQFqIQQgAhDHByECDAELCyADIAKjmyICmUQAAAAAAADgQWMEQCACqg8LQYCAgIB4C14BAX8gACsDCCABKwMIYQRAAkAgACsDECABKwMQYg0AIAArAxggASsDGGINACAAKAIgIAEoAiBHDQAgACgCJCABKAIkRiECCyACDwtBgZ8BQem2AUG0BkHa7gAQAAAL+1EDH38LfAF+IwBB4AFrIgskACAAEK8CQQgQGiEXQbD9Ci0AAARAEO8DIRgLIABByrsBECYhAkH8hAtBADYCAAJAIAJFDQAgAi0AACIERQ0AA0AgBEH/AXFFDQECQEH8hAsCfwJAAkACQAJAIATAIgRB7QBrDgcBBQUFBQIDAAtBCCAEQeMARg0DGiAEQekARw0EQRIMAwtBAQwCC0EEDAELQQILIANyIgM2AgALIAJBAWoiAi0AACEEDAALAAsgAQRAQQBBl8QEQQAQHwsCfyMAQcACayICJABBAUEcEBoiDiAAIgYQMyIFNgIEIA4gBUHIABAaIgQ2AgxE////////738hIUT////////v/yEiIAAQHCEDRP///////+//ISNE////////738hJCAEIQADQCADBEAgAygCECIBKwMYISYgASsDECElIAErA2AhJyABKwNYISggASsDUCEpIAAgACgCAEEBcjYCACAAQUBrICYgKUQAAAAAAADgP6JEAAAAAAAA8D8QMSIpoCIqOQMAIAAgJiApoSImOQMwIAAgJSAoICegRAAAAAAAAOA/okQAAAAAAADwPxAxIiegIig5AzggACAlICehIiU5AyggAygCECAANgKAASAAQcgAaiEAICIgKhAxISIgISAmEEAhISAjICgQMSEjICQgJRBAISQgBiADEB0hAwwBCwsgAiAhRAAAAAAAAELAoDkDmAIgAiAjRAAAAAAAAEJAoDkDoAIgAiAiRAAAAAAAAEJAoDkDqAIgAiACKQOYAjcD8AEgAiACKQOgAjcD+AEgAiACKQOoAjcDgAIgAiAkRAAAAAAAAELAoDkDkAIgAiACKQOQAjcD6AFBACEAIwBBwAFrIgEkACAFQQJ0IghBBWoiB0E4EBohAyAHQQQQGiEHIAEgAikDgAI3A1ggASACKQP4ATcDUCABIAIpA/ABNwNIIAEgAikD6AE3A0AgBCAFIAFBQGsgA0EAEJQOQa0BEL0HIAhBBGoiCCAHEJMOIAFBuAFqIgogCCADIAcQjA4gAUEANgKwASABQgA3A6gBIAggAyAKQQAgAUGoAWoQkg4gASgCvAEQGSABIAIpA4ACNwM4IAEgAikD+AE3AzAgASACKQPwATcDKCABIAIpA+gBNwMgIAQgBSABQSBqIANBARCUDiAIIAcQkw4gAUGgAWoiCiAIIAMgBxCMDiABQQA2ApgBIAFCADcDkAEgCCADIApBASABQZABahCSDiABKAKkARAZIAFBADYCiAEgAUIANwOAAQNAAkBBACEIIAkgASgClAFPDQADQCABKAKsASAITQRAIAlBAWohCQwDCyABKAKoASAIQQV0aiIKKwMAISEgASgCkAEgCUEFdGoiDSsDACEiIAEgDSsDECAKKwMQEEAiIzkDcCABICIgIRAxIiE5A2AgCisDGCEiIA0rAxghJCABIA0rAwggCisDCBAxIiY5A2ggASAkICIQQCIiOQN4ICIgJmUgISAjZnJFBEAgASABKQN4NwMYIAEgASkDcDcDECABIAEpA2g3AwggASABKQNgNwMAIAFBgAFqIAEQhgQLIAhBAWohCAwACwALCyADEBkgBxAZIAFBqAFqEO8EIAFBkAFqEO8EIAIgASgChAE2AowCIAEoAoABIQcgAUHAAWokAEH8hAstAABBAXEEQCACKAKMAiEIIAIrA5ACISEgAisDoAIhIyACKwOYAiEiIAIrA6gCISRB2LQKKAIAQZjcBigCACIBEIABGiACQoqAgICgATcD0AEgAgJ/ICREAAAAAAAAJECgICKhIiaZRAAAAAAAAOBBYwRAICaqDAELQYCAgIB4CzYC3AEgAgJ/ICNEAAAAAAAAJECgICGhIiaZRAAAAAAAAOBBYwRAICaqDAELQYCAgIB4CzYC2AEgAUHHqQQgAkHQAWoQICACRAAAAAAAACRAICKhOQPIASACRAAAAAAAACRAICGhOQPAASABQe2RBCACQcABahAwQcbrAyABEIABGiAFQQAgBUEAShshCQNAIAAgCUYEQEHs6wMgARCAARpBACEAA0AgACAIRwRAIAcgAEEFdGoiAysDACEmIAMrAwghJSADKwMQIScgAiADKwMYOQOYASACICc5A5ABIAIgJTkDiAEgAiAmOQOAASABQdnzAyACQYABahAwIABBAWohAAwBCwtB2esDIAEQgAEaIAIgJDkDeCACICM5A3AgAiAiOQNoIAIgITkDYCABQdnzAyACQeAAahAwQdy0CigCACABEIABGgUgBCAAQcgAbGoiAysDKCEmIAMrAzAhJSADKwM4IScgAiADQUBrKwMAOQO4ASACICc5A7ABIAIgJTkDqAEgAiAmOQOgASABQbCYBCACQaABahAwIABBAWohAAwBCwsLIA4gAigCjAJByAAQGiIMNgIIIA4gAigCjAIiAzYCAEEAIQADQCAAIANGBEAgBxAZIANBACADQQBKGyERIAIrA6gCISEgAisDoAIhIiACKwOYAiEjIAIrA5ACISRBAUEYEBoiAUEANgIAIAEgA0ECdCIAQQJyQSgQGjYCEEHgtApB/LgKKAIAEH0hCEH4tApB/LgKKAIAEH0hCSAAQSAQGiENIABBBBAaIQNBACEHA0AgByARRwRAIAwgB0HIAGxqIgAgAyAHQQR0ajYCJCAAQQQ2AiAgIiAAKwM4IiZkBEAgAiAmOQOwAiACIAArAzA5A7gCIAIgAikDuAI3A1ggAiACKQOwAjcDUCABIAggAkHQAGogDUEBEOgFIgogADYCFCAAKAIkIAo2AgALICEgAEFAaysD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DQAgCSgCGCAJEJ0ODQAgBygCABCcDiAEKAIAEJwOQQAhBEH8hAstAABBBHEEQEGs4gQgDhCAARogC0KKgICAoAE3A6ABIA5B/pEEIAtBoAFqECBBxusDIA4QgAEaA0AgCSgCBCAETARAQQAhBkT////////vfyEiRP///////+//ISNE////////7/8hJUT////////vfyEkA0AgASAGRgRAAkBBresDIA4QgAEaQQAhBCALQUBrIQIDQCAEIAkoAgBODQEgCSgCCCAEQcgAbGoiACsDKCEhIAArAzAhJiAAKwM4IScgCyAAQUBrKwMAIig5A0ggAiAnOQMAIAsgJjkDOCALICE5AzAgDkHZ8wMgC0EwahAwICQgISAhICRkGyEkICMgKCAjIChkGyEjICUgJyAlICdkGyElICIgJiAiICZjGyEiIARBAWohBAwACwALBSAXIAZBA3QiBGooAgQiByAHKAIAQQNxQQNHQTBsaigCKCgCECgCgAEhACAEIBNqIgQoAAAhBQJAIAQoAAQiAy0AAARAAn8gAEFAaysDACAAKwMwoEQAAAAAAADgP6IiIZlEAAAAAAAA4EFjBEAgIaoMAQtBgICAgHgLIQAgAyAJEOsDIScMAQsgACsDOCAAKwMooEQAAAAAAADgP6IhJyADIAkQ6gMhAAsgCwJ/ICeZRAAAAAAAAOBBYwRAICeqDAELQYCAgIB4CyICNgKQASALIAA2ApQBIA5BrO8DIAtBkAFqECBBASEEQQEgBSAFQQFNGyEFICMgALciISAhICNjGyEnICUgArciIyAjICVjGyElICIgISAhICJkGyEhICQgIyAjICRkGyEkAkACQAJ/A0AgBCAFRgRAAkAgB0FQQQAgBygCAEEDcUECRxtqKAIoKAIQKAKAASEAIAMgBUE4bGpBOGsiAi0AAEUNBCAAQUBrKwMAIAArAzCgRAAAAAAAAOA/oiIimUQAAAAAAADgQWNFDQAgIqoMAwsFAkAgAyAEQThsaiIILQAABEAgCCAJEOsDIiKZRAAAAAAAAOBBYwRAICKqIQIMAgtBgICAgHghAgwBCyAIIAkQ6gMhAAsgCyACNgKAASALIAA2AoQBIA5Bwu8DIAtBgAFqECAgJyAAtyIiICIgJ2MbIScgJSACtyIjICMgJWMbISUgISAiICEgImMbISEgJCAjICMg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ACgCECICKAK0ASAFTgRAIAIoArgBIAVBAnRqKAIAIg0QgwYgCyANECEQ2QYiBygCECICIBA2AogBIAIgDTYC6AECQAJAIAEoAgQiAkUEQET////////vfyEmRP///////+//ISUMAQtE////////738hJkT////////v/yElIA0gAhA3IgYtAABFDQAgDSABKAIARwRAIAYgDSgCRCACEDcQNEUNAQsgCUEAOgCsASAJIAM2AkQgCSAMNgJIIAkgBDYCTCAJIAlBrAFqNgJQIAkgCUGAAWo2AkAgBkHkugEgCUFAaxBIQQROBEAgCSsDmAEhJSAJKwOQASEkIAkrA4gBISYgCSsDgAEhI0GY/QorAwAiJ0QAAAAAAAAAAGQEQCAlICejISUgJCAnoyEkICYgJ6MhJiAjICejISMLIAcoAhBBA0ECQQEgCS0ArAEiAkE/RhsgAkEhRhs6AIcBDAILIA0QISECIAkgBjYCNCAJIAI2AjBBAEGN0QMgCUEwahAfC0T////////v/yEkRP///////+9/ISMLIBBBAWohECANEBwhAgNAIAIEQCACKAIQIAc2ArgBIA0gAhAdIQIMAQsLIAcoAhAiAi0AhwEEQCACKAKUASICICUgJqBEAAAAAAAA4D+iOQMIIAIgJCAjoEQAAAAAAADgP6I5AwALIAVBAWohBQwBCwsgABAcIQICfwJAA0AgAgRAAkAgAigCECIMKAK4AQ0AAkAgDCgC6AEiA0UNACADIAAoAhAoAowBKAIwRg0AIAIQISEBIAAQISEAIAkgAigCECgC6AEQITYCKCAJIAA2AiQgCSABNgIgQQFByN8EIAlBIGoQHwwECyAMIAA2AugBIAwtAIYBDQAgCyACECEQ2QYhAyACKAIQIgYgAzYCuAEgAygCECIFIBA2AogBIAUgBisDIDkDICAFIAYrAyg5AyggBSAGKwNYOQNYIAUgBisDYDkDYCAFIAYrA1A5A1AgBSAGKAIINgIIIAUgBigCDDYCDCAGLQCHASIEBEAgBSgClAEiDCAGKAKUASIDKwMAOQMAIAwgAysDCDkDCCAFIAQ6AIcBCyAQQQFqIRAgBSgCgAEgAjYCCAsgACACEB0hAgwBCwsgABAcIQ4DQCAOBEAgDigCECgCuAEhBSAAIA4QKyECA0AgAgRAIAUgAkFQQQAgAigCAEED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IAIoAgBBA3EiA0EDR0EwbGooAigiBEYEQCACQVBBACADQQJHG2ooAighBAsCQCAEKAIQKAKAASIDKAIgIAFHDQAgAykDMEKAgICAgICAksAAUg0AIAMgBSADKwMoIgZEAAAAAAAA4D+ioDkDMCAFIAagIQUgAykDEFANACAAIAQQmgoLIAAgAiABEHAhAgwBCwsLrQECA38BfCABKAIQKAKAASICKwMoIAIpAwi6oyEFIAAgARBqIQIDQCACBEAgASACIAIoAgBBA3EiA0EDR0EwbGooAigiBEYEQCACQVBBACADQQJHG2ooAighBAsCQCAEKAIQKAKAASIDKAIgIAFHDQAgAysDKEQAAAAAAAAAAGINACADIAUgAykDCLqiOQMoIAMpAxBQDQAgACAEEJsKCyAAIAIgARBwIQIMAQsLCysBAX9BARDBASICIAE2AgAgACgCBCIBQQRqIAAgARsgAjYCACAAIAI2AgQLkAECA38BfiABKAIQKAKAASkDAEIBfCEGIAAgARBqIQMDQCADBEAgASADIAMoAgBBA3EiBUEDR0EwbGooAigiBEYEQCADQVBBACAFQQJHG2ooAighBAsCQCACIARGDQAgBiAEKAIQKAKAASIFKQMAWg0AIAUgBjcDACAAIAQgARCdCgsgACADIAEQcCEDDAELCwu/CwMIfwN+A3wjAEEwayIGJAACQCAAEDNBAUYEQCAAEBwoAhAoApQBIgBCADcDACAAQgA3AwgMAQsCQCAAEDMiA0EATgRAIAOtIgogCn4hCyAAEBwhBANAIARFDQIgBCgCECgCgAEiA0KAgICAgICAksAANwMwIAMgCzcDGEEAIQMgACAEEGohAgNAAkAgAgR+IAQgAiACKAIAQQNxIgdBA0dBMGxqKAIoIgVGBEAgAkFQQQAgB0ECRxtqKAIoIQULIAQgBUYNASADRQRAIAUhAwwCCyADIAVGDQEgCwVCAAshCiAEKAIQKAKAASAKNwMAIAAgBBAdIQQMAgsgACACIAQQcCECDAALAAsAC0HAiwNBtLkBQcsAQeAXEAAACwJAIAENACAAEDMhCCAAEBwhASAIQQNIDQADQCABRQRAQgAhCkEAIQEgABAcIQIDQCACRQ0DIAIoAhAoAoABKQMAIgsgCiAKIAtUIgMbIQogAiABIAMbIQEgACACEB0hAgwACwAL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AWohBQwBCwsgBkECbSEFA0AgBUEASEUEQCAAIAUgAiADEOAKIAVBAWshBQwBCwsL7wEBBH8DQCABQQF0IgRBAXIhBgJAIAAoAgQiBSAESgRAIAMgACgCACIHIARBAnRqKAIAQQJ0aigCACADIAcgAUECdGooAgBBAnRqKAIASA0BCyABIQQLIAUgBkoEQCAGIAQgAyAAKAIAIgUgBkECdGooAgBBAnRqKAIAIAMgBSAEQQJ0aigCAEECdGooAgBIGyEECyABIARHBEAgACgCACIFIARBAnRqIgYoAgAhByAGIAUgAUECdGoiBSgCADYCACAFIAc2AgAgAiAGKAIAQQJ0aiAENgIAIAIgBSgCAEECdGogATYCACAEIQEMAQsLC6oBAQR/Qby/CigCAEUEQEG8vwpBkL4KKAIAQQQQGiIANgIAQYDACiAAQZC+CigCAEECdGo2AgALENQLQby/CigCACEBQZC+CigCACECQQAhAANAIAAgAkYEQCABIAJBBEEpEJcBQYTACkG8vwooAgA2AgAFIAEgAEECdGpB1L4KKAIAIABB4ABsaiIDQQhqNgIAIANBATYCHCADQQA2AlggAEEBaiEADAELCwu7AwEJfyMAQRBrIgQkACAAEBwhAQN/IAEEfyABKAIQIgYtALUBQQdGBH8gARC4DiABKAIQBSAGC0EANgLoASAAIAEQHSEBDAEFQQELCyEFA0ACQCAAKAIQIgEoArQBIAVOBEAgASgCuAEgBUECdGooAgAiAxAcIQEDQCABRQ0CIAMgARAdIQkCQCABKAIQLQC1AQRAIAEQISECIAQgABAhNgIEIAQgAjYCAEEAQfvYAyAEEB8gAyABEK0BDAELIAMoAhAoAowCIQIgARCmASABRwRAQceSA0G+tQFBtwFBlZUBEAAACyABKAIQIgcgAjYC8AEgAigCECICIAIoAuwBIAcoAuwBajYC7AEgASgCECICQQc6ALUBIAIgAzYC6AEgAyABECshAgNAIAJFDQECQCACKAIQKAKwASIBRQ0AA0AgASABQTBrIgcgASgCAEEDcUECRhsoAigoAhAiCC0ArAFBAUcNASAIIAM2AugBIAEgByABKAIAQQNxQQJGGygCKCgCECgCyAEoAgAiAQ0ACwsgAyACEC0hAgwACwALIAkhAQwACwALIARBEGokAA8LIAVBAWoh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AAwgACACaiAIQQxqEMMBIAhBEGokAA8LENMBAAsjAQJ/IAAoAgAiASAAKAIEIgI2AgQgAiABNgIAIABBfjYCCAsNACAAQZTPBzYCACAACxYAIAAgASACQoCAgICAgICAgH8QuwULCQAgABBhNgIACyMBAn8gACEBA0AgASICQQRqIQEgAigCAA0ACyACIABrQQJ1Cw8AIAAgACgCAEEEazYCAAsKACAAKAIAQQRrCzAAIwBBEGsiAiQAAkAgACABRgRAIAFBADoAeAwBCyACQQ9qIAEQrAsLIAJBEGokAAssACAAKAIAGiAAKAIAGiAAEJQDGiAAKAIAGiAAEIcCGiAAKAIAGiAAEJQDGgssAQF/IAAoAgQhAgNAIAEgAkcEQCAAEJUDGiACQQRrIQIMAQsLIAAgATYCBAsJACAAQQA2AgALJgAgACgCABogACgCABogABCUAxogACgCABogABCUAxogACgCABoLSwEBfyMAQRBrIgMkAAJAAkAgAkEeSw0AIAEtAHgNACABQQE6AHgMAQsgA0EPaiACEK4LIQELIANBEGokACAAIAI2AgQgACABNgIAC98CAQV/IAAoAhAoAsQBIgQgAUEGdCIIaiIFKAIEIQYCQCADQQBMBEAgAiADayECA0AgAkEBaiIHIAQgCGooAgAiBU5FBEAgBiAHQQJ0aigCACIEKAIQIAIgA2oiAjYC+AEgBiACQQJ0aiAENgIAIAAoAhAoAsQBIQQgByECDAELCyADQQFrIgcgBWohAiABQQZ0IQMDQCACIAVODQIgBiACQQJ0akEANgIAIAJBAWohAiAAKAIQKALEASIEIANqKAIAIQUMAAsACyADQQFrIQcgBSgCACEEA38gAiAEQQFrIgROBH8gAiADaiEDA0AgAkEBaiICIANORQRAIAYgAkECdGpBADYCAAwBCwsgACgCECgCxAEiBCABQQZ0aigCAAUgBiAEQQJ0aigCACIFKAIQIAQgB2oiCDYC+AEgBiAIQQJ0aiAFNgIADAELCyEFCyAEIAFBBnRqIAUgB2o2AgALRAECfyMAQRBrIgEkACAAEJUDGiABQf////8DNgIMIAFB/////wc2AgggAUEMaiABQQhqEJgMKAIAIQIgAUEQaiQAIAILCwAgAEEANgIAIAALNwEBfyMAQRBrIgMkACADIAEQqgs2AgwgAyAC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CEYEQCAEEDoMAQtBHCECIAFBA3EgAUEESXINASABQQJ2IgAgAEEBa3ENAUEwIQJBQCABayAESQ0BQRAgASABQRBNGyAEELUMCyIARQ0BGiADIAA2AgxBACECCyACCyEAQQAgAygCDCAAGyECCyADQRBqJAAgAiIDDQBBqLALKAIAIgBFDQAgABELAAwBCwsgAw8LIAAQeQsHACABIABrCwkAIAAgARCPDAsHACAAQQhLCxMAIAEQkQwEQCAAEBkPCyAAEBkLEwAgAgRAIAAgASACQQJ0EL0BCwtDACMAQRBrIgEkACABIAM2AgwgBCACIAMgAmsiAkECdRCTDCABIAIgBGo2AgggACABQQxqIAFBCGoQ9AEgAUEQaiQACxAAIAIEQCAAIAEgAhC9AQsLQAAjAEEQayIBJAAgASADNgIMIAQgAiADIAJrIgIQlQwgASACIARqNgIIIAAgAUEMaiABQQhqEPQBIAFBEGokAAsJACAAEKkHEBkLJAECfyMAQRBrIgIkACABIAAQqwUhAyACQRBqJAAgASAAIAMbCw4AQQAgACAAQX8QwgIbC7IBAQN/AkAgASACEJAMIQQjAEEQayIDJAAgBEHv////B00EQAJAIAQQrAUEQCAAIAQQxAEgACEFDAELIANBCGogACAEENgDQQFqENcDIAMoAgwaIAAgAygCCCIFEPMBIAAgAygCDBDyASAAIAQQsQELA0AgASACRwRAIAUgARDDASAFQQFqIQUgAUEBaiEBDAELCyADQQA6AAcgBSADQQdqEMMBIANBEGokAAwBCxDTAQALCw8AIAAgACgCGCABajYCGAsXACAAIAI2AhwgACABNgIUIAAgATYCGAsQACAAQgA3AgAgAEEANgIIC1cBAn8CQCAAKAIAIgJFDQACfyACKAIYIgMgAigCHEYEQCACIAEgAigCACgCNBEAAAwBCyACIANBBGo2AhggAyABNgIAIAELQX8QwgJFDQAgAEEANgIACwsxAQF/IAAoAgwiASAAKAIQRgRAIAAgACgCACgCKBECAA8LIAAgAUEEajYCDCABKAIACycBAX8gACgCDCIBIAAoAhBGBEAgACAAKAIAKAIkEQIADwsgASgCAAsnAQF/AkAgACgCACICRQ0AIAIgARCoDEF/EMICRQ0AIABBADYCAAsLVwEDfwJAQX8gACgCTBDC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DAELQQALIQYgCbchCwNAIAEoAgQgB0sEQCABIAcQpQwhBANAIAQiAgRAA0ACQCACIgNFBEAgBCECA0AgAiIDRQ0CIAAgAiACQTBqIgggACADQVBBACACKAIAQQNxIgJBAkcbaigCKEYEfyADKAIQIgIgCjkDOCACQQA2AlwgAkEAOgBZIAIgBjoAWCACQoCAgIAQNwNQIAJCADcDSCACQUBrIAs5AwAgAygCAEEDcQUgAgtBA0YbKAIoRgRAIAMoAhAiAiAKOQMQIAJBADYCNCACQQA6ADEgAiAGOgAwIAJCgICAgBA3AyggAkIANwMgIAIgCzkDGAtBACECIAMoAhAtAHBBAUcNACADIAggAygCAEEDcUEDRhsoAigoAhAiAy0ArAFBAUcNACADKALEAUEBRw0AIAMoAsABKAIAIQIMAAsACyAAIAMgACADIANBMGsiCCADKAIAQQNxIgJBAkYbKAIoRgR/IAMoAhAiAiAKOQM4IAJBADYCXCACQQA6AFkgAiAGOgBYIAJCgICAgBA3A1AgAkIANwNIIAJBQGsgCzkDACADKAIAQQNxBSACC0EDR0EwbGooAihGBEAgAygCECICIAo5AxAgAkEANgI0IAJBADoAMSACIAY6ADAgAkKAgICAEDcDKCACQgA3AyAgAiALOQMYC0EAIQIgAygCEC0AcEEBRw0BIAMgCCADKAIAQQNxQQJGGygCKCgCECIDLQCsAUEBRw0BIAMoAswBQQFHDQEgAygCyAEoAgAhAgwBCwsgBCgCECgCsAEhBAwBCwsgB0EBaiEHDAELCyAAKAIQQQE6AKEBIAVBQGskAAu+DwIFfw9+IwBB0AJrIgUkACAEQv///////z+DIQogAkL///////8/gyELIAIgBIVCgICAgICAgICAf4MhDCAEQjCIp0H//wFxIQgCQAJAIAJCMIinQf//AXEiCUH//wFrQYKAfk8EQCAIQf//AWtBgYB+Sw0BCyABUCACQv///////////wCDIg1CgICAgICAwP//AFQgDUKAgICAgIDA//8AURtFBEAgAkKAgICAgIAghCEMDAILIANQIARC////////////AIMiAkKAgICAgIDA//8AVCACQoCAgICAgMD//wBRG0UEQCAEQoCAgICAgCCEIQwgAyEBDAILIAEgDUKAgICAgIDA//8AhYRQBEAgAyACQoCAgICAgMD//wCFhFAEQEIAIQFCgICAgICA4P//ACEMDAMLIAxCgICAgICAwP//AIQhDEIAIQEMAgsgAyACQoCAgICAgMD//wCFhFAEQEIAIQEMAgsgASANhFAEQEKAgICAgIDg//8AIAwgAiADhFAbIQxCACEBDAILIAIgA4RQBEAgDEKAgICAgIDA//8AhCEMQgAhAQwCCyANQv///////z9YBEAgBUHAAmogASALIAEgCyALUCIGG3kgBkEGdK18pyIGQQ9rEKoBQRAgBmshBiAFKQPIAiELIAUpA8ACIQELIAJC////////P1YNACAFQbACaiADIAogAyAKIApQIgcbeSAHQQZ0rXynIgdBD2sQqgEgBiAHakEQayEGIAUpA7gCIQogBSkDsAIhAwsgBUGgAmogCkKAgICAgIDAAIQiEkIPhiADQjGIhCICQgBCgICAgLDmvIL1ACACfSIEQgAQlgEgBUGQAmpCACAFKQOoAn1CACAEQgAQlgEgBUGAAmogBSkDmAJCAYYgBSkDkAJCP4iEIgRCACACQgAQlgEgBUHwAWogBEIAQgAgBSkDiAJ9QgAQlgEgBUHgAWogBSkD+AFCAYYgBSkD8AFCP4iEIgRCACACQgAQlgEgBUHQAWogBEIAQgAgBSkD6AF9QgAQlgEgBUHAAWogBSkD2AFCAYYgBSkD0AFCP4iEIgRCACACQgAQlgEgBUGwAWogBEIAQgAgBSkDyAF9QgAQlgEgBUGgAWogAkIAIAUpA7gBQgGGIAUpA7ABQj+IhEIBfSICQgAQlgEgBUGQAWogA0IPhkIAIAJCABCWASAFQfAAaiACQgBCACAFKQOoASAFKQOgASINIAUpA5gBfCIEIA1UrXwgBEIBVq18fUIAEJYBIAVBgAFqQgEgBH1CACACQgAQlgEgBiAJIAhraiEGAn8gBSkDcCITQgGGIg4gBSkDiAEiD0IBhiAFKQOAAUI/iIR8IhBC5+wAfSIUQiCIIgIgC0KAgICAgIDAAIQiFUIBhiIWQiCIIgR+IhEgAUIBhiINQiCIIgogECAUVq0gDiAQVq0gBSkDeEIBhiATQj+IhCAPQj+IfHx8QgF9IhNCIIgiEH58Ig4gEVStIA4gDiATQv////8PgyITIAFCP4giFyALQgGGhEL/////D4MiC358Ig5WrXwgBCAQfnwgBCATfiIRIAsgEH58Ig8gEVStQiCGIA9CIIiEfCAOIA4gD0IghnwiDlatfCAOIA4gFEL/////D4MiFCALfiIRIAIgCn58Ig8gEVStIA8gDyATIA1C/v///w+DIhF+fCIPVq18fCIOVq18IA4gBCAUfiIYIBAgEX58IgQgAiALfnwiCyAKIBN+fCIQQiCIIAsgEFatIAQgGFStIAQgC1atfHxCIIaEfCIEIA5UrXwgBCAPIAIgEX4iAiAKIBR+fCIKQiCIIAIgClatQiCGhHwiAiAPVK0gAiAQQiCGfCACVK18fCICIARUrXwiBEL/////////AFgEQCAWIBeEIRUgBUHQAGogAiAEIAMgEhCWASABQjGGIAUpA1h9IAUpA1AiAUIAUq19IQpCACABfSELIAZB/v8AagwBCyAFQeAAaiAEQj+GIAJCAYiEIgIgBEIBiCIEIAMgEhCWASABQjCGIAUpA2h9IAUpA2AiDUIAUq19IQpCACANfSELIAEhDSAGQf//AGoLIgZB//8BTgRAIAxCgICAgICAwP//AIQhDEIAIQEMAQsCfiAGQQBKBEAgCkIBhiALQj+IhCEBIARC////////P4MgBq1CMIaEIQogC0IBhgwBCyAGQY9/TARAQgAhAQwCCyAFQUBrIAIgBEEBIAZrEKADIAVBMGogDSAVIAZB8ABqEKoBIAVBIGogAyASIAUpA0AiAiAFKQNIIgoQlgEgBSkDOCAFKQMoQgGGIAUpAyAiAUI/iIR9IAUpAzAiBCABQgGGIg1UrX0hASAEIA19CyEEIAVBEGogAyASQgNCABCWASAFIAMgEkIFQgAQlgEgCiACIAIgAyAEIAJCAYMiBHwiA1QgASADIARUrXwiASASViABIBJRG618IgJWrXwiBCACIAIgBEKAgICAgIDA//8AVCADIAUpAxBWIAEgBSkDGCIEViABIARRG3GtfCICVq18IgQgAiAEQoCAgICAgMD//wBUIAMgBSkDAFYgASAFKQMIIgNWIAEgA1Ebca18IgEgAlStfCAMhCEMCyAAIAE3AwAgACAMNwMIIAVB0AJqJAALwAECAX8CfkF/IQMCQCAAQgBSIAFC////////////AIMiBEKAgICAgIDA//8AViAEQoCAgICAgMD//wBRGw0AIAJC////////////AIMiBUKAgICAgIDA//8A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EFILIgJBMGtBCkkgAkHBAGtBGklyIAJB3wBGckUgAkHhAGtBGk9xRQRAIAZBAWohBgwBCwtCgICAgICA4P//ACEVIAJBKUYNAiABKQNwIhhCAFkEQCABIAEoAgRBAWs2AgQLAkAgAwRAIAYNAQwECwwBCwNAIBhCAFkEQCABIAEoAgRBAWs2AgQLIAZBAWsiBg0ACwwCC0HAiAtBHDYCACABQgAQigILQgAhFQsgACAWNwMAIAAgFTcDCCAOQTBqJAALygYCBX8EfiMAQYABayIFJAACQAJAAkAgAyAEQgBCABChA0UNAAJ/IARC////////P4MhCwJ/IARCMIinQf//AXEiBkH//wFHBEBBBCAGDQEaQQJBAyADIAuEUBsMAgsgAyALhFALCyEJIAJCMIinIghB//8BcSIHQf//AUYNACAJDQELIAVBEGogASACIAMgBBBiIAUgBSkDECICIAUpAxgiASACIAEQswwgBSkDCCECIAUpAwAhBAwBCyABIAJC////////////AIMiCyADIARC////////////AIMiChChA0EATARAIAEgCyADIAoQoQMEQCABIQQMAgsgBUHwAGogASACQgBCABBiIAUpA3ghAiAFKQNwIQQMAQsgBEIwiKdB//8BcSEGIAcEfiABBSAFQeAAaiABIAtCAEKAgICAgIDAu8AAEGIgBSkDaCILQjCIp0H4AGshByAFKQNgCyEEIAZFBEAgBUHQAGogAyAKQgBCgICAgICAwLvAABBiIAUpA1giCkIwiKdB+ABrIQYgBSkDUCEDCyAKQv///////z+DQoCAgICAgMAAhCEMIAtC////////P4NCgICAgICAwACEIQsgBiAHSARAA0ACfiALIAx9IAMgBFatfSIKQgBZBEAgCiAEIAN9IgSEUARAIAVBIGogASACQgBCABBiIAUpAyghAiAFKQMgIQQMBQsgCkIBhiAEQj+IhAwBCyALQgGGIARCP4iECyELIARCAYYhBCAHQQFrIgcgBkoNAAsgBiEHCwJAIAsgDH0gAyAEVq19IgpCAFMEQCALIQoMAQsgCiAEIAN9IgSEQgBSDQAgBUEwaiABIAJCAEIAEGIgBSkDOCECIAUpAzAhBAwBCyAKQv///////z9YBEADQCAEQj+IIQ0gB0EBayEHIARCAYYhBCANIApCAYaEIgpCgICAgICAwABUDQALCyAIQYCAAnEhBiAHQQBMBEAgBUFAayAEIApC////////P4MgB0H4AGogBnKtQjCGhEIAQoCAgICAgMDDPxBiIAUpA0ghAiAFKQNAIQQMAQsgCkL///////8/gyAGIAdyrUIwhoQhAgsgACAENwMAIAAgAjcDCCAFQYABaiQAC78CAQF/IwBB0ABrIgQkAAJAIANBgIABTgRAIARBIGogASACQgBCgICAgICAgP//ABBiIAQpAyghAiAEKQMgIQEgA0H//wFJBEAgA0H//wBrIQMMAgsgBEEQaiABIAJCAEKAgICAgICA//8AEGJB/f8CIAMgA0H9/wJOG0H+/wFrIQMgBCkDGCECIAQpAxAhAQwBCyADQYGAf0oNACAEQUBrIAEgAkIAQoCAgICAgIA5EGIgBCkDSCECIAQpA0AhASADQfSAfksEQCADQY3/AGohAwwBCyAEQTBqIAEgAkIAQoCAgICAgIA5EGJB6IF9IAMgA0HogX1MG0Ga/gFqIQMgBCkDOCECIAQpAzAhAQsgBCABIAJCACADQf//AGqtQjCGEGIgACAEKQMINwMIIAAgBCkDADcDACAEQdAAaiQACzwAIAAgATcDACAAIAJC////////P4MgAkKAgICAgIDA//8Ag0IwiKcgBEIwiKdBgIACcXKtQjCGhDcDCAsXAQF/IABBACABEKQDIgIgAGsgASACGwswAQF8IAEoAhAiASABKwNYIAAoAhAoAvwBQQJttyICoDkDWCABIAErA2AgAqA5A2ALowEBBH8jAEEQayIFJAAgBSACNgIMIwBBoAFrIgMkACADQQhqIgZBkPIGQZABECMaIAMgADYCNCADIAA2AhwgA0H/////B0F+IABrIgQgBEH/////B0sbIgQ2AjggAyAAIARqIgQ2AiQgAyAENgIYIAYgASACELkMIABBfkcEQCADKAIcIgAgACADKAIYRmtBADoAAAsgA0GgAWokACAFQRBqJAALpQEBBX9BqIoLKAIAIgMEQEGkigsoAgAhBQNAIAAgBSACQQJ0aiIEKAIAIgZGBEAgBCABNgIAIAAQGQ8LIAYgAUVyRQRAIAQgATYCAEEAIQELIAJBAWoiAiADRw0ACwsCQCABRQ0AQaSKCygCACADQQJ0QQRqED8iAEUNAEGkigsgADYCAEGoigtBqIoL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IAFBUEEAIAEoAgBBA3FBAkcbaigCKCICEKYBIAJHDQIgARDPByADKAIQIQEMAQsLIAAoAhAhAQwBC0G+mQNB8rcBQc0CQaIvEAAACyABKALgASIDRQRADAELIAMoAhAiAS0AtQFBA0YhCwNAIAEoAsABKAIAIgFFDQEgASABKAIAQQNxQQNHQTBsaigCKCICEKYBIAJGBEAgARDPByADKAIQIQEMAQsLQZ6ZA0HytwFB1AJBoi8QAAALIABBABC/CEEAIQIDQCAAKAIQIgEoAtwBIAJLBEAgASABKALYASACQQJ0aigCACIBNgLAASABIQMDQCADBEAgAygCECIDQQA2ArABIAMoArgBIQMMAQsLA0AgAQRAIAEQgw0gASgCECgCuAEhAQwBCwsgAkEBaiECDAELCwJAIAAoAhAiASgC5AFFBEAgASgC4AFFDQELIAAQHCEBQQAhAwNAIAEEQAJAIAEQpgEgAUcNAAJAIAEoAhAiAigCzAENACAAKAIQKALkASIERSABIARGcg0AIAEgBEEAEMsBIgMoAhAiAkEANgKcASACIAo2AqwBIAEoAhAhAgsgAigCxAENACAAKAIQKALgASICRSABIAJGcg0AIAIgAUEAEMsBIgMoAhAiAkEANgKcASACIAs2AqwBCyAAIAEQHSEBDAELCyADRQ0AIABBABC/CAsgAEGb4wIQJiIBBH8gABAzIAEQpgIQgA0FQf////8HCyECQQAhAQNAIAEgACgCECIDKALcAUkEQCADIAMoAtgBIAFBAnRqKAIANgLAASAAIAMoArQBRSACELYDGiABQQFqIQEMAQsLIAAQHCEBIAAoAhAhAwJAIAEEQCADQv////93NwLsAQNAIAEEQAJAIAEgARCmASICRgRAIAEoAhAiAygC9AEhAgwBCyABKAIQIgMgAygC9AEgAigCECgC9AFqIgI2AvQBCyACIAAoAhAiBCgC8AFKBEAgBCACNgLwAQsgAiAEKALsAUgEQCAEIAI2AuwBCyADLQC1ASIDRSADQQZGckUEQCABELgOCyAAIAEQHSEBDAELCyAAEFsgAEcNAUGs/QooAgBB5ABGBEBBASEBA0AgASAAKAIQIgMoArQBSg0DIAMoArgBIAFBAnRqKAIAEN0MIAFBAWohAQwACwALIAAQWxBuIQEDQCABRQ0CIAEoAhAtAJYCQQdGBEAgACABENgMCyABEG0hAQwACwALIANCADcC7AELQQAhAgN/IAAoAhAiASgC3AEgAk0EfyAAEBwFIAEgASgC2AEgAkECdGooAgAiATYCwAEDQCABBEAgASgCEEHAAWoQ1AwgASgCEEHIAWoQ1AwgASgCECIBQQA2ArABIAEoArgBIQEMAQsLIAJBAWohAgwBCwshAwNAAkAgAwRAIAAgAxArIQEDQCABRQ0CAkAgASgCECICKAKwASIERQ0AIAEgBCgCECgCeEYNACACQQA2ArABCyAAIAEQLSEBDAALAAsgABAcIQMDQCADBEAgACADECshAQNAIAEEQAJAIAEoAhAoArABIgJFDQAgAigCECIEKAJ4IAFHDQAgBBAZIAIQGSABKAIQQQA2ArABCyAAIAEQLSEBDAELCyAAIAMQHSEDDAELCyAAKAIQKALYARAZIAAoAhBCADcD2AEPCyAAIAMQHSEDDAALAAsEAEEAC4EBAQJ/IAJBCzYCAEEBIQMCQCABIABrQQNHDQAgACwAACIBQfgARgR/QQAFIAFB2ABHDQFBAQshASAALAABIgRB7QBHBEAgBEHNAEcNAUEBIQELIAAsAAIiAEHsAEcEQCAAQcwARw0BQQAPC0EAIQMgAQ0AIAJBDDYCAEEBIQMLIAMLqwEBAn8jAEEQayIEJAACQAJAAkAgACABIAJBAEEAEFAiBQ0AIAAgAiABQQBBABBQIgUNACAAIAEgAkEAQQEQUCIFRQ0BCyADKAIQIgIoAqwBIQEgBSgCECIAIAAoApwBIAIoApwBajYCnAEgACAAKAKsASIAIAEgACABShs2AqwBDAELIAEQISEAIAQgAhAhNgIEIAQgADYCAEEBQdbiAyAEEB8LIARBEGokAAvmAwEEf0EBIQUCQCACIAFrIgRBAEwNAAJAAn8CQAJAAkACQAJAAkACQCAAIAEtAABqLQBIIgZBBWsOFAIDBAYBAQYGBgYGBgYGBgYBBQYFAAsgBkEeRw0FC0EWIQcMBAtBfiAEQQJJDQQaIAAgASAAKALgAhEAAA0DQQIhBSAAIAEgACgC1AIRAAANAgwDC0F+IARBA0kNAxogACABIAAoAuQCEQAADQJBAyEFIAAgASAAKALYAhEAAA0BDAILQX4gBEEESQ0CGiAAIAEgACgC6AIRAAANAUEEIQUgACABIAAoAtwCEQAARQ0BCyABIAVqIQEDQCACIAFrIgZBAEwNBEEBIQQCQAJAAkAgACABLQAAai0ASCIFQRJrDgoCBAQEAQQBAQEBAAsCQAJAAkAgBUEFaw4DAAECBgsgBkECSQ0HIAAgASAAKALgAhEAAA0FQQIhBCAAIAEgACgCyAIRAAANAgwFCyAGQQNJDQYgACABIAAoAuQCEQAADQRBAyEEIAAgASAAKALMAhEAAA0BDAQLIAZBBEkNBSAAIAEgACgC6AIRAAANA0EEIQQgACABIAAoAtACEQAARQ0DCyABIARqIQEMAQsLIAFBAWohAUEcIQcLIAMgATYCACAHCw8LQX4PC0F/C7IGAQZ/IwBBEGsiByQAQQEhBQJ/AkAgAiABayIEQQBMDQACQAJAAkACQAJAAkACQCAAIAEtAABqLQBIIgZBBWsOAwECAwALAkAgBkEWaw4DBAUEAAsMBAtBfiAEQQJJDQYaIAAgASAAKALgAhEAAA0DQQIhBSAAIAEgACgC1AIRAABFDQMMAgtBfiAEQQNJDQUaIAAgASAAKALkAhEAAA0CQQMhBSAAIAEgACgC2AIRAABFDQIMAQtBfiAEQQRJDQQaIAAgASAAKALoAhEAAA0BQQQhBSAAIAEgACgC3AIRAABFDQELIAEgBWohBAJAAkACQAJAAkACQANAIAIgBGsiCEEATA0JQQEhBSAEIQYCQAJAAkACQAJAIAAgBC0AAGotAEhBBWsOGQABAgkEBAkJCQkGCQkJCQkEAwkDAwMDCQcJCyAIQQJJDQogACAEIAAoAuACEQAADQZBAiEFIAAgBCAAKALIAhEAAA0CDAYLIAhBA0kNCSAAIAQgACgC5AIRAAANBUEDIQUgACAEIAAoAswCEQAADQEMBQsgCEEESQ0IIAAgBCAAKALoAhEAAA0EQQQhBSAAIAQgACgC0AIRAABFDQQLIAQgBWohBAwBCwsgASAEIAdBDGoQ7wxFDQEgBEEBaiEFA0AgAiAFIgFrIgZBAEwNCQJAAkACQAJAAkAgACABLQAAai0ASA4QCgoEBAQAAQIKBAQEBAQEAwQLIAZBAkkNCiAAIAEgACgC4AIRAAANCSABQQJqIQUMBAsgBkEDSQ0JIAAgASAAKALkAhEAAA0IIAFBA2ohBQwDCyAGQQRJDQggACABIAAoAugCEQAADQcgAUEEaiEFDAILIAIgAUEBaiIFa0EATA0KIAUtAABBPkcNASADIAFBAmo2AgAgBygCDAwLCyABQQFqIQUMAAsACyABIAQgB0EMahDvDA0BCyADIAQ2AgAMBQtBfyACIARBAWoiBmtBAEwNBhogBC0AAUE+Rw0AIAMgBEECajYCACAHKAIMDAYLIAMgBjYCAAwDCyADIAE2AgAMAgtBfgwDCyADIAE2AgALQQAMAQtBfwshCSAHQRBqJAAgCQusAgEDfwJAIAIgAWtBAEwNAAJAAkACQCABLQAAQS1HDQAgAUEBaiEEA0AgAiAEIgFrIgRBAEwNBAJAAkACQAJAAkACQCAAIAEtAABqLQBIIgYOCQcHBAQEAAECBwMLIARBAkkNCCAAIAEgACgC4AIRAAANBiABQQJqIQQMBQsgBEEDSQ0HIAAgASAAKALkAhEAAA0FIAFBA2ohBAwECyAEQQRJDQYgACABIAAoAugCEQAADQQgAUEEaiEEDAMLIAZBG0YNAQsgAUEBaiEEDAELIAIgAUEBaiIEa0EATA0EIAQtAABBLUcNAAtBfyEFIAIgAUECaiIAa0EATA0BIAFBA2ogACABLQACQT5GIgAbIQFBDUEAIAAbIQULIAMgATYCAAsgBQ8LQX4PC0F/C4oCAQJ/AkACfwJAA0AgAyACayIFQQBMBEBBfw8LAkACQAJAAkACQAJAIAEgAi0AAGotAEgiBg4OBQUEBAQAAQIFBAQEAwMECyAFQQJJDQggASACIAEoAuACEQAADQQgAkECaiECDAULIAVBA0kNByABIAIgASgC5AIRAAANAyACQQNqIQIMBAsgBUEESQ0GIAEgAiABKALoAhEAAA0CIAJBBGohAgwDCyACQQFqIQIgACAGRw0CIAMgAmtBAEwEQEFlDwsgBCACNgIAIAEgAi0AAGotAEgiAEEeSw0DQRtBASAAdEGAnMCBBHENBBoMAwsgAkEBaiECDAELCyAEIAI2AgALQQALDwtBfgscACAAIAEgAiADEM0HIgAEQCAAQRc6AIIBCyAACxwAQdkDIAAgASACIAMgBCAFIAYgByAIIAkQ+AwLEQAgACABIAJB2ANB1wMQigsLzQQBA38jAEEQayILJAAgC0EANgIIIAtBADYCBCALQQA2AgAgCyADIAIoAkAiDEEFbGoiAzYCDAJ/AkACQCACIAMgBCAMQQF0ayIMIAtBBGogCyALQQhqIAtBDGoQywdFDQAgCygCBCIERQ0AAkACQAJAAkACQAJAIAIgBCALKAIAIgNB8qEGIAIoAhgRBgBFBEAgAQ0BDAgLIAYEQCAGIAsoAgg2AgALIAsoAgwhAyAHBEAgByADNgIACyACIAMgDCALQQRqIAsgC0EIaiALQQxqEMsHRQ0GIAsoAgQiBEUNASALKAIAIQMLIAIgBCADQfqhBiACKAIYEQYABEAgAiALKAIIIgQgDBDtAkFfcUHBAGtBGUsNByAIBEAgCCAENgIACyALKAIMIQMgCQRAIAkgAiAEIAMgAigCQGsgABEDADYCAAsgAiADIAwgC0EEaiALIAtBCGogC0EMahDLB0UNBiALKAIEIgRFDQUgCygCACEDCyABIAIgBCADQYOiBiACKAIYEQYARXINBiACIAsoAggiBCALKAIMIgMgAigCQGtBjqIGIAIoAhgRBgBFDQFBASEEIAoNAgwDCyABDQQMAwsgAiAEIAMgAigCQGtBkqIGIAIoAhgRBgBFDQRBACEEIApFDQELIAogBDYCAAsDQCACIAMgDBDtAkEJayIAQRdLQQEgAHRBk4CABHFFckUEQCADIAIoAkBqIQMMAQsLIAwgAyIERw0CC0EBDAILIAsoAgwhBAsgBSAENgIAQQALIQ0gC0EQaiQAIA0LHABB1gMgACABIAIgAyAEIAUgBiAHIAggCRD4DAv1AQEBfwNAIAIgAWtBAEoEQAJAAkACQAJAAkACQCAAIAEtAABqLQBIQQVrDgYAAQIFBAMFCyADIAMoAgRBAWo2AgQgAUECaiEBDAYLIAMgAygCBEEBajYCBCABQQNqIQEMBQsgAyADKAIEQQFqNgIEIAFBBGohAQwECyADQQA2AgQgAyADKAIAQQFqNgIAIAFBAWohAQwDCyADIAMoAgBBAWo2AgACfyACIAFBAWoiBGtBAEwEQCAEDAELIAFBAmogBCAAIAEtAAFqLQBIQQpGGwshASADQQA2AgQMAgsgAyADKAIEQQFqNgIEIAFBAWohAQwBCwsLeQEDfwJAA0ACQCABLQAAIQMgAC0AACECQQEhBCABQQFqIQEgAEEBaiEAQQEgAkEgayACIAJB4QBrQf8BcUEaSRtB/wFxIgJFQQF0IAIgA0EgayADIANB4QBrQf8BcUEaSRtB/wFxRxtBAWsOAgACAQsLQQAhBAsgBAtBAQF/AkAgAEUEQEEGIQEMAQsDQCABQQZGBEBBfw8LIAAgAUECdEHQlQZqKAIAEPsMDQEgAUEBaiEBDAALAAsgAQuiAwEEfwJAIAAQHEUNACAAEOwDBEACQCABBEAgASgCECgCzAEhAiAAKAIQIgMgATYCyAEgAyACQQFqNgLMASABIAAQxAUgASAAENIMDAELIAAoAhBBADYCzAELIAAhAQsgABBuIQIDQCACBEAgAiABEP0MIAIQbSECDAELCwJAIAAQ7ANFDQAgABAcIQIDQCACRQ0BIAIoAhAiAygC6AFFBEAgAyAANgLoAQsgACACEB0hAgwACwALAkAgAEG/8wAQJiICRQ0AIAItAABFDQACQAJAIAJBgOMAEDRFDQAgAkG0nQEQNEUNACACQcMSEDRFDQEgAkGq8gAQNEUNASACQYKVARA0DQIgABDABRoMAgsgABDABSEEIAFFDQEgBCABKAIQKALQARDAByECIAEoAhAgAjYC0AEMAQsgABDABSEFIAFFDQAgBSABKAIQKALUARDAByECIAEoAhAgAjYC1AELIAAQ7ANFDQAgACgCECIBKALQASICRQ0AIAIgASgC1AFHDQAgABDABSEBIAAoAhAiACABNgLUASAAIAE2AtABCwtvAQN/IAAoAhAtAHFBAXEEQCAAEBwhAQNAIAEEQCAAIAEQKyECA0AgAgRAIAIoAhAiAyADKAKsAUEBdDYCrAEgACACEC0hAgwBCwsgACABEB0hAQwBCwsgACgCECIAIAAoAoACQQFqQQJtNgKAAgsLwhEBEX8jAEGQAWsiCiQAAkACQCAAQYXzABAmBEAgACgCECICIAIvAYgBQRByOwGIAUH0vQpBADYCACAKQZC3CigCADYCHEHtJSAKQRxqQQAQyAEiA0HCsgFBoAJBARAuGiADQQwQ5gEiBUGE0gc2AgQgBUHI0gc2AgAgBSADKAJMIgIoAig2AgggAiAFNgIoIAAQ/gwgAEGb4wIQJiICBH8gABAzIAIQpgIQgA0FQf////8HCyEQIABBABD9DEH0vQpBADYCACAAEBwhAQNAIAEEQCABEPgBIAFGBEAgAyABECEQrwQhAiABKAIQIAI2AqQBCyAAIAEQHSEBDAELCyAAEBwhAQNAIAEEQCABKAIQKAKkAUUEQCABEPgBIQIgASgCECACKAIQKAKkATYCpAELIAAgARAdIQEMAQsLIAAQHCELA0AgC0UNAiALKAIQKAKkASEFIAAgCxArIQYDQAJAAkACQCAGBEACQEGAgAsoAgAiAkUNACAGIAIQNyICRQ0AIAItAABFDQAgAhCEAUUNBAsgBSAGIAZBMGsiDiAGKAIAQQNxQQJGGygCKBD4ASgCECgCpAEiAkYNAyAGIA4gBigCAEEDcSIBQQJGGygCKCgCECgC6AEhDSAGIAFBA0dBMGxqKAIoIgcoAhAoAugBIgwhCCAGQVBBACABQQJHG2ooAigoAhAoAugBIg8hAQJAAkAgDCAPRg0AA0AgASAIRwRAIAgoAhAiCSgCzAEgASgCECIEKALMAU4EQCAJKALIASEIBSAEKALIASEBCwwBCwsgCCAMRg0AIAggD0cNAQsCQCAMBEAgBxD4ASAMKAIQKALUAUYNAQsgDUUNAyAGIA4gBigCAEEDcUECRhsoAigQ+AEgDSgCECgC0AFHDQMLIAUhASACIQUMAwsCQCAMEMoHRQRAIA0QygdFDQELIAMgBRCwAiEBA0AgAQRAIAMgASABKAIAQQNxQQNHQTBsaigCKBArIgQEQCAEQVBBACAEKAIAQQNxQQJHG2ooAiggAkYNBwsgAyABEPgCIQEMAQsLQfi9CkH4vQooAgAiAUEBajYCACAKIAE2AhAgCkEgaiIBQeQAQeutASAKQRBqEGkaIAMgAyABEK8EIgEgBUEAQQEQUCERIAMgASACQQBBARBQIQEgESgCECIEIAQoAqwBIgJBACACQQBKGzYCrAEgBCAEKAKcASAGKAIQIgQoApwBQegHbGo2ApwBIAEoAhAiCSAJKAKsASIBIAQoAqwBIgIgASACShs2AqwBIAkgCSgCnAEgBCgCnAFqNgKcAQwECyADIAUgAiAGEPAMDAMLIAAgCxAdIQsMBAsgAiEBCyADIAUgASAGEPAMCyAAIAYQLSEGDAALAAsACyAAEO0MDAELIAAgA0EAQQAQ6AwgAxAcIQEDQCABBEAgASgCECICQQA6ALQBIAJBADYCsAEgAyABEB0hAQwBCwsgAxAcIQEDQCABBEAgAyABEOcMIAMgARAdIQEMAQsLIAMQHCEBA0AgAQRAIAEoAhBBADYCkAEgAyABEB0hAQwBCwtBACEJIAMQHCEBA0AgAQRAIAEoAhAoApABRQRAIAMgASAJQQFqIgkQyQcLIAMgARAdIQEMAQsLAkAgCUECSA0AIANBqRsQrwQhAiADEBwhAUEBIQgDQCABRQ0BIAggASgCECgCkAFGBEAgAyACIAFBAEEBEFAaIAhBAWohCAsgAyABEB0hAQwACwALIAMQHCEHA0AgBwRAIAMgBxArIQEDQCABBEAgBygCECICKALIASACKALMASICQQFqIAJBAmoQzAEhBSAHKAIQIgIgBTYCyAEgAiACKALMASICQQFqNgLMASAFIAJBAnRqIAE2AgAgBygCECICKALIASACKALMAUECdGpBADYCACABIAFBMGsiBCABKAIAQQNxQQJGGygCKCgCECICKALAASACKALEASICQQFqIAJBAmoQzAEhAiABIAQgASgCAEEDcUECRhsoAigoAhAgAjYCwAEgASAEIAEoAgBBA3FBAkYbKAIoKAIQIgUiAiACKALEASICQQFqNgLEASAFKALAASACQQJ0aiABNgIAIAEgBCABKAIAQQNxQQJGGygCKCgCECICKALAASACKALEAUECdGpBADYCACADIAEQLSEBDAELCyADIAcQHSEHDAELCyADQQEgECAAQe+FARAmIgIEfyACEIsCBUF/CxCCDxogACgCEEL/////dzcC7AFBACEHAkAgCUECSA0AIAlBAWoiAhDIByEHQQEhAQNAIAEgAkYNASAHIAFBAnRqQf////8HNgIAIAFBAWohAQwACwALIAAQHCEIA0AgCARAIAgQ+AEhAiAIKAIQIgUgAigCECgCpAEoAhAiAigC9AEiBDYC9AEgBCAAKAIQIgEoAvABSgRAIAEgBDYC8AELIAQgASgC7AFIBEAgASAENgLsAQsgBwRAIAUgAigCkAEiAjYCkAEgByACQQJ0aiICIAIoAgAiAiAEIAIgBEgbNgIACyAAIAgQHSEIDAELCwJAIAcEQCAAEBwhAQNAIAEEQCABKAIQIgIgAigC9AEgByACKAKQAUECdGooAgBrNgL0ASAAIAEQHSEBDAEFQQEhBgwDCwALAAtBACEGIAAoAhAoAuwBIgVBAEwNACAAEBwhAQNAIAEEQCABKAIQIgIgAigC9AEgBWs2AvQBIAAgARAdIQEMAQsLIAAoAhAiAiACKALsASAFazYC7AEgAiACKALwASAFazYC8AELIAAg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AihHDQAgCCAEEPUNRQ0AIAQoAhAhBCAGQfgAaiILIAgoAhBBEGpBKBAjGiAGQdAAaiIIIARBEGpBKBAjGiALIAgQ1QlFDQELCyABIAJrQQJIDQAgACAHIAIgBUEBEPANCyACQQFqIQIgACgCECIBKALEASEFDAELAAsACwALIAZBoAFqJAALIAAoAhAiBSgC7AEhAgNAIAUoAvABIAJOBEBBACEDIAJBBnQiByAFKALEAWoiCCgCACIGQQAgBkEAShshCUEAIQEDQCABIAlHBEAgCCgCBCABQQJ0aigCACgCECIEIAM2AvgBIAFBAWohASAELQC1AUEGRgR/IAQoAuwBBUEBCyADaiEDDAELCyADIAZKBEAgA0EBakEEEBohBiAAKAIQIgUoAsQBIAdqKAIAIQEDQCABQQBKBEAgBiAFKALEASAHaigCBCABQQFrIgFBAnRqKAIAIgQoAhAoAvgBQQJ0aiAENgIADAELCyAFKALEASAHaiADNgIAIAYgA0ECdGpBADYCACAFKALEASAHaigCBBAZIAAoAhAiBSgCxAEgB2ogBjYCBAsgAkEBaiECDAELCwJ/IwBBEGsiDCQAIAAiBygCEEHAAWohAANAAkAgACgCACIDBEBBACEAIAMoAhAiASgC0AEiAkUNAQNAIAIgAEECdGooAgAiAkUNAiACEOkNIABBAWohACADKAIQIgEoAtABIQIMAAsACwJAIAcoAhAiASgCxAEiAygCOEUEQCABKAK0AUEATA0BCyADKAIEIQVBACECAkADQCAFIAJBAnRqKAIAIgBFDQIgACgCECgC2AEhBkEAIQACQANAIAYgAEECdGooAgAiBARAAkAgBCgCECIEKAJgRQ0AIAQtAHINACABKALsAQ0DIAEoAvABQQZ0QcABaiEAAn8gAwRAIAMgABCyAQwBCyAAEP0BCyEAIAcoAhAiASAAQUBrNgLEASABKALwASEAA0AgBygCECIBKALEASECIABBAE4EQCACIABBBnRqIgEgAUFAakHAABAjGiAAQQFrIQAMAQsLIAIgAEEGdGoiAEEANgIAIABBADYCCEECQQQQTSICRQ0FIABBADYCOCAAIAI2AgQgACACNgIMIABCgICAgICAgPg/NwMYIABCgICAgICAgPg/NwMoIABCgICAgICAgPg/NwMQIABCgICAgICAgPg/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ASgCAEEDcUEDRhsoAigQKhAyENkBGyEOQQAhDQwBCwsgA0IANwNIIANCADcDQANAIABBAWohAQJAAkAgAC0AACIQQdwARwRAIBBFDQEMAgsgASwAACIFRQ0BIABBAmohAAJAAkACQAJAAkACQAJAAkAgBUHFAGsOCgMHAQUHBwcGBwIACyAFQdQARg0DIAJFIAVB3ABHcg0GIANBQGtB3AAQnAEMCQsgA0FAayAIEP4BDAgLIANBQGsgDxD+AQwHCyANDQYgA0FAayIBIAoQ/gEgBgRAIAMgDDYCMCABQY4yIANBMGoQ2wELIAMgCzYCJCADIA42AiAgA0FAayIBQbExIANBIGoQ2wEgB0UNBiADIAk2AhAgAUGOMiADQRBqENsBDAYLIANBQGsgChD+AQwFCyADQUBrIAsQ/gEMBAsgA0FAayAEEP4BDAMLIAMgBTYCACADQUBrQYq7ASADENsBDAILIANBQGsQuQMhESADQdAAaiQAIBEPCyADQUBrIBDAEJwBIAEhAAwACwAL1wIBBX8jAEEQayICJAAgAUIANwMYIAFCADcDICABKAIAIgQtAAAiAwRAIAJCADcDCCACQgA3AwADQAJAIANFDQACfwJAIANB3wBqQf8BcUHdAE0EQCABKAIMQQJGDQELIARBAWohBQJAIANBCkYEQCAAIAEgAhC5A0HuABCvCAwBCyADQdwARgRAAkAgBSwAACIGQewAayIDQQZLQQEgA3RBxQBxRXJFBEAgACABIAIQuQMgBSwAABCvCAwBCyACIAYQnAELIARBAmogBSAELQABGwwDCyACIAPAEJwBCyAFDAELIAIgA8AQnAEgAiAELAABIgMQnAEgA0UNASAEQQJqCyIELQAAIQMMAQsLIAIQJARAIAAgASACELkDQe4AEK8ICyACLQAPQf8BRgRAIAIoAgAQGQsgASABQRhqIgApAwA3AyggASAAKQMINwMwCyACQRBqJAALpAIBBX8gACgCECgCwAEhAwNAIAMiASgCECgCuAEiAwRAIAAgASADQQBBABBQDQEgACABIANBAEEBEFAiBEH9JEG4AUEBEC4aIAQoAhBBADYCrAEgASgCECICKALIASACKALMASICQQFqIAJBAmpBBBCHASEFIAEoAhAiAiAFNgLIASACIAIoAswBIgJBAWo2AswBIAUgAkECdGog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ASAETgRAIARBAnQiBSAAKAKQAmooAgAhAANAIAAoAhAiBigCyAEoAgAiAQRAIAEQgAIgASgCEBAZIAEQGQwBCwsDQCAGKALAASgCACIBBEAgARCAAiABEBkgACgCECEGDAELCyACEFsgABDYBCAAKAIQKALAARAZIAAoAhAoAsgBEBkgACgCEBAZIAAQGSACKAIQKAKQAiAFakEANgIAIARBAWohBCACKAIQIQAMAQsLDAELQaehA0GUtgFB6QFBtiwQAAALIAIQswggAhD8DiACEPcOIAJBAhCyCCEBQQEhAANAIAIoAhAiBCgCtAEgAE4EQCAEKAK4ASAAQQJ0aigCABCUDyABaiEBIABBAWohAAwBCwsgAhDfDiABC6MBAgN/A3wjAEEQayICJAACfwJAAkACQAJAIAAsAARBAWsOAwMBAAILIAAoAgAiAUEIaiEAIAFBGGoMAwsgACgCACIBQRhqIQAgAUEoagwCCyACQeUFNgIEIAJBvbkBNgIAQZjcBigCAEH/qwEgAhAgEAEACyAAKAIAIgFBOGohACABQcgAagshAyAAKwMAIQQgAysDACEGIAJBEGokACAGIAShCw8AQfD6CUH8uAooAgAQfQsTACAAKAJUEHMaIAAQ/gUgABAZCyUBAX8DQCAALQAAIgFFBEBBAA8LIABBAWohACABQSBGDQALQQELMAAgABCbDwJAIAAQJwRAIABBADoADwwBCyAAQQA2AgQLIAAQJwR/IAAFIAAoAgALC/UBAQV/IwBBEGsiBCQAQSgQSiEBQZiBCygCACIFEGwhAyABIAA6ABACQAJAIAMEQCABIAM2AgwgASADQTgQGiIDNgIIIAUQhgEhAANAIABFDQIgAyACQThsaiAAQQhqQTgQIxogAkEBaiECIAAoAgAhAAwACwALQTgQSiEAIAFBATYCDCABIAA2AghBw+UEEJ8BIgJFDQEgACACNgIAIABBpIELKAIAKAIANgIECyAFQQBBwAAgBSgCABEDABpBnIELKAIAIgAgAUEBIAAoAgARAwAaIARBEGokAA8LIARBATYCAEGY3AYoAgBB+88DIAQQIBApAAvQAgEFfyMAQRBrIgQkAAJAAkAgABAkIAAQPU8EQCAAED0iA0EBaiIBIANBAXRBgAggAxsiAiABIAJLGyEBIAAQJCEFAkAgAC0AD0H/AUYE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wAFqEB4gBhAZIANFDQAgBEGYAWoiAyAAKAIQQThqQSgQIxogA0MAAIA+EIoDIQMgBCACNgKQASAAQfLNBCAEQZABahAeA0AgAiAFRgRAIABBl7UDEBsaIAArA+gDIQggACsD8AMhCSAEQoCAgICAgID4PzcDYCAEIAk5A1ggBCAIOQNQIABB1bcEIARB0ABqEB4gBEFAayAAKALoArK7OQMAIARCADcDOCAEQgA3AzAgAEGxtwQgBEEwahAeIARB2PkKKAIAQQJrNgIgIARCADcDECAEQgA3AxggAEHQuAQgBEEQahAeIAQgAzYCACAAQaG1AyAEEB4gAxAZBSABIAVBBHRqIgYrAwAhCCAGKwMIIQkgACsD+AMhCiAAKwOABCELIARCADcDgAEgBCAJIAugOQN4IAQgCCAKoDkDcCAAQcHTASAEQfAAahAeIAVBAWohBQwBCwsLBSABIAVBBHRqIgcrAwAhCCAHKwMIIQkgACsD+AMhCiAAKwOABCELIAQgACgCECsDmAE5A+gCIARCADcD4AIgBCAJIAugOQPYAiAEIAggCqA5A9ACIABBvIsEIARB0AJqEB4gBUEBaiEFDAELCyAEQaADaiQAC7oFAwJ/CXwCfSMAQfACayIDJAAgAEGPkgQQGxpB2PkKQdT5CigCAEEGazYCACAAKwOABCELIAArA/ADIQYgASsDGCEFIAArA/gDIQwgACgCECIEKwOYASEIIAArA+gDIQcgASsDACEJIAErAxAhDSABKwMIIQogA0G4AmoiASAEQRBqQSgQIxogAUMAAAAAEIoDIQEgA0IANwPoAiADQoCAgICAgID4PzcDoAIgA0IANwPgAiADIAggByANIAmhorYiDiAGIAUgCqGitiIPkrsiBaNEAAAAAAAA4D+iRAAAAAAAABRAora7OQOoAiADQeACaiIEQaiLBCADQaACahB4IAMgD7siCDkDkAIgAyAFRAAAAAAAANA/ojkDiAIgAyAOuyIFOQOAAiAEQdW3BCADQYACahB4IAMgACgC6AKyuzkD8AEgA0IANwPoASADQoCAgICAgKCrwAA3A+ABIARBsbcEIANB4AFqEHggA0HY+QooAgA2AtABIAMgByAJIAygora7Igc5A8ABIAMgBiAKIAugora7IgY5A8gBIARB0LgEIANBwAFqEHggAyABNgKwASAEQaG1AyADQbABahB4IAAgBBDoBBAbGiABEBkgAgRAIANBiAFqIgEgACgCEEE4akEoECMaIAFDAAAAABCKAyEBIANCADcDgAEgA0IANwN4IANCADcDcCAAQdzBBCADQfAAahAeIANCgICAgICAgPg/NwNgIAMgCDkDWCADIAU5A1AgAEHVtwQgA0HQAGoQHiADQUBrIAAoAugCsrs5AwAgA0IANwM4IANCADcDMCAAQbG3BCADQTBqEB4gA0HY+QooAgA2AiAgAyAHOQMQIAMgBjkDGCAAQdC4BCADQRBqEB4gAyABNgIAIABBobUDIAMQHiABEBkLIANB4AJqEHEgA0HwAmokAAvoAwIDfwZ8IwBB0AFrIgMkACACKAIAIQQgAigCBCIFKwMQIQYgAyAFKAIANgKwASADIAY5A6gBIAMgBDYCoAEgAEGY5AMgA0GgAWoQHkHY+QpB1PkKKAIAQQlrNgIAAnwgASsDACIGIAIsADAiBEHsAEYNABogBEHyAEYEQCAGIAIrAyChDAELIAYgAisDIEQAAAAAAADgv6KgCyEGIAArA/ADIQcgACsDgAQhCCABKwMIIQkgACsD6AMhCiAAKwP4AyELIANB+ABqIgEgACgCEEEQakEoECMaIAFDAAAAABCKAyEBIANCADcDyAEgA0IANwPAASACKAIEKAIAIQQgAigCACEFIANCADcDcCADQoCAgICAgIDoPzcDaCADIAU2AmQgAyAENgJgIANBwAFqIgRBy8MDIANB4ABqEHggAyACKAIEKwMQIAArA+gDojkDUCAEQZiLBCADQdAAahB4IANBQGsgACgC6AKyuzkDACADQgA3AzggA0IANwMwIARBsbcEIANBMGoQeCADQdj5CigCADYCICADIAogBiALoKI5AxAgAyAHIAkgCKCiOQMYIARB0LgEIANBEGoQeCADIAE2AgAgBEGhtQMgAxB4IAAgBBDoBBAbGiAEEHEgARAZIANB0AFqJAALHAAgAEGxlQQQGxpB1PkKQdT5CigCAEEFajYCAAscACAAQZ+VBBAbGkHU+QpB1PkKKAIAQQVrNgIACwsAIABBypcEEBsaCy0BAX8jAEEQayIBJAAgASAAKAIQKAIIECE2AgAgAEHv5gMgARAeIAFBEGokAAsLACAAQZftAxAbGgscACAAQYLtAxAbGkHU+QpB1PkKKAIAQQJrNgIACwsAIABBgJcEEBsaCwsAIABB7pYEEBsaCwsAIABBj+wDEBsaCz8BAX8jAEEQayIEJAAgBCADNgIIIAQgATYCACAEIAI2AgQgAEH7ogQgBBAeQdT5CiACQXZsNgIAIARBEGokAAsLACAAQeL5AxAbGguBAgIBfwN8IwBBQGoiASQAIAEgACgCECgCCBAhNgIwIABBu90DIAFBMGoQHiAAKwPwAiEDIAArA+gDIQIgASAAKwP4AkQAAAAAAADgP6IgACsD8AOiIgQ5AxggASACIANEAAAAAAAA4D+ioiIDOQMQIAEgA0QAAAAAAEB/QKMQyQVEAAAAAACAZkCiRBgtRFT7IQlAoyICIAKgIAREAAAAAABAf0CjEMkFRAAAAAAAgGZAokQYLURU+yEJQKMiAiACoBAxRDMzMzMzM/M/ojkDICABIAQ5AwggASADOQMAIABB4r0DIAEQHiAAQaS3AxAbGiAAQZ+2AxAbGiABQUBrJAALcwEBfyMAQSBrIgEkACAAQc+8BBAbGiAAQc+2AxAbGiAAQdi1AxAbGiAAQdjgBBAbGiABQaT0ADYCFCABQZ70ADYCECAAQcS6BCABQRBqEB4gAUHljgE2AgQgAUHfjgE2AgAgAEHEugQgARAeIAFBIGokAAuXAQECfyMAQTBrIgQkACAAKAIQIgMoApABBEAgABCABCAAQYexAxAbGiAAIAEgAhCEAiAAQYmwAxAbGiAEQQhqIgEgA0EQakEoECMaIAAgARCLAyADKAKQASICQQFGBH8gAEGCkQIQGxogAygCkAEFIAILQQJGBEAgAEGS4gIQGxoLIAAQ/wMgAEHA5QQQGxoLIARBMGokAAuzAQEBfyMAQTBrIgQkACAAKAIQIgMoApABBEAgABCABCAAQYexAxAbGiAAIAEgAhCEAiAAQYmwAxAbGiAEQQhqIgEgA0EQakEoECMaIAAgARCLAyAAQZ+wAxAbGiAAIAMrA5gBEHQgAygCkAEiAkEBRgR/IABBgpECEBsaIAMoApABBSACC0ECRgRAIABBkuICEBsaCyAAQcmvAxAbGiAAEP8DIABBwOUEEBsaCyAEQTBqJAALCQAgACABEMYNC4MCAQJ/IwBB0ABrIgUkACAAKAIQIgQoApABBEAgABCABCAAQe2vAxAbGiAAIAEgAhCEAiAAQYmwAxAbGgJAIAMEQCAFQShqIgEgBEE4akEoECMaIAAgARCLAwwBC0HQ+QooAgAEQCAAQd+OARAbGgwBCyAAQceuAxAbGgtB0PkKKAIAQQFGBEBB0PkKQQA2AgALIABBn7ADEBsaIAAgBCsDmAEQdCAAQfywAxAbGiAAIAUgBEEQakEoECMQiwMgBCgCkAEiA0EBRgR/IABBgpECEBsaIAQoApABBSADC0ECRgRAIABBkuICEBsaCyAAEP8DIABBwOUEEBsaCyAFQdAAaiQAC68CAgJ/AXwjAEHQAGsiBCQAIAAoAhAiAygCkAEEQCABIAErAwAiBSABKwMQIAWhoTkDACABIAErAwgiBSABKwMYIAWhoTkDCCAAEIAEIABBkbADEBsaIAAgAUECEIQCIABBibADEBsaAkAgAgRAIARBKGoiASADQThqQSgQIxogACABEIsDDAELQdD5CigCAARAIABB344BEBsaDAELIABBx64DEBsaC0HQ+QooAgBBAUYEQEHQ+QpBADYCAAsgAEGfsAMQGxogACADKwOYARB0IABB/LADEBsaIAAgBCADQRBqQSgQIxCLAyADKAKQASIBQQFGBH8gAEGCkQIQGxogAygCkAEFIAELQQJGBEAgAEGS4gIQGxoLIAAQ/wMgAEHA5QQQGxoLIARB0ABqJAALzAICA38BfCMAQdAAayIDJAACQCAAKAIQIgQoApABRQ0AAn8gAigCBCsDECAAKwPgAqIiBplEAAAAAAAA4EFjBEAgBqoMAQtBgICAgHgLIgVFDQAgABCABCAAQZavAxAbGiABIAErAwggBbdEmpmZmZmZ4b+ioDkDCCADIAEpAwg3A0ggAyABKQMANwNAIAAgA0FAaxDeASADIAIoAgA2AjAgAEH+rwMgA0EwahAeIANBCGoiASAEQRBqQSgQIxogACABEIsDIABBwAgQGxogAigCBCIBKAIIIgRBBGogASAEGygCACEBIABByK4DEBsaIAAgARAbGiAAQciuAxAbGiADIAU2AgAgAEGlCCADEB4CQCAAIAIsADAiAUHsAEYEf0GmFgUgAUHyAEcNAUH2ngELEBsaCyAAEP8DIABBwOUEEBsaCyADQdAAaiQACwsAQdD5CkF/NgIACwsAQdD5CkEBNgIAC24BAn8jAEEgayIBJAAgACgCECECIABB8JsDEBsaIAIoAggQ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IANCnI7H4/G4nNY/NwNYIANCnI7H4/G4nNY/NwNQAkAgAygCaEESRyAHQQJHckUEQCACIAMoAnA2AmQgAiADKwN4OQNwIANBMGogABDWAkEBIQYgAy0AOEEBcUUNASADKgIwIQogAyADKgI0u0QAAAAAAABSQKM5A1ggAyAKu0QAAAAAAABSQKM5A1AMAQsgAkF/NgJkIAdBAkchBgtBiP0KLQAABEAjAEHgAWsiASQAQc29BEEbQQFBmNwGKAIAIgUQRRogAisDACEIIAEgAisDCDkD2AEgASAIOQPQASAFQamKBCABQdABahAwIAItAFwhBCABIAIoAlg2AsQBIAEgBEEBcTYCwAEgBUGaqAQgAUHAAWoQICACKwMQIQggASACKwMYOQO4ASABIAg5A7ABIAVB3IoEIAFBsAFqEDAgASACKAIgNgKgASAFQaakBCABQaABahAgIAEgAikCJDcDkAEgBUGSpQQgAUGQAWoQICACKwMwIQkgAisDOCEIIAEgAigCQDYCgAEgASAIOQN4IAEgCTkDcCAFQb+kBCABQfAAahAwIAIrA0ghCSACKwNQIQggASACLQBcQQF2QQFxNgJgIAEgCDkDWCABIAk5A1AgBUHXpgQgAUHQAGoQMCACLQBcIQQgASACKwN4OQNIIAFBADYCRCABIARBAnZBAXE2AkAgBUH0iQQgAUFAaxAwIAIoAmAhByACKAJkIQQgAisDcCEIIAEgAi0AaDYCMCABIAg5AyggASAENgIkIAEgB0ECdEGg6ARqKAIANgIgIAVBlqYEIAFBIGoQMCABIAIoAmxBAnRBwOgEaigCADYCECAFQczgAyABQRBqECAgASACKAKAATYCACAFQeSnBCABECAgAUHgAWokAAsgACADQeQAahCVBiEHAkAgAygCZEEBRgRAIAMgAykDWDcDCCADIAMpA1A3AwAgACACIAMQ4QkgBkUEQCAAIANB6ABqEMsDGgsgABCSAwwBCyAAQQJBCCADQTBqEL4DGiADQQE6ADxBACEFA0AgAygCZCIEIAVKBEAgByAFQQJ0aigCACIEQQAQpwMaIAMgAykDWDcDGCADIAMpA1A3AxAgBCACIANBEGoQ4QkgBkUEQCAEIANB6ABqEMsDGgsgBEECEI0CIAQQkgMgBUEBaiEFDAELCyAEIAcgACADQTBqENsEC0EA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QdwBahAlRQ0AIAAtABdFDQAgACgCHCIDIABBIGprQZ8BSg0AIAAgA0EEajYCHCADIAAoAhg2AgALIAAgAiAAKALMASAEEPgLIAApAwAhBiAFIAApAwg3AwggBSAGNwMAIABB3AFqIABBIGogACgCHCAEEKgBIABB/AJqIABB+AJqEFgEQCAEIAQoAgBBAnI2AgALIAAoAvwCIQcgARAvGiAAQdwBahAvGiAAQYADaiQAIAcLvAMBAX8jAEHwAmsiACQAIAAgAjYC6AIgACABNgLsAiAAQcwBaiADIABB4AFqIABB3AFqIABB2AFqEKMHIABBwAFqEEwiASABEFEQOSAAIAFBABA+IgI2ArwBIAAgAEEQajYCDCAAQQA2AgggAEEBOgAHIABBxQA6AAYDQAJAIABB7AJqIABB6AJqEFgNACAAKAK8ASABECUgAmpGBEAgARAlIQMgASABECVBAXQQOSABIAEQURA5IAAgAyABQQAQPiICajYCvAELIABB7AJqIgMQeyAAQQdqIABBBmogAiAAQbwBaiAAKALcASAAKALYASAAQcwBaiAAQRBqIABBDGogAEEIaiAAQeABahCiBw0AIAMQjwEaDAELCwJAIABBzAFqECVFDQAgAC0AB0UNACAAKAIMIgMgAEEQamtBnwFKDQAgACADQQRqNgIMIAMgACgCCDYCAAsgBSACIAAoArwBIAQQ+Qs5AwAgAEHMAWogAEEQaiAAKAIMIAQQqAEgAEHsAmogAEHoAmoQWARAIAQgBCgCAEECcjYCAAsgACgC7AIhBiABEC8aIABBzAFqEC8aIABB8AJqJAAgBgu8AwEBfyMAQfACayIAJAAgACACNgLoAiAAIAE2AuwCIABBzAFqIAMgAEHgAWogAEHcAWogAEHYAWoQowcgAEHAAWoQTCIBIAEQURA5IAAgAUEAED4iAjYCvAEgACAAQRBqNgIMIABBADYCCCAAQQE6AAcgAEHFADoABgNAAkAgAEHsAmogAEHoAmoQWA0AIAAoArwBIAEQJSACakYEQCABECUhAyABIAEQJUEBdBA5IAEgARBREDkgACADIAFBABA+IgJqNgK8AQsgAEHsAmoiAxB7IABBB2ogAEEGaiACIABBvAFqIAAoAtwBIAAoAtgBIABBzAFqIABBEGogAEEMaiAAQQhqIABB4AFqEKIHDQAgAxCPARoMAQsLAkAgAEHMAWoQJUUNACAALQAHRQ0AIAAoAgwiAyAAQRBqa0GfAUoNACAAIANBBGo2AgwgAyAAKAIINgIACyAFIAIgACgCvAEgBBD6CzgCACAAQcwBaiAAQRBqIAAoAgwgBBCoASAAQewCaiAAQegCahBYBEAgBCAEKAIAQQJyNgIACyAAKALsAiEGIAEQLxogAEHMAWoQLxogAEHwAmokACAGC50DAQN/IwBB0AJrIgAkACAAIAI2AsgCIAAgATYCzAIgAxCiAiEGIAMgAEHQAWoQowQhByAAQcQBaiADIABBxAJqEKIEIABBuAFqEEwiASABEFEQOSAAIAFBABA+IgI2ArQBIAAgAEEQajYCDCAAQQA2AggDQAJAIABBzAJqIABByAJqEFgNACAAKAK0ASABECUgAmpGBEAgARAlIQMgASABECVBAXQQOSABIAEQURA5IAAgAyABQQAQPiICajYCtAELIABBzAJqIgMQeyAGIAIgAEG0AWogAEEIaiAAKALEAiAAQcQBaiAAQRBqIABBDGogBxDSAw0AIAMQjwEaDAELCwJAIABBxAFqECVFDQAgACgCDCIDIABBEGprQZ8BSg0AIAAgA0EEajYCDCADIAAoAgg2AgALIAUgAiAAKAK0ASAEIAYQ+ws3AwAgAEHEAWogAEEQaiAAKAIMIAQQqAEgAEHMAmogAEHIAmoQWARAIAQgBCgCAEECcjYCAAsgACgCzAIhCCABEC8aIABBxAFqEC8aIABB0AJqJAAgCAudAwEDfyMAQdACayIAJAAgACACNgLIAiAAIAE2AswCIAMQogIhBiADIABB0AFqEKMEIQcgAEHEAWogAyAAQcQCahCiBCAAQbgBahBMIgEgARBREDkgACABQQAQPiICNgK0ASAAIABBEGo2AgwgAEEANgIIA0ACQCAAQcwCaiAAQcgCahBYDQAgACgCtAEgARAlIAJqRgRAIAEQJSEDIAEgARAlQQF0EDkgASABEFEQOSAAIAMgAUEAED4iAmo2ArQBCyAAQcwCaiIDEHsgBiACIABBtAFqIABBCGogACgCxAIgAEHEAWogAEEQaiAAQQxqIAcQ0gMNACADEI8BGgwBCwsCQCAAQcQBahAlRQ0AIAAoAgwiAyAAQRBqa0GfAUoNACAAIANBBGo2AgwgAyAAKAIINgIACyAFIAIgACgCtAEgBCAGEP8LOwEAIABBxAFqIABBEGogACgCDCAEEKgBIABBzAJqIABByAJqEFgEQCAEIAQoAgBBAnI2AgALIAAoAswCIQggARAvGiAAQcQBahAvGiAAQdACaiQAIAgLnQMBA38jAEHQAmsiACQAIAAgAjYCyAIgACABNgLMAiADEKICIQYgAyAAQdABahCjBCEHIABBxAFqIAMgAEHEAmoQogQgAEG4AWoQTCIBIAEQURA5IAAgAUEAED4iAjYCtAEgACAAQRBqNgIMIABBADYCCANAAkAgAEHMAmogAEHIAmoQWA0AIAAoArQBIAEQJSACakYEQCABECUhAyABIAEQJUEBdBA5IAEgARBREDkgACADIAFBABA+IgJqNgK0AQsgAEHMAmoiAxB7IAYgAiAAQbQBaiAAQQhqIAAoAsQCIABBxAFqIABBEGogAEEMaiAHENIDDQAgAxCPARoMAQsLAkAgAEHEAWoQJUUNACAAKAIMIgMgAEEQamtBnwFKDQAgACADQQRqNgIMIAMgACgCCDYCAAsgBSACIAAoArQBIAQgBhCADDcDACAAQcQBaiAAQRBqIAAoAgwgBBCoASAAQcwCaiAAQcgCahBYBEAgBCAEKAIAQQJyNgIACyAAKALMAiEIIAEQLxogAEHEAWoQLxogAEHQAmokACAIC50DAQN/IwBB0AJrIgAkACAAIAI2AsgCIAAgATYCzAIgAxCiAiEGIAMgAEHQAWoQowQhByAAQcQBaiADIABBxAJqEKIEIABBuAFqEEwiASABEFEQOSAAIAFBABA+IgI2ArQBIAAgAEEQajYCDCAAQQA2AggDQAJAIABBzAJqIABByAJqEFgNACAAKAK0ASABECUgAmpGBEAgARAlIQMgASABECVBAXQQOSABIAEQURA5IAAgAyABQQAQPiICajYCtAELIABBzAJqIgMQeyAGIAIgAEG0AWogAEEIaiAAKALEAiAAQcQBaiAAQRBqIABBDGogBxDSAw0AIAMQjwEaDAELCwJAIABBxAFqECVFDQAgACgCDCIDIABBEGprQZ8BSg0AIAAgA0EEajYCDCADIAAoAgg2AgALIAUgAiAAKAK0ASAEIAYQgQw2AgAgAEHEAWogAEEQaiAAKAIMIAQQqAEgAEHMAmogAEHIAmoQWARAIAQgBCgCAEECcjYCAAsg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4AKjoDkD2AJBAAsqACAAQYACOwGYBCAAIAArA9gCRAAAAAAAACTAIAArA+ACo6A5A9gCQQALKgAgAEGAAjsBmAQgACAAKwPQAkQAAAAAAAAkwCAAKwPgAqOgOQPQAkEACwoAIAAgAUEBEG8LCwBB4P0KIAA2AgALC6/0CZQDAEGACAvD3QT/2P/gAMXQ08YAfgAgLXRhZ3MgeyVkJXMweCVsbHh9AHslc30AICVkfQAlcyB7ICVzIH0AfGVkZ2VsYWJlbHwAIC1mb250IHsAcXVhcnR6AGlkeCA9PSBzegBjbnQgPT0gc3oAbG96AGdyYXBodml6AGd2d3JpdGVfbm9fegBwb3J0aG94eQBzY2FsZXh5AC9zdmcvbmF2eQBpbnZlbXB0eQBub2RlbGlzdF9pc19lbXB0eQBndl9zdGFja19pc19lbXB0eQByZWZlcmVuY2UgdG8gYmluYXJ5IGVudGl0eQBhc3luY2hyb25vdXMgZW50aXR5AGluY29tcGxldGUgbWFya3VwIGluIHBhcmFtZXRlciBlbnRpdHkAZW50aXR5IGRlY2xhcmVkIGluIHBhcmFtZXRlciBlbnRpdHkAY2Fubm90IHN1c3BlbmQgaW4gZXh0ZXJuYWwgcGFyYW1ldGVyIGVudGl0eQBYTUwgb3IgdGV4dCBkZWNsYXJhdGlvbiBub3QgYXQgc3RhcnQgb2YgZW50aXR5AHVuZGVmaW5lZCBlbnRpdHkAaW5maW5pdHkAZmFudGFzeQBTcGFyc2VNYXRyaXhfY29vcmRpbmF0ZV9mb3JtX2FkZF9lbnRyeQAvc3ZnL2l2b3J5AG91dCBvZiBtZW1vcnkARmVicnVhcnkASmFudWFyeQBndnBsdWdpbl9kb3RfbGF5b3V0X0xUWF9saWJyYXJ5AGd2cGx1Z2luX25lYXRvX2xheW91dF9MVFhfbGlicmFyeQBndnBsdWdpbl9jb3JlX0xUWF9saWJyYXJ5AGdhdGhlcl90aW1lX2VudHJvcHkAY29weQBhbGJhbnkASnVseQBTcGFyc2VNYXRyaXhfbXVsdGlwbHkAZXF1YWxseQBhc3NlbWJseQBzdW1tZXJza3kAc2h5AHNhdGlzZnkAYmVhdXRpZnkAbm9qdXN0aWZ5AENsYXNzaWZ5AC9zdmcvbGlnaHRncmV5AC9zdmcvZGltZ3JleQAvc3ZnL2RhcmtncmV5AC9zdmcvbGlnaHRzbGF0ZWdyZXkAL3N2Zy9kYXJrc2xhdGVncmV5AC9zdmcvc2xhdGVncmV5AHdlYmdyZXkAeDExZ3JleQAvc3ZnL2dyZXkAa2V5AG1vdmUgdG8gZnJvbnQgbG9jayBpbmNvbnNpc3RlbmN5AGV4dHJhY3RfYWRqYWNlbmN5AG1lcmdlX29uZXdheQBhcnJheQBhbGxvY0FycmF5AC9zdmcvbGlnaHRncmF5AC9zdmcvZGltZ3JheQAvc3ZnL2RhcmtncmF5AC9zdmcvbGlnaHRzbGF0ZWdyYXkAL3N2Zy9kYXJrc2xhdGVncmF5AC9zdmcvc2xhdGVncmF5AHdlYmdyYXkAeDExZ3JheQAvc3ZnL2dyYXkAVGh1cnNkYXkAVHVlc2RheQBXZWRuZXNkYXkAU2F0dXJkYXkAU3VuZGF5AE1vbmRheQBGcmlkYXkATWF5AC4uLy4uL2xpYi9jZ3JhcGgvZ3JhbW1hci55AFIueCAhPSBRLnggfHwgUi55ICE9IFEueQAlbS8lZC8leQBwb3J0aG95eABwb3J0aG9feXgAeHh4AHB4AGJveAB2aWV3Qm94AGNoa0JvdW5kQm94AC9NZWRpYUJveABnZXRfZWRnZV9sYWJlbF9tYXRyaXgAaWRlYWxfZGlzdGFuY2VfbWF0cml4AG11c3Qgbm90IHVuZGVjbGFyZSBwcmVmaXgAdW5ib3VuZCBwcmVmaXgAaHRtbGxleABtYXgAIyUwMnglMDJ4JTAyeCUwMngAIyUwMnglMDJ4JTAyeAAjJTJ4JTJ4JTJ4JTJ4ACMlMXglMXglMXgALSsgICAwWDB4AC0wWCswWCAwWC0weCsweCAweAByYXJyb3cAbGFycm93AEhlbHZldGljYS1OYXJyb3cAYXJyb3dfbGVuZ3RoX2Nyb3cAL3N2Zy9zbm93AHNwcmluZ19lbGVjdHJpY2FsX2VtYmVkZGluZ19zbG93AC9zdmcvbGlnaHR5ZWxsb3cAL3N2Zy9ncmVlbnllbGxvdwAvc3ZnL2xpZ2h0Z29sZGVucm9keWVsbG93AC9zdmcveWVsbG93AGZhdGFsIGVycm9yIC0gc2Nhbm5lciBpbnB1dCBidWZmZXIgb3ZlcmZsb3cAZmxleCBzY2FubmVyIHB1c2gtYmFjayBvdmVyZmxvdwBjb3VyaWVybmV3AFNwcmluZ1Ntb290aGVyX25ldwBUcmlhbmdsZVNtb290aGVyX25ldwBkaWFnX3ByZWNvbl9uZXcAUXVhZFRyZWVfbmV3AFN0cmVzc01ham9yaXphdGlvblNtb290aGVyMl9uZXcAciAmJiBuICYmIG5ldwBza2V3AHN0cnZpZXcAL3N2Zy9ob25leWRldwAgLWFuY2hvciB3AHNvcnR2AHBvdjpwb3YATm92AGludgBlcXVpdgBwaXYAbm9uYW1lLmd2ACV6dQAvc3ZnL3BlcnUAbnUAbXUAJWMlbGx1AFRodQB0YXUAVGF1AE51AE11AF9wb3J0XyVzXyglZClfKCVkKV8ldQBwbGFpbnRleHQAPHRleHQAc3RyZXNzd3QAaW5wdXQAdGV4dGxheW91dABkb3RfbGF5b3V0AG5lYXRvX2xheW91dABpbml0TGF5b3V0AHVzZXJvdXQAY2x1c3QAbWFwQ2x1c3QAbGFiZWxqdXN0AHNjQWRqdXN0AEF1Z3VzdABlZGdlc2ZpcnN0AG5vZGVzZmlyc3QAbWF4aW1hbF9pbmRlcGVuZGVudF9lZGdlX3NldF9oZWF2ZXN0X2VkZ2VfcGVybm9kZV9zdXBlcm5vZGVzX2ZpcnN0AGV4aXN0AHJlYWxpZ25Ob2RlbGlzdABhcHBlbmROb2RlbGlzdABkZWZhdWx0ZGlzdABtaW5kaXN0AHBvd2VyX2Rpc3QAZ3JhcGhfZGlzdABhdmdfZGlzdABnZXRFZGdlTGlzdABpcXVlc3QAbG93YXN0AHNwcmluZ19lbGVjdHJpY2FsX2VtYmVkZGluZ19mYXN0AGd2X3NvcnQAZGVnbGlzdF9zb3J0AHZpZXdwb3J0AHRhaWxwb3J0AHVuZXhwZWN0ZWQgcGFyc2VyIHN0YXRlIC0gcGxlYXNlIHNlbmQgYSBidWcgcmVwb3J0AGhlYWRwb3J0AFJUcmVlSW5zZXJ0AGZpbmRTVmVydABzdGFydABwYXJ0AGVzdGltYXRlX3RleHRfd2lkdGhfMXB0AHF1b3QAf3Jvb3QAbm90AGVtaXRfeGRvdAB4ZG90Onhkb3QAZXBzOnhkb3QAc3ZnOnhkb3QAanBnOnhkb3QAcG5nOnhkb3QAanBlZzp4ZG90AGdpZjp4ZG90AGpwZTp4ZG90AHhkb3QxLjQ6eGRvdAB4ZG90MS4yOnhkb3QAc2RvdABtaWRkb3QAZ3Y6ZG90AHBsYWluLWV4dDpkb3QAZG90OmRvdABlcHM6ZG90AGNhbm9uOmRvdABwbGFpbjpkb3QAc3ZnOmRvdABqcGc6ZG90AHBuZzpkb3QAanBlZzpkb3QAZ2lmOmRvdABqcGU6ZG90AH9ib3QAZG9Eb3QAc3Bhbi0+Zm9udAB2YWd4YnByaW50AGxvY2F0ZV9lbmRwb2ludABkZWNpZGVfcG9pbnQAVW5zYXRpc2ZpZWQgY29uc3RyYWludAB0cmFuc3BhcmVudABjb21wb25lbnQAaW52YWxpZCBhcmd1bWVudABjb21tZW50AGp1bmsgYWZ0ZXIgZG9jdW1lbnQgZWxlbWVudABjZW50AGkgPT0gZWNudABhcmlhbG10AGx0AGNpcmN1aXQAcG9seV9pbml0AE11bHRpbGV2ZWxfaW5pdABuc2xpbWl0AG1jbGltaXQAUG9ydHJhaXQAbGlnaHQAdmlydHVhbF93ZWlnaHQAbGhlaWdodABLUF9SaWdodABCb29rbWFuLUxpZ2h0AGd0AEtQX0xlZnQAYWd4c2V0AGNoYXJzZXQAaW5zZXQAYml0YXJyYXlfcmVzZXQAc3Vic2V0AGJpdGFycmF5X3NldABub2RlbGlzdF9zZXQAc2NhcmxldAAvc3ZnL2Rhcmt2aW9sZXQAL3N2Zy9ibHVldmlvbGV0AC9zdmcvdmlvbGV0AFRyZWJ1Y2hldABhZ3hnZXQAdGFpbHRhcmdldABsYWJlbHRhcmdldABlZGdldGFyZ2V0AGhlYWR0YXJnZXQAYml0YXJyYXlfZ2V0AG5vZGVsaXN0X2dldABzYW1lX2xpc3RfZ2V0AGVkZ2VfbGlzdF9nZXQAcG9pbnRzX2dldAB0cmlhbmdsZXNfZ2V0AHZlY19nZXQAc3R5bGVzaGVldABzdHJpY3QAYWdjb3B5ZGljdABhZ21ha2VkYXRhZGljdAByZWMtPmRpY3QgPT0gZGF0YWRpY3QAd3JpdGVfZGljdABzZWN0AGVuY29kaW5nIHNwZWNpZmllZCBpbiBYTUwgZGVjbGFyYXRpb24gaXMgaW5jb3JyZWN0AGFzcGVjdABsYXllcnNlbGVjdABDb21iaW5lUmVjdABLUF9TdWJ0cmFjdABRdWFkVHJlZV9yZXB1bHNpdmVfZm9yY2VfaW50ZXJhY3QAY29tcGFjdABPY3QAcmVxdWVzdGVkIGZlYXR1cmUgcmVxdWlyZXMgWE1MX0RURCBzdXBwb3J0IGluIEV4cGF0AGxhYmVsZmxvYXQAbGFiZWxfZmxvYXQAU3BhcnNlTWF0cml4X2Zyb21fY29vcmRpbmF0ZV9mb3JtYXQAL3N2Zy93aGVhdABvYmpsaXN0X2F0AG5vZGVsaXN0X2F0AHNhbWVfbGlzdF9hdABwb2ludHNfYXQAdHJpYW5nbGVzX2F0AFNhdABBZ3JhcGhpbmZvX3QAQWdlZGdlaW5mb190AEFnbm9kZWluZm9fdABcdABmbGF0aW5kZXgoYWdoZWFkKGUpKSA8IE0tPm5yb3dzAG1pbnVzAG9wbHVzAGhlYXJ0cwBzYW1wbGVwb2ludHMAZGlyZWRnZWNvbnN0cmFpbnRzAGxldmVsIGFzc2lnbm1lbnQgY29uc3RyYWludHMAeHkgcHNldWRvLW9ydGhvZ29uYWwgY29uc3RyYWludHMAeXggcHNldWRvLW9ydGhvZ29uYWwgY29uc3RyYWludHMAeHkgb3J0aG9nb25hbCBjb25zdHJhaW50cwB5eCBvcnRob2dvbmFsIGNvbnN0cmFpbnRzAGxpbmUgc2VnbWVudHMAcmVjdHMAYWNjb3VudGluZ1JlcG9ydFN0YXRzAGVudGl0eVRyYWNraW5nUmVwb3J0U3RhdHMAWmFwZkRpbmdiYXRzAHJlbWluY3Jvc3MAY29tcHJlc3MAZ3Z1c2Vyc2hhcGVfZmlsZV9hY2Nlc3MAYnJhc3MAY2xhc3MAYXBwbHlhdHRycwBhZ21ha2VhdHRycwBiaW5kYXR0cnMAcGFyc2VfbGF5ZXJzAG1rQ2x1c3RlcnMAcm91bmRfY29ybmVycwBtYWtlX2JhcnJpZXJzAGNkYXRhLT5udG9wbGV2ZWw9PWFnbm5vZGVzKGcpLWNkYXRhLT5udmFycwBjYW5ub3QgcmVhbGxvYyBvcHMAY2Fubm90IHJlYWxsb2MgcG5scHMAZXBzAGNvcmVfbG9hZGltYWdlX3BzAGVwczpwcwBwczI6cHMAKGxpYik6cHMAYWd4YnVmX3RyaW1femVyb3MAdGV4Z3lyZWhlcm9zAGltYWdlcG9zAHRpbm9zAHNldEVkZ2VMYWJlbFBvcwBTZXR0aW5nIGluaXRpYWwgcG9zaXRpb25zAHhsaW50ZXJzZWN0aW9ucwBjb2x1bW5zAGRlamF2dXNhbnMAbmltYnVzc2FucwBsaWJlcmF0aW9uc2FucwBmcmVlc2FucwBPcGVuU2FucwBvZmZzZXQgPT0gbl90ZXJtcwBkaXRlbXMAaW5kZXggPCBwdmVjLT5fZWxlbXMAZGlhbXMAZmxhdGluZGV4KGFndGFpbChlKSkgPCBNLT5uY29scwBjYW5ub3QgcmVhbGxvYyBkcS5wbmxzAGNhbm5vdCByZWFsbG9jIHBubHMAbGV2ZWxzAGZvcmNlbGFiZWxzAG1ha2VTaW1wbGVGbGF0TGFiZWxzAGRpYWdvbmFscwBtZXJnZV9yYW5rcwBvYmpwbHBta3MAc3BsaXRCbG9ja3MAaW52aXMAY2Fubm90IHJlYWxsb2MgdHJpcwBDYWxjdWxhdGluZyBzaG9ydGVzdCBwYXRocwB5ZXMAc2hvd2JveGVzAGJlYXV0aWZ5X2xlYXZlcwBhdHRhY2hfZWRnZV9sYWJlbF9jb29yZGluYXRlcwBwb2x5bGluZXMAX2RvdF9zcGxpbmVzAG9ydGhvZ29uYWwgbGluZXMAdGV4Z3lyZXRlcm1lcwBvdGltZXMAVGltZXMAZm9udG5hbWVzAHByZWZpeCBtdXN0IG5vdCBiZSBib3VuZCB0byBvbmUgb2YgdGhlIHJlc2VydmVkIG5hbWVzcGFjZSBuYW1lcwBTcGFyc2VNYXRyaXhfc3VtX3JlcGVhdF9lbnRyaWVzAHBlcmlwaGVyaWVzAEdldEJyYW5jaGVzAGYgPCBncmFwaFtqXS5uZWRnZXMAbWlubWF4X2VkZ2VzAG1ha2VfZmxhdF9ib3R0b21fZWRnZXMAdW5kb0NsdXN0ZXJFZGdlcwBjb21wb3VuZEVkZ2VzAG1lcmdlX3RyZWVzAF9fY2x1c3Rlcm5vZGVzAE5EX2lkKG5wKSA9PSBuX25vZGVzAExvYWROb2RlcwBzaWRlcwBzcGFkZXMAdmVydGljZXMAY29vcmRzAHNldGJvdW5kcwBtZHMAY2RzAGVtaXRfZWRnZV9ncmFwaGljcwBjbHVicwBjb25zb2xhcwAlbGYlMnMAClN0cmluZyBzdGFydGluZzo8JS44MHMAClN0cmluZyBzdGFydGluZzoiJS44MHMAICUuKnMAJS4qcyVzJXMAZXhwYXQ6IEFjY291bnRpbmcoJXApOiBEaXJlY3QgJTEwbGx1LCBpbmRpcmVjdCAlMTBsbHUsIGFtcGxpZmljYXRpb24gJTguMmYlcwAgJXM6JXMAX18lZDolcwAvJXMvJXMAJXMtJXMALCVzACBmb250LWZhbWlseT0iJXMAIiBzdHJva2UtZGFzaGFycmF5PSIlcwAiIGNsYXNzPSIlcwBwb2x5ICVzACgoJWYsJWYpLCglZiwlZikpICVzICVzAGNvbG9yICVzACBUaXRsZTogJXMAInN0cmljdCI6ICVzAHIgJiYgcwBjb3VyAHV0cgBhcHBlbmRhdHRyAGFkZGF0dHIAYmVnaW5zdHIAc3Rydmlld19zdHIAcG92X2NvbG9yX2FzX3N0cgB2cHNjIT1udWxscHRyAGJlbmRUb1N0cgB1YXJyAGNyYXJyAGxhcnIAaGFycgBkYXJyAHVBcnIAckFycgBsQXJyAGhBcnIAZEFycgByICYmIHJyAEFwcgBTcGFyc2VNYXRyaXhfbXVsdGlwbHlfdmVjdG9yAHRlcm1pbmF0b3IAaW5zdWxhdG9yAHRleGd5cmVjdXJzb3IAc3ludGF4IGVycm9yAEVycm9yAHJmbG9vcgBsZmxvb3IAbGFiZWxmb250Y29sb3IAcGVuY29sb3IAZmlsbGNvbG9yAGJnY29sb3IAcm93IG1ham9yAGNvbHVtbiBtYWpvcgBuZWlnaGJvcgBtcgByYW5rZGlyAHBhZ2VkaXIAbGF5ZXIATm9kZUNvdmVyAC9zdmcvc2lsdmVyAGNsdXN0ZXIAZXhwYW5kQ2x1c3RlcgBycHJvbW90ZXIAbHByb21vdGVyAGNlbnRlcgBtYXhpdGVyAHBhcnRpYWwgY2hhcmFjdGVyACEgcm9vdFBhcnNlci0+bV9wYXJlbnRQYXJzZXIAZGtncmVlbmNvcHBlcgBjb29sY29wcGVyAGd2X3NvcnRfY29tcGFyX3dyYXBwZXIAdGFwZXIAb3ZlcmxhcF9iZXppZXIAZmlnX2JlemllcgBjb3VyaWVyAENvdXJpZXIAaGllcgBkYWdnZXIARGFnZ2VyAG91dHB1dG9yZGVyAHBvc3RvcmRlcgBmbGF0X3Jlb3JkZXIAY2VsbGJvcmRlcgBmaXhMYWJlbE9yZGVyAGN5bGluZGVyAC9zdmcvbGF2ZW5kZXIAcmVuZGVyAGZvbGRlcgBjbHVzdGVyX2xlYWRlcgBORF9VRl9zaXplKG4pIDw9IDEgfHwgbiA9PSBsZWFkZXIAT2N0b2JlcgByZWZlcmVuY2UgdG8gaW52YWxpZCBjaGFyYWN0ZXIgbnVtYmVyAE5vdmVtYmVyAFNlcHRlbWJlcgBEZWNlbWJlcgBtYWNyAGJyAHN0YXIAZmVsZHNwYXIAcmVndWxhcgBzYW1lX2xpc3RfY2xlYXIAaW9zX2Jhc2U6OmNsZWFyAGJydmJhcgBNYXIAXHIATkRfcmFuayh2KSA9PSByAHN0cmVxAHN0cnZpZXdfZXEAc3Rydmlld19zdHJfZXEAc3Rydmlld19jYXNlX3N0cl9lcQBzdHJ2aWV3X2Nhc2VfZXEAdnAAJSVCZWdpblByb2xvZwovRG90RGljdCAyMDAgZGljdCBkZWYKRG90RGljdCBiZWdpbgoKL3NldHVwTGF0aW4xIHsKbWFyawovRW5jb2RpbmdWZWN0b3IgMjU2IGFycmF5IGRlZgogRW5jb2RpbmdWZWN0b3IgMAoKSVNPTGF0aW4xRW5jb2RpbmcgMCAyNTUgZ2V0aW50ZXJ2YWwgcHV0aW50ZXJ2YWwKRW5jb2RpbmdWZWN0b3IgNDUgL2h5cGhlbiBwdXQKCiUgU2V0IHVwIElTTyBMYXRpbiAxIGNoYXJhY3RlciBlbmNvZGluZwovc3Rhcm5ldElTTyB7CiAgICAgICAgZHVwIGR1cCBmaW5kZm9udCBkdXAgbGVuZ3RoIGRpY3QgYmVnaW4KICAgICAgICB7IDEgaW5kZXggL0ZJRCBuZSB7IGRlZiB9eyBwb3AgcG9wIH0gaWZlbHNlCiAgICAgICAgfSBmb3JhbGwKICAgICAgICAvRW5jb2RpbmcgRW5jb2RpbmdWZWN0b3IgZGVmCiAgICAgICAgY3VycmVudGRpY3QgZW5kIGRlZmluZWZvbnQKfSBkZWYKL1RpbWVzLVJvbWFuIHN0YXJuZXRJU08gZGVmCi9UaW1lcy1JdGFsaWMgc3Rhcm5ldElTTyBkZWYKL1RpbWVzLUJvbGQgc3Rhcm5ldElTTyBkZWYKL1RpbWVzLUJvbGRJdGFsaWMgc3Rhcm5ldElTTyBkZWYKL0hlbHZldGljYSBzdGFybmV0SVNPIGRlZgovSGVsdmV0aWNhLU9ibGlxdWUgc3Rhcm5ldElTTyBkZWYKL0hlbHZldGljYS1Cb2xkIHN0YXJuZXRJU08gZGVmCi9IZWx2ZXRpY2EtQm9sZE9ibGlxdWUgc3Rhcm5ldElTTyBkZWYKL0NvdXJpZXIgc3Rhcm5ldElTTyBkZWYKL0NvdXJpZXItT2JsaXF1ZSBzdGFybmV0SVNPIGRlZgovQ291cmllci1Cb2xkIHN0YXJuZXRJU08gZGVmCi9Db3VyaWVyLUJvbGRPYmxpcXVlIHN0YXJuZXRJU08gZGVmCmNsZWFydG9tYXJrCn0gYmluZCBkZWYKCiUlQmVnaW5SZXNvdXJjZTogcHJvY3NldCBncmFwaHZpeiAwIDAKL2Nvb3JkLWZvbnQtZmFtaWx5IC9UaW1lcy1Sb21hbiBkZWYKL2RlZmF1bHQtZm9udC1mYW1pbHkgL1RpbWVzLVJvbWFuIGRlZgovY29vcmRmb250IGNvb3JkLWZvbnQtZmFtaWx5IGZpbmRmb250IDggc2NhbGVmb250IGRlZgoKL0ludlNjYWxlRmFjdG9yIDEuMCBkZWYKL3NldF9zY2FsZSB7CiAgICAgICBkdXAgMSBleGNoIGRpdiAvSW52U2NhbGVGYWN0b3IgZXhjaCBkZWYKICAgICAgIHNjYWxlCn0gYmluZCBkZWYKCiUgc3R5bGVzCi9zb2xpZCB7IFtdIDAgc2V0ZGFzaCB9IGJpbmQgZGVmCi9kYXNoZWQgeyBbOSBJbnZTY2FsZUZhY3RvciBtdWwgZHVwIF0gMCBzZXRkYXNoIH0gYmluZCBkZWYKL2RvdHRlZCB7IFsxIEludlNjYWxlRmFjdG9yIG11bCA2IEludlNjYWxlRmFjdG9yIG11bF0gMCBzZXRkYXNoIH0gYmluZCBkZWYKL2ludmlzIHsvZmlsbCB7bmV3cGF0aH0gZGVmIC9zdHJva2Uge25ld3BhdGh9IGRlZiAvc2hvdyB7cG9wIG5ld3BhdGh9IGRlZn0gYmluZCBkZWYKL2JvbGQgeyAyIHNldGxpbmV3aWR0aCB9IGJpbmQgZGVmCi9maWxsZWQgeyB9IGJpbmQgZGVmCi91bmZpbGxlZCB7IH0gYmluZCBkZWYKL3JvdW5kZWQgeyB9IGJpbmQgZGVmCi9kaWFnb25hbHMgeyB9IGJpbmQgZGVmCi90YXBlcmVkIHsgfSBiaW5kIGRlZgoKJSBob29rcyBmb3Igc2V0dGluZyBjb2xvciAKL25vZGVjb2xvciB7IHNldGhzYmNvbG9yIH0gYmluZCBkZWYKL2VkZ2Vjb2xvciB7IHNldGhzYmNvbG9yIH0gYmluZCBkZWYKL2dyYXBoY29sb3IgeyBzZXRoc2Jjb2xvciB9IGJpbmQgZGVmCi9ub3Bjb2xvciB7cG9wIHBvcCBwb3B9IGJpbmQgZGVmCgovYmVnaW5wYWdlIHsJJSBpIGogbnBhZ2VzCgkvbnBhZ2VzIGV4Y2ggZGVmCgkvaiBleGNoIGRlZgoJL2kgZXhjaCBkZWYKCS9zdHIgMTAgc3RyaW5nIGRlZgoJbnBhZ2VzIDEgZ3QgewoJCWdzYXZlCgkJCWNvb3JkZm9udCBzZXRmb250CgkJCTAgMCBtb3ZldG8KCQkJKFwoKSBzaG93IGkgc3RyIGN2cyBzaG93ICgsKSBzaG93IGogc3RyIGN2cyBzaG93IChcKSkgc2hvdwoJCWdyZXN0b3JlCgl9IGlmCn0gYmluZCBkZWYKCi9zZXRfZm9udCB7CglmaW5kZm9udCBleGNoCglzY2FsZWZvbnQgc2V0Zm9udAp9IGRlZgoKJSBkcmF3IHRleHQgZml0dGVkIHRvIGl0cyBleHBlY3RlZCB3aWR0aAovYWxpZ25lZHRleHQgewkJCSUgd2lkdGggdGV4dAoJL3RleHQgZXhjaCBkZWYKCS93aWR0aCBleGNoIGRlZgoJZ3NhdmUKCQl3aWR0aCAwIGd0IHsKCQkJW10gMCBzZXRkYXNoCgkJCXRleHQgc3RyaW5nd2lkdGggcG9wIHdpZHRoIGV4Y2ggc3ViIHRleHQgbGVuZ3RoIGRpdiAwIHRleHQgYXNob3cKCQl9IGlmCglncmVzdG9yZQp9IGRlZgoKL2JveHByaW0gewkJCQklIHhjb3JuZXIgeWNvcm5lciB4c2l6ZSB5c2l6ZQoJCTQgMiByb2xsCgkJbW92ZXRvCgkJMiBjb3B5CgkJZXhjaCAwIHJsaW5ldG8KCQkwIGV4Y2ggcmxpbmV0bwoJCXBvcCBuZWcgMCBybGluZXRvCgkJY2xvc2VwYXRoCn0gYmluZCBkZWYKCi9lbGxpcHNlX3BhdGggewoJL3J5IGV4Y2ggZGVmCgkvcnggZXhjaCBkZWYKCS95IGV4Y2ggZGVmCgkveCBleGNoIGRlZgoJbWF0cml4IGN1cnJlbnRtYXRyaXgKCW5ld3BhdGgKCXggeSB0cmFuc2xhdGUKCXJ4IHJ5IHNjYWxlCgkwIDAgMSAwIDM2MCBhcmMKCXNldG1hdHJpeAp9IGJpbmQgZGVmCgovZW5kcGFnZSB7IHNob3dwYWdlIH0gYmluZCBkZWYKL3Nob3dwYWdlIHsgfSBkZWYKCi9sYXllcmNvbG9yc2VxCglbCSUgbGF5ZXIgY29sb3Igc2VxdWVuY2UgLSBkYXJrZXN0IHRvIGxpZ2h0ZXN0CgkJWzAgMCAwXQoJCVsuMiAuOCAuOF0KCQlbLjQgLjggLjhdCgkJWy42IC44IC44XQoJCVsuOCAuOCAuOF0KCV0KZGVmCgovbGF5ZXJsZW4gbGF5ZXJjb2xvcnNlcSBsZW5ndGggZGVmCgovc2V0bGF5ZXIgey9tYXhsYXllciBleGNoIGRlZiAvY3VybGF5ZXIgZXhjaCBkZWYKCWxheWVyY29sb3JzZXEgY3VybGF5ZXIgMSBzdWIgbGF5ZXJsZW4gbW9kIGdldAoJYWxvYWQgcG9wIHNldGhzYmNvbG9yCgkvbm9kZWNvbG9yIHtub3Bjb2xvcn0gZGVmCgkvZWRnZWNvbG9yIHtub3Bjb2xvcn0gZGVmCgkvZ3JhcGhjb2xvciB7bm9wY29sb3J9IGRlZgp9IGJpbmQgZGVmCgovb25sYXllciB7IGN1cmxheWVyIG5lIHtpbnZpc30gaWYgfSBkZWYKCi9vbmxheWVycyB7CgkvbXl1cHBlciBleGNoIGRlZgoJL215bG93ZXIgZXhjaCBkZWYKCWN1cmxheWVyIG15bG93ZXIgbHQKCWN1cmxheWVyIG15dXBwZXIgZ3QKCW9yCgl7aW52aXN9IGlmCn0gZGVmCgovY3VybGF5ZXIgMCBkZWYKCiUlRW5kUmVzb3VyY2UKJSVFbmRQcm9sb2cKJSVCZWdpblNldHVwCjE0IGRlZmF1bHQtZm9udC1mYW1pbHkgc2V0X2ZvbnQKJSAvYXJyb3dsZW5ndGggMTAgZGVmCiUgL2Fycm93d2lkdGggNSBkZWYKCiUgbWFrZSBzdXJlIHBkZm1hcmsgaXMgaGFybWxlc3MgZm9yIFBTLWludGVycHJldGVycyBvdGhlciB0aGFuIERpc3RpbGxlcgovcGRmbWFyayB3aGVyZSB7cG9wfSB7dXNlcmRpY3QgL3BkZm1hcmsgL2NsZWFydG9tYXJrIGxvYWQgcHV0fSBpZmVsc2UKJSBtYWtlICc8PCcgYW5kICc+Picgc2FmZSBvbiBQUyBMZXZlbCAxIGRldmljZXMKL2xhbmd1YWdlbGV2ZWwgd2hlcmUge3BvcCBsYW5ndWFnZWxldmVsfXsxfSBpZmVsc2UKMiBsdCB7CiAgICB1c2VyZGljdCAoPDwpIGN2biAoWykgY3ZuIGxvYWQgcHV0CiAgICB1c2VyZGljdCAoPj4pIGN2biAoWykgY3ZuIGxvYWQgcHV0Cn0gaWYKCiUlRW5kU2V0dXAAc3VwAGdyb3VwAGN1cAB0aGluc3AAZW5zcABlbXNwAG5ic3AAcGVycAB3ZWllcnAAZ2VuZXJhdGUtY29uc3RyYWludHMuY3BwAGNzb2x2ZV9WUFNDLmNwcAB/dG9wAHByb3AAYWd4YnBvcABlc3RhY2tfcG9wAG5vcABhc3ltcABjb21wAGZpbmRDQ29tcABibXAAc2NhbGVfY2xhbXAAbXA6bXAAeGxwAGxwICE9IGNscAB0YWlsX2xwAGhlYWRfbHAAdGFpbHRvb2x0aXAAbGFiZWx0b29sdGlwAGVkZ2V0b29sdGlwAGhlYWR0b29sdGlwAGhlbGxpcAB0YWlsY2xpcABoZWFkY2xpcAAvc3ZnL3BhcGF5YXdoaXAAaHAAdHJhbnNwb3NlX3N0ZXAAbGF5ZXJsaXN0c2VwAGxheWVyc2VwAGlwc2VwAHJhbmtzZXAAbm9kZXNlcABzdWJncmFwaHMgbmVzdGVkIG1vcmUgdGhhbiAlZCBkZWVwAFNlcABzZmRwAGNwAHdlYnAAY2x1c3Rlcl9tYXAAY21hcHg6bWFwAGVwczptYXAAY21hcHhfbnA6bWFwAGltYXBfbnA6bWFwAGlzbWFwOm1hcABpbWFwOm1hcABjbWFwOm1hcABzdmc6bWFwAGpwZzptYXAAcG5nOm1hcABqcGVnOm1hcABnaWY6bWFwAGpwZTptYXAAb3ZlcmxhcABPdmVybGFwAGxldmVsc2dhcABjYXAAS1BfVXAAJUk6JU06JVMgJXAAc3RhcnQgPD0gcAByc3F1bwBsc3F1bwByZHF1bwBsZHF1bwBiZHF1bwBzYnF1bwByc2FxdW8AbHNhcXVvAHJhcXVvAGxhcXVvAGF1dG8ATnVuaXRvAC9zdmcvdG9tYXRvAG5lYXRvAGV1cm8AL3N2Zy9nYWluc2Jvcm8ATWV0aG9kWmVybwBtaWNybwBuaW1idXNtb25vAGxpYmVyYXRpb25tb25vAGZyZWVtb25vAGFyaW1vAHJhdGlvAHBvcnRobwByaG8AUmhvAC9zdmcvaW5kaWdvAHBpbmZvAGNjZ3JhcGhpbmZvAGNjZ25vZGVpbmZvAGNsX2VkZ2VfaW5mbwBnZXRQYWNrSW5mbwBtYWtlSW5mbwBwYXJzZVBhY2tNb2RlSW5mbwBjaXJjbwBpY28AJTAzbwAvc3ZnL3Jvc3licm93bgAvc3ZnL3NhbmR5YnJvd24AdmVyeWRhcmticm93bgAvc3ZnL3NhZGRsZWJyb3duAC9zdmcvYnJvd24AS1BfRG93bgBjYW5ub3QgY2hhbmdlIHNldHRpbmcgb25jZSBwYXJzaW5nIGhhcyBiZWd1bgBTdW4ASnVuAHRob3JuAC9zdmcvY3JpbXNvbgB4ZG90X2pzb24AeGRvdF9qc29uOmpzb24AanNvbjA6anNvbgBvbWljcm9uAE9taWNyb24Ac2Nhcm9uAFNjYXJvbgB3ZWJtYXJvb24AeDExbWFyb29uAC9zdmcvbWFyb29uAC9zdmcvbGlnaHRzYWxtb24AL3N2Zy9kYXJrc2FsbW9uAC9zdmcvc2FsbW9uAHVwc2lsb24AZXBzaWxvbgBVcHNpbG9uAEVwc2lsb24AcmVzb2x1dGlvbgBkaXN0b3J0aW9uAHN0ZDo6ZXhjZXB0aW9uAGRvdF9wb3NpdGlvbgBTZXR0aW5nIHVwIHN0cmVzcyBmdW5jdGlvbgB1bmNsb3NlZCBDREFUQSBzZWN0aW9uAHBvc3RhY3Rpb24Acm90YXRpb24Ab3JpZW50YXRpb24AYWJvbWluYXRpb24AYWNjb3VudGluZ0dldEN1cnJlbnRBbXBsaWZpY2F0aW9uAHhkb3R2ZXJzaW9uAFNUc2V0VW5pb24APHBvbHlnb24AaGV4YWdvbgBzZXB0YWdvbgBwZW50YWdvbgB0cmlwbGVvY3RhZ29uAGRvdWJsZW9jdGFnb24AL3N2Zy9sZW1vbmNoaWZmb24ATW9uAHBsdXNtbgBub3RpbgBpc2luAC9zdmcvbW9jY2FzaW4AcGluAG1pbgB2b3JvX21hcmdpbgBpbmZpbgBvbmVkX29wdGltaXplcl90cmFpbgBwbGFpbgBtYWtlX2NoYWluAG1lcmdlX2NoYWluAHZhbGlnbgBiYWxpZ24AeWVuAE11bHRpbGV2ZWxfY29hcnNlbgBjdXJyZW4AUG9ic29wZW4AZ3Z1c2Vyc2hhcGVfb3BlbgBlbnRpdHlUcmFja2luZ09uT3BlbgAvc3ZnL2xpbmVuAGRpbWVuAG1pbmxlbgBzdHlsZV90b2tlbgB1bmNsb3NlZCB0b2tlbgAvc3ZnL3llbGxvd2dyZWVuAG1lZGl1bWZvcmVzdGdyZWVuAC9zdmcvZm9yZXN0Z3JlZW4AL3N2Zy9saWdodGdyZWVuAGh1bnRlcnNncmVlbgAvc3ZnL2xhd25ncmVlbgAvc3ZnL2RhcmtncmVlbgAvc3ZnL21lZGl1bXNwcmluZ2dyZWVuAC9zdmcvc3ByaW5nZ3JlZW4AL3N2Zy9kYXJrb2xpdmVncmVlbgAvc3ZnL2xpbWVncmVlbgAvc3ZnL3BhbGVncmVlbgB3ZWJncmVlbgAvc3ZnL2xpZ2h0c2VhZ3JlZW4AL3N2Zy9tZWRpdW1zZWFncmVlbgAvc3ZnL2RhcmtzZWFncmVlbgAvc3ZnL3NlYWdyZWVuAHgxMWdyZWVuAC9zdmcvZ3JlZW4AR3JlZW4AL3N2Zy9saWdodGN5YW4AL3N2Zy9kYXJrY3lhbgAvc3ZnL2N5YW4AbmV3dGFuAGRhcmt0YW4AL3N2Zy90YW4Acm93c3BhbgBjb2xzcGFuAG5hbgB0aW1lc25ld3JvbWFuAG5pbWJ1c3JvbWFuAHRpbWVzcm9tYW4AVGltZXMtUm9tYW4AUGFsYXRpbm8tUm9tYW4ATmV3Q2VudHVyeVNjaGxiay1Sb21hbgBKYW4AR0RfcmFuayhnKVtyXS5uIDw9IEdEX3JhbmsoZylbcl0uYW4AYWd4YnB1dF9uAFxuAG5fbm9kZXMgPT0gZ3JhcGgtPm4AQS0+bSA9PSBBLT5uAGpvYi0+b2JqLT51Lm4AcywlbGYsJWxmJW4AIGUsJWxmLCVsZiVuACVkICUxWyJdJW4AdiA9PSBuAG56YyA9PSBuAGIgPT0gbgBuY2x1c3RlciA8PSBuAHIgJiYgbgBwc3ltAGFsZWZzeW0AdGhldGFzeW0AcXVhbnR1bQBzdW0AL3N2Zy9wbHVtAGludnRyYXBleml1bQBtZWRpdW0AOTpwcmlzbQBscm0AY3VzdG9tAGFwdHItPnRhZyA9PSBUX2F0b20AL2Rldi91cmFuZG9tAG1tAHJsbQBzaW0ASU1EU19naXZlbl9kaW0Ab3JkbQBjbQBwYXJhbGxlbG9ncmFtAC9zdmcvbWludGNyZWFtAEp1bAB0bABmcmFzbABTeW1ib2wAPD94bWwAeXVtbAB1dW1sAG91bWwAaXVtbABldW1sAGF1bWwAWXVtbABVdW1sAE91bWwASXVtbABFdW1sAEF1bWwAY29yZV9sb2FkaW1hZ2VfdnJtbABqcGc6dnJtbABwbmc6dnJtbABqcGVnOnZybWwAZ2lmOnZybWwAanBlOnZybWwAYnVsbABmaWxsAHJ0cC0+c3BsaXQuUGFydGl0aW9uc1swXS5jb3VudFswXSA+PSBydHAtPk1pbkZpbGwgJiYgcnRwLT5zcGxpdC5QYXJ0aXRpb25zWzBdLmNvdW50WzFdID49IHJ0cC0+TWluRmlsbAAvc3ZnL3NlYXNoZWxsAGZvcmFsbABBcHJpbABwZXJtaWwAcmNlaWwAbGNlaWwAY2NlZGlsAENjZWRpbABhcnJvd3RhaWwAbHRhaWwAc2FtZXRhaWwAbGV2ZWwgPj0gMCAmJiBsZXZlbCA8PSBuLT5sZXZlbABsZXZlbCA+PSAwICYmIGxldmVsIDw9ICgqbiktPmxldmVsAHN0cmVzc19tYWpvcml6YXRpb25fa0RfbWtlcm5lbABpc19wYXJhbGxlbABDYWxjdWxhdGluZyBjaXJjdWl0IG1vZGVsAENhbGN1bGF0aW5nIHN1YnNldCBtb2RlbABDYWxjdWxhdGluZyBNRFMgbW9kZWwAeGxhYmVsAHRhaWxsYWJlbABoZWFkbGFiZWwAbWFrZV9sYWJlbABncmFwaCBsYWJlbABpZXhjbABvYmpwLT5sYmwAb3ZhbABtZXJnZXZpcnR1YWwAL3N2Zy9saWdodGNvcmFsAC9zdmcvY29yYWwAU3BhcnNlTWF0cml4X2Zyb21fY29vcmRpbmF0ZV9hcnJheXNfaW50ZXJuYWwATXVsdGlsZXZlbF9jb2Fyc2VuX2ludGVybmFsAFF1YWRUcmVlX2FkZF9pbnRlcm5hbABhcnJvd19sZW5ndGhfbm9ybWFsAGFyaWFsAHJhZGlhbAAvc3ZnL3RlYWwAcmVhbABsb2NhbABlc3RpbWF0ZV9jaGFyYWN0ZXJfd2lkdGhfY2Fub25pY2FsAGdsb2JhbABxLT5sAC4uLy4uL2xpYi9jZ3JhcGgvc2Nhbi5sAHRrOnRrAGdpZjp0awBwYXRjaHdvcmsAdG9rAGJvb2sAQXZhbnRHYXJkZS1Cb29rAHNpbmsAb3ZlcmxhcF9zaHJpbmsAc3BpY3lwaW5rAC9zdmcvaG90cGluawAvc3ZnL2xpZ2h0cGluawAvc3ZnL2RlZXBwaW5rAG5lb25waW5rAC9zdmcvcGluawBuZXdyYW5rAGNsdXN0ZXJyYW5rAF9uZXdfcmFuawBpbnN0YWxsX2luX3JhbmsAcmVtb3ZlX2Zyb21fcmFuawAvc3ZnL2Nvcm5zaWxrAG9uZWJsb2NrAHYtPmxlZnQtPmJsb2NrID09IHYtPnJpZ2h0LT5ibG9jawAvc3ZnL2ZpcmVicmljawBQUWNoZWNrAHBhY2sAL3N2Zy9ibGFjawBCbGFjawBiYWNrAHp3agB6d25qAGpvYi0+b2JqAGdldGludHJzeGkAcHNpAFBzaQBDYWxpYnJpAEZyaQB0d29waQBkcGkAdm9yb25vaQBWb3Jvbm9pAGNoYW5pAGRlbWkAQm9va21hbi1EZW1pAEF2YW50R2FyZGUtRGVtaQAvc3ZnL2RhcmtraGFraQAvc3ZnL2toYWtpAHBoaQBjaGkAUGhpAENoaQBkaQBYaQBQaQBORF9pZChucCkgPT0gaQBTdHJlc3NNYWpvcml6YXRpb25TbW9vdGhlcl9zbW9vdGgAU3ByaW5nU21vb3RoZXJfc21vb3RoAGJvdGgAc3RhcnRzd2l0aABsaW5lbGVuZ3RoAGJhZF9hcnJheV9uZXdfbGVuZ3RoAGF2ZXJhZ2VfZWRnZV9sZW5ndGgAZXRoAHBlbndpZHRoAGx3aWR0aABzZXRsaW5ld2lkdGgAUHNob3J0ZXN0cGF0aABzaG9ydHBhdGgAZm9udHBhdGgAUG9ic3BhdGgAYmVnaW5wYXRoAGltYWdlcGF0aABlbmRwYXRoAHN0cmFpZ2h0X3BhdGgAbWFwX3BhdGgAPHBhdGgAY2Fubm90IGZpbmQgdHJpYW5nbGUgcGF0aAAvc3ZnL2xhdmVuZGVyYmx1c2gAZmxlc2gAb3NsYXNoAE9zbGFzaABkdHN0cmhhc2gAbmRhc2gAbWRhc2gAZGlncmFwaABzdWJncmFwaABjb25zdHJ1Y3RfZ3JhcGgAY2hrU2dyYXBoAGNsb3Nlc3RfcGFpcnMyZ3JhcGgAYWdkZWxldGUgb24gd3JvbmcgZ3JhcGgAY29ubmVjdEdyYXBoAHVwc2loACVzbGluZS10aHJvdWdoAGZsYXRfc2VhcmNoAGNoYW5TZWFyY2gAUlRyZWVTZWFyY2gATWFyY2gARGlzY29uQnJhbmNoAFBpY2tCcmFuY2gAQWRkQnJhbmNoAC4uLy4uL2xpYi9jZ3JhcGgvYml0YXJyYXkuaAAuLi8uLi9saWIvY2dyYXBoL3N0cnZpZXcuaAAuLi8uLi9saWIvY2lyY29nZW4vbm9kZWxpc3QuaAAuLi8uLi9saWIvY2dyYXBoL3NvcnQuaAAuLi8uLi9saWIvY29tbW9uL2JveGVzLmgALi4vLi4vbGliL2NncmFwaC9zdHJlcS5oAC4uLy4uL2xpYi9jZ3JhcGgvY2xhbXAuaAAuLi8uLi9saWIvY2dyYXBoL3N0YWNrLmgALi4vLi4vbGliL2NncmFwaC9zdGFydHN3aXRoLmgALi4vLi4vbGliL2NncmFwaC9hZ3hidWYuaAAuLi8uLi9saWIvY2dyYXBoL3Rva2VuaXplLmgALi4vLi4vbGliL2NncmFwaC9hbGxvYy5oAGF1eGcAcm93ZwBjb3JlX2xvYWRpbWFnZV9zdmcAc3ZnOnN2ZwBqcGc6c3ZnAHBuZzpzdmcAanBlZzpzdmcAZ2lmOnN2ZwBqcGU6c3ZnAHN2Z19pbmxpbmU6c3ZnAEF1ZwBkb1Byb2xvZwBwb3dlcl9pdGVyYXRpb25fb3J0aG9nAHBuZwBpZGVhbF9kaXN0X3NjaGVtZSB2YWx1ZSB3cm9uZwB4ZG90IHZlcnNpb24gIiVzIiB0b28gbG9uZwBjb25nAGxibGVuY2xvc2luZwBiYXNpY19zdHJpbmcAZmFpbHVyZSBtYWxsb2MnaW5nIGZvciByZXN1bHQgc3RyaW5nAHNwcmluZwBvcmRlcmluZwBhcmluZwBBcmluZwBEYW1waW5nAFdhcm5pbmcAb3ZlcmxhcF9zY2FsaW5nAHggYW5kIHkgc2NhbGluZwBvbGQgc2NhbGluZwBzbW9vdGhpbmcAdW5rbm93biBlbmNvZGluZwBtdWx0aWxldmVsX3NwcmluZ19lbGVjdHJpY2FsX2VtYmVkZGluZwBzcHJpbmdfZWxlY3RyaWNhbF9zcHJpbmdfZW1iZWRkaW5nAGNlbGxwYWRkaW5nAGNlbGxzcGFjaW5nAHJhbmcAbGFuZwBmaXZlcG92ZXJoYW5nAHRocmVlcG92ZXJoYW5nAG5vdmVyaGFuZwBlbWl0X2h0bWxfaW1nAGNvbGcAb3JpZwBzemxpZwBvZWxpZwBhZWxpZwBPRWxpZwBBRWxpZwBjb3JlX2xvYWRpbWFnZV9maWcAanBnOmZpZwBwbmc6ZmlnAGZpZzpmaWcAanBlZzpmaWcAZ2lmOmZpZwBqcGU6ZmlnAGVnZwBuZXh0X3NlZwByZWcAanBlZwBpID09IGRlZwBkZwBjZwBjbG9zZXN1YmcAbWlzbWF0Y2hlZCB0YWcAYmV6LT5zZmxhZwBiZXotPmVmbGFnACFmbGFnADxnACUuNWcsJS41ZywlLjVnLCUuNWcAJS41ZyAlLjVnACVnICVnAGJveEludGVyc2VjdGYAZXBzZgBhZ2VkZ2VzZXFjbXBmAGNjd3JvdGF0ZXBmAGZub2YAaW5mAHNlbGYAaGFsZgAlbGYlbGYlbGYlbGYAJWxmLCVsZiwlbGYsJWxmLCVsZgAlbGYgJWxmICVsZiAlbGYAbGliZXJhdGlvbnNlcmlmAGZyZWVzZXJpZgBzYW5zLVNlcmlmAGdpZgAvc3ZnL3BlYWNocHVmZgByaWZmAGFjY291bnRpbmdSZXBvcnREaWZmAHRhaWxocmVmAGxhYmVsaHJlZgBlZGdlaHJlZgBoZWFkaHJlZgBvcmRmAHBkZgBzaWdtYWYAXGYAJS4wTGYAJUxmAHVzLT5mACUuMDNmACVzIHRyYW5zbWl0ICUuM2YAcmdiPCU5LjNmLCAlOS4zZiwgJTkuM2Y+IHRyYW5zbWl0ICUuM2YAJS4wMmYAJS4yZgAlZiwlZgAiIGZpbGwtb3BhY2l0eT0iJWYAIiBzdHJva2Utb3BhY2l0eT0iJWYACmZpbmFsIGUgPSAlZgBicm9uemUAYXJyb3dzaXplAGxhYmVsZm9udHNpemUAc2VhcmNoc2l6ZQBub2RlbGlzdF9yZXNpemUAZml4ZWRzaXplAG5vZGVsaXN0X3NpemUAc2FtZV9saXN0X3NpemUAdGV4dHNwYW5fc2l6ZQBiei5zaXplAHBvaW50LXNpemUAbm9ybWFsaXplAGljdXJ2ZQBub2RlbGlzdF9yZW1vdmUAIXYtPmFjdGl2ZQAtYWN0aXZlAGZvbnRfaW5fbGlzdF9wZXJtaXNzaXZlAC9zdmcvb2xpdmUAdWdyYXZlAG9ncmF2ZQBpZ3JhdmUAZWdyYXZlAGFncmF2ZQBVZ3JhdmUAT2dyYXZlAElncmF2ZQBFZ3JhdmUAQWdyYXZlAHRydWUAL3N2Zy9iaXNxdWUAb2JsaXF1ZQBBdmFudEdhcmRlLUJvb2tPYmxpcXVlAEF2YW50R2FyZGUtRGVtaU9ibGlxdWUASGVsdmV0aWNhLU5hcnJvdy1Cb2xkT2JsaXF1ZQBDb3VyaWVyLUJvbGRPYmxpcXVlAEhlbHZldGljYS1Cb2xkT2JsaXF1ZQBIZWx2ZXRpY2EtTmFycm93LU9ibGlxdWUAQ291cmllci1PYmxpcXVlAEhlbHZldGljYS1PYmxpcXVlAG5hdnlibHVlAC9zdmcvbGlnaHRza3libHVlAC9zdmcvZGVlcHNreWJsdWUAL3N2Zy9za3libHVlAG5ld21pZG5pZ2h0Ymx1ZQAvc3ZnL21pZG5pZ2h0Ymx1ZQAvc3ZnL2xpZ2h0Ymx1ZQAvc3ZnL2NhZGV0Ymx1ZQAvc3ZnL2Nvcm5mbG93ZXJibHVlAC9zdmcvZG9kZ2VyYmx1ZQAvc3ZnL3Bvd2RlcmJsdWUAbmVvbmJsdWUAL3N2Zy9tZWRpdW1ibHVlAC9zdmcvbGlnaHRzdGVlbGJsdWUAL3N2Zy9zdGVlbGJsdWUAL3N2Zy9yb3lhbGJsdWUAL3N2Zy9kYXJrYmx1ZQByaWNoYmx1ZQBsaWdodHNsYXRlYmx1ZQAvc3ZnL21lZGl1bXNsYXRlYmx1ZQAvc3ZnL2RhcmtzbGF0ZWJsdWUAL3N2Zy9zbGF0ZWJsdWUAL3N2Zy9hbGljZWJsdWUAL3N2Zy9ibHVlAEJsdWUAbmVhdG9fZW5xdWV1ZQBUdWUAY29udmVydFNQdG9Sb3V0ZQB5YWN1dGUAdWFjdXRlAG9hY3V0ZQBpYWN1dGUAZWFjdXRlAGFhY3V0ZQBZYWN1dGUAVWFjdXRlAE9hY3V0ZQBJYWN1dGUARWFjdXRlAEFhY3V0ZQByZWZlcmVuY2UgdG8gZXh0ZXJuYWwgZW50aXR5IGluIGF0dHJpYnV0ZQBkdXBsaWNhdGUgYXR0cmlidXRlAG5vdGUAcHJpbWVyc2l0ZQByaWJvc2l0ZQByZXN0cmljdGlvbnNpdGUAcHJvdGVhc2VzaXRlAC9zdmcvZ2hvc3R3aGl0ZQAvc3ZnL25hdmFqb3doaXRlAC9zdmcvZmxvcmFsd2hpdGUAL3N2Zy9hbnRpcXVld2hpdGUAL3N2Zy93aGl0ZQBXaGl0ZQBwb3Bfb2JqX3N0YXRlAHBjcF9yb3RhdGUAY29uY2VudHJhdGUAZGVjb3JhdGUAUXVhZFRyZWVfcmVwdWxzaXZlX2ZvcmNlX2FjY3VtdWxhdGUAbm90cmFuc2xhdGUAL3N2Zy9jaG9jb2xhdGUAZ2VvbVVwZGF0ZQBpbnZob3VzZQAvc3ZnL2NoYXJ0cmV1c2UAPGVsbGlwc2UAd2VkZ2VkRWxsaXBzZQBkdXN0eXJvc2UAL3N2Zy9taXN0eXJvc2UAU3BhcnNlTWF0cml4X3RyYW5zcG9zZQBhZ2Nsb3NlAGVudGl0eVRyYWNraW5nT25DbG9zZQBTcGFyc2VNYXRyaXhfbXVsdGlwbHlfZGVuc2UAZmFsc2UAL3N2Zy9tZWRpdW10dXJxdW9pc2UAL3N2Zy9kYXJrdHVycXVvaXNlAC9zdmcvcGFsZXR1cnF1b2lzZQAvc3ZnL3R1cnF1b2lzZQBwaGFzZQAvc3ZnL2F6dXJlAHNpZ25hdHVyZQBtZW1vcnkgcmUtYWxsb2NhdGlvbiBmYWlsdXJlAG1lbW9yeSBhbGxvY2F0aW9uIGZhaWx1cmUAY29yZQBNc3F1YXJlAFBhbGF0aW5vIExpbm90eXBlAEEtPnR5cGUgPT0gQi0+dHlwZQBzdXBlAGd2cmVuZGVyX3VzZXJzaGFwZQBtaXRlcl9zaGFwZQBsYW5kc2NhcGUATGFuZHNjYXBlAEp1bmUAbm9uZQBkb2N1bWVudCBpcyBub3Qgc3RhbmRhbG9uZQBjb3VzaW5lAC9zdmcvbWVkaXVtYXF1YW1hcmluZQAvc3ZnL2FxdWFtYXJpbmUAPHBvbHlsaW5lAG1ha2VQb2x5bGluZQAlc292ZXJsaW5lAHVuZGVybGluZQBsaW5lYXJfc3BsaW5lAGJfc3BsaW5lAG1ha2VTcGxpbmUAb2xpbmUAYWd4YnVmX2lzX2lubGluZQBzdmdfaW5saW5lAHJlZmluZQBwcmltZQBQcmltZQAvc3ZnL2xpbWUAY29sb3JzY2hlbWUAbGFiZWxfc2NoZW1lAHNhbWUAbGFiZWxmb250bmFtZQBVRl9zZXRuYW1lAGZvbnRfbmFtZQBmb250LT5uYW1lAHVzLT5uYW1lAHJlc2VydmVkIHByZWZpeCAoeG1sKSBtdXN0IG5vdCBiZSB1bmRlY2xhcmVkIG9yIGJvdW5kIHRvIGFub3RoZXIgbmFtZXNwYWNlIG5hbWUAc3R5bGUAL3N2Zy90aGlzdGxlAHRpdGxlAC9zdmcvbWVkaXVtcHVycGxlAGRhcmtwdXJwbGUAd2VicHVycGxlAHJlYmVjY2FwdXJwbGUAdmVyeV9saWdodF9wdXJwbGUAbWVkX3B1cnBsZQB4MTFwdXJwbGUAL3N2Zy9wdXJwbGUAc2hhcGVmaWxlAGdyYWRpZW50YW5nbGUAcmVjdGFuZ2xlAFJlY3RhbmdsZQBsYWJlbGFuZ2xlAGludnRyaWFuZ2xlAGRlc3RpbmF0aW9uIHBvaW50IG5vdCBpbiBhbnkgdHJpYW5nbGUAc291cmNlIHBvaW50IG5vdCBpbiBhbnkgdHJpYW5nbGUAZGZzQ3ljbGUAZG91YmxlY2lyY2xlAE1jaXJjbGUAaW52aXNpYmxlAHRob3JuZGFsZQBpbnB1dHNjYWxlAG9zY2FsZQBpbWFnZXNjYWxlAC9zdmcvd2hpdGVzbW9rZQBtYW5kYXJpbm9yYW5nZQAvc3ZnL2RhcmtvcmFuZ2UAL3N2Zy9vcmFuZ2UAL3N2Zy9iZWlnZQBuZXdlZGdlAGRlbGV0ZV9mYXN0X2VkZ2UAZGVsZXRlX2ZsYXRfZWRnZQBtYWtlX2ZsYXRfZWRnZQBtYWtlX3JlZ3VsYXJfZWRnZQBlbWl0X2JlZ2luX2VkZ2UAYWRkX3RyZWVfZWRnZQBlbWl0X2VuZF9lZGdlAG1ha2VfZmxhdF9sYWJlbGVkX2VkZ2UAbWFrZVNlbGZFZGdlAG1ha2VDb21wb3VuZEVkZ2UAb3NhZ2UAcGFnZQBndmxvYWRpbWFnZQB2ZWUAdGVlAFFVQURfVFJFRV9IWUJSSUQsIHNpemUgbGFyZ2VyIHRoYW4gJWQsIHN3aXRjaCB0byBmYXN0IHF1YWR0cmVlAGZlYXNpYmxlX3RyZWUAU3BhcnNlTWF0cml4X2RpdmlkZV9yb3dfYnlfZGVncmVlAG9iamxpc3RfZnJlZQBzYW1lX2xpc3RfZnJlZQBwb2ludHNfZnJlZQBib3hlc19mcmVlAGd2X3N0YWNrX2ZyZWUAbmV3bm9kZQBpbnN0YWxsbm9kZQBhZ25vZGUAZGVsZXRlX2Zhc3Rfbm9kZQBwYWNrbW9kZQBTcGxpdE5vZGUAb3RpbGRlAG50aWxkZQBhdGlsZGUAT3RpbGRlAE50aWxkZQBBdGlsZGUAZGl2aWRlAHRyYWRlAGdyYXBodml6X25vZGVfaW5kdWNlAHNvdXJjZQByZXB1bHNpdmVmb3JjZQBpbGxlZ2FsIHBhcmFtZXRlciBlbnRpdHkgcmVmZXJlbmNlAGVycm9yIGluIHByb2Nlc3NpbmcgZXh0ZXJuYWwgZW50aXR5IHJlZmVyZW5jZQByZWN1cnNpdmUgZW50aXR5IHJlZmVyZW5jZQBsYWJlbGRpc3RhbmNlAFRCYmFsYW5jZQBkZXZpY2UAbW9ub3NwYWNlAC9zdmcvb2xkbGFjZQBmYWNlAHN1YmUAIC1hbmNob3IgZQBzMS0+Y29tbV9jb29yZD09czItPmNvbW1fY29vcmQATXJlY29yZABmb3J3YXJkAHByb2QAbGlnaHRnb2xkZW5yb2QAbWVkaXVtZ29sZGVucm9kAC9zdmcvZGFya2dvbGRlbnJvZAAvc3ZnL3BhbGVnb2xkZW5yb2QAL3N2Zy9nb2xkZW5yb2QAL3N2Zy9idXJseXdvb2QAbGlnaHR3b29kAG1lZGl1bXdvb2QAZGFya3dvb2QAX2JhY2tncm91bmQAY29tcG91bmQAbm8gZWxlbWVudCBmb3VuZABmYXRhbCBmbGV4IHNjYW5uZXIgaW50ZXJuYWwgZXJyb3ItLW5vIGFjdGlvbiBmb3VuZAAvc3ZnL2JsYW5jaGVkYWxtb25kAGFycm93X2xlbmd0aF9kaWFtb25kAE1kaWFtb25kAGd2dXNlcnNoYXBlX2ZpbmQAb2JqbGlzdF90cnlfYXBwZW5kAGRlZ2xpc3RfdHJ5X2FwcGVuZABub2RlbGlzdF90cnlfYXBwZW5kAGNsaXN0X3RyeV9hcHBlbmQAc2FtZV9saXN0X3RyeV9hcHBlbmQAZWRnZV9saXN0X3RyeV9hcHBlbmQAcG9pbnRzX3RyeV9hcHBlbmQAYm94ZXNfdHJ5X2FwcGVuZABsYXllcl9uYW1lc190cnlfYXBwZW5kAHZhcmFycl90cnlfYXBwZW5kAGVzdGFja190cnlfYXBwZW5kAGd2X3N0YWNrX3RyeV9hcHBlbmQAaW50X3N0YWNrX3RyeV9hcHBlbmQAaXJhbmQAZXhwYW5kAGN1bWJlcmxhbmQAYnJpZ2h0Z29sZABvbGRnb2xkAC9zdmcvZ29sZABib2xkAEhlbHZldGljYS1OYXJyb3ctQm9sZABUaW1lcy1Cb2xkAENvdXJpZXItQm9sZABQYWxhdGluby1Cb2xkAE5ld0NlbnR1cnlTY2hsYmstQm9sZABIZWx2ZXRpY2EtQm9sZABuLT5icmFuY2hbaV0uY2hpbGQAJXMlbGQAc29saWQAL3N2Zy9tZWRpdW1vcmNoaWQAL3N2Zy9kYXJrb3JjaGlkAC9zdmcvb3JjaGlkAGlsbGVnYWwgY2hhcmFjdGVyKHMpIGluIHB1YmxpYyBpZABkaWprc3RyYV9zZ2QAZml4ZWQAY3VydmVkAGRlcml2ZWQAZG90dGVkAG1lbW9yeSBleGhhdXN0ZWQAcGFyc2luZyBhYm9ydGVkAGF0dHJpYnV0ZSBtYWNyb3Mgbm90IGltcGxlbWVudGVkAGFjY291bnRpbmdEaWZmVG9sZXJhdGVkAGZhdGFsIGZsZXggc2Nhbm5lciBpbnRlcm5hbCBlcnJvci0tZW5kIG9mIGJ1ZmZlciBtaXNzZWQAY29uZGVuc2VkAC9zdmcvbWVkaXVtdmlvbGV0cmVkAC9zdmcvcGFsZXZpb2xldHJlZABJbXByb3BlciAlcyB2YWx1ZSAlcyAtIGlnbm9yZWQAJXMgdmFsdWUgJXMgPCAlZCAtIHRvbyBzbWFsbCAtIGlnbm9yZWQAJXMgdmFsdWUgJXMgPiAlZCAtIHRvbyBsYXJnZSAtIGlnbm9yZWQAL3N2Zy9pbmRpYW5yZWQAL3N2Zy9kYXJrcmVkAGEgc3VjY2Vzc2Z1bCBwcmlvciBjYWxsIHRvIGZ1bmN0aW9uIFhNTF9HZXRCdWZmZXIgaXMgcmVxdWlyZWQAdGFwZXJlZAAvc3ZnL29yYW5nZXJlZAByZXNlcnZlZCBwcmVmaXggKHhtbG5zKSBtdXN0IG5vdCBiZSBkZWNsYXJlZCBvciB1bmRlY2xhcmVkAC9zdmcvcmVkAHN0cmlwZWQAaWxsLWNvbmRpdGlvbmVkAHVuZGVmaW5lZABub3QgY29uc3RyYWluZWQAbGFiZWxhbGlnbmVkAHRleHQgZGVjbGFyYXRpb24gbm90IHdlbGwtZm9ybWVkAFhNTCBkZWNsYXJhdGlvbiBub3Qgd2VsbC1mb3JtZWQAdW5maWxsZWQAaW5wdXQgaW4gZmxleCBzY2FubmVyIGZhaWxlZAB0cmlhbmd1bGF0aW9uIGZhaWxlZABwYXJzaW5nIGZpbmlzaGVkAGRhc2hlZABsaW1pdCBvbiBpbnB1dCBhbXBsaWZpY2F0aW9uIGZhY3RvciAoZnJvbSBEVEQgYW5kIGVudGl0aWVzKSBicmVhY2hlZAAlczolZDogY2xhaW1lZCB1bnJlYWNoYWJsZSBjb2RlIHdhcyByZWFjaGVkAHdlZGdlZABzaXplPT1mcmVlZAByb3VuZGVkAHBhcnNlciBub3Qgc3VzcGVuZGVkAHBhcnNlciBzdXNwZW5kZWQAV2VkAFJlZABTcGFyc2VNYXRyaXhfYWRkAGRkICE9IHBhcmVudF9kZABLUF9BZGQAcGFkAHhsaGR4dW5sb2FkAHJlYWQAYXJyb3doZWFkAGxoZWFkAHNhbWVoZWFkAGJveDNkAGNjJXNfJWQAX3NwYW5fJWQAX2Jsb2NrXyVkAF93ZWFrXyVkAF9jbG9uZV8lZAAuJWQAJWxmLCVkACVkLCVkLCVkLCVkACAlZCwlZABjYyVzKyVkACVzIGluIGxpbmUgJWQAJWQgJWQgJWQgJWQgJWQgJWQgJS4xZiAlLjRmICVkICUuMWYgJS4xZiAlZCAlZAAlJSUlQm91bmRpbmdCb3g6ICVkICVkICVkICVkACJfc3ViZ3JhcGhfY250IjogJWQAIl9ndmlkIjogJWQAImhlYWQiOiAlZABhZ3hicHV0YwB2cHNjAGNwLT5zcmMAdWNpcmMAb2NpcmMAaWNpcmMAZWNpcmMAYWNpcmMAVWNpcmMAT2NpcmMASWNpcmMARWNpcmMAQWNpcmMAcGMAbGFiZWxsb2MAZ3ZfcmVjYWxsb2MAc3RkOjpiYWRfYWxsb2MAYmFrZXJzY2hvYwBzZW1pU3dlZXRDaG9jAG1jAFNwYXJzZU1hdHJpeF9pc19zeW1tZXRyaWMAcGljOnBpYwBpdGFsaWMAQm9va21hbi1MaWdodEl0YWxpYwBaYXBmQ2hhbmNlcnktTWVkaXVtSXRhbGljAEJvb2ttYW4tRGVtaUl0YWxpYwBUaW1lcy1Cb2xkSXRhbGljAFBhbGF0aW5vLUJvbGRJdGFsaWMATmV3Q2VudHVyeVNjaGxiay1Cb2xkSXRhbGljAFRpbWVzLUl0YWxpYwBQYWxhdGluby1JdGFsaWMATmV3Q2VudHVyeVNjaGxiay1JdGFsaWMAcmFkaWMAI2ZjZmNmYwA6ICUuMmYgc2VjAGxpc3RkZWxyZWMAbGV2ZWwgZ3JhcGggcmVjAGxldmVsIGVkZ2UgcmVjAGxldmVsIG5vZGUgcmVjAERlYwBfbmVhdG9fY2MAYmMAdmlzaWJpbGl0eS5jAFNwYXJzZU1hdHJpeC5jAGh0bWxsZXguYwBpbmRleC5jAHNtYXJ0X2luaV94LmMAZ3ZyZW5kZXJfY29yZV9wb3YuYwBjdnQuYwBsYXlvdXQuYwB0ZXh0c3Bhbl9sdXQuYwBhZGp1c3QuYwBub2RlbGlzdC5jAHNob3J0ZXN0LmMAY2xvc2VzdC5jAHNhbWVwb3J0LmMAZ3ZyZW5kZXJfY29yZV9kb3QuYwBjb25zdHJhaW50LmMAZG90aW5pdC5jAG5lYXRvaW5pdC5jAHBhdGNod29ya2luaXQuYwBvc2FnZWluaXQuYwBlbWl0LmMAZmxhdC5jAGFycm93cy5jAG1pbmNyb3NzLmMAc3RyZXNzLmMAcG9zdF9wcm9jZXNzLmMAY2NvbXBzLmMAbnMuYwB1dGlscy5jAHhsYWJlbHMuYwBzaGFwZXMuYwBkb3RzcGxpbmVzLmMAbmVhdG9zcGxpbmVzLmMAY2x1c3RlcmVkZ2VzLmMAYXR0ci5jAGZhc3Rnci5jAGNsdXN0ZXIuYwB0YXBlci5jAGd2cmVuZGVyLmMAc3BsaXQucS5jAGNvbXAuYwBndnJlbmRlcl9jb3JlX21wLmMAZ3ZyZW5kZXJfY29yZV9tYXAuYwBvcnRoby5jAGd2cmVuZGVyX2NvcmVfanNvbi5jAHBvc2l0aW9uLmMAdGV4dHNwYW4uYwBnZW9tLmMAcm91dGVzcGwuYwB4bWwuYwBNdWx0aWxldmVsLmMAZ2VuZXJhbC5jAHNwcmluZ19lbGVjdHJpY2FsLmMAZ3ZyZW5kZXJfY29yZV90ay5jAHJhbmsuYwBwYWNrLmMAYmxvY2twYXRoLmMAZHRzdHJoYXNoLmMAcmF3Z3JhcGguYwBndnJlbmRlcl9jb3JlX3N2Zy5jAGd2cmVuZGVyX2NvcmVfZmlnLmMAc3R1ZmYuYwBtYXplLmMAc3BhcnNlX3NvbHZlLmMAd3JpdGUuYwBjb2x4bGF0ZS5jAHhtbHBhcnNlLmMAZ3Zsb2FkaW1hZ2VfY29yZS5jAGd2dXNlcnNoYXBlLmMAcmVjdGFuZ2xlLmMAY2lyY2xlLmMAaHRtbHRhYmxlLmMAZWRnZS5jAGd2bG9hZGltYWdlLmMAYmxvY2t0cmVlLmMAUXVhZFRyZWUuYwBub2RlLmMAbm9kZV9pbmR1Y2UuYwBndmRldmljZS5jAGNvbXBvdW5kLmMAdHJhcGV6b2lkLmMAc2dkLmMAcG9zdHByb2MuYwBjb25jLmMAcmVjLmMAZGlqa3N0cmEuYwBmUFEuYwBjbGFzczIuYwAlbGYsJWxmLCVsZiwlbGYlYwAlbGYsJWxmLCVsZiwlW14sXSVjAFwlYwAkYwBuc3ViAHNldGhzYgByYgBwcm90ZWN0X3JzcWIAam9iAGNvcmVfbG9hZGltYWdlX3BzbGliAEZlYgBvZGIAaW5pdF9zcGxpbmVzX2JiAGJlemllcl9iYgBwcm90ZWluc3RhYgBybmFzdGFiAC9zdmcvb2xpdmVkcmFiAFxiAHJ3YQAvc3ZnL2FxdWEAaW90YQBJb3RhAC9zdmcvZGFya21hZ2VudGEAL3N2Zy9tYWdlbnRhAGRlbHRhAERlbHRhAHpldGEAdGhldGEAVGhldGEAYmV0YQBaZXRhAEJldGEAX0FHX3N0cmRhdGEAcHJldiAhPSBvYmotPmRhdGEAbWFrZUdyYXBoRGF0YQBFdGEAbmltYnVzc2Fuc2EAcGFyYQBrYXBwYQBLYXBwYQAvc3ZnL3NpZW5uYQBWZXJkYW5hAGdhbW1hAEdhbW1hAHNpZ21hAFNpZ21hAGNvbnNvbGEAbmFibGEAL3N2Zy9mdWNoc2lhAEdlb3JnaWEAYWxwaGEAQWxwaGEAb21lZ2EAT21lZ2EAYXJlYQBSZWN0QXJlYQBsYW1iZGEATGFtYmRhAGhlbHZldGljYQBIZWx2ZXRpY2EAbWljYQA+PGEAYABfdGRyYXdfAF90bGRyYXdfAF9obGRyYXdfAF9sZHJhd18AX2hkcmF3XwBfZHJhd18AJXNfAHBhZ2UlZCwlZF8AX2NjXwAgaWQ9ImFfAF4Abl9lZGdlcyA9PSBncmFwaC0+c291cmNlc1tncmFwaC0+bl0AamRbbWFza1tqY1trXV1dID09IGpjW2tdAGpjW21hc2tbamJba11dXSA9PSBqYltrXQBqYVttYXNrW2phW2pdXV0gPT0gamFbal0AcS0+cXRzW2lpXQAhcnRwLT5zcGxpdC5QYXJ0aXRpb25zWzBdLnRha2VuW2ldAHItPmJvdW5kYXJ5W2ldIDw9IHItPmJvdW5kYXJ5W05VTURJTVMgKyBpXQBbJS4wM2YsJS4wM2ZdAFtpbnRlcm5hbCBoYXJkLWNvZGVkXQBucC0+Y2VsbHNbMV0AbnAtPmNlbGxzWzBdAHVzLT5uYW1lWzBdAGNwLT5zcmNbMF0AXFwAInBvaW50cyI6IFsAInN0b3BzIjogWwAJWwBaAGNvbXB1dGVTY2FsZVhZAHk8PVkAJWEgJWIgJWQgJUg6JU06JVMgJVkAUE9TSVgAdGFyZ2V0IDw9IChzaXplX3QpSU5UX01BWABwYXRoY291bnQgPD0gSU5UX01BWABwYWlyLnJpZ2h0IDw9IElOVF9NQVgAcGFpci5sZWZ0IDw9IElOVF9NQVgAbl9lZGdlcyA8PSBJTlRfTUFYAHN0cC5udmVydGljZXMgPD0gSU5UX01BWABncmFwaC0+biA8PSBJTlRfTUFYAGkgPD0gSU5UX01BWABUcmVlX2VkZ2Uuc2l6ZSA8PSBJTlRfTUFYAGNsaXN0X3NpemUoJmxpc3QpIC0gMSA8PSBJTlRfTUFYAGxheWVyX25hbWVzX3NpemUoJmxheWVySURzKSAtIDEgPD0gSU5UX01BWABzdHJsZW4oYXJncykgPD0gSU5UX01BWABvYmpsaXN0X3NpemUoJm9iamwpIDw9IElOVF9NQVgAcmVjdC5ib3VuZGFyeVszXSA8IElOVF9NQVgAcmVjdC5ib3VuZGFyeVsyXSA8IElOVF9NQVgAcmVzdWx0IDw9IChpbnQpVUNIQVJfTUFYAHNzeiA8PSBVQ0hBUl9NQVgAeDw9WABXAFYAVQBcVABURVhUAFNUUkVTU19NQUpPUklaQVRJT05fUE9XRVJfRElTVABTVFJFU1NfTUFKT1JJWkFUSU9OX0dSQVBIX0RJU1QAU1RSRVNTX01BSk9SSVpBVElPTl9BVkdfRElTVABGQVNUAEZPTlQAYiA9PSBCX1JJR0hUAEhFSUdIVABCX0xFRlQAXyVsbHVfU1VTUEVDVABCVABUcmVidWNoZXQgTVMASU5WSVMAJUg6JU06JVMAVlIAVFIAQS0+Zm9ybWF0ID09IEItPmZvcm1hdCAmJiBBLT5mb3JtYXQgPT0gRk9STUFUX0NTUgBMUgBESVIASFIAQ0VOVEVSACUlVFJBSUxFUgBBLT50eXBlID09IE1BVFJJWF9UWVBFX1JFQUwgfHwgQS0+dHlwZSA9PSBNQVRSSVhfVFlQRV9JTlRFR0VSAENFTExCT1JERVIAQlIAKlIAUQBFWFAAQl9VUABTVVAAVE9QAE8AbWFwTgBcTgBCX0RPV04AVEhPUk4AJSVCRUdJTgBST1dTUEFOAENPTFNQQU4ATkFOAFBNAEJPVFRPTQBCTQBBTQBcTAB0YWlsVVJMAGxhYmVsVVJMAGVkZ2VVUkwAaGVhZFVSTABIVE1MAHghPU5VTEwARURfdG9fdmlydChvcmlnKSA9PSBOVUxMAEVEX3RvX3ZpcnQoZSkgPT0gTlVMTABwcmVmaXggIT0gTlVMTABkdGQtPnNjYWZmSW5kZXggIT0gTlVMTABpbnB1dCAhPSBOVUxMAGxpc3QgIT0gTlVMTAByZWZlcmVudCAhPSBOVUxMAHMgIT0gTlVMTABhdHRyICE9IE5VTEwAbGVhZGVyICE9IE5VTEwAb3J0aG9nICE9IE5VTEwAc2VsZiAhPSBOVUxMAHZhbHVlICE9IE5VTEwAam9iLT5vdXRwdXRfZmlsZSAhPSBOVUxMAGIgIT0gTlVMTABzb3VyY2UuZGF0YSAhPSBOVUxMAGIuZGF0YSAhPSBOVUxMAGEuZGF0YSAhPSBOVUxMAGxpc3QgJiYgbGlzdFswXSAhPSBOVUxMAEVEX3RvX3ZpcnQob3JpZykgIT0gTlVMTABMQ19BTEwAQkwAYmVzdGNvc3QgPCBIVUdFX1ZBTABOT1JNQUwAUkFESUFMAEEtPnR5cGUgPT0gTUFUUklYX1RZUEVfUkVBTABVUlcgQ2hhbmNlcnkgTABVUlcgQm9va21hbiBMAENlbnR1cnkgU2Nob29sYm9vayBMAFVSVyBHb3RoaWMgTABLSwBKAGkgPCBNQVhfSQBQLT5lbmQudGhldGEgPCAyICogTV9QSQBcSABFVEgAV0lEVEgARE9URk9OVFBBVEgAR0RGT05UUEFUSABta05Db25zdHJhaW50RwBcRwBFWFBBVF9FTlRJVFlfREVCVUcARVhQQVRfRU5UUk9QWV9ERUJVRwBFWFBBVF9BQ0NPVU5USU5HX0RFQlVHAFJORwBTUFJJTkcAQ0VMTFBBRERJTkcAQ0VMTFNQQUNJTkcATEFORwBJTUcAXHhGACUlRU9GAElORgBceEZGAFJJRkYAZGVsdGEgPD0gMHhGRkZGAFx4RUYAXHhERgBceENGAFx4QkYAXHhBRgBceDlGAFx4OEYAXHg3RgBceDFGAFx4RQBcRQBQT0lOVC1TSVpFAFRSVUUAQ0xPU0UARkFMU0UAa2luZCA9PSBMVF9OT05FAEdSQURJRU5UQU5HTEUAVFJJQU5HTEUATUlERExFAElOVklTSUJMRQBUQUJMRQBBR1RZUEUob2JqKSA9PSBBR0lORURHRSB8fCBBR1RZUEUob2JqKSA9PSBBR09VVEVER0UAXHhGRQBceEVFAFx4REUAQl9OT0RFAFx4Q0UAXHhCRQBceEFFAFx4OUUAXHg4RQBceDFFAFREAEEtPmZvcm1hdCA9PSBGT1JNQVRfQ09PUkQAbiAmJiBpID49IDAgJiYgaSA8IE5PREVDQVJEACUlRU5EAEhZQlJJRABTT0xJRABceEZEAFx4RUQARE9UVEVEAERBU0hFRABST1VOREVEAFx4REQAXHhDRABceEJEAFx4QUQAXHg5RABceDhEAFx4MUQAXHhDAGRlbGV0ZVZQU0MAXHhGQwBceEVDAFx4REMAXHhDQwBceEJDAFx4QUMAXHg5QwBceDhDAFx4MUMAXHhCAFNVQgBceEZCAFx4RUIAXHhEQgBceENCAFx4QkIAXHhBQgBceDlCAFx4OEIAXHgxQgBBICYmIEIAXHhGQQBceEVBAFx4REEAXHhDQQBceEJBAFx4QUEAXHg5QQBceDhBAFx4MUEAQAA/ADwlcz4APG5pbD4APC90c3Bhbj48L3RleHRQYXRoPgAKICAgIDwlOS4zZiwgJTkuM2YsICU5LjNmPgA+Cjx0aXRsZT4APEZPTlQ+ADxCUj4APEhUTUw+ADwvSFRNTD4APElNRz4AU3ludGF4IGVycm9yOiBub24tc3BhY2Ugc3RyaW5nIHVzZWQgYmVmb3JlIDxUQUJMRT4AU3ludGF4IGVycm9yOiBub24tc3BhY2Ugc3RyaW5nIHVzZWQgYWZ0ZXIgPC9UQUJMRT4APFREPgAtPgAiPgAJW2tleT0APD0APAAmI3gleDsAJnF1b3Q7ACZsdDsAJmd0OwAmYW1wOwAjJWQ7ACYjMzk7ACYjNDU7ACYjOTM7ACYjMTM7ACYjMTYwOwAmIzEwOwA7c3RvcC1vcGFjaXR5OgAlJUJvdW5kaW5nQm94OgBjYWxjdWxhdGluZyBzaG9ydGVzdCBwYXRocyBhbmQgc2V0dGluZyB1cCBzdHJlc3MgdGVybXM6ADxzdG9wIG9mZnNldD0iJS4wM2YiIHN0eWxlPSJzdG9wLWNvbG9yOgA8c3RvcCBvZmZzZXQ9IjEiIHN0eWxlPSJzdG9wLWNvbG9yOgA8c3RvcCBvZmZzZXQ9IjAiIHN0eWxlPSJzdG9wLWNvbG9yOgBzb2x2aW5nIG1vZGVsOgBncmV5OQBncmF5OQBceEY5AFx4RTkAXHhEOQBceEM5AFx4QjkAXHhBOQBncmV5OTkAZ3JheTk5AFx4OTkAZ3JleTg5AGdyYXk4OQBceDg5AGdyZXk3OQBncmF5NzkAZ3JleTY5AGdyYXk2OQBncmV5NTkAZ3JheTU5AGdyZXk0OQBncmF5NDkAZ3JleTM5AGdyYXkzOQBncmV5MjkAZ3JheTI5AGdyZXkxOQBncmF5MTkAXHgxOQAvcmRneTkvOQAvYnVwdTkvOQAvcmRwdTkvOQAvcHVidTkvOQAveWxnbmJ1OS85AC9nbmJ1OS85AC9yZHlsYnU5LzkAL3JkYnU5LzkAL2dyZXlzOS85AC9ncmVlbnM5LzkAL2JsdWVzOS85AC9wdXJwbGVzOS85AC9vcmFuZ2VzOS85AC9yZWRzOS85AC9wdW9yOS85AC95bG9yYnI5LzkAL3B1YnVnbjkvOQAvYnVnbjkvOQAvcHJnbjkvOQAvcmR5bGduOS85AC95bGduOS85AC9zcGVjdHJhbDkvOQAvcGl5ZzkvOQAvYnJiZzkvOQAvcHVyZDkvOQAveWxvcnJkOS85AC9vcnJkOS85AC9wYWlyZWQ5LzkAL3NldDM5LzkAL3NldDE5LzkAL3Bhc3RlbDE5LzkAL3BhaXJlZDEyLzkAL3NldDMxMi85AC9yZGd5MTEvOQAvcmR5bGJ1MTEvOQAvcmRidTExLzkAL3B1b3IxMS85AC9wcmduMTEvOQAvcmR5bGduMTEvOQAvc3BlY3RyYWwxMS85AC9waXlnMTEvOQAvYnJiZzExLzkAL3BhaXJlZDExLzkAL3NldDMxMS85AC9yZGd5MTAvOQAvcmR5bGJ1MTAvOQAvcmRidTEwLzkAL3B1b3IxMC85AC9wcmduMTAvOQAvcmR5bGduMTAvOQAvc3BlY3RyYWwxMC85AC9waXlnMTAvOQAvYnJiZzEwLzkAL3BhaXJlZDEwLzkAL3NldDMxMC85AGdyZXk4AGdyYXk4AFx4OAB1dGY4ACNmOGY4ZjgAI2U4ZThlOABceEY4AEdJRjgAXHhFOABceEQ4AFx4QzgAXHhCOABceEE4AGdyZXk5OABncmF5OTgAXHg5OABncmV5ODgAZ3JheTg4AFx4ODgAZ3JleTc4AGdyYXk3OABncmV5NjgAZ3JheTY4AGdyZXk1OABncmF5NTgAMjAyNDAyMTAuMjE1OABncmV5NDgAZ3JheTQ4AGdyZXkzOABncmF5MzgAZ3JleTI4AGdyYXkyOABncmV5MTgAZ3JheTE4AFx4MTgAL3JkZ3k5LzgAL2J1cHU5LzgAL3JkcHU5LzgAL3B1YnU5LzgAL3lsZ25idTkvOAAvZ25idTkvOAAvcmR5bGJ1OS84AC9yZGJ1OS84AC9ncmV5czkvOAAvZ3JlZW5zOS84AC9ibHVlczkvOAAvcHVycGxlczkvOAAvb3JhbmdlczkvOAAvcmVkczkvOAAvcHVvcjkvOAAveWxvcmJyOS84AC9wdWJ1Z245LzgAL2J1Z245LzgAL3ByZ245LzgAL3JkeWxnbjkvOAAveWxnbjkvOAAvc3BlY3RyYWw5LzgAL3BpeWc5LzgAL2JyYmc5LzgAL3B1cmQ5LzgAL3lsb3JyZDkvOAAvb3JyZDkvOAAvcGFpcmVkOS84AC9zZXQzOS84AC9zZXQxOS84AC9wYXN0ZWwxOS84AC9yZGd5OC84AC9idXB1OC84AC9yZHB1OC84AC9wdWJ1OC84AC95bGduYnU4LzgAL2duYnU4LzgAL3JkeWxidTgvOAAvcmRidTgvOAAvYWNjZW50OC84AC9ncmV5czgvOAAvZ3JlZW5zOC84AC9ibHVlczgvOAAvcHVycGxlczgvOAAvb3JhbmdlczgvOAAvcmVkczgvOAAvcHVvcjgvOAAveWxvcmJyOC84AC9wdWJ1Z244LzgAL2J1Z244LzgAL3ByZ244LzgAL3JkeWxnbjgvOAAveWxnbjgvOAAvc3BlY3RyYWw4LzgAL3BpeWc4LzgAL2JyYmc4LzgAL3B1cmQ4LzgAL3lsb3JyZDgvOAAvb3JyZDgvOAAvcGFpcmVkOC84AC9zZXQzOC84AC9zZXQyOC84AC9wYXN0ZWwyOC84AC9kYXJrMjgvOAAvc2V0MTgvOAAvcGFzdGVsMTgvOAAvcGFpcmVkMTIvOAAvc2V0MzEyLzgAL3JkZ3kxMS84AC9yZHlsYnUxMS84AC9yZGJ1MTEvOAAvcHVvcjExLzgAL3ByZ24xMS84AC9yZHlsZ24xMS84AC9zcGVjdHJhbDExLzgAL3BpeWcxMS84AC9icmJnMTEvOAAvcGFpcmVkMTEvOAAvc2V0MzExLzgAL3JkZ3kxMC84AC9yZHlsYnUxMC84AC9yZGJ1MTAvOAAvcHVvcjEwLzgAL3ByZ24xMC84AC9yZHlsZ24xMC84AC9zcGVjdHJhbDEwLzgAL3BpeWcxMC84AC9icmJnMTAvOAAvcGFpcmVkMTAvOAAvc2V0MzEwLzgAdXRmLTgAQy5VVEYtOABncmV5NwBncmF5NwBceDcAXHhGNwBceEU3AFx4RDcAXHhDNwBceEI3AFx4QTcAZ3JleTk3AGdyYXk5NwBceDk3AGdyZXk4NwBncmF5ODcAXHg4NwBncmV5NzcAZ3JheTc3AGdyZXk2NwBncmF5NjcAZ3JleTU3AGdyYXk1NwBncmV5NDcAZ3JheTQ3AGdyZXkzNwBncmF5MzcAZ3JleTI3AGdyYXkyNwBncmV5MTcAZ3JheTE3AFx4MTcAL3JkZ3k5LzcAL2J1cHU5LzcAL3JkcHU5LzcAL3B1YnU5LzcAL3lsZ25idTkvNwAvZ25idTkvNwAvcmR5bGJ1OS83AC9yZGJ1OS83AC9ncmV5czkvNwAvZ3JlZW5zOS83AC9ibHVlczkvNwAvcHVycGxlczkvNwAvb3JhbmdlczkvNwAvcmVkczkvNwAvcHVvcjkvNwAveWxvcmJyOS83AC9wdWJ1Z245LzcAL2J1Z245LzcAL3ByZ245LzcAL3JkeWxnbjkvNwAveWxnbjkvNwAvc3BlY3RyYWw5LzcAL3BpeWc5LzcAL2JyYmc5LzcAL3B1cmQ5LzcAL3lsb3JyZDkvNwAvb3JyZDkvNwAvcGFpcmVkOS83AC9zZXQzOS83AC9zZXQxOS83AC9wYXN0ZWwxOS83AC9yZGd5OC83AC9idXB1OC83AC9yZHB1OC83AC9wdWJ1OC83AC95bGduYnU4LzcAL2duYnU4LzcAL3JkeWxidTgvNwAvcmRidTgvNwAvYWNjZW50OC83AC9ncmV5czgvNwAvZ3JlZW5zOC83AC9ibHVlczgvNwAvcHVycGxlczgvNwAvb3JhbmdlczgvNwAvcmVkczgvNwAvcHVvcjgvNwAveWxvcmJyOC83AC9wdWJ1Z244LzcAL2J1Z244LzcAL3ByZ244LzcAL3JkeWxnbjgvNwAveWxnbjgvNwAvc3BlY3RyYWw4LzcAL3BpeWc4LzcAL2JyYmc4LzcAL3B1cmQ4LzcAL3lsb3JyZDgvNwAvb3JyZDgvNwAvcGFpcmVkOC83AC9zZXQzOC83AC9zZXQyOC83AC9wYXN0ZWwyOC83AC9kYXJrMjgvNwAvc2V0MTgvNwAvcGFzdGVsMTgvNwAvcmRneTcvNwAvYnVwdTcvNwAvcmRwdTcvNwAvcHVidTcvNwAveWxnbmJ1Ny83AC9nbmJ1Ny83AC9yZHlsYnU3LzcAL3JkYnU3LzcAL2FjY2VudDcvNwAvZ3JleXM3LzcAL2dyZWVuczcvNwAvYmx1ZXM3LzcAL3B1cnBsZXM3LzcAL29yYW5nZXM3LzcAL3JlZHM3LzcAL3B1b3I3LzcAL3lsb3JicjcvNwAvcHVidWduNy83AC9idWduNy83AC9wcmduNy83AC9yZHlsZ243LzcAL3lsZ243LzcAL3NwZWN0cmFsNy83AC9waXlnNy83AC9icmJnNy83AC9wdXJkNy83AC95bG9ycmQ3LzcAL29ycmQ3LzcAL3BhaXJlZDcvNwAvc2V0MzcvNwAvc2V0MjcvNwAvcGFzdGVsMjcvNwAvZGFyazI3LzcAL3NldDE3LzcAL3Bhc3RlbDE3LzcAL3BhaXJlZDEyLzcAL3NldDMxMi83AC9yZGd5MTEvNwAvcmR5bGJ1MTEvNwAvcmRidTExLzcAL3B1b3IxMS83AC9wcmduMTEvNwAvcmR5bGduMTEvNwAvc3BlY3RyYWwxMS83AC9waXlnMTEvNwAvYnJiZzExLzcAL3BhaXJlZDExLzcAL3NldDMxMS83AC9yZGd5MTAvNwAvcmR5bGJ1MTAvNwAvcmRidTEwLzcAL3B1b3IxMC83AC9wcmduMTAvNwAvcmR5bGduMTAvNwAvc3BlY3RyYWwxMC83AC9waXlnMTAvNwAvYnJiZzEwLzcAL3BhaXJlZDEwLzcAL3NldDMxMC83ADEuNwBncmV5NgBncmF5NgBceDYAXHhGNgBceEU2AFx4RDYAXHhDNgBceEI2AFx4QTYAZ3JleTk2AGdyYXk5NgBceDk2AGdyZXk4NgBncmF5ODYAXHg4NgBncmV5NzYAZ3JheTc2AGdyZXk2NgBncmF5NjYAZ3JleTU2AGdyYXk1NgBncmV5NDYAZ3JheTQ2AGdyZXkzNgBncmF5MzYAZ3JleTI2AGdyYXkyNgBncmV5MTYAZ3JheTE2AFx4MTYAL3JkZ3k5LzYAL2J1cHU5LzYAL3JkcHU5LzYAL3B1YnU5LzYAL3lsZ25idTkvNgAvZ25idTkvNgAvcmR5bGJ1OS82AC9yZGJ1OS82AC9ncmV5czkvNgAvZ3JlZW5zOS82AC9ibHVlczkvNgAvcHVycGxlczkvNgAvb3JhbmdlczkvNgAvcmVkczkvNgAvcHVvcjkvNgAveWxvcmJyOS82AC9wdWJ1Z245LzYAL2J1Z245LzYAL3ByZ245LzYAL3JkeWxnbjkvNgAveWxnbjkvNgAvc3BlY3RyYWw5LzYAL3BpeWc5LzYAL2JyYmc5LzYAL3B1cmQ5LzYAL3lsb3JyZDkvNgAvb3JyZDkvNgAvcGFpcmVkOS82AC9zZXQzOS82AC9zZXQxOS82AC9wYXN0ZWwxOS82AC9yZGd5OC82AC9idXB1OC82AC9yZHB1OC82AC9wdWJ1OC82AC95bGduYnU4LzYAL2duYnU4LzYAL3JkeWxidTgvNgAvcmRidTgvNgAvYWNjZW50OC82AC9ncmV5czgvNgAvZ3JlZW5zOC82AC9ibHVlczgvNgAvcHVycGxlczgvNgAvb3JhbmdlczgvNgAvcmVkczgvNgAvcHVvcjgvNgAveWxvcmJyOC82AC9wdWJ1Z244LzYAL2J1Z244LzYAL3ByZ244LzYAL3JkeWxnbjgvNgAveWxnbjgvNgAvc3BlY3RyYWw4LzYAL3BpeWc4LzYAL2JyYmc4LzYAL3B1cmQ4LzYAL3lsb3JyZDgvNgAvb3JyZDgvNgAvcGFpcmVkOC82AC9zZXQzOC82AC9zZXQyOC82AC9wYXN0ZWwyOC82AC9kYXJrMjgvNgAvc2V0MTgvNgAvcGFzdGVsMTgvNgAvcmRneTcvNgAvYnVwdTcvNgAvcmRwdTcvNgAvcHVidTcvNgAveWxnbmJ1Ny82AC9nbmJ1Ny82AC9yZHlsYnU3LzYAL3JkYnU3LzYAL2FjY2VudDcvNgAvZ3JleXM3LzYAL2dyZWVuczcvNgAvYmx1ZXM3LzYAL3B1cnBsZXM3LzYAL29yYW5nZXM3LzYAL3JlZHM3LzYAL3B1b3I3LzYAL3lsb3JicjcvNgAvcHVidWduNy82AC9idWduNy82AC9wcmduNy82AC9yZHlsZ243LzYAL3lsZ243LzYAL3NwZWN0cmFsNy82AC9waXlnNy82AC9icmJnNy82AC9wdXJkNy82AC95bG9ycmQ3LzYAL29ycmQ3LzYAL3BhaXJlZDcvNgAvc2V0MzcvNgAvc2V0MjcvNgAvcGFzdGVsMjcvNgAvZGFyazI3LzYAL3NldDE3LzYAL3Bhc3RlbDE3LzYAL3JkZ3k2LzYAL2J1cHU2LzYAL3JkcHU2LzYAL3B1YnU2LzYAL3lsZ25idTYvNgAvZ25idTYvNgAvcmR5bGJ1Ni82AC9yZGJ1Ni82AC9hY2NlbnQ2LzYAL2dyZXlzNi82AC9ncmVlbnM2LzYAL2JsdWVzNi82AC9wdXJwbGVzNi82AC9vcmFuZ2VzNi82AC9yZWRzNi82AC9wdW9yNi82AC95bG9yYnI2LzYAL3B1YnVnbjYvNgAvYnVnbjYvNgAvcHJnbjYvNgAvcmR5bGduNi82AC95bGduNi82AC9zcGVjdHJhbDYvNgAvcGl5ZzYvNgAvYnJiZzYvNgAvcHVyZDYvNgAveWxvcnJkNi82AC9vcnJkNi82AC9wYWlyZWQ2LzYAL3NldDM2LzYAL3NldDI2LzYAL3Bhc3RlbDI2LzYAL2RhcmsyNi82AC9zZXQxNi82AC9wYXN0ZWwxNi82AC9wYWlyZWQxMi82AC9zZXQzMTIvNgAvcmRneTExLzYAL3JkeWxidTExLzYAL3JkYnUxMS82AC9wdW9yMTEvNgAvcHJnbjExLzYAL3JkeWxnbjExLzYAL3NwZWN0cmFsMTEvNgAvcGl5ZzExLzYAL2JyYmcxMS82AC9wYWlyZWQxMS82AC9zZXQzMTEvNgAvcmRneTEwLzYAL3JkeWxidTEwLzYAL3JkYnUxMC82AC9wdW9yMTAvNgAvcHJnbjEwLzYAL3JkeWxnbjEwLzYAL3NwZWN0cmFsMTAvNgAvcGl5ZzEwLzYAL2JyYmcxMC82AC9wYWlyZWQxMC82AC9zZXQzMTAvNgBncmV5NQBncmF5NQBceDUAYmlnNQBceEY1AFx4RTUAXHhENQBceEM1AFx4QjUAXHhBNQBncmV5OTUAZ3JheTk1AFx4OTUAZ3JleTg1AGdyYXk4NQBceDg1AGdyZXk3NQBncmF5NzUAZ3JleTY1AGdyYXk2NQBncmV5NTUAZ3JheTU1AGdyZXk0NQBncmF5NDUAZ3JleTM1AGdyYXkzNQBncmV5MjUAZ3JheTI1AGdyZXkxNQBncmF5MTUAXHgxNQBncmF5MDUAL3JkZ3k5LzUAL2J1cHU5LzUAL3JkcHU5LzUAL3B1YnU5LzUAL3lsZ25idTkvNQAvZ25idTkvNQAvcmR5bGJ1OS81AC9yZGJ1OS81AC9ncmV5czkvNQAvZ3JlZW5zOS81AC9ibHVlczkvNQAvcHVycGxlczkvNQAvb3JhbmdlczkvNQAvcmVkczkvNQAvcHVvcjkvNQAveWxvcmJyOS81AC9wdWJ1Z245LzUAL2J1Z245LzUAL3ByZ245LzUAL3JkeWxnbjkvNQAveWxnbjkvNQAvc3BlY3RyYWw5LzUAL3BpeWc5LzUAL2JyYmc5LzUAL3B1cmQ5LzUAL3lsb3JyZDkvNQAvb3JyZDkvNQAvcGFpcmVkOS81AC9zZXQzOS81AC9zZXQxOS81AC9wYXN0ZWwxOS81AC9yZGd5OC81AC9idXB1OC81AC9yZHB1OC81AC9wdWJ1OC81AC95bGduYnU4LzUAL2duYnU4LzUAL3JkeWxidTgvNQAvcmRidTgvNQAvYWNjZW50OC81AC9ncmV5czgvNQAvZ3JlZW5zOC81AC9ibHVlczgvNQAvcHVycGxlczgvNQAvb3JhbmdlczgvNQAvcmVkczgvNQAvcHVvcjgvNQAveWxvcmJyOC81AC9wdWJ1Z244LzUAL2J1Z244LzUAL3ByZ244LzUAL3JkeWxnbjgvNQAveWxnbjgvNQAvc3BlY3RyYWw4LzUAL3BpeWc4LzUAL2JyYmc4LzUAL3B1cmQ4LzUAL3lsb3JyZDgvNQAvb3JyZDgvNQAvcGFpcmVkOC81AC9zZXQzOC81AC9zZXQyOC81AC9wYXN0ZWwyOC81AC9kYXJrMjgvNQAvc2V0MTgvNQAvcGFzdGVsMTgvNQAvcmRneTcvNQAvYnVwdTcvNQAvcmRwdTcvNQAvcHVidTcvNQAveWxnbmJ1Ny81AC9nbmJ1Ny81AC9yZHlsYnU3LzUAL3JkYnU3LzUAL2FjY2VudDcvNQAvZ3JleXM3LzUAL2dyZWVuczcvNQAvYmx1ZXM3LzUAL3B1cnBsZXM3LzUAL29yYW5nZXM3LzUAL3JlZHM3LzUAL3B1b3I3LzUAL3lsb3JicjcvNQAvcHVidWduNy81AC9idWduNy81AC9wcmduNy81AC9yZHlsZ243LzUAL3lsZ243LzUAL3NwZWN0cmFsNy81AC9waXlnNy81AC9icmJnNy81AC9wdXJkNy81AC95bG9ycmQ3LzUAL29ycmQ3LzUAL3BhaXJlZDcvNQAvc2V0MzcvNQAvc2V0MjcvNQAvcGFzdGVsMjcvNQAvZGFyazI3LzUAL3NldDE3LzUAL3Bhc3RlbDE3LzUAL3JkZ3k2LzUAL2J1cHU2LzUAL3JkcHU2LzUAL3B1YnU2LzUAL3lsZ25idTYvNQAvZ25idTYvNQAvcmR5bGJ1Ni81AC9yZGJ1Ni81AC9hY2NlbnQ2LzUAL2dyZXlzNi81AC9ncmVlbnM2LzUAL2JsdWVzNi81AC9wdXJwbGVzNi81AC9vcmFuZ2VzNi81AC9yZWRzNi81AC9wdW9yNi81AC95bG9yYnI2LzUAL3B1YnVnbjYvNQAvYnVnbjYvNQAvcHJnbjYvNQAvcmR5bGduNi81AC95bGduNi81AC9zcGVjdHJhbDYvNQAvcGl5ZzYvNQAvYnJiZzYvNQAvcHVyZDYvNQAveWxvcnJkNi81AC9vcnJkNi81AC9wYWlyZWQ2LzUAL3NldDM2LzUAL3NldDI2LzUAL3Bhc3RlbDI2LzUAL2RhcmsyNi81AC9zZXQxNi81AC9wYXN0ZWwxNi81AC9yZGd5NS81AC9idXB1NS81AC9yZHB1NS81AC9wdWJ1NS81AC95bGduYnU1LzUAL2duYnU1LzUAL3JkeWxidTUvNQAvcmRidTUvNQAvYWNjZW50NS81AC9ncmV5czUvNQAvZ3JlZW5zNS81AC9ibHVlczUvNQAvcHVycGxlczUvNQAvb3JhbmdlczUvNQAvcmVkczUvNQAvcHVvcjUvNQAveWxvcmJyNS81AC9wdWJ1Z241LzUAL2J1Z241LzUAL3ByZ241LzUAL3JkeWxnbjUvNQAveWxnbjUvNQAvc3BlY3RyYWw1LzUAL3BpeWc1LzUAL2JyYmc1LzUAL3B1cmQ1LzUAL3lsb3JyZDUvNQAvb3JyZDUvNQAvcGFpcmVkNS81AC9zZXQzNS81AC9zZXQyNS81AC9wYXN0ZWwyNS81AC9kYXJrMjUvNQAvc2V0MTUvNQAvcGFzdGVsMTUvNQAvcGFpcmVkMTIvNQAvc2V0MzEyLzUAL3JkZ3kxMS81AC9yZHlsYnUxMS81AC9yZGJ1MTEvNQAvcHVvcjExLzUAL3ByZ24xMS81AC9yZHlsZ24xMS81AC9zcGVjdHJhbDExLzUAL3BpeWcxMS81AC9icmJnMTEvNQAvcGFpcmVkMTEvNQAvc2V0MzExLzUAL3JkZ3kxMC81AC9yZHlsYnUxMC81AC9yZGJ1MTAvNQAvcHVvcjEwLzUAL3ByZ24xMC81AC9yZHlsZ24xMC81AC9zcGVjdHJhbDEwLzUAL3BpeWcxMC81AC9icmJnMTAvNQAvcGFpcmVkMTAvNQAvc2V0MzEwLzUAYmlnLTUAQklHLTUAIC1kYXNoIDUAaXZvcnk0AGdyZXk0AGRhcmtzbGF0ZWdyYXk0AFx4NABzbm93NABsaWdodHllbGxvdzQAaG9uZXlkZXc0AHdoZWF0NAB0b21hdG80AHJvc3licm93bjQAbWFyb29uNABsaWdodHNhbG1vbjQAbGVtb25jaGlmZm9uNABzcHJpbmdncmVlbjQAZGFya29saXZlZ3JlZW40AHBhbGVncmVlbjQAZGFya3NlYWdyZWVuNABsaWdodGN5YW40AHRhbjQAcGx1bTQAc2Vhc2hlbGw0AGNvcmFsNABob3RwaW5rNABsaWdodHBpbms0AGRlZXBwaW5rNABjb3Juc2lsazQAZmlyZWJyaWNrNABraGFraTQAbGF2ZW5kZXJibHVzaDQAcGVhY2hwdWZmNABiaXNxdWU0AGxpZ2h0c2t5Ymx1ZTQAZGVlcHNreWJsdWU0AGxpZ2h0Ymx1ZTQAY2FkZXRibHVlNABkb2RnZXJibHVlNABsaWdodHN0ZWVsYmx1ZTQAcm95YWxibHVlNABzbGF0ZWJsdWU0AG5hdmFqb3doaXRlNABhbnRpcXVld2hpdGU0AGNob2NvbGF0ZTQAY2hhcnRyZXVzZTQAbWlzdHlyb3NlNABwYWxldHVycXVvaXNlNABhenVyZTQAdGhlcmU0AGFxdWFtYXJpbmU0AHRoaXN0bGU0AG1lZGl1bXB1cnBsZTQAZGFya29yYW5nZTQAbGlnaHRnb2xkZW5yb2Q0AGRhcmtnb2xkZW5yb2Q0AGJ1cmx5d29vZDQAZ29sZDQAbWVkaXVtb3JjaGlkNABkYXJrb3JjaGlkNABwYWxldmlvbGV0cmVkNABpbmRpYW5yZWQ0AG9yYW5nZXJlZDQAb2xpdmVkcmFiNABtYWdlbnRhNABzaWVubmE0AFx4RjQAXHhFNABceEQ0AFx4QzQAXHhCNABceEE0AGdyZXk5NABncmF5OTQAXHg5NABncmV5ODQAZ3JheTg0AFx4ODQAZ3JleTc0AGdyYXk3NABncmV5NjQAZ3JheTY0AGdyZXk1NABncmF5NTQAZ3JleTQ0AGdyYXk0NABncmV5MzQAZ3JheTM0AGZyYWMzNABncmV5MjQAZ3JheTI0AGdyZXkxNABncmF5MTQAXHgxNABmcmFjMTQAL3JkZ3k5LzQAL2J1cHU5LzQAL3JkcHU5LzQAL3B1YnU5LzQAL3lsZ25idTkvNAAvZ25idTkvNAAvcmR5bGJ1OS80AC9yZGJ1OS80AC9ncmV5czkvNAAvZ3JlZW5zOS80AC9ibHVlczkvNAAvcHVycGxlczkvNAAvb3JhbmdlczkvNAAvcmVkczkvNAAvcHVvcjkvNAAveWxvcmJyOS80AC9wdWJ1Z245LzQAL2J1Z245LzQAL3ByZ245LzQAL3JkeWxnbjkvNAAveWxnbjkvNAAvc3BlY3RyYWw5LzQAL3BpeWc5LzQAL2JyYmc5LzQAL3B1cmQ5LzQAL3lsb3JyZDkvNAAvb3JyZDkvNAAvcGFpcmVkOS80AC9zZXQzOS80AC9zZXQxOS80AC9wYXN0ZWwxOS80AC9yZGd5OC80AC9idXB1OC80AC9yZHB1OC80AC9wdWJ1OC80AC95bGduYnU4LzQAL2duYnU4LzQAL3JkeWxidTgvNAAvcmRidTgvNAAvYWNjZW50OC80AC9ncmV5czgvNAAvZ3JlZW5zOC80AC9ibHVlczgvNAAvcHVycGxlczgvNAAvb3JhbmdlczgvNAAvcmVkczgvNAAvcHVvcjgvNAAveWxvcmJyOC80AC9wdWJ1Z244LzQAL2J1Z244LzQAL3ByZ244LzQAL3JkeWxnbjgvNAAveWxnbjgvNAAvc3BlY3RyYWw4LzQAL3BpeWc4LzQAL2JyYmc4LzQAL3B1cmQ4LzQAL3lsb3JyZDgvNAAvb3JyZDgvNAAvcGFpcmVkOC80AC9zZXQzOC80AC9zZXQyOC80AC9wYXN0ZWwyOC80AC9kYXJrMjgvNAAvc2V0MTgvNAAvcGFzdGVsMTgvNAAvcmRneTcvNAAvYnVwdTcvNAAvcmRwdTcvNAAvcHVidTcvNAAveWxnbmJ1Ny80AC9nbmJ1Ny80AC9yZHlsYnU3LzQAL3JkYnU3LzQAL2FjY2VudDcvNAAvZ3JleXM3LzQAL2dyZWVuczcvNAAvYmx1ZXM3LzQAL3B1cnBsZXM3LzQAL29yYW5nZXM3LzQAL3JlZHM3LzQAL3B1b3I3LzQAL3lsb3JicjcvNAAvcHVidWduNy80AC9idWduNy80AC9wcmduNy80AC9yZHlsZ243LzQAL3lsZ243LzQAL3NwZWN0cmFsNy80AC9waXlnNy80AC9icmJnNy80AC9wdXJkNy80AC95bG9ycmQ3LzQAL29ycmQ3LzQAL3BhaXJlZDcvNAAvc2V0MzcvNAAvc2V0MjcvNAAvcGFzdGVsMjcvNAAvZGFyazI3LzQAL3NldDE3LzQAL3Bhc3RlbDE3LzQAL3JkZ3k2LzQAL2J1cHU2LzQAL3JkcHU2LzQAL3B1YnU2LzQAL3lsZ25idTYvNAAvZ25idTYvNAAvcmR5bGJ1Ni80AC9yZGJ1Ni80AC9hY2NlbnQ2LzQAL2dyZXlzNi80AC9ncmVlbnM2LzQAL2JsdWVzNi80AC9wdXJwbGVzNi80AC9vcmFuZ2VzNi80AC9yZWRzNi80AC9wdW9yNi80AC95bG9yYnI2LzQAL3B1YnVnbjYvNAAvYnVnbjYvNAAvcHJnbjYvNAAvcmR5bGduNi80AC95bGduNi80AC9zcGVjdHJhbDYvNAAvcGl5ZzYvNAAvYnJiZzYvNAAvcHVyZDYvNAAveWxvcnJkNi80AC9vcnJkNi80AC9wYWlyZWQ2LzQAL3NldDM2LzQAL3NldDI2LzQAL3Bhc3RlbDI2LzQAL2RhcmsyNi80AC9zZXQxNi80AC9wYXN0ZWwxNi80AC9yZGd5NS80AC9idXB1NS80AC9yZHB1NS80AC9wdWJ1NS80AC95bGduYnU1LzQAL2duYnU1LzQAL3JkeWxidTUvNAAvcmRidTUvNAAvYWNjZW50NS80AC9ncmV5czUvNAAvZ3JlZW5zNS80AC9ibHVlczUvNAAvcHVycGxlczUvNAAvb3JhbmdlczUvNAAvcmVkczUvNAAvcHVvcjUvNAAveWxvcmJyNS80AC9wdWJ1Z241LzQAL2J1Z241LzQAL3ByZ241LzQAL3JkeWxnbjUvNAAveWxnbjUvNAAvc3BlY3RyYWw1LzQAL3BpeWc1LzQAL2JyYmc1LzQAL3B1cmQ1LzQAL3lsb3JyZDUvNAAvb3JyZDUvNAAvcGFpcmVkNS80AC9zZXQzNS80AC9zZXQyNS80AC9wYXN0ZWwyNS80AC9kYXJrMjUvNAAvc2V0MTUvNAAvcGFzdGVsMTUvNAAvcmRneTQvNAAvYnVwdTQvNAAvcmRwdTQvNAAvcHVidTQvNAAveWxnbmJ1NC80AC9nbmJ1NC80AC9yZHlsYnU0LzQAL3JkYnU0LzQAL2FjY2VudDQvNAAvZ3JleXM0LzQAL2dyZWVuczQvNAAvYmx1ZXM0LzQAL3B1cnBsZXM0LzQAL29yYW5nZXM0LzQAL3JlZHM0LzQAL3B1b3I0LzQAL3lsb3JicjQvNAAvcHVidWduNC80AC9idWduNC80AC9wcmduNC80AC9yZHlsZ240LzQAL3lsZ240LzQAL3NwZWN0cmFsNC80AC9waXlnNC80AC9icmJnNC80AC9wdXJkNC80AC95bG9ycmQ0LzQAL29ycmQ0LzQAL3BhaXJlZDQvNAAvc2V0MzQvNAAvc2V0MjQvNAAvcGFzdGVsMjQvNAAvZGFyazI0LzQAL3NldDE0LzQAL3Bhc3RlbDE0LzQAL3BhaXJlZDEyLzQAL3NldDMxMi80AC9yZGd5MTEvNAAvcmR5bGJ1MTEvNAAvcmRidTExLzQAL3B1b3IxMS80AC9wcmduMTEvNAAvcmR5bGduMTEvNAAvc3BlY3RyYWwxMS80AC9waXlnMTEvNAAvYnJiZzExLzQAL3BhaXJlZDExLzQAL3NldDMxMS80AC9yZGd5MTAvNAAvcmR5bGJ1MTAvNAAvcmRidTEwLzQAL3B1b3IxMC80AC9wcmduMTAvNAAvcmR5bGduMTAvNAAvc3BlY3RyYWwxMC80AC9waXlnMTAvNAAvYnJiZzEwLzQAL3BhaXJlZDEwLzQAL3NldDMxMC80ADEuNABuID49IDQAc2lkZXMgPT0gNABpdm9yeTMAU3BhcnNlTWF0cml4X211bHRpcGx5MwBncmV5MwBkYXJrc2xhdGVncmF5MwBceDMAc25vdzMAbGlnaHR5ZWxsb3czAGhvbmV5ZGV3MwB3aGVhdDMAc3VwMwB0b21hdG8zAHJvc3licm93bjMAbWFyb29uMwBsaWdodHNhbG1vbjMAbGVtb25jaGlmZm9uMwBzcHJpbmdncmVlbjMAZGFya29saXZlZ3JlZW4zAHBhbGVncmVlbjMAZGFya3NlYWdyZWVuMwBsaWdodGN5YW4zAHRhbjMAcGx1bTMAc2Vhc2hlbGwzAGNvcmFsMwBob3RwaW5rMwBsaWdodHBpbmszAGRlZXBwaW5rMwBjb3Juc2lsazMAZmlyZWJyaWNrMwBraGFraTMAbGF2ZW5kZXJibHVzaDMAcGVhY2hwdWZmMwBiaXNxdWUzAGxpZ2h0c2t5Ymx1ZTMAZGVlcHNreWJsdWUzAGxpZ2h0Ymx1ZTMAY2FkZXRibHVlMwBkb2RnZXJibHVlMwBsaWdodHN0ZWVsYmx1ZTMAcm95YWxibHVlMwBzbGF0ZWJsdWUzAG5hdmFqb3doaXRlMwBhbnRpcXVld2hpdGUzAGNob2NvbGF0ZTMAY2hhcnRyZXVzZTMAbWlzdHlyb3NlMwBwYWxldHVycXVvaXNlMwBhenVyZTMAYXF1YW1hcmluZTMAdGhpc3RsZTMAbWVkaXVtcHVycGxlMwBkYXJrb3JhbmdlMwBsaWdodGdvbGRlbnJvZDMAZGFya2dvbGRlbnJvZDMAYnVybHl3b29kMwBnb2xkMwBtZWRpdW1vcmNoaWQzAGRhcmtvcmNoaWQzAHBhbGV2aW9sZXRyZWQzAGluZGlhbnJlZDMAb3JhbmdlcmVkMwBvbGl2ZWRyYWIzAG1hZ2VudGEzAHNpZW5uYTMAXHhGMwBceEUzAFx4RDMAXHhDMwBceEIzAFx4QTMAZ3JleTkzAGdyYXk5MwBceDkzAGdyZXk4MwBncmF5ODMAXHg4MwBncmV5NzMAZ3JheTczAGdyZXk2MwBncmF5NjMAZ3JleTUzAGdyYXk1MwBncmV5NDMAZ3JheTQzAGdyZXkzMwBncmF5MzMAZ3JleTIzAGdyYXkyMwBncmV5MTMAZ3JheTEzAFx4MTMAL3JkZ3k5LzMAL2J1cHU5LzMAL3JkcHU5LzMAL3B1YnU5LzMAL3lsZ25idTkvMwAvZ25idTkvMwAvcmR5bGJ1OS8zAC9yZGJ1OS8zAC9ncmV5czkvMwAvZ3JlZW5zOS8zAC9ibHVlczkvMwAvcHVycGxlczkvMwAvb3JhbmdlczkvMwAvcmVkczkvMwAvcHVvcjkvMwAveWxvcmJyOS8zAC9wdWJ1Z245LzMAL2J1Z245LzMAL3ByZ245LzMAL3JkeWxnbjkvMwAveWxnbjkvMwAvc3BlY3RyYWw5LzMAL3BpeWc5LzMAL2JyYmc5LzMAL3B1cmQ5LzMAL3lsb3JyZDkvMwAvb3JyZDkvMwAvcGFpcmVkOS8zAC9zZXQzOS8zAC9zZXQxOS8zAC9wYXN0ZWwxOS8zAC9yZGd5OC8zAC9idXB1OC8zAC9yZHB1OC8zAC9wdWJ1OC8zAC95bGduYnU4LzMAL2duYnU4LzMAL3JkeWxidTgvMwAvcmRidTgvMwAvYWNjZW50OC8zAC9ncmV5czgvMwAvZ3JlZW5zOC8zAC9ibHVlczgvMwAvcHVycGxlczgvMwAvb3JhbmdlczgvMwAvcmVkczgvMwAvcHVvcjgvMwAveWxvcmJyOC8zAC9wdWJ1Z244LzMAL2J1Z244LzMAL3ByZ244LzMAL3JkeWxnbjgvMwAveWxnbjgvMwAvc3BlY3RyYWw4LzMAL3BpeWc4LzMAL2JyYmc4LzMAL3B1cmQ4LzMAL3lsb3JyZDgvMwAvb3JyZDgvMwAvcGFpcmVkOC8zAC9zZXQzOC8zAC9zZXQyOC8zAC9wYXN0ZWwyOC8zAC9kYXJrMjgvMwAvc2V0MTgvMwAvcGFzdGVsMTgvMwAvcmRneTcvMwAvYnVwdTcvMwAvcmRwdTcvMwAvcHVidTcvMwAveWxnbmJ1Ny8zAC9nbmJ1Ny8zAC9yZHlsYnU3LzMAL3JkYnU3LzMAL2FjY2VudDcvMwAvZ3JleXM3LzMAL2dyZWVuczcvMwAvYmx1ZXM3LzMAL3B1cnBsZXM3LzMAL29yYW5nZXM3LzMAL3JlZHM3LzMAL3B1b3I3LzMAL3lsb3JicjcvMwAvcHVidWduNy8zAC9idWduNy8zAC9wcmduNy8zAC9yZHlsZ243LzMAL3lsZ243LzMAL3NwZWN0cmFsNy8zAC9waXlnNy8zAC9icmJnNy8zAC9wdXJkNy8zAC95bG9ycmQ3LzMAL29ycmQ3LzMAL3BhaXJlZDcvMwAvc2V0MzcvMwAvc2V0MjcvMwAvcGFzdGVsMjcvMwAvZGFyazI3LzMAL3NldDE3LzMAL3Bhc3RlbDE3LzMAL3JkZ3k2LzMAL2J1cHU2LzMAL3JkcHU2LzMAL3B1YnU2LzMAL3lsZ25idTYvMwAvZ25idTYvMwAvcmR5bGJ1Ni8zAC9yZGJ1Ni8zAC9hY2NlbnQ2LzMAL2dyZXlzNi8zAC9ncmVlbnM2LzMAL2JsdWVzNi8zAC9wdXJwbGVzNi8zAC9vcmFuZ2VzNi8zAC9yZWRzNi8zAC9wdW9yNi8zAC95bG9yYnI2LzMAL3B1YnVnbjYvMwAvYnVnbjYvMwAvcHJnbjYvMwAvcmR5bGduNi8zAC95bGduNi8zAC9zcGVjdHJhbDYvMwAvcGl5ZzYvMwAvYnJiZzYvMwAvcHVyZDYvMwAveWxvcnJkNi8zAC9vcnJkNi8zAC9wYWlyZWQ2LzMAL3NldDM2LzMAL3NldDI2LzMAL3Bhc3RlbDI2LzMAL2RhcmsyNi8zAC9zZXQxNi8zAC9wYXN0ZWwxNi8zAC9yZGd5NS8zAC9idXB1NS8zAC9yZHB1NS8zAC9wdWJ1NS8zAC95bGduYnU1LzMAL2duYnU1LzMAL3JkeWxidTUvMwAvcmRidTUvMwAvYWNjZW50NS8zAC9ncmV5czUvMwAvZ3JlZW5zNS8zAC9ibHVlczUvMwAvcHVycGxlczUvMwAvb3JhbmdlczUvMwAvcmVkczUvMwAvcHVvcjUvMwAveWxvcmJyNS8zAC9wdWJ1Z241LzMAL2J1Z241LzMAL3ByZ241LzMAL3JkeWxnbjUvMwAveWxnbjUvMwAvc3BlY3RyYWw1LzMAL3BpeWc1LzMAL2JyYmc1LzMAL3B1cmQ1LzMAL3lsb3JyZDUvMwAvb3JyZDUvMwAvcGFpcmVkNS8zAC9zZXQzNS8zAC9zZXQyNS8zAC9wYXN0ZWwyNS8zAC9kYXJrMjUvMwAvc2V0MTUvMwAvcGFzdGVsMTUvMwAvcmRneTQvMwAvYnVwdTQvMwAvcmRwdTQvMwAvcHVidTQvMwAveWxnbmJ1NC8zAC9nbmJ1NC8zAC9yZHlsYnU0LzMAL3JkYnU0LzMAL2FjY2VudDQvMwAvZ3JleXM0LzMAL2dyZWVuczQvMwAvYmx1ZXM0LzMAL3B1cnBsZXM0LzMAL29yYW5nZXM0LzMAL3JlZHM0LzMAL3B1b3I0LzMAL3lsb3JicjQvMwAvcHVidWduNC8zAC9idWduNC8zAC9wcmduNC8zAC9yZHlsZ240LzMAL3lsZ240LzMAL3NwZWN0cmFsNC8zAC9waXlnNC8zAC9icmJnNC8zAC9wdXJkNC8zAC95bG9ycmQ0LzMAL29ycmQ0LzMAL3BhaXJlZDQvMwAvc2V0MzQvMwAvc2V0MjQvMwAvcGFzdGVsMjQvMwAvZGFyazI0LzMAL3NldDE0LzMAL3Bhc3RlbDE0LzMAL3JkZ3kzLzMAL2J1cHUzLzMAL3JkcHUzLzMAL3B1YnUzLzMAL3lsZ25idTMvMwAvZ25idTMvMwAvcmR5bGJ1My8zAC9yZGJ1My8zAC9hY2NlbnQzLzMAL2dyZXlzMy8zAC9ncmVlbnMzLzMAL2JsdWVzMy8zAC9wdXJwbGVzMy8zAC9vcmFuZ2VzMy8zAC9yZWRzMy8zAC9wdW9yMy8zAC95bG9yYnIzLzMAL3B1YnVnbjMvMwAvYnVnbjMvMwAvcHJnbjMvMwAvcmR5bGduMy8zAC95bGduMy8zAC9zcGVjdHJhbDMvMwAvcGl5ZzMvMwAvYnJiZzMvMwAvcHVyZDMvMwAveWxvcnJkMy8zAC9vcnJkMy8zAC9wYWlyZWQzLzMAL3NldDMzLzMAL3NldDIzLzMAL3Bhc3RlbDIzLzMAL2RhcmsyMy8zAC9zZXQxMy8zAC9wYXN0ZWwxMy8zAC9wYWlyZWQxMi8zAC9zZXQzMTIvMwAvcmRneTExLzMAL3JkeWxidTExLzMAL3JkYnUxMS8zAC9wdW9yMTEvMwAvcHJnbjExLzMAL3JkeWxnbjExLzMAL3NwZWN0cmFsMTEvMwAvcGl5ZzExLzMAL2JyYmcxMS8zAC9wYWlyZWQxMS8zAC9zZXQzMTEvMwAvcmRneTEwLzMAL3JkeWxidTEwLzMAL3JkYnUxMC8zAC9wdW9yMTAvMwAvcHJnbjEwLzMAL3JkeWxnbjEwLzMAL3NwZWN0cmFsMTAvMwAvcGl5ZzEwLzMAL2JyYmcxMC8zAC9wYWlyZWQxMC8zAC9zZXQzMTAvMwBpdm9yeTIAZ3JleTIAZGFya3NsYXRlZ3JheTIAXHgyAHNub3cyAGxpZ2h0eWVsbG93MgBob25leWRldzIAUlRyZWVJbnNlcnQyAHdoZWF0MgBzdXAyAG5vcDIAdG9tYXRvMgByb3N5YnJvd24yAG1hcm9vbjIAbGlnaHRzYWxtb24yAGxlbW9uY2hpZmZvbjIAc3ByaW5nZ3JlZW4yAGRhcmtvbGl2ZWdyZWVuMgBwYWxlZ3JlZW4yAGRhcmtzZWFncmVlbjIAbGlnaHRjeWFuMgB0YW4yAHBsdW0yAHNlYXNoZWxsMgBjb3JhbDIAaG90cGluazIAbGlnaHRwaW5rMgBkZWVwcGluazIAY29ybnNpbGsyAGZpcmVicmljazIAa2hha2kyAGxhdmVuZGVyYmx1c2gyAHBlYWNocHVmZjIAYnJvbnplMgBiaXNxdWUyAGxpZ2h0c2t5Ymx1ZTIAZGVlcHNreWJsdWUyAGxpZ2h0Ymx1ZTIAY2FkZXRibHVlMgBkb2RnZXJibHVlMgBsaWdodHN0ZWVsYmx1ZTIAcm95YWxibHVlMgBzbGF0ZWJsdWUyAG5hdmFqb3doaXRlMgBhbnRpcXVld2hpdGUyAGNob2NvbGF0ZTIAY2hhcnRyZXVzZTIAbWlzdHlyb3NlMgBwYWxldHVycXVvaXNlMgBhenVyZTIAYXF1YW1hcmluZTIAdGhpc3RsZTIAbWVkaXVtcHVycGxlMgBkYXJrb3JhbmdlMgBsaWdodGdvbGRlbnJvZDIAZGFya2dvbGRlbnJvZDIAYnVybHl3b29kMgBnb2xkMgBtZWRpdW1vcmNoaWQyAGRhcmtvcmNoaWQyAHBhbGV2aW9sZXRyZWQyAGluZGlhbnJlZDIAb3JhbmdlcmVkMgBvbGl2ZWRyYWIyAG1hZ2VudGEyAHNpZW5uYTIAXHhGMgBceEUyAFx4RDIAXHhDMgBceEIyAFx4QTIAZ3JleTkyAGdyYXk5MgBceDkyAGdyZXk4MgBncmF5ODIAXHg4MgBncmV5NzIAZ3JheTcyAGdyZXk2MgBncmF5NjIAZ3JleTUyAGdyYXk1MgBncmV5NDIAZ3JheTQyAGdyZXkzMgBncmF5MzIAZ3JleTIyAGdyYXkyMgBncmV5MTIAZ3JheTEyAFx4MTIAZnJhYzEyAC9wYWlyZWQxMi8xMgAvc2V0MzEyLzEyAC9yZGd5OS8yAC9idXB1OS8yAC9yZHB1OS8yAC9wdWJ1OS8yAC95bGduYnU5LzIAL2duYnU5LzIAL3JkeWxidTkvMgAvcmRidTkvMgAvZ3JleXM5LzIAL2dyZWVuczkvMgAvYmx1ZXM5LzIAL3B1cnBsZXM5LzIAL29yYW5nZXM5LzIAL3JlZHM5LzIAL3B1b3I5LzIAL3lsb3JicjkvMgAvcHVidWduOS8yAC9idWduOS8yAC9wcmduOS8yAC9yZHlsZ245LzIAL3lsZ245LzIAL3NwZWN0cmFsOS8yAC9waXlnOS8yAC9icmJnOS8yAC9wdXJkOS8yAC95bG9ycmQ5LzIAL29ycmQ5LzIAL3BhaXJlZDkvMgAvc2V0MzkvMgAvc2V0MTkvMgAvcGFzdGVsMTkvMgAvcmRneTgvMgAvYnVwdTgvMgAvcmRwdTgvMgAvcHVidTgvMgAveWxnbmJ1OC8yAC9nbmJ1OC8yAC9yZHlsYnU4LzIAL3JkYnU4LzIAL2FjY2VudDgvMgAvZ3JleXM4LzIAL2dyZWVuczgvMgAvYmx1ZXM4LzIAL3B1cnBsZXM4LzIAL29yYW5nZXM4LzIAL3JlZHM4LzIAL3B1b3I4LzIAL3lsb3JicjgvMgAvcHVidWduOC8yAC9idWduOC8yAC9wcmduOC8yAC9yZHlsZ244LzIAL3lsZ244LzIAL3NwZWN0cmFsOC8yAC9waXlnOC8yAC9icmJnOC8yAC9wdXJkOC8yAC95bG9ycmQ4LzIAL29ycmQ4LzIAL3BhaXJlZDgvMgAvc2V0MzgvMgAvc2V0MjgvMgAvcGFzdGVsMjgvMgAvZGFyazI4LzIAL3NldDE4LzIAL3Bhc3RlbDE4LzIAL3JkZ3k3LzIAL2J1cHU3LzIAL3JkcHU3LzIAL3B1YnU3LzIAL3lsZ25idTcvMgAvZ25idTcvMgAvcmR5bGJ1Ny8yAC9yZGJ1Ny8yAC9hY2NlbnQ3LzIAL2dyZXlzNy8yAC9ncmVlbnM3LzIAL2JsdWVzNy8yAC9wdXJwbGVzNy8yAC9vcmFuZ2VzNy8yAC9yZWRzNy8yAC9wdW9yNy8yAC95bG9yYnI3LzIAL3B1YnVnbjcvMgAvYnVnbjcvMgAvcHJnbjcvMgAvcmR5bGduNy8yAC95bGduNy8yAC9zcGVjdHJhbDcvMgAvcGl5ZzcvMgAvYnJiZzcvMgAvcHVyZDcvMgAveWxvcnJkNy8yAC9vcnJkNy8yAC9wYWlyZWQ3LzIAL3NldDM3LzIAL3NldDI3LzIAL3Bhc3RlbDI3LzIAL2RhcmsyNy8yAC9zZXQxNy8yAC9wYXN0ZWwxNy8yAC9yZGd5Ni8yAC9idXB1Ni8yAC9yZHB1Ni8yAC9wdWJ1Ni8yAC95bGduYnU2LzIAL2duYnU2LzIAL3JkeWxidTYvMgAvcmRidTYvMgAvYWNjZW50Ni8yAC9ncmV5czYvMgAvZ3JlZW5zNi8yAC9ibHVlczYvMgAvcHVycGxlczYvMgAvb3JhbmdlczYvMgAvcmVkczYvMgAvcHVvcjYvMgAveWxvcmJyNi8yAC9wdWJ1Z242LzIAL2J1Z242LzIAL3ByZ242LzIAL3JkeWxnbjYvMgAveWxnbjYvMgAvc3BlY3RyYWw2LzIAL3BpeWc2LzIAL2JyYmc2LzIAL3B1cmQ2LzIAL3lsb3JyZDYvMgAvb3JyZDYvMgAvcGFpcmVkNi8yAC9zZXQzNi8yAC9zZXQyNi8yAC9wYXN0ZWwyNi8yAC9kYXJrMjYvMgAvc2V0MTYvMgAvcGFzdGVsMTYvMgAvcmRneTUvMgAvYnVwdTUvMgAvcmRwdTUvMgAvcHVidTUvMgAveWxnbmJ1NS8yAC9nbmJ1NS8yAC9yZHlsYnU1LzIAL3JkYnU1LzIAL2FjY2VudDUvMgAvZ3JleXM1LzIAL2dyZWVuczUvMgAvYmx1ZXM1LzIAL3B1cnBsZXM1LzIAL29yYW5nZXM1LzIAL3JlZHM1LzIAL3B1b3I1LzIAL3lsb3JicjUvMgAvcHVidWduNS8yAC9idWduNS8yAC9wcmduNS8yAC9yZHlsZ241LzIAL3lsZ241LzIAL3NwZWN0cmFsNS8yAC9waXlnNS8yAC9icmJnNS8yAC9wdXJkNS8yAC95bG9ycmQ1LzIAL29ycmQ1LzIAL3BhaXJlZDUvMgAvc2V0MzUvMgAvc2V0MjUvMgAvcGFzdGVsMjUvMgAvZGFyazI1LzIAL3NldDE1LzIAL3Bhc3RlbDE1LzIAL3JkZ3k0LzIAL2J1cHU0LzIAL3JkcHU0LzIAL3B1YnU0LzIAL3lsZ25idTQvMgAvZ25idTQvMgAvcmR5bGJ1NC8yAC9yZGJ1NC8yAC9hY2NlbnQ0LzIAL2dyZXlzNC8yAC9ncmVlbnM0LzIAL2JsdWVzNC8yAC9wdXJwbGVzNC8yAC9vcmFuZ2VzNC8yAC9yZWRzNC8yAC9wdW9yNC8yAC95bG9yYnI0LzIAL3B1YnVnbjQvMgAvYnVnbjQvMgAvcHJnbjQvMgAvcmR5bGduNC8yAC95bGduNC8yAC9zcGVjdHJhbDQvMgAvcGl5ZzQvMgAvYnJiZzQvMgAvcHVyZDQvMgAveWxvcnJkNC8yAC9vcnJkNC8yAC9wYWlyZWQ0LzIAL3NldDM0LzIAL3NldDI0LzIAL3Bhc3RlbDI0LzIAL2RhcmsyNC8yAC9zZXQxNC8yAC9wYXN0ZWwxNC8yAC9yZGd5My8yAC9idXB1My8yAC9yZHB1My8yAC9wdWJ1My8yAC95bGduYnUzLzIAL2duYnUzLzIAL3JkeWxidTMvMgAvcmRidTMvMgAvYWNjZW50My8yAC9ncmV5czMvMgAvZ3JlZW5zMy8yAC9ibHVlczMvMgAvcHVycGxlczMvMgAvb3JhbmdlczMvMgAvcmVkczMvMgAvcHVvcjMvMgAveWxvcmJyMy8yAC9wdWJ1Z24zLzIAL2J1Z24zLzIAL3ByZ24zLzIAL3JkeWxnbjMvMgAveWxnbjMvMgAvc3BlY3RyYWwzLzIAL3BpeWczLzIAL2JyYmczLzIAL3B1cmQzLzIAL3lsb3JyZDMvMgAvb3JyZDMvMgAvcGFpcmVkMy8yAC9zZXQzMy8yAC9zZXQyMy8yAC9wYXN0ZWwyMy8yAC9kYXJrMjMvMgAvc2V0MTMvMgAvcGFzdGVsMTMvMgAvcGFpcmVkMTIvMgAvc2V0MzEyLzIAL3JkZ3kxMS8yAC9yZHlsYnUxMS8yAC9yZGJ1MTEvMgAvcHVvcjExLzIAL3ByZ24xMS8yAC9yZHlsZ24xMS8yAC9zcGVjdHJhbDExLzIAL3BpeWcxMS8yAC9icmJnMTEvMgAvcGFpcmVkMTEvMgAvc2V0MzExLzIAL3JkZ3kxMC8yAC9yZHlsYnUxMC8yAC9yZGJ1MTAvMgAvcHVvcjEwLzIAL3ByZ24xMC8yAC9yZHlsZ24xMC8yAC9zcGVjdHJhbDEwLzIAL3BpeWcxMC8yAC9icmJnMTAvMgAvcGFpcmVkMTAvMgAvc2V0MzEwLzIAMS4yACAtZGFzaCAyAHN6ID49IDIAbGVuID49IDIAZXhwID09IDEgfHwgZXhwID09IDIAZGltID09IDIATkRfb3V0KHYpLnNpemUgPT0gMgBpdm9yeTEAZ3JleTEAZGFya3NsYXRlZ3JheTEAXHgxAHNub3cxAGxpZ2h0eWVsbG93MQBob25leWRldzEAbnNsaW1pdDEAd2hlYXQxAHN1cDEAbm9wMQB0b21hdG8xAHJvc3licm93bjEAbWFyb29uMQBsaWdodHNhbG1vbjEAbGVtb25jaGlmZm9uMQBsYXRpbjEAYWdvcGVuMQBzcHJpbmdncmVlbjEAZGFya29saXZlZ3JlZW4xAHBhbGVncmVlbjEAZGFya3NlYWdyZWVuMQBsaWdodGN5YW4xAHRhbjEAcGx1bTEAc2Vhc2hlbGwxAGNvcmFsMQBob3RwaW5rMQBsaWdodHBpbmsxAGRlZXBwaW5rMQBjb3Juc2lsazEAZmlyZWJyaWNrMQBqMCA8PSBpMSAmJiBpMSA8PSBqMQBraGFraTEAbGF2ZW5kZXJibHVzaDEAcGVhY2hwdWZmMQBiaXNxdWUxAGxpZ2h0c2t5Ymx1ZTEAZGVlcHNreWJsdWUxAGxpZ2h0Ymx1ZTEAY2FkZXRibHVlMQBkb2RnZXJibHVlMQBsaWdodHN0ZWVsYmx1ZTEAcm95YWxibHVlMQBzbGF0ZWJsdWUxAG5hdmFqb3doaXRlMQBhbnRpcXVld2hpdGUxAGNob2NvbGF0ZTEAY2hhcnRyZXVzZTEAbWlzdHlyb3NlMQBwYWxldHVycXVvaXNlMQBhenVyZTEAYXF1YW1hcmluZTEAdGhpc3RsZTEAbWVkaXVtcHVycGxlMQBkYXJrb3JhbmdlMQBhcmdfZTAgJiYgYXJnX2UxAGxpZ2h0Z29sZGVucm9kMQBkYXJrZ29sZGVucm9kMQBidXJseXdvb2QxAGdvbGQxAG1lZGl1bW9yY2hpZDEAZGFya29yY2hpZDEAcGFsZXZpb2xldHJlZDEAaW5kaWFucmVkMQBvcmFuZ2VyZWQxAG9saXZlZHJhYjEAbWFnZW50YTEAc2llbm5hMQBceEYxAFx4RTEAXHhEMQBceEMxAFx4QjEAXHhBMQBncmV5OTEAZ3JheTkxAFx4OTEAZ3JleTgxAGdyYXk4MQBceDgxAGdyZXk3MQBncmF5NzEAZ3JleTYxAGdyYXk2MQBncmV5NTEAZ3JheTUxAGdyZXk0MQBncmF5NDEAZ3JleTMxAGdyYXkzMQBncmV5MjEAZ3JheTIxAGdyZXkxMQBncmF5MTEAXHgxMQAvcGFpcmVkMTIvMTEAL3NldDMxMi8xMQAvcmRneTExLzExAC9yZHlsYnUxMS8xMQAvcmRidTExLzExAC9wdW9yMTEvMTEAL3ByZ24xMS8xMQAvcmR5bGduMTEvMTEAL3NwZWN0cmFsMTEvMTEAL3BpeWcxMS8xMQAvYnJiZzExLzExAC9wYWlyZWQxMS8xMQAvc2V0MzExLzExAGNzW2ldLT5zbGFjaygpPi0wLjAwMDAwMDEAL3JkZ3k5LzEAL2J1cHU5LzEAL3JkcHU5LzEAL3B1YnU5LzEAL3lsZ25idTkvMQAvZ25idTkvMQAvcmR5bGJ1OS8xAC9yZGJ1OS8xAC9ncmV5czkvMQAvZ3JlZW5zOS8xAC9ibHVlczkvMQAvcHVycGxlczkvMQAvb3JhbmdlczkvMQAvcmVkczkvMQAvcHVvcjkvMQAveWxvcmJyOS8xAC9wdWJ1Z245LzEAL2J1Z245LzEAL3ByZ245LzEAL3JkeWxnbjkvMQAveWxnbjkvMQAvc3BlY3RyYWw5LzEAL3BpeWc5LzEAL2JyYmc5LzEAL3B1cmQ5LzEAL3lsb3JyZDkvMQAvb3JyZDkvMQAvcGFpcmVkOS8xAC9zZXQzOS8xAC9zZXQxOS8xAC9wYXN0ZWwxOS8xAC9yZGd5OC8xAC9idXB1OC8xAC9yZHB1OC8xAC9wdWJ1OC8xAC95bGduYnU4LzEAL2duYnU4LzEAL3JkeWxidTgvMQAvcmRidTgvMQAvYWNjZW50OC8xAC9ncmV5czgvMQAvZ3JlZW5zOC8xAC9ibHVlczgvMQAvcHVycGxlczgvMQAvb3JhbmdlczgvMQAvcmVkczgvMQAvcHVvcjgvMQAveWxvcmJyOC8xAC9wdWJ1Z244LzEAL2J1Z244LzEAL3ByZ244LzEAL3JkeWxnbjgvMQAveWxnbjgvMQAvc3BlY3RyYWw4LzEAL3BpeWc4LzEAL2JyYmc4LzEAL3B1cmQ4LzEAL3lsb3JyZDgvMQAvb3JyZDgvMQAvcGFpcmVkOC8xAC9zZXQzOC8xAC9zZXQyOC8xAC9wYXN0ZWwyOC8xAC9kYXJrMjgvMQAvc2V0MTgvMQAvcGFzdGVsMTgvMQAvcmRneTcvMQAvYnVwdTcvMQAvcmRwdTcvMQAvcHVidTcvMQAveWxnbmJ1Ny8xAC9nbmJ1Ny8xAC9yZHlsYnU3LzEAL3JkYnU3LzEAL2FjY2VudDcvMQAvZ3JleXM3LzEAL2dyZWVuczcvMQAvYmx1ZXM3LzEAL3B1cnBsZXM3LzEAL29yYW5nZXM3LzEAL3JlZHM3LzEAL3B1b3I3LzEAL3lsb3JicjcvMQAvcHVidWduNy8xAC9idWduNy8xAC9wcmduNy8xAC9yZHlsZ243LzEAL3lsZ243LzEAL3NwZWN0cmFsNy8xAC9waXlnNy8xAC9icmJnNy8xAC9wdXJkNy8xAC95bG9ycmQ3LzEAL29ycmQ3LzEAL3BhaXJlZDcvMQAvc2V0MzcvMQAvc2V0MjcvMQAvcGFzdGVsMjcvMQAvZGFyazI3LzEAL3NldDE3LzEAL3Bhc3RlbDE3LzEAL3JkZ3k2LzEAL2J1cHU2LzEAL3JkcHU2LzEAL3B1YnU2LzEAL3lsZ25idTYvMQAvZ25idTYvMQAvcmR5bGJ1Ni8xAC9yZGJ1Ni8xAC9hY2NlbnQ2LzEAL2dyZXlzNi8xAC9ncmVlbnM2LzEAL2JsdWVzNi8xAC9wdXJwbGVzNi8xAC9vcmFuZ2VzNi8xAC9yZWRzNi8xAC9wdW9yNi8xAC95bG9yYnI2LzEAL3B1YnVnbjYvMQAvYnVnbjYvMQAvcHJnbjYvMQAvcmR5bGduNi8xAC95bGduNi8xAC9zcGVjdHJhbDYvMQAvcGl5ZzYvMQAvYnJiZzYvMQAvcHVyZDYvMQAveWxvcnJkNi8xAC9vcnJkNi8xAC9wYWlyZWQ2LzEAL3NldDM2LzEAL3NldDI2LzEAL3Bhc3RlbDI2LzEAL2RhcmsyNi8xAC9zZXQxNi8xAC9wYXN0ZWwxNi8xAC9yZGd5NS8xAC9idXB1NS8xAC9yZHB1NS8xAC9wdWJ1NS8xAC95bGduYnU1LzEAL2duYnU1LzEAL3JkeWxidTUvMQAvcmRidTUvMQAvYWNjZW50NS8xAC9ncmV5czUvMQAvZ3JlZW5zNS8xAC9ibHVlczUvMQAvcHVycGxlczUvMQAvb3JhbmdlczUvMQAvcmVkczUvMQAvcHVvcjUvMQAveWxvcmJyNS8xAC9wdWJ1Z241LzEAL2J1Z241LzEAL3ByZ241LzEAL3JkeWxnbjUvMQAveWxnbjUvMQAvc3BlY3RyYWw1LzEAL3BpeWc1LzEAL2JyYmc1LzEAL3B1cmQ1LzEAL3lsb3JyZDUvMQAvb3JyZDUvMQAvcGFpcmVkNS8xAC9zZXQzNS8xAC9zZXQyNS8xAC9wYXN0ZWwyNS8xAC9kYXJrMjUvMQAvc2V0MTUvMQAvcGFzdGVsMTUvMQAvcmRneTQvMQAvYnVwdTQvMQAvcmRwdTQvMQAvcHVidTQvMQAveWxnbmJ1NC8xAC9nbmJ1NC8xAC9yZHlsYnU0LzEAL3JkYnU0LzEAL2FjY2VudDQvMQAvZ3JleXM0LzEAL2dyZWVuczQvMQAvYmx1ZXM0LzEAL3B1cnBsZXM0LzEAL29yYW5nZXM0LzEAL3JlZHM0LzEAL3B1b3I0LzEAL3lsb3JicjQvMQAvcHVidWduNC8xAC9idWduNC8xAC9wcmduNC8xAC9yZHlsZ240LzEAL3lsZ240LzEAL3NwZWN0cmFsNC8xAC9waXlnNC8xAC9icmJnNC8xAC9wdXJkNC8xAC95bG9ycmQ0LzEAL29ycmQ0LzEAL3BhaXJlZDQvMQAvc2V0MzQvMQAvc2V0MjQvMQAvcGFzdGVsMjQvMQAvZGFyazI0LzEAL3NldDE0LzEAL3Bhc3RlbDE0LzEAL3JkZ3kzLzEAL2J1cHUzLzEAL3JkcHUzLzEAL3B1YnUzLzEAL3lsZ25idTMvMQAvZ25idTMvMQAvcmR5bGJ1My8xAC9yZGJ1My8xAC9hY2NlbnQzLzEAL2dyZXlzMy8xAC9ncmVlbnMzLzEAL2JsdWVzMy8xAC9wdXJwbGVzMy8xAC9vcmFuZ2VzMy8xAC9yZWRzMy8xAC9wdW9yMy8xAC95bG9yYnIzLzEAL3B1YnVnbjMvMQAvYnVnbjMvMQAvcHJnbjMvMQAvcmR5bGduMy8xAC95bGduMy8xAC9zcGVjdHJhbDMvMQAvcGl5ZzMvMQAvYnJiZzMvMQAvcHVyZDMvMQAveWxvcnJkMy8xAC9vcnJkMy8xAC9wYWlyZWQzLzEAL3NldDMzLzEAL3NldDIzLzEAL3Bhc3RlbDIzLzEAL2RhcmsyMy8xAC9zZXQxMy8xAC9wYXN0ZWwxMy8xAC9wYWlyZWQxMi8xAC9zZXQzMTIvMQAvcmRneTExLzEAL3JkeWxidTExLzEAL3JkYnUxMS8xAC9wdW9yMTEvMQAvcHJnbjExLzEAL3JkeWxnbjExLzEAL3NwZWN0cmFsMTEvMQAvcGl5ZzExLzEAL2JyYmcxMS8xAC9wYWlyZWQxMS8xAC9zZXQzMTEvMQAvcmRneTEwLzEAL3JkeWxidTEwLzEAL3JkYnUxMC8xAC9wdW9yMTAvMQAvcHJnbjEwLzEAL3JkeWxnbjEwLzEAL3NwZWN0cmFsMTAvMQAvcGl5ZzEwLzEAL2JyYmcxMC8xAC9wYWlyZWQxMC8xAC9zZXQzMTAvMQAxMC4wLjEAbGF0aW4tMQBJU09fODg1OS0xAElTTzg4NTktMQBJU08tODg1OS0xAHIwLT5oZWFwX2luZGV4ID4gLTEgfHwgcjEtPmhlYXBfaW5kZXggPiAtMQBuID4gMQBpID49IDEAcS0+biA9PSAxAHJ0cC0+c3BsaXQuUGFydGl0aW9uc1swXS5wYXJ0aXRpb25baV0gPT0gMCB8fCBydHAtPnNwbGl0LlBhcnRpdGlvbnNbMF0ucGFydGl0aW9uW2ldID09IDEAYnouc2l6ZSAlIDMgPT0gMQBUcmVlX2VkZ2Uuc2l6ZSA9PSBOX25vZGVzIC0gMQBkdHNpemUoZy0+bl9pZCkgPT0gb3NpemUgKyAxAG4tPmNvdW50ICsgKCpubiktPmNvdW50ID09IE5PREVDQVJEICsgMQBydHAtPnNwbGl0LlBhcnRpdGlvbnNbMF0uY291bnRbMF0gKyBydHAtPnNwbGl0LlBhcnRpdGlvbnNbMF0uY291bnRbMV0gPT0gTk9ERUNBUkQgKyAxAGdyZXkwAGdyYXkwAGpzb24wACNmMGYwZjAAI2UwZTBlMAB4Yi0+dS5zLmxvY2F0ZWQgPiBBR1hCVUZfSU5MSU5FX1NJWkVfMABcMABUMABceEYwAFx4RTAAXHhEMABceEMwAFx4QjAAXHhBMABncmV5OTAAZ3JheTkwAFx4OTAAZ3JleTgwAGdyYXk4MABceDgwACM4MDgwODAAZ3JleTcwAGdyYXk3MABjY3dyb3QgPT0gMCB8fCBjY3dyb3QgPT0gOTAgfHwgY2N3cm90ID09IDE4MCB8fCBjY3dyb3QgPT0gMjcwAGN3cm90ID09IDAgfHwgY3dyb3QgPT0gOTAgfHwgY3dyb3QgPT0gMTgwIHx8IGN3cm90ID09IDI3MABncmV5NjAAZ3JheTYwAGdyZXk1MABncmF5NTAAZ3JleTQwAGdyYXk0MAByLndpZHRoKCk8MWU0MABncmV5MzAAZ3JheTMwACMzMDMwMzAAZ3JleTIwAGdyYXkyMABncmV5MTAAZ3JheTEwAFx4MTAAIzEwMTAxMAAvcGFpcmVkMTIvMTAAL3NldDMxMi8xMAAvcmRneTExLzEwAC9yZHlsYnUxMS8xMAAvcmRidTExLzEwAC9wdW9yMTEvMTAAL3ByZ24xMS8xMAAvcmR5bGduMTEvMTAAL3NwZWN0cmFsMTEvMTAAL3BpeWcxMS8xMAAvYnJiZzExLzEwAC9wYWlyZWQxMS8xMAAvc2V0MzExLzEwAC9yZGd5MTAvMTAAL3JkeWxidTEwLzEwAC9yZGJ1MTAvMTAAL3B1b3IxMC8xMAAvcHJnbjEwLzEwAC9yZHlsZ24xMC8xMAAvc3BlY3RyYWwxMC8xMAAvcGl5ZzEwLzEwAC9icmJnMTAvMTAAL3BhaXJlZDEwLzEwAC9zZXQzMTAvMTAAMTIwMABncmV5MTAwAGdyYXkxMDAASVNPLUlSLTEwMAAxMDAwMAAlIVBTLUFkb2JlLTMuMABueiA+IDAAZGlzdCA+IDAAcGF0aGNvdW50ID4gMAB3Z3QgPiAwAG5zaXRlcyA+IDAAKHJ2ID09IDApIHx8IChORF9vcmRlcihydiktTkRfb3JkZXIodikpKmRpciA+IDAAbGVuID4gMABxdDEtPm4gPiAwICYmIHF0Mi0+biA+IDAAd2lkdGggPiAwAGxpc3QtPnNpemUgPiAwAHNwbC0+c2l6ZSA+IDAAYnouc2l6ZSA+IDAAZ3JhcGgtPndlaWdodHNbeF0gPiAwAGdyYXBoLT53ZWlnaHRzW25fZWRnZXNdID4gMABtID4gMCAmJiBuID4gMCAmJiBueiA+PSAwAHItPmhlYXBfaW5kZXggPj0gMAB0ID49IDAAbm5vZGVzID49IDAAbl9vYnMgPj0gMABwb2x5cC0+cG4gPj0gMABwcC0+cG4gPj0gMABvYnNbcG9seV9pXS0+cG4gPj0gMABzcGwucG4gPj0gMABzcGxpbmUucG4gPj0gMABuLT5sZXZlbCA+PSAwAG9yaWdpbmFsID49IDAAUGFjayA+PSAwAGlpIDwgMTw8ZGltICYmIGlpID49IDAAd2lkdGggPj0gMABqZGlhZyA+PSAwAGlkaWFnID49IDAAcGJzX25baV0gPj0gMABvYmotPnVybF9ic3BsaW5lbWFwX25baV0gPj0gMABwYnNfblswXSA+PSAwAFYgPj0gMABhZ25ub2RlcyhncmFwaCkgPj0gMABvYmpwMS0+c3oueCA9PSAwICYmIG9ianAxLT5zei55ID09IDAAY19jbnQgPT0gMAByYW5rX3Jlc3VsdCA9PSAwAGdldHRpbWVvZmRheV9yZXMgPT0gMABqID09IDAATkRfaW4ocmlnaHQpLnNpemUgKyBORF9vdXQocmlnaHQpLnNpemUgPT0gMABkdHNpemUoZGVzdCkgPT0gMABkdHNpemUoZy0+bl9zZXEpID09IDAAZHRzaXplKGctPmdfc2VxKSA9PSAwAGR0c2l6ZShnLT5lX3NlcSkgPT0gMABHRF9taW5yYW5rKGcpID09IDAAZHRzaXplKGctPm5faWQpID09IDAAZHRzaXplKGctPmdfaWQpID09IDAAZHRzaXplKGctPmVfaWQpID09IDAAY29zeCAhPSAwIHx8IHNpbnggIT0gMAByZXN1bHQgPT0gKGludCkoc2l6ZSAtIDEpIHx8IHJlc3VsdCA8IDAAbWFza1tpaV0gPCAwAE5EX2hlYXBpbmRleCh2KSA8IDAAXC8AWDExLwAlLipzLgBzcGVjaWZpZWQgcm9vdCBub2RlICIlcyIgd2FzIG5vdCBmb3VuZC4AR3JhcGggJXMgaGFzIGFycmF5IHBhY2tpbmcgd2l0aCB1c2VyIHZhbHVlcyBidXQgbm8gInNvcnR2IiBhdHRyaWJ1dGVzIGFyZSBkZWZpbmVkLgAxLgAtMC4AJSFQUy1BZG9iZS0AJVBERi0APCEtLQAgLAB3KwAqAHN0cmVxKGFwdHItPnUubmFtZSxLZXkpAE5EX29yZGVyKHYpIDwgTkRfb3JkZXIodykAdSA9PSBVRl9maW5kKHUpACFwb2ludHNfaXNfZW1wdHkocGxpc3QpAG5wIDwgbm9kZWxpc3Rfc2l6ZShsaXN0KQBvbmUgPCBub2RlbGlzdF9zaXplKGxpc3QpACEocS0+cXRzKQAhaW50c19pc19lbXB0eSgmbGVhdmVzKQBkdHNpemUoZy0+bl9pZCkgPT0gZHRzaXplKGctPm5fc2VxKQBORF9yYW5rKGZyb20pIDwgTkRfcmFuayh0bykAbm90IHdlbGwtZm9ybWVkIChpbnZhbGlkIHRva2VuKQBhZ3N1YnJlcChnLG4pAG4gIT0gTkRfbmV4dChuKQBmaW5kX2Zhc3Rfbm9kZShnLCBuKQAobnVsbCkAKCFqY24pICYmICghdmFsKQAhKHEtPmwpAHN5bS0+aWQgPj0gMCAmJiBzeW0tPmlkIDwgdG9wZGljdHNpemUob2JqKQAhKCpmbGFnKQBTcGFyc2VNYXRyaXhfaXNfc3ltbWV0cmljKEEsIHRydWUpAHZhbHVlICYmIHN0cmxlbih2YWx1ZSkAU3BhcnNlTWF0cml4X2lzX3N5bW1ldHJpYyhBLCBmYWxzZSkARURfbGFiZWwoZmUpACFUUkVFX0VER0UoZSkAIWNvbnN0cmFpbmluZ19mbGF0X2VkZ2UoZywgZSkAcl8lZCkAbF8lZCkAbW92ZSB0byAoJWQsICVkKQA7IHNwbGluZSB0byAoJWQsICVkKQA7IGxpbmUgdG8gKCVkLCAlZCkAKGxpYikAIVNwYXJzZU1hdHJpeF9oYXNfZGlhZ29uYWwoQSkAU3BhcnNlTWF0cml4X2tub3duX3N0cnVjdXJhbF9zeW1tZXRyaWMoQSkAIHNjYW5uaW5nIGEgSFRNTCBzdHJpbmcgKG1pc3NpbmcgJz4nPyBiYWQgbmVzdGluZz8gbG9uZ2VyIHRoYW4gJWQ/KQAgc2Nhbm5pbmcgYSBxdW90ZWQgc3RyaW5nIChtaXNzaW5nIGVuZHF1b3RlPyBsb25nZXIgdGhhbiAlZD8pACBzY2FubmluZyBhIC8qLi4uKi8gY29tbWVudCAobWlzc2luZyAnKi8/IGxvbmdlciB0aGFuICVkPykAZmFsbGJhY2soNCkAYWd0YWlsKGUpID09IFVGX2ZpbmQoYWd0YWlsKGUpKQBhZ2hlYWQoZSkgPT0gVUZfZmluZChhZ2hlYWQoZSkpAG91dCBvZiBkeW5hbWljIG1lbW9yeSBpbiB5eV9nZXRfbmV4dF9idWZmZXIoKQBvdXQgb2YgZHluYW1pYyBtZW1vcnkgaW4geXlfY3JlYXRlX2J1ZmZlcigpAG91dCBvZiBkeW5hbWljIG1lbW9yeSBpbiB5eWVuc3VyZV9idWZmZXJfc3RhY2soKQBzZXRsaW5ld2lkdGgoACkgcm90YXRlKCVkKSB0cmFuc2xhdGUoACB0cmFuc2Zvcm09InNjYWxlKABOT1RBVElPTigAICgAIG5lYXIgJyVzJwAlbGYsJWxmLCVsZiwnJVteJ10nACYAJQAkAHVybCgjADx0ZXh0UGF0aCB4bGluazpocmVmPSIjADxhcmVhIHNoYXBlPSJwb2x5IgAgZmlsbD0iIyUwMnglMDJ4JTAyeCIAYm94ZXMuc2l6ZSA8PSAoc2l6ZV90KUlOVF9NQVggJiYgImludGVnZXIgb3ZlcmZsb3ciAChzZXEgJiBTRVFfTUFTSykgPT0gc2VxICYmICJzZXF1ZW5jZSBJRCBvdmVyZmxvdyIAZ3Zfc29ydF9jb21wYXIgPT0gTlVMTCAmJiBndl9zb3J0X2FyZyA9PSBOVUxMICYmICJ1bnN1cHBvcnRlZCByZWN1cnNpdmUgY2FsbCB0byBndl9zb3J0IgBndl9zb3J0X2NvbXBhciAhPSBOVUxMICYmICJubyBjb21wYXJhdG9yIHNldCBpbiBndl9zb3J0IgBvcC0+b3AudS5wb2x5Z29uLmNudCA8PSBJTlRfTUFYICYmICJwb2x5Z29uIGNvdW50IGV4Y2VlZHMgZ3ZyZW5kZXJfcG9seWdvbiBzdXBwb3J0IgAgdGV4dC1hbmNob3I9InN0YXJ0IgBmdWxsX2xlbmd0aF93aXRob3V0X3NoYWZ0ID4gMCAmJiAibm9uLXBvc2l0aXZlIGZ1bGwgbGVuZ3RoIHdpdGhvdXQgc2hhZnQiADxhcmVhIHNoYXBlPSJyZWN0IgBzaXplID4gMCAmJiAiYXR0ZW1wdCB0byBhbGxvY2F0ZSBhcnJheSBvZiAwLXNpemVkIGVsZW1lbnRzIgBpbmRleCA8IHNlbGYtPnNpemVfYml0cyAmJiAib3V0IG9mIGJvdW5kcyBhY2Nlc3MiAGluZGV4IDwgc2VsZi5zaXplX2JpdHMgJiYgIm91dCBvZiBib3VuZHMgYWNjZXNzIgAqczEgIT0gKnMyICYmICJkdXBsaWNhdGUgc2VwYXJhdG9yIGNoYXJhY3RlcnMiAEdEX21pbnJhbmsoc3ViZykgPD0gR0RfbWF4cmFuayhzdWJnKSAmJiAiY29ycnVwdGVkIHJhbmsgYm91bmRzIgBpbmRleCA8IGxpc3QtPnNpemUgJiYgImluZGV4IG91dCBvZiBib3VuZHMiACAoKyU2ZCBieXRlcyAlc3wlZCwgeG1scGFyc2UuYzolZCkgJSpzIgAgZm9udC1mYW1pbHk9IiVzIgAgZm9udC13ZWlnaHQ9IiVzIgAgZmlsbD0iJXMiACBmb250LXN0cmV0Y2g9IiVzIgAgZm9udC1zdHlsZT0iJXMiAGJhZCBlZGdlIGxlbiAiJXMiACBiYXNlbGluZS1zaGlmdD0ic3VwZXIiAGFneGJsZW4oeGIpIDw9IHNpemVvZih4Yi0+dS5zdG9yZSkgJiYgImFneGJ1ZiBjb3JydXB0aW9uIgAgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIiB4bWxuczp4bGluaz0iaHR0cDovL3d3dy53My5vcmcvMTk5OS94bGluayIAZnVsbF9sZW5ndGggPiAwICYmICJub24tcG9zaXRpdmUgZnVsbCBsZW5ndGgiAGZ1bGxfYmFzZV93aWR0aCA+IDAgJiYgIm5vbi1wb3NpdGl2ZSBmdWxsIGJhc2Ugd2lkdGgiAG5vbWluYWxfYmFzZV93aWR0aCA+IDAgJiYgIm5vbi1wb3NpdGl2ZSBub21pbmFsIGJhc2Ugd2lkdGgiACIgd2lkdGg9IiVncHgiIGhlaWdodD0iJWdweCIgcHJlc2VydmVBc3BlY3RSYXRpbz0ieE1pbllNaW4gbWVldCIgeD0iJWciIHk9IiVnIgAiIHdpZHRoPSIlZ3B4IiBoZWlnaHQ9IiVncHgiIHByZXNlcnZlQXNwZWN0UmF0aW89InhNaWRZTWlkIG1lZXQiIHg9IiVnIiB5PSIlZyIAIGZvbnQtc2l6ZT0iJS4yZiIAIHZpZXdCb3g9IiUuMmYgJS4yZiAlLjJmICUuMmYiACBmaWxsLW9wYWNpdHk9IiVmIgAoeGItPnUucy5sb2NhdGVkID09IEFHWEJVRl9PTl9IRUFQIHx8IHhiLT51LnMubG9jYXRlZCA8PSBzaXplb2YoeGItPnUuc3RvcmUpKSAmJiAiY29ycnVwdGVkIGFneGJ1ZiB0eXBlIgAgdGV4dC1hbmNob3I9Im1pZGRsZSIAPGFyZWEgc2hhcGU9ImNpcmNsZSIAb2xkX25tZW1iIDwgU0laRV9NQVggLyBzaXplICYmICJjbGFpbWVkIHByZXZpb3VzIGV4dGVudCBpcyB0b28gbGFyZ2UiAHRoZXRhID49IDAgJiYgdGhldGEgPD0gTV9QSSAmJiAidGhldGEgb3V0IG9mIHJhbmdlIgAgdGV4dC1hbmNob3I9ImVuZCIAIGZvbnQtd2VpZ2h0PSJib2xkIgAgZm9udC1zdHlsZT0iaXRhbGljIgAgYmFzZWxpbmUtc2hpZnQ9InN1YiIAXCIAbGxlbiA8PSAoc2l6ZV90KUlOVF9NQVggJiYgIlhNTCB0b2tlbiB0b28gbG9uZyBmb3IgZXhwYXQgQVBJIgAiIHJ5PSIAX3AiIHN0YXJ0T2Zmc2V0PSI1MCUiPjx0c3BhbiB4PSIwIiBkeT0iACIgY3k9IgAiIHk9IgAiIHJ4PSIAIGN4PSIAIHg9IgAgdGFyZ2V0PSIAIHBvaW50cz0iACBjb29yZHM9IgAgdGV4dC1kZWNvcmF0aW9uPSIAIGZpbGw9IgAiIHN0cm9rZS13aWR0aD0iADxpbWFnZSB4bGluazpocmVmPSIAPD94bWwtc3R5bGVzaGVldCBocmVmPSIAIiBuYW1lPSIAIHhsaW5rOnRpdGxlPSIAIHRpdGxlPSIAIiBzdHJva2U9IgA8ZGVmcz4KPGxpbmVhckdyYWRpZW50IGlkPSIAPGRlZnM+CjxyYWRpYWxHcmFkaWVudCBpZD0iADxtYXAgaWQ9IgA8ZyBpZD0iACBkPSIAIiB5Mj0iACIgeDI9IgAiIHkxPSIAeDE9IgAgdHJhbnNmb3JtPSJyb3RhdGUoJWQgJWcgJWcpIgBhZ3hibGVuKCZTYnVmKSA9PSAwICYmICJwZW5kaW5nIHN0cmluZyBkYXRhIHRoYXQgd2FzIG5vdCBjb25zdW1lZCAobWlzc2luZyAiICJlbmRzdHIoKS9lbmRodG1sc3RyKCk/KSIAIGFsdD0iIgBDeWNsZSBFcnJvciEAUHVyZSB2aXJ0dWFsIGZ1bmN0aW9uIGNhbGxlZCEAPCEtLSBHZW5lcmF0ZWQgYnkgACVjICV6dSAAdCAldSAAIGNyZWF0ZSB0ZXh0IAB4TGF5b3V0IABkZWZhdWx0IABzdHJpY3QgACVzJXp1IC0lcyAAIC1zbW9vdGggYmV6aWVyIAAgbW92ZXRvIAAgdmVyc2lvbiAAIGNyZWF0ZSBwb2x5Z29uIAAgLXRleHQgeyVzfSAtZmlsbCAAIGNyZWF0ZSBvdmFsIAAgLXdpZHRoIABuZXdwYXRoIABncmFwaCAAcywlLjVnLCUuNWcgACUuNWcsJS41ZywlLjVnLCUuNWcgAGUsJS41ZywlLjVnIAAlZyAlZyAAJS4wM2xmIAAlLjNmIAAgLW91dGxpbmUgACBjcmVhdGUgbGluZSAAbm9kZSAAJWQgJWQgJWQgJWQgJWQgJWQgJS4xZiAlLjRmICVkICUuMWYgJS4xZiAlZCAlZCAAVG90YWwgc2l6ZSA+IDEgaW4gIiVzIiBjb2xvciBzcGVjIABbIC9SZWN0IFsgAFQgAFMgAE9QRU4gAEkgAEYgAEUgAEMgACAtPiAAUmFuayBzZXBhcmF0aW9uID0gAG5ldHdvcmsgc2ltcGxleDogAFVuc2F0aXNmaWVkIGNvbnN0cmFpbnQ6IABDYWxjdWxhdGluZyBzaG9ydGVzdCBwYXRoczogACVzOiAAU29sdmluZyBtb2RlbDogAFNldHRpbmcgdXAgc3ByaW5nIG1vZGVsOiAAY29udmVydCBncmFwaDogACBUaXRsZTogACJ0ZXh0IjogAHsiZnJhYyI6ICUuMDNmLCAiY29sb3IiOiAAIm5hbWUiOiAAInN0eWxlIjogACJmYWNlIjogADIgADwhLS0gACAtLSAAJSAAX3AiIABsXyVkIiBncmFkaWVudFVuaXRzPSJ1c2VyU3BhY2VPblVzZSIgAA0gICAgICAgICAgICAgICAgaXRlciA9ICVkLCBzdGVwID0gJWYgRm5vcm0gPSAlZiBueiA9ICVkICBLID0gJWYgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgAAogICAgADoJIAAgICAgJXN9CgB0cnlpbmcgdG8gYWRkIHRvIHJlY3QgeyVmICsvLSAlZiwgJWYgKy8tICVmfQoAI2RlZmF1bHQgeyBmaW5pc2ggeyBhbWJpZW50IDAuMSBkaWZmdXNlIDAuOSB9IH0KAHBpZ21lbnQgeyBjb2xvciAlcyB9CgBsaWdodF9zb3VyY2UgeyA8MTUwMCwzMDAwLC0yNTAwPiBjb2xvciBXaGl0ZSB9CgBnbG9iYWxfc2V0dGluZ3MgeyBhc3N1bWVkX2dhbW1hIDEuMCB9CgAgICAgdGV4dHVyZSBJbWFnZVRleHR1cmUgeyB1cmwgIiVzIiB9CgAgICAgfQoALy9za3kKcGxhbmUgeyA8MCwgMSwgMD4sIDEgaG9sbG93CiAgICB0ZXh0dXJlIHsKICAgICAgICBwaWdtZW50IHsgYm96byB0dXJidWxlbmNlIDAuOTUKICAgICAgICAgICAgY29sb3JfbWFwIHsKICAgICAgICAgICAgICAgIFswLjAwIHJnYiA8MC4wNSwgMC4yMCwgMC41MD5dCiAgICAgICAgICAgICAgICBbMC41MCByZ2IgPDAuMDUsIDAuMjAsIDAuNTA+XQogICAgICAgICAgICAgICAgWzAuNzUgcmdiIDwxLjAwLCAxLjAwLCAxLjAwPl0KICAgICAgICAgICAgICAgIFswLjc1IHJnYiA8MC4yNSwgMC4yNSwgMC4yNT5dCiAgICAgICAgICAgICAgICBbMS4wMCByZ2IgPDAuNTAsIDAuNTAsIDAuNTA+XQogICAgICAgICAgICB9CiAgICAgICAgICAgIHNjYWxlIDwxLjAwLCAxLjAwLCAxLjUwPiAqIDIuNTAKICAgICAgICAgICAgdHJhbnNsYXRlIDwwLjAwLCAwLjAwLCAwLjAwPgogICAgICAgIH0KICAgICAgICBmaW5pc2ggeyBhbWJpZW50IDEgZGlmZnVzZSAwIH0KICAgIH0KICAgIHNjYWxlIDEwMDAwCn0KLy9taXN0CmZvZyB7IGZvZ190eXBlIDIKICAgIGRpc3RhbmNlIDUwCiAgICBjb2xvciByZ2IgPDEuMDAsIDEuMDAsIDEuMDA+ICogMC43NQogICAgZm9nX29mZnNldCAwLjEwCiAgICBmb2dfYWx0IDEuNTAKICAgIHR1cmJ1bGVuY2UgMS43NQp9Ci8vZ25kCnBsYW5lIHsgPDAuMDAsIDEuMDAsIDAuMDA+LCAwCiAgICB0ZXh0dXJlIHsKICAgICAgICBwaWdtZW50eyBjb2xvciByZ2IgPDAuMjUsIDAuNDUsIDAuMDA+IH0KICAgICAgICBub3JtYWwgeyBidW1wcyAwLjc1IHNjYWxlIDAuMDEgfQogICAgICAgIGZpbmlzaCB7IHBob25nIDAuMTAgfQogICAgfQp9CgBjYW1lcmEgeyBsb2NhdGlvbiA8JS4zZiAsICUuM2YgLCAtNTAwLjAwMD4KICAgICAgICAgbG9va19hdCAgPCUuM2YgLCAlLjNmICwgMC4wMDA+CiAgICAgICAgIHJpZ2h0IHggKiBpbWFnZV93aWR0aCAvIGltYWdlX2hlaWdodAogICAgICAgICBhbmdsZSAlLjNmCn0KACAgICBtYXRlcmlhbCBNYXRlcmlhbCB7CgBTaGFwZSB7CgAgIGFwcGVhcmFuY2UgQXBwZWFyYW5jZSB7CgAvdXNlcl9zaGFwZV8lZCB7CgBncmFwaCBHIHsKAGFycm93aGVhZCA9IDcgJXMgbm90IHVzZWQgYnkgZ3JhcGh2aXoKAGJveHJhZCA9IDAgJXMgbm8gcm91bmRlZCBjb3JuZXJzIGluIGdyYXBodml6CgBvdXQgb2YgbWVtb3J5CgAlczogY291bGQgbm90IGFsbG9jYXRlIG1lbW9yeQoAR3JhcGh2aXogYnVpbHQgd2l0aG91dCBhbnkgdHJpYW5ndWxhdGlvbiBsaWJyYXJ5CgByZW1vdmVfb3ZlcmxhcDogR3JhcGh2aXogbm90IGJ1aWx0IHdpdGggdHJpYW5ndWxhdGlvbiBsaWJyYXJ5CgAlcyBmaWxsIGhhcyBubyBtZWFuaW5nIGluIERXQiAyLCBncGljIGNhbiB1c2UgZmlsbCBvciBmaWxsZWQsIDEwdGggRWRpdGlvbiB1c2VzIGZpbGwgb25seQoAYm94cmFkPTIuMCAlcyB3aWxsIGJlIHJlc2V0IHRvIDAuMCBieSBncGljIG9ubHkKAGluIGNoZWNrcGF0aCwgc3RhcnQgcG9ydCBub3QgaW4gZmlyc3QgYm94CgBpbiBjaGVja3BhdGgsIGVuZCBwb3J0IG5vdCBpbiBsYXN0IGJveAoAJWQgJWQgIyUwMnglMDJ4JTAyeAoASGVhcCBvdmVyZmxvdwoAdGV4dCB7CiAgICB0dGYgIiVzIiwKICAgICIlcyIsICUuM2YsICUuM2YKICAgICAgICBub19zaGFkb3cKACVkICVkICVkICUuMGYgJWQgJWQgJWQgJWQgJWQgJS4xZiAlZCAlZCAlZCAlZCAlZCAlenUKAHRvdGFsIGFkZGVkIHNvIGZhciA9ICV6dQoAcm9vdCA9ICVzIG1heCBzdGVwcyB0byByb290ID0gJWxsdQoALnBzICUuMGYqXG4oU0Z1LyUuMGZ1CgAgIG1hcmdpbiAldQoAICVzIGFsaWduZWR0ZXh0CgBsYXllcnMgbm90IHN1cHBvcnRlZCBpbiAlcyBvdXRwdXQKAGFkZF90cmVlX2VkZ2U6IGVtcHR5IG91dGVkZ2UgbGlzdAoAYWRkX3RyZWVfZWRnZTogZW1wdHkgaW5lZGdlIGxpc3QKAE5vIGxpYnogc3VwcG9ydAoAJXMgLlBTIHcvbyBhcmdzIGNhdXNlcyBHTlUgcGljIHRvIHNjYWxlIGRyYXdpbmcgdG8gZml0IDguNXgxMSBwYXBlcjsgRFdCIGRvZXMgbm90CgAlcyBHTlUgcGljIHN1cHBvcnRzIGEgbGluZXRoaWNrIHZhcmlhYmxlIHRvIHNldCBsaW5lIHRoaWNrbmVzczsgRFdCIGFuZCAxMHRoIEVkLiBkbyBub3QKACVzIEdOVSBwaWMgc3VwcG9ydHMgYSBib3hyYWQgdmFyaWFibGUgdG8gZHJhdyBib3hlcyB3aXRoIHJvdW5kZWQgY29ybmVyczsgRFdCIGFuZCAxMHRoIEVkLiBkbyBub3QKACAvJXMgc2V0X2ZvbnQKACVzJS4qcyBpcyBub3QgYSB0cm9mZiBmb250CgB1bmV4cGVjdGVkIGNhc2UgaW4gbG9jYXRlX2VuZHBvaW50CgBjZWxsIHNpemUgdG9vIHNtYWxsIGZvciBjb250ZW50CgB0YWJsZSBzaXplIHRvbyBzbWFsbCBmb3IgY29udGVudAoAJSVFbmREb2N1bWVudAoAVW5jbG9zZWQgY29tbWVudAoATGFiZWwgY2xvc2VkIGJlZm9yZSBlbmQgb2YgSFRNTCBlbGVtZW50CgBQb3J0cmFpdAoAZml4ZWQgY2VsbCBzaXplIHdpdGggdW5zcGVjaWZpZWQgd2lkdGggb3IgaGVpZ2h0CgBmaXhlZCB0YWJsZSBzaXplIHdpdGggdW5zcGVjaWZpZWQgd2lkdGggb3IgaGVpZ2h0CgBwb3MgYXR0cmlidXRlIGZvciBlZGdlICglcywlcykgZG9lc24ndCBoYXZlIDNuKzEgcG9pbnRzCgAgIGdlbmVyYXRlZCAlZCBjb25zdHJhaW50cwoAc3BsaW5lcyBhbmQgY2x1c3RlciBlZGdlcyBub3Qgc3VwcG9ydGVkIC0gdXNpbmcgbGluZSBzZWdtZW50cwoAb2JqZWN0cwoAV2FybmluZzogbm9kZSAlcywgcG9zaXRpb24gJXMsIGV4cGVjdGVkIHR3byBmbG9hdHMKAGNhbm5vdCBhbGxvY2F0ZSBwcwoAc2NhbGU9MS4wICVzIHJlcXVpcmVkIGZvciBjb21wYXJpc29ucwoAU2V0dGluZyBpbml0aWFsIHBvc2l0aW9ucwoAJXMgRFdCIDIgY29tcGF0aWJpbGl0eSBkZWZpbml0aW9ucwoAYXJyYXkgcGFja2luZzogJXMgJWQgcm93cyAlZCBjb2x1bW5zCgBzeW50YXggYW1iaWd1aXR5IC0gYmFkbHkgZGVsaW1pdGVkIG51bWJlciAnJXMnIGluIGxpbmUgJWQgb2YgJXMgc3BsaXRzIGludG8gdHdvIHRva2VucwoAZWRnZSBsYWJlbHMgd2l0aCBzcGxpbmVzPWN1cnZlZCBub3Qgc3VwcG9ydGVkIGluIGRvdCAtIHVzZSB4bGFiZWxzCgBmbGF0IGVkZ2UgYmV0d2VlbiBhZGphY2VudCBub2RlcyBvbmUgb2Ygd2hpY2ggaGFzIGEgcmVjb3JkIHNoYXBlIC0gcmVwbGFjZSByZWNvcmRzIHdpdGggSFRNTC1saWtlIGxhYmVscwoAb3V0IG9mIG1lbW9yeSB3aGVuIHRyeWluZyB0byBhbGxvY2F0ZSAlenUgYnl0ZXMKAGludGVnZXIgb3ZlcmZsb3cgd2hlbiB0cnlpbmcgdG8gYWxsb2NhdGUgJXp1ICogJXp1IGJ5dGVzCgB1cGRhdGU6IG1pc21hdGNoZWQgbGNhIGluIHRyZWV1cGRhdGVzCgBncmFwaCAlcywgY29vcmQgJXMsIGV4cGVjdGVkIGZvdXIgZG91YmxlcwoAbm9kZSAlcywgcG9zaXRpb24gJXMsIGV4cGVjdGVkIHR3byBkb3VibGVzCgBGb3VuZCAlZCBEaUctQ29MYSBib3VuZGFyaWVzCgBJbmNoZXMKACglNHp1KSAlN3p1IG5vZGVzICU3enUgZWRnZXMKAGNvbXBvdW5kRWRnZXM6IGNvdWxkIG5vdCBjb25zdHJ1Y3Qgb2JzdGFjbGVzIC0gZmFsbGluZyBiYWNrIHRvIHN0cmFpZ2h0IGxpbmUgZWRnZXMKAHRoZSBib3VuZGluZyBib3hlcyBvZiBzb21lIG5vZGVzIHRvdWNoIC0gZmFsbGluZyBiYWNrIHRvIHN0cmFpZ2h0IGxpbmUgZWRnZXMKAGNvbXBvdW5kRWRnZXM6IG5vZGVzIHRvdWNoIC0gZmFsbGluZyBiYWNrIHRvIHN0cmFpZ2h0IGxpbmUgZWRnZXMKAHNvbWUgbm9kZXMgd2l0aCBtYXJnaW4gKCUuMDJmLCUuMDJmKSB0b3VjaCAtIGZhbGxpbmcgYmFjayB0byBzdHJhaWdodCBsaW5lIGVkZ2VzCgBtZXJnZTI6IGdyYXBoICVzLCByYW5rICVkIGhhcyBvbmx5ICVkIDwgJWQgbm9kZXMKAFNjYW5uaW5nIGdyYXBoICVzLCAlZCBub2RlcwoAV2FybmluZzogbm8gaGFyZC1jb2RlZCBtZXRyaWNzIGZvciAnJXMnLiAgRmFsbGluZyBiYWNrIHRvICdUaW1lcycgbWV0cmljcwoAaW4gZWRnZSAlcyVzJXMKAFVzaW5nICVzOiAlczolcwoARm9ybWF0OiAiJXMiIG5vdCByZWNvZ25pemVkLiBVc2Ugb25lIG9mOiVzCgBMYXlvdXQgdHlwZTogIiVzIiBub3QgcmVjb2duaXplZC4gVXNlIG9uZSBvZjolcwoAbGF5b3V0ICVzCgAuZnQgJXMKAGJhZCBsYWJlbCBmb3JtYXQgJXMKAGluIHJvdXRlc3BsaW5lcywgZWRnZSBpcyBhIGxvb3AgYXQgJXMKACAgICAgICAlN2Qgbm9kZXMgJTdkIGVkZ2VzICU3enUgY29tcG9uZW50cyAlcwoAaW4gbGFiZWwgb2YgZWRnZSAlcyAlcyAlcwoAICBFZGdlICVzICVzICVzCgBvcnRobyAlcyAlcwoAcG9seWxpbmUgJXMgJXMKAHNwbGluZSAlcyAlcwoAcmVjdGFuZ2xlICglZCwlZCkgKCVkLCVkKSAlcyAlcwoAaW4gY2x1c3RlciAlcwoAJXMgd2FzIGFscmVhZHkgaW4gYSByYW5rc2V0LCBkZWxldGVkIGZyb20gY2x1c3RlciAlcwoAJXMgLT4gJXM6IHRhaWwgbm90IGluc2lkZSB0YWlsIGNsdXN0ZXIgJXMKACVzIC0+ICVzOiBoZWFkIGlzIGluc2lkZSB0YWlsIGNsdXN0ZXIgJXMKAGhlYWQgY2x1c3RlciAlcyBpbnNpZGUgdGFpbCBjbHVzdGVyICVzCgBoZWFkIG5vZGUgJXMgaW5zaWRlIHRhaWwgY2x1c3RlciAlcwoAJXMgLT4gJXM6IGhlYWQgbm90IGluc2lkZSBoZWFkIGNsdXN0ZXIgJXMKACVzIC0+ICVzOiB0YWlsIGlzIGluc2lkZSBoZWFkIGNsdXN0ZXIgJXMKAHRhaWwgY2x1c3RlciAlcyBpbnNpZGUgaGVhZCBjbHVzdGVyICVzCgB0YWlsIG5vZGUgJXMgaW5zaWRlIGhlYWQgY2x1c3RlciAlcwoAVW5oYW5kbGVkIGFkanVzdCBvcHRpb24gJXMKAHJlcG9zaXRpb24gJXMKAG5vIHBvc2l0aW9uIGZvciBlZGdlIHdpdGggeGxhYmVsICVzCgBubyBwb3NpdGlvbiBmb3IgZWRnZSB3aXRoIHRhaWwgbGFiZWwgJXMKAG5vIHBvc2l0aW9uIGZvciBlZGdlIHdpdGggbGFiZWwgJXMKAG5vIHBvc2l0aW9uIGZvciBlZGdlIHdpdGggaGVhZCBsYWJlbCAlcwoALy8qKiogYmVnaW5fZ3JhcGggJXMKAE1heC4gaXRlcmF0aW9ucyAoJWQpIHJlYWNoZWQgb24gZ3JhcGggJXMKAENvdWxkIG5vdCBwYXJzZSAiX2JhY2tncm91bmQiIGF0dHJpYnV0ZSBpbiBncmFwaCAlcwoAaW4gbGFiZWwgb2YgZ3JhcGggJXMKAENyZWF0aW5nIGVkZ2VzIHVzaW5nICVzCgBBZGp1c3RpbmcgJXMgdXNpbmcgJXMKACVzIHdoaWxlIG9wZW5pbmcgJXMKAGRlcml2ZSBncmFwaCBfZGdfJWQgb2YgJXMKACBdICAlenUgdHJ1ZSAlcwoAXSAgJWQgdHJ1ZSAlcwoAIF0gICV6dSBmYWxzZSAlcwoAXSAgJWQgZmFsc2UgJXMKAG1ha2VQb2x5OiB1bmtub3duIHNoYXBlIHR5cGUgJXMKAG1ha2VBZGRQb2x5OiB1bmtub3duIHNoYXBlIHR5cGUgJXMKAHVzaW5nICVzIGZvciB1bmtub3duIHNoYXBlICVzCgAgIG9jdHJlZSBzY2hlbWUgJXMKAGNhbid0IG9wZW4gbGlicmFyeSBmaWxlICVzCgBjYW4ndCBmaW5kIGxpYnJhcnkgZmlsZSAlcwoAQm91bmRpbmdCb3ggbm90IGZvdW5kIGluIGVwc2YgZmlsZSAlcwoAY291bGRuJ3Qgb3BlbiBlcHNmIGZpbGUgJXMKAGNvdWxkbid0IHJlYWQgZnJvbSBlcHNmIGZpbGUgJXMKAGluIG5vZGUgJXMKAHNoYXBlZmlsZSBub3Qgc2V0IG9yIG5vdCBmb3VuZCBmb3IgZXBzZiBub2RlICVzCgBpbiBsYWJlbCBvZiBub2RlICVzCgBlbmQgJXMKAHJhbmtpbmc6IGZhaWx1cmUgdG8gY3JlYXRlIHN0cm9uZyBjb25zdHJhaW50IGVkZ2UgYmV0d2VlbiBub2RlcyAlcyBhbmQgJXMKAG9vcHMsIGludGVybmFsIGVycm9yOiB1bmhhbmRsZWQgY29sb3IgdHlwZT0lZCAlcwoAJWQgJWQgJWQgJWQgJWQgJWQgJWQgJWQgJWQgJS4xZiAlZCAlZCAlZCAlZCAlZCAlZAogJWQgJXMKAHJvb3QgPSAlcwoALy8qKiogdGV4dHNwYW46ICVzLCBmb250c2l6ZSA9ICUuM2YsIGZvbnRuYW1lID0gJXMKAHRyaWVzID0gJWQsIG1vZGUgPSAlcwoALy8qKiogY29tbWVudDogJXMKAGZvbnRuYW1lOiAiJXMiIHJlc29sdmVkIHRvOiAlcwoAJSUlJVBhZ2VPcmllbnRhdGlvbjogJXMKAGRlbGF1bmF5X3RyaWFuZ3VsYXRpb246ICVzCgBkZWxhdW5heV90cmk6ICVzCgBndnByaW50ZjogJXMKAG5lc3Rpbmcgbm90IGFsbG93ZWQgaW4gc3R5bGU6ICVzCgB1bm1hdGNoZWQgJyknIGluIHN0eWxlOiAlcwoAdW5tYXRjaGVkICcoJyBpbiBzdHlsZTogJXMKACUlJSVUaXRsZTogJXMKACVzIFRpdGxlOiAlcwoAIyBUaXRsZTogJXMKAC8vKioqIGJlZ2luX25vZGU6ICVzCgByZWFsbG9jIGZhaWxlZDogJXMKAGxpYi9wYXRocGxhbi8lczolZDogJXMKAGdyaWQoJWQsJWQpOiAlcwoAQ291bGQgbm90IG9wZW4gIiVzIiBmb3Igd3JpdGluZyA6ICVzCgBzdGFydCBwb3J0OiAoJS41ZywgJS41ZyksIHRhbmdlbnQgYW5nbGU6ICUuNWcsICVzCgBlbmQgcG9ydDogKCUuNWcsICUuNWcpLCB0YW5nZW50IGFuZ2xlOiAlLjVnLCAlcwoAIFslenVdICVwIHNldCAlZCAoJS4wMmYsJS4wMmYpICglLjAyZiwlLjAyZikgJXMKACUlICVzCgAjICVzCgAgIG1vZGUgICAlcwoAY29uanVnYXRlX2dyYWRpZW50OiB1bmV4cGVjdGVkIGxlbmd0aCAwIHZlY3RvcgoAJXMgdG8gY2hhbmdlIGRyYXdpbmcgc2l6ZSwgbXVsdGlwbHkgdGhlIHdpZHRoIGFuZCBoZWlnaHQgb24gdGhlIC5QUyBsaW5lIGFib3ZlIGFuZCB0aGUgbnVtYmVyIG9uIHRoZSB0d28gbGluZXMgYmVsb3cgKHJvdW5kZWQgdG8gdGhlIG5lYXJlc3QgaW50ZWdlcikgYnkgYSBzY2FsZSBmYWN0b3IKAGFkZF9zZWdtZW50OiBlcnJvcgoAJS41ZyAlLjVnICUuNWcgJXNjb2xvcgoAMCAwIDAgZWRnZWNvbG9yCgAwLjggMC44IDAuOCBzZXRyZ2Jjb2xvcgoAMCAwIDEgc2V0cmdiY29sb3IKADEgMCAwIHNldHJnYmNvbG9yCgAwIDAgMCBzZXRyZ2Jjb2xvcgoAJWQgJWQgc2V0bGF5ZXIKAC8vKioqIGVuZF9sYXllcgoAVVRGLTggaW5wdXQgdXNlcyBub24tTGF0aW4xIGNoYXJhY3RlcnMgd2hpY2ggY2Fubm90IGJlIGhhbmRsZWQgYnkgdGhpcyBQb3N0U2NyaXB0IGRyaXZlcgoATGV0dGVyCgAvLyoqKiBiZWdpbl9jbHVzdGVyCgAvLyoqKiBlbmRfY2x1c3RlcgoAcmVtb3ZpbmcgZW1wdHkgY2x1c3RlcgoAQ2VudGVyCgBXYXJuaW5nOiBubyB2YWx1ZSBmb3Igd2lkdGggb2Ygbm9uLUFTQ0lJIGNoYXJhY3RlciAldS4gRmFsbGluZyBiYWNrIHRvIHdpZHRoIG9mIHNwYWNlIGNoYXJhY3RlcgoAYmFzZSByZWZlcmVyCgAlJVBhZ2VUcmFpbGVyCgAlJVRyYWlsZXIKAC8vKioqIGJlemllcgoAIiVzIiB3YXMgbm90IGZvdW5kIGFzIGEgZmlsZSBvciBhcyBhIHNoYXBlIGxpYnJhcnkgbWVtYmVyCgBzdG9wCgAgY3VydmV0bwoAbmV3cGF0aCAlZCAlZCBtb3ZldG8KACVkICVkIGxpbmV0bwoAIGxheW91dD1uZWF0bwoAbm9kZSAlcyBpbiBncmFwaCAlcyBoYXMgbm8gcG9zaXRpb24KACVzIG1heHBzaHQgYW5kIG1heHBzd2lkIGhhdmUgbm8gbWVhbmluZyBpbiBEV0IgMi4wLCBzZXQgcGFnZSBib3VuZGFyaWVzIGluIGdwaWMgYW5kIGluIDEwdGggRWRpdGlvbgoAJXMgYXJyb3doZWFkIGhhcyBubyBtZWFuaW5nIGluIERXQiAyLCBhcnJvd2hlYWQgPSA3IG1ha2VzIGZpbGxlZCBhcnJvd2hlYWRzIGluIGdwaWMgYW5kIGluIDEwdGggRWRpdGlvbgoAJXMgYXJyb3doZWFkIGlzIHVuZGVmaW5lZCBpbiBEV0IgMiwgaW5pdGlhbGx5IDEgaW4gZ3BpYywgMiBpbiAxMHRoIEVkaXRpb24KAG1ham9yaXphdGlvbgoALy8qKiogcG9seWdvbgoAb3ZlcmZsb3cgd2hlbiBjb21wdXRpbmcgZWRnZSB3ZWlnaHQgc3VtCgBzZmRwIG9ubHkgc3VwcG9ydHMgc3RhcnQ9cmFuZG9tCgBub2RlIHBvc2l0aW9ucyBhcmUgaWdub3JlZCB1bmxlc3Mgc3RhcnQ9cmFuZG9tCgBjbG9zZXBhdGggZmlsbAoAIGVsbGlwc2VfcGF0aCBmaWxsCgAlZiAlZiAlZiAlZiBjZWxsCgAgICVkICVkIGNlbGwKAGdyYXBoICVzIGlzIGRpc2Nvbm5lY3RlZC4gSGVuY2UsIHRoZSBjaXJjdWl0IG1vZGVsCgBncmFwaCBpcyBkaXNjb25uZWN0ZWQuIEhlbmNlLCB0aGUgY2lyY3VpdCBtb2RlbAoAZWRnZXMgaW4gZ3JhcGggJXMgaGF2ZSBubyBsZW4gYXR0cmlidXRlLiBIZW5jZSwgdGhlIG1kcyBtb2RlbAoAY2lyY3VpdCBtb2RlbCBub3QgeWV0IHN1cHBvcnRlZCBpbiBHbW9kZT1zZ2QsIHJldmVydGluZyB0byBzaG9ydHBhdGggbW9kZWwKAG1kcyBtb2RlbCBub3QgeWV0IHN1cHBvcnRlZCBpbiBHbW9kZT1zZ2QsIHJldmVydGluZyB0byBzaG9ydHBhdGggbW9kZWwKAG5vZGUgJyVzJywgZ3JhcGggJyVzJyBzaXplIHRvbyBzbWFsbCBmb3IgbGFiZWwKACVzIERXQiAyIGRvZXNuJ3QgdXNlIGZpbGwgYW5kIGRvZXNuJ3QgZGVmaW5lIGZpbGx2YWwKAFsge0NhdGFsb2d9IDw8IC9VUkkgPDwgL0Jhc2UgJXMgPj4gPj4KL1BVVCBwZGZtYXJrCgBbIC9Dcm9wQm94IFslZCAlZCAlZCAlZF0gL1BBR0VTIHBkZm1hcmsKACAgL0JvcmRlciBbIDAgMCAwIF0KICAvQWN0aW9uIDw8IC9TdWJ0eXBlIC9VUkkgL1VSSSAlcyA+PgogIC9TdWJ0eXBlIC9MaW5rCi9BTk4gcGRmbWFyawoAdHJvdWJsZSBpbiBpbml0X3JhbmsKAGxpbmV0aGljayA9IDA7IG9sZGxpbmV0aGljayA9IGxpbmV0aGljawoAIHNldGxpbmV3aWR0aAoAZ3NhdmUKJWQgJWQgJWQgJWQgYm94cHJpbSBjbGlwIG5ld3BhdGgKAGdzYXZlICVnICVnIHRyYW5zbGF0ZSBuZXdwYXRoCgAvLyoqKiBlbmRfZ3JhcGgKAGxheW91dCBhdHRyaWJ1dGUgaXMgaW52YWxpZCBleGNlcHQgb24gdGhlIHJvb3QgZ3JhcGgKAGluIGNoZWNrcGF0aCwgYm94ZXMgJWQgYW5kICVkIGRvbid0IHRvdWNoCgBtZXJnZV9vbmV3YXkgZ2xpdGNoCgAlcyBkb24ndCBjaGFuZ2UgYW55dGhpbmcgYmVsb3cgdGhpcyBsaW5lIGluIHRoaXMgZHJhd2luZwoATm9kZSBub3QgYWRqYWNlbnQgdG8gY2VsbCAtLSBBYm9ydGluZwoAaW5jb21wYXJhYmxlIHNlZ21lbnRzICEhIC0tIEFib3J0aW5nCgBBbHRlcm5hdGl2ZWx5LCBjb25zaWRlciBydW5uaW5nIG5lYXRvIHVzaW5nIC1HcGFjaz10cnVlIG9yIGRlY29tcG9zaW5nCgBsYWJlbF9zY2hlbWUgPSAlZCA+IDQgOiBpZ25vcmluZwoAZ3ZyZW5kZXJfc2V0X3N0eWxlOiB1bnN1cHBvcnRlZCBzdHlsZSAlcyAtIGlnbm9yaW5nCgBBcnJvdyB0eXBlICIlcyIgdW5rbm93biAtIGlnbm9yaW5nCgBmZHAgZG9lcyBub3Qgc3VwcG9ydCBzdGFydD1zZWxmIC0gaWdub3JpbmcKACVzIGF0dHJpYnV0ZSB2YWx1ZSBtdXN0IGJlIDEgb3IgMiAtIGlnbm9yaW5nCgBNb3JlIHRoYW4gMiBjb2xvcnMgc3BlY2lmaWVkIGZvciBhIGdyYWRpZW50IC0gaWdub3JpbmcgcmVtYWluaW5nCgBhcyByZXF1aXJlZCBieSB0aGUgLW4gZmxhZwoAYmJbJXNdICUuNWcgJS41ZyAlLjVnICUuNWcKAC9wYXRoYm94IHsKICAgIC9ZIGV4Y2ggJS41ZyBzdWIgZGVmCiAgICAvWCBleGNoICUuNWcgc3ViIGRlZgogICAgL3kgZXhjaCAlLjVnIHN1YiBkZWYKICAgIC94IGV4Y2ggJS41ZyBzdWIgZGVmCiAgICBuZXdwYXRoIHggeSBtb3ZldG8KICAgIFggeSBsaW5ldG8KICAgIFggWSBsaW5ldG8KICAgIHggWSBsaW5ldG8KICAgIGNsb3NlcGF0aCBzdHJva2UKIH0gZGVmCi9kYmdzdGFydCB7IGdzYXZlICUuNWcgJS41ZyB0cmFuc2xhdGUgfSBkZWYKL2Fycm93bGVuZ3RoIDEwIGRlZgovYXJyb3d3aWR0aCBhcnJvd2xlbmd0aCAyIGRpdiBkZWYKL2Fycm93aGVhZCB7CiAgICBnc2F2ZQogICAgcm90YXRlCiAgICBjdXJyZW50cG9pbnQKICAgIG5ld3BhdGgKICAgIG1vdmV0bwogICAgYXJyb3dsZW5ndGggYXJyb3d3aWR0aCAyIGRpdiBybGluZXRvCiAgICAwIGFycm93d2lkdGggbmVnIHJsaW5ldG8KICAgIGNsb3NlcGF0aCBmaWxsCiAgICBncmVzdG9yZQp9IGJpbmQgZGVmCi9tYWtlYXJyb3cgewogICAgY3VycmVudHBvaW50IGV4Y2ggcG9wIHN1YiBleGNoIGN1cnJlbnRwb2ludCBwb3Agc3ViIGF0YW4KICAgIGFycm93aGVhZAp9IGJpbmQgZGVmCi9wb2ludCB7ICAgIG5ld3BhdGggICAgMiAwIDM2MCBhcmMgZmlsbH0gZGVmL21ha2V2ZWMgewogICAgL1kgZXhjaCBkZWYKICAgIC9YIGV4Y2ggZGVmCiAgICAveSBleGNoIGRlZgogICAgL3ggZXhjaCBkZWYKICAgIG5ld3BhdGggeCB5IG1vdmV0bwogICAgWCBZIGxpbmV0byBzdHJva2UKICAgIFggWSBtb3ZldG8KICAgIHggeSBtYWtlYXJyb3cKfSBkZWYKAC9wYXRoYm94IHsKICAgIC9YIGV4Y2ggbmVnICUuNWcgc3ViIGRlZgogICAgL1kgZXhjaCAlLjVnIHN1YiBkZWYKICAgIC94IGV4Y2ggbmVnICUuNWcgc3ViIGRlZgogICAgL3kgZXhjaCAlLjVnIHN1YiBkZWYKICAgIG5ld3BhdGggeCB5IG1vdmV0bwogICAgWCB5IGxpbmV0bwogICAgWCBZIGxpbmV0bwogICAgeCBZIGxpbmV0bwogICAgY2xvc2VwYXRoIHN0cm9rZQp9IGRlZgoAJSFQUy1BZG9iZS0yLjAKL25vZGUgewogIC9ZIGV4Y2ggZGVmCiAgL1ggZXhjaCBkZWYKICAveSBleGNoIGRlZgogIC94IGV4Y2ggZGVmCiAgbmV3cGF0aAogIHggeSBtb3ZldG8KICB4IFkgbGluZXRvCiAgWCBZIGxpbmV0bwogIFggeSBsaW5ldG8KICBjbG9zZXBhdGggZmlsbAp9IGRlZgovY2VsbCB7CiAgL1kgZXhjaCBkZWYKICAvWCBleGNoIGRlZgogIC95IGV4Y2ggZGVmCiAgL3ggZXhjaCBkZWYKICBuZXdwYXRoCiAgeCB5IG1vdmV0bwogIHggWSBsaW5ldG8KICBYIFkgbGluZXRvCiAgWCB5IGxpbmV0bwogIGNsb3NlcGF0aCBzdHJva2UKfSBkZWYKAH0gYmluZCBkZWYKAC5QUyAlLjVmICUuNWYKAG92ZXJsYXA6ICVzIHZhbHVlICVkIHNjYWxpbmcgJS4wNGYKACAgYmVhdXRpZnlfbGVhdmVzICVkIG5vZGUgd2VpZ2h0cyAlZCByb3RhdGlvbiAlLjAzZgoAICByZXB1bHNpdmUgYW5kIGF0dHJhY3RpdmUgZXhwb25lbnRzOiAlLjAzZiAlLjAzZgoAICBLIDogJS4wM2YgQyA6ICUuMDNmCgAlcyAlLjNmCgAKaW50ZXJzZWN0aW9uIGF0ICUuM2YgJS4zZgoAICAgIHNjYWxlICUuM2YKAHRvcnVzIHsgJS4zZiwgJS4zZgoAICAgIDwlOS4zZiwgJTkuM2YsICU5LjNmPiwgJS4zZgoAIGluICVzIC0gc2V0dGluZyB0byAlLjAyZgoALm5yIFNGICUuMGYKc2NhbGV0aGlja25lc3MgPSAlLjBmCgAlcyBzYXZlIHBvaW50IHNpemUgYW5kIGZvbnQKLm5yIC5TIFxuKC5zCi5uciBERiBcbiguZgoAc2hvd3BhZ2UKJSUlJVRyYWlsZXIKJSUlJUJvdW5kaW5nQm94OiAlLmYgJS5mICUuZiAlLmYKAGFkZGluZyAlenUgaXRlbXMsIHRvdGFsIGFyZWEgPSAlZiwgdyA9ICVmLCBhcmVhL3c9JWYKAGdhcD0lZiwlZgoAICBhc3BlY3QgJWYKAGEgJWYgYiAlZiBjICVmIGQgJWYgciAlZgoAbW9kZWwgJWQgc21hcnRfaW5pdCAlZCBzdHJlc3N3dCAlZCBpdGVyYXRpb25zICVkIHRvbCAlZgoAU29sdmluZyBtb2RlbCAlZCBpdGVyYXRpb25zICVkIHRvbCAlZgoAJXMgY29vcmQgJS41ZyAlLjVnIGh0ICVmIHdpZHRoICVmCgByZWMgJWYgJWYgJWYgJWYKACVzIDogJWYgJWYgJWYgJWYKACVzIDogJWYgJWYKAG1heHBzaHQgPSAlZgptYXhwc3dpZCA9ICVmCgBtZHNNb2RlbDogZGVsdGEgPSAlZgoAIHIxICVmIHIyICVmCgBQYWNraW5nOiBjb21wdXRlIGdyaWQgc2l6ZQoAZ3NhdmUKACUlRW5kQ29tbWVudHMKc2F2ZQoAVW5yZWNvZ25pemVkIGNoYXJhY3RlciAnJWMnICglZCkgaW4gc2lkZXMgYXR0cmlidXRlCgBJbWFnZXMgdW5zdXBwb3J0ZWQgaW4gImJhY2tncm91bmQiIGF0dHJpYnV0ZQoAJXMgR05VIHBpYyB2cy4gMTB0aCBFZGl0aW9uIGRcKGUndGVudGUKAHJlc2V0ICVzIHNldCB0byBrbm93biBzdGF0ZQoAJWcgJWcgc2V0X3NjYWxlICVkIHJvdGF0ZSAlZyAlZyB0cmFuc2xhdGUKACVmICVmIHRyYW5zbGF0ZQoAJWQgJWQgdHJhbnNsYXRlCgAvLyoqKiBlbGxpcHNlCgBVbnJlY29nbml6ZWQgb3ZlcmxhcCB2YWx1ZSAiJXMiIC0gdXNpbmcgZmFsc2UKAHN1cnByaXNlCgBtZW1vcnkgYWxsb2NhdGlvbiBmYWlsdXJlCgAlczogdnNucHJpbnRmIGZhaWx1cmUKAGVuZHBhZ2UKc2hvd3BhZ2UKZ3Jlc3RvcmUKAGVuZApyZXN0b3JlCgBsYXlvdXQgd2FzIG5vdCBkb25lCgBMYXlvdXQgd2FzIG5vdCBkb25lCgAvLyoqKiBwb2x5bGluZQoAdHJ5aW5nIHRvIGRlbGV0ZSBhIG5vbi1saW5lCgAjIGVuZCBvZiBGSUcgZmlsZQoAU2luZ2xlCgByZW5kZXJlciBmb3IgJXMgaXMgdW5hdmFpbGFibGUKAGR5bmFtaWMgbG9hZGluZyBub3QgYXZhaWxhYmxlCgAlZCAlZCBsaW5ldG8gc3Ryb2tlCgBjbG9zZXBhdGggc3Ryb2tlCgAgZWxsaXBzZV9wYXRoIHN0cm9rZQoALy8qKiogYmVnaW5fZWRnZQoALy8qKiogZW5kX2VkZ2UKAGxvc3QgJXMgJXMgZWRnZQoAb3ZlcmZsb3cgd2hlbiBjYWxjdWxhdGluZyB2aXJ0dWFsIHdlaWdodCBvZiBlZGdlCgBhZGRfdHJlZV9lZGdlOiBtaXNzaW5nIHRyZWUgZWRnZQoAaW4gcm91dGVzcGxpbmVzLCBjYW5ub3QgZmluZCBOT1JNQUwgZWRnZQoAc2hvd3BhZ2UKACVkICVkICVkIGJlZ2lucGFnZQoALy8qKiogYmVnaW5fcGFnZQoALy8qKiogZW5kX3BhZ2UKAEZpbGVuYW1lICIlcyIgaXMgdW5zYWZlCgBsYWJlbDogYXJlYSB0b28gbGFyZ2UgZm9yIHJ0cmVlCgAvLyoqKiBlbmRfbm9kZQoAVXNpbmcgZGVmYXVsdCBjYWxjdWxhdGlvbiBmb3Igcm9vdCBub2RlCgBjb250YWluX25vZGVzIGNsdXN0ICVzIHJhbmsgJWQgbWlzc2luZyBub2RlCgAlZiAlZiAlZiAlZiBub2RlCgA8PCAvUGFnZVNpemUgWyVkICVkXSA+PiBzZXRwYWdlZGV2aWNlCgBpbiBjaGVja3BhdGgsIGJveCAlZCBoYXMgTEwgY29vcmQgPiBVUiBjb29yZAoAaW4gY2hlY2twYXRoLCBib3ggMCBoYXMgTEwgY29vcmQgPiBVUiBjb29yZAoAY2x1c3RlciBuYW1lZCAlcyBub3QgZm91bmQKAG5vZGUgJXMsIHBvcnQgJXMgdW5yZWNvZ25pemVkCgAlcyVzIHVuc3VwcG9ydGVkCgBjbHVzdGVyIGN5Y2xlICVzIC0tICVzIG5vdCBzdXBwb3J0ZWQKACVzIC0+ICVzOiBzcGxpbmUgc2l6ZSA+IDEgbm90IHN1cHBvcnRlZAoAbGF5b3V0IGFib3J0ZWQKAHBhZ2VkaXI9JXMgaWdub3JlZAoAVHdvIGNsdXN0ZXJzIG5hbWVkICVzIC0gdGhlIHNlY29uZCB3aWxsIGJlIGlnbm9yZWQKAElsbGVnYWwgYXR0cmlidXRlICVzIGluICVzIC0gaWdub3JlZAoAVW5rbm93biB2YWx1ZSAlcyBmb3IgYXR0cmlidXRlICJtb2RlbCIgaW4gZ3JhcGggJXMgLSBpZ25vcmVkCgBJbGxlZ2FsIHZhbHVlICVzIGZvciBhdHRyaWJ1dGUgIm1vZGUiIGluIGdyYXBoICVzIC0gaWdub3JlZAoAc3RhcnQ9MCBub3Qgc3VwcG9ydGVkIHdpdGggbW9kZT1zZWxmIC0gaWdub3JlZAoAT3ZlcmxhcCB2YWx1ZSAiJXMiIHVuc3VwcG9ydGVkIC0gaWdub3JlZAoAVW5rbm93biB2YWx1ZSAlcyBmb3IgUk9XUyAtIGlnbm9yZWQKAFVua25vd24gdmFsdWUgJXMgZm9yIENPTFVNTlMgLSBpZ25vcmVkCgBJbGxlZ2FsIHZhbHVlICVzIGZvciBWQUxJR04gLSBpZ25vcmVkCgBJbGxlZ2FsIHZhbHVlICVzIGZvciBBTElHTiAtIGlnbm9yZWQKAElsbGVnYWwgdmFsdWUgJXMgZm9yIEZJWEVEU0laRSAtIGlnbm9yZWQKAElsbGVnYWwgdmFsdWUgJS4qcyBmb3IgU1RZTEUgLSBpZ25vcmVkCgBJbGxlZ2FsIHZhbHVlICVzIGZvciBCQUxJR04gaW4gVEQgLSBpZ25vcmVkCgBJbGxlZ2FsIHZhbHVlICVzIGZvciBBTElHTiBpbiBURCAtIGlnbm9yZWQKAFJPV1NQQU4gdmFsdWUgY2Fubm90IGJlIDAgLSBpZ25vcmVkCgBDT0xTUEFOIHZhbHVlIGNhbm5vdCBiZSAwIC0gaWdub3JlZAoAbm9kZSAlcywgcG9ydCAlcywgdW5yZWNvZ25pemVkIGNvbXBhc3MgcG9pbnQgJyVzJyAtIGlnbm9yZWQKAFVua25vd24gInNwbGluZXMiIHZhbHVlOiAiJXMiIC0gaWdub3JlZAoAaW4gcm91dGVzcGxpbmVzLCBQc2hvcnRlc3RwYXRoIGZhaWxlZAoAaW4gcm91dGVzcGxpbmVzLCBQcm91dGVzcGxpbmUgZmFpbGVkCgAlLjVnICUuNWcgdHJhbnNsYXRlIG5ld3BhdGggdXNlcl9zaGFwZV8lZAoAbnNpemVzY2FsZT0lZixpdGVyYXRpb25zPSVkCgBjdHJsLT5vdmVybGFwPSVkCgAlcyAlZCBub2RlcyAlZCBlZGdlcyBtYXhpdGVyPSVkIGJhbGFuY2U9JWQKAC8vKioqIGJlZ2luX2xheWVyOiAlcywgJWQvJWQKAGRlZ2VuZXJhdGUgY29uY2VudHJhdGVkIHJhbmsgJXMsJWQKAGNpcmNsZSAlcyAlZCwlZCwlZAoAcmVjdCAlcyAlZCwlZCAlZCwlZAoAbWluY3Jvc3M6IHBhc3MgJWQgaXRlciAlZCB0cnlpbmcgJWQgY3VyX2Nyb3NzICVkIGJlc3RfY3Jvc3MgJWQKACAgbWF4IGxl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ZWZpbmUgc2V0ZmlsbHZhbCBZIGZpbGx2YWwgPSBZOwoJZGVmaW5lIGJvbGQgWSBZOwoJZGVmaW5lIGZpbGxlZCBZIGZpbGwgWTsKWgoAaWYgYm94cmFkID4gMS4wICYmIGRhc2h3aWQgPCAwLjA3NSB0aGVuIFgKCWZpbGx2YWwgPSAxOwoJZGVmaW5lIGZpbGwgWSBZOwoJZGVmaW5lIHNvbGlkIFkgWTsKCWRlZmluZSByZXNldCBZIHNjYWxlPTEuMCBZOwpYCgAgQUJPUlRJTkcKACUlRU9GCgAlcyByZXN0b3JlIHBvaW50IHNpemUgYW5kIGZvbnQKLnBzIFxuKC5TCi5mdCBcbihERgoAXQouUEUKAGludmFsaWRhdGVfcGF0aDogc2tpcHBlZCBvdmVyIExDQQoASW52YWxpZCAlZC1ieXRlIFVURjggZm91bmQgaW4gaW5wdXQgb2YgZ3JhcGggJXMgLSB0cmVhdGVkIGFzIExhdGluLTEuIFBlcmhhcHMgIi1HY2hhcnNldD1sYXRpbjEiIGlzIG5lZWRlZD8KAFVURjggY29kZXMgPiA0IGJ5dGVzIGFyZSBub3QgY3VycmVudGx5IHN1cHBvcnRlZCAoZ3JhcGggJXMpIC0gdHJlYXRlZCBhcyBMYXRpbi0xLiBQZXJoYXBzICItR2NoYXJzZXQ9bGF0aW4xIiBpcyBuZWVkZWQ/CgA8L3RleHQ+CgA8L2xpbmVhckdyYWRpZW50Pgo8L2RlZnM+CgA8L3JhZGlhbEdyYWRpZW50Pgo8L2RlZnM+CgA8L21hcD4KADwvc3ZnPgoAPC9hPgo8L2c+CgAgICAgcm90YXRlICAgPCU5LjNmLCAlOS4zZiwgJTkuM2Y+CgAgICAgc2NhbGUgICAgPCU5LjNmLCAlOS4zZiwgJTkuM2Y+CgA8L3RpdGxlPgoAIiB0eXBlPSJ0ZXh0L2NzcyI/PgoAPD94bWwgdmVyc2lvbj0iMS4wIiBlbmNvZGluZz0iVVRGLTgiIHN0YW5kYWxvbmU9Im5vIj8+CgAgICAgdHJhbnNsYXRlPCU5LjNmLCAlOS4zZiwgJWQuMDAwPgoAOyIvPgoAIFBhZ2VzOiAlZCAtLT4KACkKIC0tPgoAIC0+CgA8IURPQ1RZUEUgc3ZnIFBVQkxJQyAiLS8vVzNDLy9EVEQgU1ZHIDEuMS8vRU4iCiAiaHR0cDovL3d3dy53My5vcmcvR3JhcGhpY3MvU1ZHLzEuMS9EVEQvc3ZnMTEuZHRkIj4KACkiPgoAcl8lZCIgY3g9IjUwJSUiIGN5PSI1MCUlIiByPSI3NSUlIiBmeD0iJS4wZiUlIiBmeT0iJS4wZiUlIj4KACIgPgoAI2RlY2xhcmUgJXMgPSAlczsKAAklcwlzb3JyeSwgdGhlIGdyb2ZmIGZvbGtzIGNoYW5nZWQgZ3BpYzsgc2VuZCBhbnkgY29tcGxhaW50IHRvIHRoZW07CgAJJXMJaW5zdGFsbCBhIG1vcmUgcmVjZW50IHZlcnNpb24gb2YgZ3BpYyBvciBzd2l0Y2ggdG8gRFdCIG9yIDEwdGggRWRpdGlvbiBwaWM7CgBdOwoAaWYgZmlsbHZhbCA+IDAuNCB0aGVuIFgKCWRlZmluZSBzZXRmaWxsdmFsIFkgZmlsbHZhbCA9IDEgLSBZOwoJZGVmaW5lIGJvbGQgWSB0aGlja25lc3MgMiBZOwoAI3ZlcnNpb24gMy42OwoAZWxsaXBzZSBhdHRyczAgJXN3aWQgJS41ZiBodCAlLjVmIGF0ICglLjVmLCUuNWYpOwoAIiBhdCAoJS41ZiwlLjVmKTsKACUlQmVnaW5Eb2N1bWVudDoKACVkIGJveGVzOgoAcGFjayBpbmZvOgoAc3ByaW5nX2VsZWN0cmljYWxfY29udHJvbDoKAFVuc3VwcG9ydGVkIGNoYXJzZXQgIiVzIiAtIGFzc3VtaW5nIHV0Zi04CgAgICAgICBhbWJpZW50SW50ZW5zaXR5IDAuMzMKACNGSUcgMy4yCgAtMgoAJXMgbm9uLWZhdGFsIHJ1bi10aW1lIHBpYyB2ZXJzaW9uIGRldGVybWluYXRpb24sIHZlcnNpb24gMgoAJXMgZmlsbHZhbCBpcyAwLjMgaW4gMTB0aCBFZGl0aW9uIChmaWxsIDAgbWVhbnMgYmxhY2spLCAwLjUgaW4gZ3BpYyAoZmlsbCAwIG1lYW5zIHdoaXRlKSwgdW5kZWZpbmVkIGluIERXQiAyCgAlcyByZXNldCB3b3JrcyBpbiBncGljIGFuZCAxMHRoIGVkaXRpb24sIGJ1dCBpc24ndCBkZWZpbmVkIGluIERXQiAyCgBzZXR1cExhdGluMQoAXDAwMQoAJXMgICAgICAgIHRvbGVyYW5jZSAwLjAxCgAgICAgdG9sZXJhbmNlIDAuMQoAJSVQYWdlczogMQoAICAgICAgICBkaWZmdXNlQ29sb3IgMSAxIDEKADEwMC4wMAoAIEVQU0YtMy4wCgAlcyBib3hyYWQgaXMgbm93IDAuMCBpbiBncGljLCBlbHNlIGl0IHJlbWFpbnMgMi4wCgBzcGhlcmUgezwlOS4zZiwgJTkuM2YsICU5LjNmPiwgMS4wCgBXYXJuaW5nOiBubyB2YWx1ZSBmb3Igd2lkdGggb2YgQVNDSUkgY2hhcmFjdGVyICV1LiBGYWxsaW5nIGJhY2sgdG8gMAoAaW5zdGFsbF9pbl9yYW5rLCBsaW5lICVkOiAlcyAlcyByYW5rICVkIGkgPSAlZCBhbiA9IDAKAGNvbmNlbnRyYXRlPXRydWUgbWF5IG5vdCB3b3JrIGNvcnJlY3RseS4KAE5vIGxpYnogc3VwcG9ydC4KAHR3b3BpOiB1c2Ugb2Ygd2VpZ2h0PTAgY3JlYXRlcyBkaXNjb25uZWN0ZWQgY29tcG9uZW50LgoAdGhlIGdyYXBoIGludG8gY29ubmVjdGVkIGNvbXBvbmVudHMuCgBPcnRob2dvbmFsIGVkZ2VzIGRvIG5vdCBjdXJyZW50bHkgaGFuZGxlIGVkZ2UgbGFiZWxzLiBUcnkgdXNpbmcgeGxhYmVscy4KAGd2UmVuZGVySm9icyAlczogJS4yZiBzZWNzLgoAbWluY3Jvc3MgJXM6ICVkIGNyb3NzaW5ncywgJS4yZiBzZWNzLgoAJXMgaXMgbm90IGEga25vd24gY29sb3IuCgBpcyBpbmFwcHJvcHJpYXRlLiBSZXZlcnRpbmcgdG8gdGhlIHNob3J0ZXN0IHBhdGggbW9kZWwuCgBpcyB1bmRlZmluZWQuIFJldmVydGluZyB0byB0aGUgc2hvcnRlc3QgcGF0aCBtb2RlbC4KAFVuYWJsZSB0byByZWNsYWltIGJveCBzcGFjZSBpbiBzcGxpbmUgcm91dGluZyBmb3IgZWRnZSAiJXMiIC0+ICIlcyIuIFNvbWV0aGluZyBpcyBwcm9iYWJseSBzZXJpb3VzbHkgd3JvbmcuCgBFcnJvciBkdXJpbmcgY29udmVyc2lvbiB0byAiVVRGLTgiLiBRdWl0aW5nLgoAb3JkZXJpbmcgJyVzJyBub3QgcmVjb2duaXplZC4KAGdyYWRpZW50IHBlbiBjb2xvcnMgbm90IHlldCBzdXBwb3J0ZWQuCgAgIGluaXRDTWFqVlBTQyBkb25lOiAlZCBnbG9iYWwgY29uc3RyYWludHMgZ2VuZXJhdGVkLgoAVGhlIGNoYXJhY3RlciAnJWMnIGFwcGVhcnMgaW4gYm90aCB0aGUgbGF5ZXJzZXAgYW5kIGxheWVybGlzdHNlcCBhdHRyaWJ1dGVzIC0gbGF5ZXJsaXN0c2VwIGlnbm9yZWQuCgB0aGUgYXNwZWN0IGF0dHJpYnV0ZSBoYXMgYmVlbiBkaXNhYmxlZCBkdWUgdG8gaW1wbGVtZW50YXRpb24gZmxhd3MgLSBhdHRyaWJ1dGUgaWdub3JlZC4KAFRoZSBsYXllcnNlbGVjdCBhdHRyaWJ1dGUgIiVzIiBkb2VzIG5vdCBtYXRjaCBhbnkgbGF5ZXIgc3BlY2lmZWQgYnkgdGhlIGxheWVycyBhdHRyaWJ1dGUgLSBpZ25vcmVkLgoAJXp1IG91dCBvZiAlenUgbGFiZWxzIHBvc2l0aW9uZWQuCgAlenUgb3V0IG9mICV6dSBleHRlcmlvciBsYWJlbHMgcG9zaXRpb25lZC4KACAgZ2VuZXJhdGUgZWRnZSBjb25zdHJhaW50cy4uLgoAR2VuZXJhdGluZyBOb24tb3ZlcmxhcCBDb25zdHJhaW50cy4uLgoAR2VuZXJhdGluZyBFZGdlIENvbnN0cmFpbnRzLi4uCgBHZW5lcmF0aW5nIERpRy1Db0xhIEVkZ2UgQ29uc3RyYWludHMuLi4KAFJlbW92aW5nIG92ZXJsYXBzIGFzIHBvc3Rwcm9jZXNzLi4uCgAuLi4gJXMgLi4uCgBFZGdlIGxlbmd0aCAlZiBsYXJnZXIgdGhhbiBtYXhpbXVtICVkIGFsbG93ZWQuCkNoZWNrIGZvciBvdmVyd2lkZSBub2RlKHMpLgoAb3JkZXJpbmcgJyVzJyBub3QgcmVjb2duaXplZCBmb3Igbm9kZSAnJXMnLgoAcG9seWdvbiB7ICV6dSwKAHNwaGVyZV9zd2VlcCB7CiAgICAlcwogICAgJXp1LAoAImRpcmVjdGVkIjogJXMsCgAid2lkdGgiOiAlLjAzZiwKACJz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c2FibGVkIGJlY2F1c2UgdGhlIGVudmlyb25tZW50IGNvbnRhaW5zIFNFUlZFUl9OQU1FPSIlcyIKAENvdWxkIG5vdCBwYXJzZSB4ZG90ICIlcyIKAE5vIGxvYWRpbWFnZSBwbHVnaW4gZm9yICIlcyIKACBbJXp1XSAoJS4wMmYsJS4wMmYpICglLjAyZiwlLjAyZikgJXAgIiVzIgoAZm9udG5hbWU6IHVuYWJsZSB0byByZXNvbHZlICIlcyIKAER1cGxpY2F0ZSBjbHVzdGVyIG5hbWUgIiVzIgoAdW5yZWNvZ25pemVkIGFwaSBuYW1lICIlcyIKAGltYWdlIGNyZWF0ZSBwaG90byAicGhvdG9fJXMiIC1maWxlICIlcyIKAE5vIG9yIGltcHJvcGVyIHNoYXBlZmlsZT0iJXMiIGZvciBub2RlICIlcyIKAE5vIG9yIGltcHJvcGVyIGltYWdlPSIlcyIgZm9yIG5vZGUgIiVzIgoAbm9kZSAiJXMiIGlzIGNvbnRhaW5lZCBpbiB0d28gbm9uLWNvbXBhcmFibGUgY2x1c3RlcnMgIiVzIiBhbmQgIiVzIgoARXJyb3I6IG5vZGUgIiVzIiBiZWxvbmdzIHRvIHR3byBub24tbmVzdGVkIGNsdXN0ZXJzICIlcyIgYW5kICIlcyIKACAgIiVzIgoAI2luY2x1ZGUgImNvbG9ycy5pbmMiCiNpbmNsdWRlICJ0ZXh0dXJlcy5pbmMiCiNpbmNsdWRlICJzaGFwZXMuaW5jIgoAc2NhbGUgYnkgJWcsJWcgCgBjb21wcmVzcyAlZyAKAFVua25vd24gSFRNTCBlbGVtZW50IDwlcz4gb24gbGluZSAlZCAKACVzIGluIGxpbmUgJWQgCgBMYXlvdXQgd2FzIG5vdCBkb25lLiAgTWlzc2luZyBsYXlvdXQgcGx1Z2lucz8gCgCJUE5HDQoaCgAlJSFQUy1BZG9iZS0yLjAKJSUlJUJvdW5kaW5nQm94OiAoYXRlbmQpCi9wb2ludCB7CiAgL1kgZXhjaCBkZWYKICAvWCBleGNoIGRlZgogIG5ld3BhdGgKICBYIFkgMyAwIDM2MCBhcmMgZmlsbAp9IGRlZgovY2VsbCB7CiAgL1kgZXhjaCBkZWYKICAvWCBleGNoIGRlZgogIC95IGV4Y2ggZGVm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AAAAAAAAADMzMzMzM/M/7AAAAO0AAAAGAAAAAAAAAJqZmZmZmek/7gAAAO8AAAAHAEGe8wQLC/A/8AAAAPEAAAAIAEG28wQLMOA/8gAAAPMAAABsbnJzb2xpZAAAc2V0bGluZXdpZHRoADEAAAAAG3MAAEnAAAB8iABB8PMEC+gBCACu/9EACgCu/67/CwCu/67/rv+u/67/rv+u/67/BQDRAK7/0QDRANEA0QDRANEA0QDRAK7/+/+u/w4A7P+u/67/rv+u/9EA0QDRANEA0QANACUADABCABAAUAATAG0AewAUAJgADwCmAMMArv+u/67/rv+u/67/rv+u/67/rv+u/67/rv+u/67/rv+u/67/rv+u/67/rv+u/67/FwCu/3cArv8HAC4Arv8mAK7/FwARACMArv8NAK7/rv+u/67/OgCu/67/NQCu/67/rv8oAK7/BwCu/zsARQCu/0gArv+u/67/rv+u/wBB4fUEC8EGAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAQIDBAUGBwgJCgsMDQ4PEBESExQVFhcYGRobHB0eHyAhIiMkJSYnKAAAAAAAAAAAAgICAgICEAxZAQAfUAgDBxITFFcWFwgLaQwfCgUMDikRKw8tEC8wIDIGNDUbHB0eCwwhIiMkJSYnKAwYGRcEChscGiAqCiEiIyQlJicoDAoOUwosWDFYWFhYWFgMGxwPLlgzISIjJCUmJygbHP9T//8hIiMkJSYnKAz//wX///8JFP//////DBsc/xAVFiEiIyQlJicoGxz/////ISIjJCUmJygM/xITFBEWF////////wwbHP///xIhIiMkJSYnKBsc/////yEiIyQlJicoDP///////xP///////8MGxz/////ISIjJCUmJygbHP////8hIiMkJSYnKBITFBUWFxgZ////////////IyQlJicbEhMUFhciNmgBHzhWISACGxsbXhsbNzlwNtLCTwQ8IkciPyJEIiJYImUiIgUGX2A5BAcICQoLDA0OBGZnXWptBQZvWDtxBwgJCgsMDQ4Ecjxbcz5hRhsSExQWFwQFBj9BYkkHCAkKCwwNDgUGAFwAAAcICQoLDA0OBAAATwAAAFNCAAAAAAAEBQYARFRVBwgJCgsMDQ4FBgAAAAAHCAkKCwwNDgQAKiwuRzEzAAAAAAAABAUGAAAASgcICQoLDA0OBQYAAAAABwgJCgsMDQ4EAAAAAAAATAAAAAAAAAQFBgAAAAAHCAkKCwwNDgUGAAAAAAcICQoLDA0OKSstLzAyNDUAQav8BAsuKSstMDIABC8AJCMAEhQWGhweIBgABQcvLy8ALy8AAAkIKAAAASICBgAAAAAACABB5vwECz4lAyYTCikVCyoXDi0ZERsMKx0NLB8PIRAAMwAwAC9DADEALwA1LidCMkEAOjgAPDRFADYAQAAAPwBENzs5PQBBsf0EC0UCAwMBAQIBAQEDAwMDAwMDAwEBAQEBAQEBAQEBAQEBAQECAQECAAYBAwMDAwMBAAECAwAEAQIDAAQABAAEAAMCAQIBAgEAQYH+BAtFKSoqKissLC0tLS0tLS0tLS0uLzAxMjM0NTY3ODk6Ozw9Pj4/P0FAQkJCQkJCQ0NERERGRUdHR0lISkhLSExITU1OTk9PAEHQ/gQLjgGu/67//P/oAPb///8aAAAAJwABADIArv+u/wIAJAADAC8Arv+u/67/rv+u//7/lACu/wkAGwCu/7z/rv+u/6//rv+u/67/rv+u/67/rv8AAP8DDxARIzokPSVAFUMmRSdIGEsZTRooHE4dHlBRUllabGtuY2RXaQAIAAAACAAAAAAAAAA5AQAAOgEAADgBAEH2/wQLCfC/AAAAAAAAAQBBiIAFCw1pbnZpcwAAZmlsbGVkAEGggAULkwKdGQAAf08AAOU0AAAvCwAACwAAAAwAAAANAAAADgAAAA8AAAAQAAAAEQAAABIAAAAVAAAAFgAAABcAAAAYAAAAGQAAABoAAAAbAAAAHAAAAB8AAAAgAAAAIQAAACIAAAAjAAAAJAAAACUAAAAmAAAAKQAAACoAAAArAAAALAAAAC0AAAAuAAAALwAAADAAAAAzAAAANAAAADUAAAA2AAAANwAAADgAAAA5AAAAOgAAAD0AAAA+AAAAPwAAAEAAAABBAAAAQgAAAEMAAABEAAAARwAAAEgAAABJAAAASgAAAEsAAABMAAAATQAAAE4AAABRAAAAUgAAAFMAAABUAAAAVQAAAFYAAABXAAAAWAAAAHyRAgBBvoIFC4UIoED/////////////////////////////////////////////////////////////////////////////////////AAKqAkQDAAQABKoGOQZxAaoCqgIABIMEAAKqAgACOQIABAAEAAQABAAEAAQABAAEAAQABDkCOQKDBIMEgwSNA14HxwVWBVYFxwXjBHMExwXHBaoCHQPHBeMEHQfHBccFcwTHBVYFcwTjBMcFxwWNB8cFxwXjBKoCOQKqAsEDAASqAo0DAASNAwAEjQOqAgAEAAQ5AjkCAAQ5AjkGAAQABAAEAASqAh0DOQIABAAExwUABAAEjQPXA5oB1wNUBP///////////////////////////////////////////////////////////////////////////////////////wACqgJxBAAEAAQACKoGOQKqAqoCAASPBAACqgIAAjkCAAQABAAEAAQABAAEAAQABAAEAASqAqoCjwSPBI8EAARxB8cFVgXHBccFVgXjBDkGOQYdAwAEOQZWBY0HxwU5BuMEOQbHBXMEVgXHBccFAAjHBccFVgWqAjkCqgKmBAAEqgIABHMEjQNzBI0DqgIABHMEOQKqAnMEOQKqBnMEAARzBHMEjQMdA6oCcwQABMcFAAQABI0DJwPDAScDKQT///////////////////////////////////////////////////////////////////////////////////////8AAqoCXAMABAAEqgY5BrYBqgKqAgAEZgUAAqoCAAI5AgAEAAQABAAEAAQABAAEAAQABAAEqgKqAmYFZgVmBQAEXAfjBOMEVgXHBeME4wTHBccFqgKNA1YFcwSqBlYFxwXjBMcF4wQABHMExwXjBKoG4wRzBHMEHQM5Ah0DYAMABKoCAAQABI0DAASNAzkCAAQABDkCOQKNAzkCxwUABAAEAAQABB0DHQM5AgAEjQNWBY0DjQMdAzMDMwIzA1QE////////////////////////////////////////////////////////////////////////////////////////AAIdA3EEAAQABKoGOQY5AqoCqgIABI8EAAKqAgACOQIABAAEAAQABAAEAAQABAAEAAQABKoCqgKPBI8EjwQABKgGVgVWBVYFxwVWBVYFxwU5Bh0DAARWBeMEHQfHBccF4wTHBVYFcwTjBMcFVgUdB1YF4wTjBKoCOQKqAo8EAASqAgAEAASNAwAEjQOqAgAEcwQ5AjkCAAQ5AjkGcwQABAAEAAQdAx0DOQJzBI0DVgUABI0DHQPJAsMByQKPBP//pJECAEHOigULhQigQP////////////////////////////////////////////////////////////////////////////////////85AjkC1wJzBHMEHQdWBYcBqgKqAh0DrAQ5AqoCOQI5AnMEcwRzBHMEcwRzBHMEcwRzBHMEOQI5AqwErASsBHMEHwhWBVYFxwXHBVYF4wQ5BscFOQIABFYFcwSqBscFOQZWBTkGxwVWBeMExwVWBY0HVgVWBeMEOQI5AjkCwQNzBKoCcwRzBAAEcwRzBDkCcwRzBMcBxwEABMcBqgZzBHMEcwRzBKoCAAQ5AnMEAATHBQAEAAQABKwCFAKsAqwE////////////////////////////////////////////////////////////////////////////////////////OQKqAssDcwRzBB0HxwXnAaoCqgIdA6wEOQKqAjkCOQJzBHMEcwRzBHMEcwRzBHMEcwRzBKoCqgKsBKwErATjBM0HxwXHBccFxwVWBeMEOQbHBTkCcwTHBeMEqgbHBTkGVgU5BscFVgXjBMcFVgWNB1YFVgXjBKoCOQKqAqwEcwSqAnME4wRzBOMEcwSqAuME4wQ5AjkCcwQ5Ah0H4wTjBOME4wQdA3MEqgLjBHMEOQZzBHMEAAQdAz0CHQOsBP///////////////////////////////////////////////////////////////////////////////////////zkCOQLXAnMEcwQdB1YFhwGqAqoCHQOsBDkCqgI5AjkCcwRzBHMEcwRzBHMEcwRzBHMEcwQ5AjkCrASsBKwEcwQfCFYFVgXHBccFVgXjBDkGxwU5AgAEVgVzBKoGxwU5BlYFOQbHBVYF4wTHBVYFjQdWBVYF4wQ5AjkCOQLBA3MEqgJzBHMEAARzBHMEOQJzBHMExwHHAQAExwGqBnMEcwRzBHMEqgIABDkCcwQABMcFAAQABAAErAIUAqwCrAT///////////////////////////////////////////////////////////////////////////////////////85AqoCywNzBHMEHQfHBecBqgKqAh0DrAQ5AqoCOQI5AnMEcwRzBHMEcwRzBHMEcwRzBHMEqgKqAqwErASsBOMEzQfHBccFxwXHBVYF4wQ5BscFOQJzBMcF4wSqBscFOQZWBTkGxwVWBeMExwVWBY0HVgVWBeMEqgI5AqoCrARzBKoCcwTjBHME4wRzBKoC4wTjBDkCOQJzBDkCHQfjBOME4wTjBB0DcwSqAuMEcwQ5BnMEcwQABB0DPQIdA6wE///YkQIAQd6SBQuFCKBA/////////////////////////////////////////////////////////////////////////////////////80EzQTNBM0EzQTNBM0EzQTNBM0EzQTNBM0EzQTNBM0EzQTNBM0EzQTNBM0EzQTNBM0EzQTNBM0EzQTNBM0EzQTNBM0EzQTNBM0EzQTNBM0EzQTNBM0EzQTNBM0EzQTNBM0EzQTNBM0EzQTNBM0EzQTNBM0EzQTNBM0EzQTNBM0EzQTNBM0EzQTNBM0EzQTNBM0EzQTNBM0EzQTNBM0EzQTNBM0EzQTNBM0EzQTNBM0EzQTNBM0EzQTNBM0EzQT////////////////////////////////////////////////////////////////////////////////////////NBM0EzQTNBM0EzQTNBM0EzQTNBM0EzQTNBM0EzQTNBM0EzQTNBM0EzQTNBM0EzQTNBM0EzQTNBM0EzQTNBM0EzQTNBM0EzQTNBM0EzQTNBM0EzQTNBM0EzQTNBM0EzQTNBM0EzQTNBM0EzQTNBM0EzQTNBM0EzQTNBM0EzQTNBM0EzQTNBM0EzQTNBM0EzQTNBM0EzQTNBM0EzQTNBM0EzQTNBM0EzQTNBM0EzQTNBM0EzQTNBM0EzQTNBM0E////////////////////////////////////////////////////////////////////////////////////////zQTNBM0EzQTNBM0EzQTNBM0EzQTNBM0EzQTNBM0EzQTNBM0EzQTNBM0EzQTNBM0EzQTNBM0EzQTNBM0EzQTNBM0EzQTNBM0EzQTNBM0EzQTNBM0EzQTNBM0EzQTNBM0EzQTNBM0EzQTNBM0EzQTNBM0EzQTNBM0EzQTNBM0EzQTNBM0EzQTNBM0EzQTNBM0EzQTNBM0EzQTNBM0EzQTNBM0EzQTNBM0EzQTNBM0EzQTNBM0EzQTNBM0EzQTNBP///////////////////////////////////////////////////////////////////////////////////////80EzQTNBM0EzQTNBM0EzQTNBM0EzQTNBM0EzQTNBM0EzQTNBM0EzQTNBM0EzQTNBM0EzQTNBM0EzQTNBM0EzQTNBM0EzQTNBM0EzQTNBM0EzQTNBM0EzQTNBM0EzQTNBM0EzQTNBM0EzQTNBM0EzQTNBM0EzQTNBM0EzQTNBM0EzQTNBM0EzQTNBM0EzQTNBM0EzQTNBM0EzQTNBM0EzQTNBM0EzQTNBM0EzQTNBM0EzQTNBM0EzQTNBM0EzQT//wCSAgBB7ZoFC4YIQI9AAAD///////////////////////////////8CAf///////////////////////////////////////////////wIB5ACIAVgCWAKiA7UC3QA9AT0BwgFYAuQAqAHkABsBWAJYAlgCWAJYAlgCWAJYAlgCWALkAOQAWAJYAlgCuwGyA9kCpAKhAuYCRwIkAtYC+QIBAUQBcQIfAlcD5AL/AnkC/wKdAmcCWgLYArECTQSKAlQCTQI7ARsBOwFYAvQB9AESAkcCzwFHAhQCTQFKAjgC6ADsAPQBKAFYAzgCLAJHAkcCZgHhAV4BMQIDAkkDDQICAs8BYAEJAWABWAL//wAA////////////////////////////////DwH///////////////////////////////////////////////8PAfgAwAFYAlgCsQPWAvMAZgFmAcUBWAL4ALIB+AA5AVgCWAJYAlgCWAJYAlgCWAJYAlgC+AD4AFgCWAJYAssBtgPoArACqAL6AlUCMgLgAgUDGgFiAZkCMgJkA+wCEQOMAhEDrgJ3Am0C4gLJAlkEoAJqAl0CYgE5AWIBWAL0AfQBIwJYAtgBWAIeAmwBXAJJAv8AAwEYAj8BbQNJAkACWAJYAogB6AGAAUMCDwJVAyICDgLaAYcBIAGHAVgC//8AAP///////////////////////////////wIB////////////////////////////////////////////////AgHkAIgBWAJYAqIDtQLdAD0BPQHCAVgC5ACoAeQAGwFYAlgCWAJYAlgCWAJYAlgCWAJYAuQA5ABYAlgCWAK7AbID2QKkAqEC5gJHAiQC1gL5AgEBRAFxAh8CWAPjAv8CeQL/Ap0CZwJaAtgCsAJNBIoCVAJNAjsBGwE7AVgC9AH0ARICRwLPAUcCFAJNAUoCOALoAOwA9AEoAVgDOAIsAkcCRwJmAeEBXgExAgMCSQMNAgICzwFgAQkBYAFYAv//AAD///////////////////////////////8PAf///////////////////////////////////////////////w8B+ADAAVgCWAKxA9YC8wBmAWYBxQFYAvgAsgH4ADkBWAJYAlgCWAJYAlgCWAJYAlgCWAL4APgAWAJYAlgCywG2A+gCsAKoAvoCVQIyAuACBQMaAWIBmAIyAmUD6wIRA4wCEQOuAncCbQLiAskCWQSgAmoCXQJiATkBYgFYAvQB9AEjAlgC2AFYAh4CbAFcAkkC/wADARgCPwFtA0kCQAJYAlgCiAHoAYABQwIPAlUDIgIOAtoBhwEgAYcBWAL//wiSAgBB/qIFC4UIoED/////////////////////////////////////////////////////////////////////////////////////iwI1A64DtAYXBZoHPQYzAh8DHwMABLQGiwLjAosCsgIXBRcFFwUXBRcFFwUXBRcFFwUXBbICsgK0BrQGtAY/BAAIeQV9BZYFKQYOBZoEMwYEBlwCXAI/BXUE5wb8BUwG0wRMBo8FFAXjBNsFeQXpB3sF4wR7BR8DsgIfA7QGAAQABOcEFAVmBBQF7ATRAhQFEgU5AjkCogQ5AssHEgXlBBQFFAVKAysEIwMSBbwEiwa8BLwEMwQXBbICFwW0Bv///////////////////////////////////////////////////////////////////////////////////////8kCpgMrBLQGkQUECPoGcwKoA6gDLwS0BgoDUgMKA+wCkQWRBZEFkQWRBZEFkQWRBZEFkQUzAzMDtAa0BrQGpAQACDEGGQbfBaQGdwV3BZEGsgb6AvoCMwYZBfYHsgbNBt0FzQYpBsMFdQV/BjEG0wgrBssFzQWoA+wCqAO0BgAEAARmBboFvgS6BW0FewO6BbIFvgK+AlIFvgJWCLIFfwW6BboF8gPDBNMDsgU3BWQHKQU3BagEsgXsArIFtAb///////////////////////////////////////////////////////////////////////////////////////+LAjUDrgO0BhcFmgc9BjMCHwMfAwAEtAaLAuMCiwKyAhcFFwUXBRcFFwUXBRcFFwUXBRcFsgKyArQGtAa0Bj8EAAh5BX0FlgUpBg4FmgQzBgQGXAJcAj8FdQTnBvwFTAbTBEwGjwUUBeME2wV5BekHewXjBHsFHwOyAh8DtAYABAAE5wQUBWYEFAXsBNECFAUSBTkCOQKiBDkCywcSBeUEFAUUBUoDKwQjAxIFvASLBrwEvAQzBBcFsgIXBbQG////////////////////////////////////////////////////////////////////////////////////////yQKmAysEkQWRBQQI+gZzAqgDqAMvBLQGCgNSAwoD7AKRBZEFkQWRBZEFkQWRBZEFkQWRBTMDMwO0BrQGtAakBAAIMQYZBt8FpAZ3BXcFkQayBvoC+gIzBhkF9geyBs0G3QXNBikGwwV1BX8GMQbTCCsGywXNBagD7AKoA7QGAAQABGYFugW+BLoFbQV7A7oFsgW+Ar4CUgW+AlYIsgV/BboFugXyA8ME0wOyBTcFZAcpBTcFqASyBewCsgW0Bv//EJICAEGOqwULhQigQGYE////////////////////////////////AAD///////////////////////////////////////////////9mBGYEZgRmBGYEZgRmBGYEZgRmBGYEZgRmBGYEZgRmBGYEZgRmBGYEZgRmBGYEZgRmBGYEZgRmBGYEZgRmBGYEZgRmBGYEZgRmBGYEZgRmBGYEZgRmBGYEZgRmBGYEZgRmBGYEZgRmBGYEZgRmBGYEZgRmBGYEZgRmBGYEZgRmBGYEZgRmBGYEZgRmBGYEZgRmBGYEZgRmBGYEZgRmBGYEZgRmBGYEZgRmBGYEZgRmBGYEZgRmBGYEZgRmBGYE//9mBP///////////////////////////////wAA////////////////////////////////////////////////ZgRmBGYEZgRmBGYEZgRmBGYEZgRmBGYEZgRmBGYEZgRmBGYEZgRmBGYEZgRmBGYEZgRmBGYEZgRmBGYEZgRmBGYEZgRmBGYEZgRmBGYEZgRmBGYEZgRmBGYEZgRmBGYEZgRmBGYEZgRmBGYEZgRmBGYEZgRmBGYEZgRmBGYEZgRmBGYEZgRmBGYEZgRmBGYEZgRmBGYEZgRmBGYEZgRmBGYEZgRmBGYEZgRmBGYEZgRmBGYEZgRmBGYEZgRmBP//ZgT///////////////////////////////8AAP///////////////////////////////////////////////2YEZgRmBGYEZgRmBGYEZgRmBGYEZgRmBGYEZgRmBGYEZgRmBGYEZgRmBGYEZgRmBGYEZgRmBGYEZgRmBGYEZgRmBGYEZgRmBGYEZgRmBGYEZgRmBGYEZgRmBGYEZgRmBGYEZgRmBGYEZgRmBGYEZgRmBGYEZgRmBGYEZgRmBGYEZgRmBGYEZgRmBGYEZgRmBGYEZgRmBGYEZgRmBGYEZgRmBGYEZgRmBGYEZgRmBGYEZgRmBGYEZgRmBGYEZgT///////////////////////////////////////////////////////////////////////////////////////9mBGYEZgRmBGYEZgRmBGYEZgRmBGYEZgRmBGYEZgRmBGYEZgRmBGYEZgRmBGYEZgRmBGYEZgRmBGYEZgRmBGYEZgRmBGYEZgRmBGYEZgRmBGYEZgRmBGYEZgRmBGYEZgRmBGYEZgRmBGYEZgRmBGYEZgRmBGYEZgRmBGYEZgRmBGYEZgRmBGYEZgRmBGYEZgRmBGYEZgRmBGYEZgRmBGYEZgRmBGYEZgRmBGYEZgRmBGYEZgRmBGYEZgRmBGYE//8ckgIAQZ6zBQuFCKBA/////////////////////////////////////////////////////////////////////////////////////2kC8AKZAjIEMgTNBKYFRwHwAvAC8AIyBPAC8ALwAjIEMgQyBDIEMgQyBDIEMgQyBDIEMgTwAvACMgQyBDIE8AIqBrgEhwTJBOgESQQzBGkFPAU6AtADmwQNBK0FGwVkBXYEaAWoBNkDpQQwBbME0QZ0BJAEZwTwAtgC8AIyBDIEMgQ0BHUE9gN1BF0E9QIEBF8ESALvAgkEXAKkBl8ESwR1BHUEHAM9AywDXwTrA/QFAgTyA8wD8AIyBPACMgT///////////////////////////////////////////////////////////////////////////////////////9pAvAC7wKwBLAEeQWmBdYB8ALwAnUDsATwAvAC8AIfA7AEsASwBLAEsASwBLAEsASwBLAE8ALwArAEsASwBIEDKgYRBcME5QQkBY0EqwRfBXgFOgJDBPAEbAT2BVcFoAWyBKwF4wQXBOUEbAX5BBIHzgToBHsENwPYAjcDsASwBLAEQwSnBBgEpQSZBPUCBAS+BGMC7wJiBFwC4Aa5BIcEqQSsBGsDcgMsA7oEOARFBmsERQQ6BHgDsAR4A7AE////////////////////////////////////////////////////////////////////////////////////////aQLwApkCMgTZA80EpgVHAfAC8ALwAjIE8ALwAvACMgQyBDIEMgQyBDIEMgQyBDIEMgQyBPAC8AIyBDIEMgTwAioG4wSHBMkE6ARJBDMEaQU8BToC0AObBA0EFwYbBWQFWQRkBagE2QOlBDAFswTRBnQEkARnBPAC2ALwAjIEMgQyBDQEdQSuA3UETAQ2AwQEdQR0Au8CCQSQAqQGXwRLBHUEdQRVAz0DXAN0BOsD9AUCBPIDzAPwAjIE8AIyBP///////////////////////////////////////////////////////////////////////////////////////2kC8AIgA7AEsATcBaYFaQLwAvACdQOwBPAC8ALwAi0DsASwBLAEsASwBLAEsASwBLAEsATwAvACsASwBLAELQMqBukEuATnBA8FvwSvBGkFbQU6Av0DMwU6BEoGSAWeBasEKAb9BAMEewVLBXcFaQdBBXgF5ATiA9ID4gOwBLAEsAS+BL8E8QO/BGoESANIBH8EnQIaA1EEjwKkBn8EjwTKBMoEkwOsA4EDdQRrBDAGmwSDBEME4gOwBOIDsAT//yiSAgBBrrsFC4UIoED/////////////////////////////////////////////////////////////////////////////////////0AImA6wDjAYWBZwI0AUmAqIDogMWBYwG6QKiA+kCogMWBRYFFgUWBRYFFgUWBRYFFgUWBaIDogOMBowGjAZdBAAIeAV8BZYFKgYPBZkENAYDBl4DowOLBXQEvgb8BUwG0wRMBpAFeAXuBNsFeAXpB3sF7AR7BaIDogOiA4wGFgUWBc4E/AQrBPwExATQAvwEEAUyAsECvAQyAsgHEAXbBPwE/ARqAysEJwMQBbwEjAa8BLwENAQUBaIDFAWMBv///////////////////////////////////////////////////////////////////////////////////////7wCOAOzBPAGsAUtCuYGqAJZBFkEsAXwBuQC1wPkAoQFsAWwBbAFsAWwBbAFsAWwBbAFsAU4AzgD8AbwBvAG7wS2BzYGGAbKBaQGdwU0BX0GswZeBHEEKwYZBZUHxgbNBt0FzQZCBq8FdAV/BhwGBwkcBuUFiQVZBIQFWQTwBrAFsAVYBZgFtQSYBVAFYQOYBbMFvAI5A14FvAJ3CLMFfgWYBZgF+gO/BKUDswUzBdYHWgU1BcYEsAVZBLAF8Ab////////////////////////////////////////////////////////////////////////////////////////QAiYDrAOMBhYFnAjQBSYCogOiAxYFjAbpAqID6QKiAxYFFgUWBRYFFgUWBRYFFgUWBRYFogOiA4wGjAaMBl0EAAh2BXwFlgUgBg8FmQQ0BgMGXgOjA4sFdAS+BvwFTAbTBEwGkAV4Be4E2wV2BewHewXsBHsFogOiA6IDjAYWBRYFzgT8BCsE/ATEBNAC+QQQBTICwQKyBDICyQcQBdsE/AT8BGoDKwQnAxAFugSMBrwEugQ0BBQFogMUBYwG////////////////////////////////////////////////////////////////////////////////////////vAI4A7ME8AawBS0K5gaoAlkEWQSwBfAG5ALXA+QChAWwBbAFsAWwBbAFsAWwBbAFsAWwBTgDOAPwBvAG8AbvBLYHNgYYBsoFpAZ3BTQFfQazBl4EcQQrBhkFlQfGBs0G3QXNBkIGrwV0BX8GHAYHCRwG5QWJBVkEhAVZBPAGsAWwBVgFmAW1BJgFUAVhA5gFswW8AjkDXgW8AncIswV8BZgFmAX6A78EpQOzBTEF1gdaBTUFxgSwBVkEsAXwBv//MJICAEG+wwULhQigQP////////////////////////////////////////////////////////////////////////////////////8UAiMCNQMrBZMElgbXBcUBXgJeAmoEkwT2AZMCIQLwApMEkwSTBJMEkwSTBJMEkwSTBJMEIQIhApMEkwSTBG8DMQcQBS8FDAXVBXMEIQTTBecFOwIjAukEJwQ5BwgGOwbRBDsG8gRkBG0E0wXDBGgHngR7BJEEogLwAqICVgSWA54EcwTnBM8D5wR9BLYCYgTpBAYCBgIzBAYCcQfpBNUE5wTnBEQD0QPTAukEAgQ5BjEECAS+AwgDaAQIA5ME////////////////////////////////////////////////////////////////////////////////////////FAJKAscDKwWRBDUHAAYhArYCtgJcBJEEUgKTAkgCTgORBJEEkQSRBJEEkQSRBJEEkQSRBEgCUgKRBJEEkQTRAy0HhQVgBRkF7AV7BGQEywUfBqYCpgJQBYUEiweBBl4GBgVeBkgFaASiBAwGMwW8B1YF/gSiBKYCTgOmAkIESgPbBNUEEAUdBBAFugQZA4UEQgVxAnEC9gRxAtsHQgX0BBAFEAWiA/oDeQNCBY0E2QagBI0E5wMnA2gEJwORBP///////////////////////////////////////////////////////////////////////////////////////xQCEgIXAysFaARYBlwFvAFIAkgCagRoBOwBfwIGAs0CaARoBGgEaARoBGgEaARoBGgEaAQGAgYCaARoBGgEagPHBnEEyQSuBFQFFwTHA2oFbQUvAiMCdQTLA7IGngXDBYcEwwWNBAQE/ANoBWIE0QYnBAYEPwRKAs0CSgIjBCcDbwSFBJ4EmgOeBPIDgQICBJ4ECAIIAucDCAL6Bp4EfQSeBJ4EKwNtA5gCngSyA7wF0wOyA40DywJoBMsCaAT///////////////////////////////////////////////////////////////////////////////////////8UAkoCoAMrBWgE2QaqBQoCtgK2AlwEaAQ5ApMCSAJeA2gEaARoBGgEaARoBGgEaARoBGgESAJIAmgEaARoBKwD2QYGBfYE5QRqBVYEPwSFBZoFkwKmAucEJQQKBwoG1wWkBNcF3wQ9BD8EhwW4BCcH2QSDBEoEpgJeA6YCOQQzA28EwQTDBN0DwQR1BPwCVATVBGACYAKLBGACPQfVBK4EwwTBBF4DyQNIA9UEGQROBj8EJwSkA9cCaATXAmgE//84kgIAQc7LBQuFCKBA/////////////////////////////////////////////////////////////////////////////////////+4BpgJLAyUF4QSKBq8FuQEAAwADxwMlBSgC/gIoAsAD6QRwA3gEagSFBDoEhwQFBMUEhwSAAoACJQUlBSUF1ANuB14FOwUjBf4FOgXLBM0FhQYeAyQEjgXUBGsHIwb0BeEE9AWdBX0E8wQNBlUFzgevBewE0AQAA8ADAAMlBSUFAAQIBHsEogOYBN4DmgITBKgEWAJWAkkESgIMB7oEUASSBHoERwN1A8MCmgT5A+YFCgTwA40DcQMAA3EDJQX///////////////////////////////////////////////////////////////////////////////////////8IAgMDFASgBSAFCQdlBicCkwOTA9sDoAWgAggDoALGA5wF6wMDBf8EMgXLBC8FbwRpBS8F8ALwAqAFoAWgBWMEvAcRBg8GuQWsBsUFXwV1Bk4HkQPDBIkGfAUwCLcGjwacBY8GYQYxBXkFqwYZBgMJeAbbBYQFkwPGA5MDoAWgBQAExAQqBUAETgWTBCUDnQRwBdQCxQIOBcECIAiFBRYFQwUwBSkEGgQuA2oFiQToBrQEfwQ0BAAEGgMABKAF////////////////////////////////////////////////////////////////////////////////////////7gGmAksDJQXhBIoGrwW5AQADAAPHAyUFKAL+AigCwAPpBHADeARqBIUEOgSHBPkDxQSHBBIDEgMlBSUFJQXUA24HXgU7BSMF/gU6BcsEzQWFBh4DJASOBdQEawcjBtgF4QTYBZ0FfQTzBA0GVQXOB68F7ATQBAADwAMAAyUFJQUABJUEbgShA5oExgOhApUEgARhAlQCOQRIAgkHuARMBKAEcQSxA3MDxwKaBE4ElAYCBHoEjQNxAwADcQMlBf///////////////////////////////////////////////////////////////////////////////////////wgCAwMUBKAFIAUJB2UGJwKTA5MD2wOgBaACCAOgAsYDnAXrAwMF/wQyBcsELwWIBGkFLwXwAvACoAWgBaAFYwS8BxEGEwa5BawGxQVfBXUGTgebA8MEiQZ8BUQIowaPBqYFjwZhBjkFeQWrBhkGAwlrBtsFhAWTA8YDkwOgBaAFAARIBTEFSQRNBXUEDAMyBWcF7QLrAiEF1gIECIUFFgVNBTMFRQQjBFYDewXmBHgHqwRbBSMEAAQaAwAEoAX//0CSAgBB3tMFC6QIoED/////////////////////////////////////////////////////////////////////////////////////zwGbAjUD/AMOBLgFdQXEAW0CbQL8A/wD/wFzAgUCFwMOBA4EDgQOBA4EDgQOBA4EDgQOBCQCJAL8A/wD/AO1AycHoQRaBEQE7AToA60DDAX8BAQCjQIoBF0D1wYqBUwFIgRiBVgErQPmAyIFigQeBycE5gO/A3QCFwN0AvwD/ANUAtUDNARiAzQE+wNxAsQDNATWAeoBowPWAWQGNAQ4BDQENATKAiEDrgI0BJ0DuAV3A58DKQOEAq8DhAL8A///AAD///////////////////////////////8AAP///////////////////////////////////////////////88BmwKCA/wDDgTVBaMF3gF+An4C/AP8AxACcwIjAnADDgQOBA4EDgQOBA4EDgQOBA4EDgQ1AjUC/AP8A/wDtQMwB9kEfAQ8BAsF5wOsAxkFDAUiAqYCYARiA/4GRQVpBUIEfQWBBMgD9gM5BbsEQAdoBCgE0wOZAnADmQL8A/wDZwLzA0sEWQNLBAcEiALLA0sE9wELAtcD9wGCBksETQRLBEsE2AIxA8YCSwTJA/YFrQPKAy4DwALNA8AC/AP////////////////////////////////////////////////////////////////////////////////////////PAZsCNQP8Aw4EuAV1BcQBbQJtAvwD/AP/AXMCBQIaAw4EDgQOBA4EDgQOBA4EDgQOBA4EJAIkAvwD/AP8A7UDJwehBFoELgTsBOgDrQMMBfwEBAKNAigEXQPXBigFPAUiBFAFWASeA+YDIgWKBB8HJwTmA78DdAITA3QC/AP8A1QCHQQdBFQDHQTSA3ECHQQdBNYB6gGjA9YBVAYdBBsEHQQdBL4CHQOuAh0EkQO4BXcDlAMpA4QCrwOEAvwD////////////////////////////////////////////////////////////////////////////////////////zwGbAoID/AMOBNUFowXeAX4CfgL8A/wDEAJzAiMCeQMOBA4EDgQOBA4EDgQOBA4EDgQOBDUCNQL8A/wD/AO1AzAH2QR8BCYECwXnA6wDGQUMBSICpgJgBGID/gZABVkFQgRrBYEEuQP2AzkFuwRBB2gEKATTA5kCZgOZAvwD/ANnAjkEOQRLAzkE7gOIAjkEOAT3AQsC1wP3AW4GOAQ4BDkEOQTRAicDxgI4BMED9gWtA8MDLgPAAs0DwAL8A///RWgAACVkAABJYwAAPGQAADpjAABoAQAAaQEAAGoBAABqAQBBkNwFC9EFEe7uEwgD7v7u7u4B7u7uAe7uCf7uEhUX7hIB7u7u7goN7u7u7u7u7u7uAe7uFggBARkOGO7uGxga7u4d7u7u7gEV++7u7u4QHu7u7gAAAAAAAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICFhECAgICAgICAgICAgICEhACEwICAgICAgICAgICAgICAgICAgICAgICAgICAgICFAIVAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIOAg8CAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAQIDBAUGBwgJCgsMDQAAAAsDBAUPBwMMDQYMDQ4MDRoVAAEAAwcOBg8IDA0SEwkqEBEQFi8wDTIREy4yFBIUEkETLBNCQCpCGf//LAAAAAAiDA0OIw8JEBEKEBHMEBEtRfwBBvYPB/YkAhARLzAoNklKJjE7PD02Kjk6Pj8v2EBEMDclR0M1SCsAADgAAAAAAAMJAAAAAQ4CCwwIIyQlMzg6AA0QEhsWHBInLyIXMB45BgcyBQ8RFBgpABMpAAAAAAA0FSgdHgAhJjEfLjsZLAAbACAaKis3ADU2LQAAAAAAAgIBAAMDAQABAAEBAQACAQEAAgIDAQEAAAUAAQMBAwUDAQEBAQIAAQAEAgACAwEAAwIBAAEBAAEBAQMAAAAAABcYGBgZGhsbHBwdHR4eHx8gICEhIiMjJSYkJCcnKCgoKSkqKiorKywsLS4uLzAxMzI0NDQ1NTU2Njc3AAAAAO7u/O7u7u7u7h8g7vnv7u7uDO7u7gYP7u7y7u7u7u717gBB8OEFCyH/AwgEIQULEhMnFBUWKTJBFxgZGiwzNEJGGxwdLh5LHyAAQaHiBQu2AwEBAQEBAQEBAgMBAQIBAQEBAQEBAQEBAQEBAQEBAQECAQQFAQEBAQEBBgEBBwgJCgoKCgoKCgoKCgEBCwEMAQ0ODxAREhMUFRYTExMTFxgZExobHB0TExMTEwEeAQETAR8gISIjEyQlJhMTExMnKCkTKissLRMTExMTAQEBAQETExMTExMTExMTExMTExMTExMTExMTExMTExMTExMTExMTExMTExMTExMTExMTExMTExMTExMTExMTEy4TExMvExMTExMTExMTExMTExMTExMTExMTExMTExMTExMTExMTExMTExMTExMTExMTExMwExMTExMTExMTExMTExMTEwAAAAAAAAQABAAcABwAIQAhACQAIgAKAAIAFgAJACIAIgAiABUAHQABABQAFAAUABQAFAAUABQACAAEAAUAHAAbABcAHAAhACAAHwAeAAkAEwAAABUAEgAVAAMABwAVABUAFAAUABQAFAAUABQAFAAUAAgABAAFAAUABgAcABoAGAAZACEABwAVABQAFAAUABQAFAAUAAsAFAANABQADAAUABQAFAAOABQAFAAUABAAFAAPABQAEQBB4uUFC5UEAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAwAEAAcAAwAEAAUABQAGAAYACAAHAAcAEQAWABIAEQASAAgACAAPAA8AFwAPABgADwAZABoAGgAeABYANAAeAAUAMgAGACIAIgAzABcAGAA1ABkAGgAaACoANgAqADQANwAyAEUAOwA8ADMAOwA8AEYANQBHAEgATAA2ACIASQBKADcARQBOAFAAYgBRAFIAVABGAEcAVQBIAEwAVgBJAEoAWABaAE4ARABQAFEAUgBUADgALwAsAFUAKQBWABsAEABYAFoAXQBdAF0AXQBdAF0AXQBeAF4AXgBeAF4AXgBeAF8AXwBfAF8AXwBfAF8AYAAJAGAAYABgAGAAYABhAGEAYwACAGMAYwBjAGMAYwBkAAAAZAAAAGQAZABkAGUAAABlAGUAZQBlAGUAZgAAAAAAZgBmAGYAZgBnAAAAZwBnAGcAZwBoAAAAaABoAGgAaABoAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAQYTqBQvNAa4ALgAvADMANQAwADcAqgDbANsA2wDbAAAAPQCHADcANwDbANsAAAAoADUALgAyAC8AYgAAAAAARwAAANsA2wBRAAAA2wDbANsAAADbAIQAVQDbAIIA2wAAAIEA2wAAAD4AQgBBAEgARABSAFsAAAAAAF4AXwDbAAAA2wDbANsAAAAAAHsASQBXAFIAWgBaAF0AAABfAAAAXwAAAGUAXQBfAAAAXQBuAGoAAABpAAAAbgAAANsAkwCaAKEAqACrAHAAsQC4AL8AxgDNANMAQeLrBQvPAVwAAQBdAF0AXgBeAF8AXwBcAFwAXABcAFwAYABcAFwAXABhAFwAXABiAGIAYgBiAGIAYgBiAGMAZABlAGYAXABcAFwAZwBcAFwAXABgAFwAXABhAFwAYQBcAGgAYQBcAGIAYgBiAGIAYgBiAGIAYgBjAGQAZQBlAFwAZgBcAFwAXABnAGgAYQBiAGIAYgBiAGIAYgBiAGIAYgBiAGIAYgBiAGIAYgBiAGIAYgBiAGIAYgBiAGIAAABcAFwAXABcAFwAXABcAFwAXABcAFwAXABBwe0FCzABAQIDAQQBBQEGBwcBBgYGBgYGBgYGBgYGBgYGBgMGBgYGBgYGBgYGBgYGBgYGBgYAQYLuBQuVBAoACwAMAA0ADgAKAA8AEAARABIAEwAKABQAFQAVABUAFgAXABUAGAAVABUAGQAVABUAFQAaABUAFQAKABUAFQAVABYAFwAYABUAFQAZABUAFQAVABoAFQAVABUAFQAbAAwADAAkAB4AHgAgACEAIAAhACQAJQAmAC0AMgAvAC4AKgAlACYAKAApADMAKgA0ACsANQA2ADcAPAAyAEcAPQAiAEUAIgA/AEAARgAzADQASAA1ADYANwAvAEkAKgBHAEoARQBMAFwAPABGAFwAPQBNAEgATgBPAFIASQBBAFAAUQBKAEwAUwBUADEAVQBWAFcATQBOAFgATwBSAFkAUABRAFoAWwBTAEQAVABVAFYAVwBLAEQALABYACwAWQA4ACwAWgBbAB0AHQAdAB0AHQAdAB0AHwAfAB8AHwAfAB8AHwAjACMAIwAjACMAIwAjACcAXAAnACcAJwAnACcAMAAwADkAHAA5ADkAOQA5ADkAOgBcADoAXAA6ADoAOgA7AFwAOwA7ADsAOwA7AD4AXABcAD4APgA+AD4AQgBcAEIAQgBCAEIAQwBcAEMAQwBDAEMAQwAJAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAEGg8gULVFBOAAA3TQAA5BAAAIw8AAA7PAAAQzwAAAAAAAAj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HBwcFhwcHBwcHBwcHBwWHBocHBYcHBwcHBYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWHBYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYcFhYWFhYWFhYAQZCCBgt5//////////////////////////////////////////8AAAAAAAAABP7//4f+//8HAAAAAAAAAAD//3////9///////////N//v3//////3///////////w/g/////zH8////AAAAAAAAAP//////////////AQD4AwBBoIMGC0FA1///+/////9/f1T9/w8A/t////////////7f/////wMA////////nxn////PPwMAAAAAAAD+////fwL+////fwBB6oMGC7MB////BwcAAAAAAP7//wf+BwAAAAD+//////////98/38vAGAAAADg////////IwAAAP8DAAAA4J/5///9xQMAAACwAwADAOCH+f///W0DAAAAXgAAHADgr/v///3tIwAAAAABAAAA4J/5///9zSMAAACwAwAAAODHPdYYx78DAAAAAAAAAADg3/3///3vAwAAAAADAAAA4N/9///97wMAAABAAwAAAODf/f///f8DAAAAAAMAQbCFBgsZ/v////9/DQA/AAAAAAAAAJYl8P6ubA0gHwBB2IUGCwb//v///wMAQYSGBgty/////z8A/////38A7doHAAAAAFABUDGCq2IsAAAAAEAAyYD1BwAAAAAIAQL/////////////////////////D///////////////A///Pz//////Pz//qv///z/////////fX9wfzw//H9wfAAAAAEBMAEGAhwYLAQcAQZCHBgsmgAAAAP4DAAD+////////////HwD+/////////////wfg/////x8AQdCHBgsV//////////////////////////8/AEHwhwYLFf//////////////////////////DwBBlYgGC8kCYP8H/v//h/7//wcAAAAAAACAAP//f////3//////AAAAAAAAAP//////////////AQD4AwADAAAAAAD//////////z8AAAADAAAAwNf///v/////f39U/f8PAP7f///////////+3/////97AP///////58Z////zz8DAAAAAAAA/v///38C/v///38A/v/7//+7FgD///8HBwAAAAAA/v//B///BwD/A////////////3z/f+///z3/A+7////////z/z8e/8//AADun/n///3F0585gLDP/wMA5If5///9bdOHOQBewP8fAO6v+////e3zvzsAAMH/AADun/n///3N8485wLDD/wAA7Mc91hjHv8PHPYAAgP8AAO7f/f///e/D3z1gAMP/AADs3/3///3vw989YEDD/wAA7N/9///9/8PPPYAAw/8AQfCKBgs4/v////9//wf/f/8DAAAAAJYl8P6ubP87Xz//AwAAAAAAAAAD/wOgwv/+////A/7/3w+//v8//gIAQcqLBgtr/x8CAAAAoAAAAP7/PgD+////////////H2b+/////////////3faAQAA2wEAANwBAADdAQAA3gEAAN8BAADgAQAA4QEAAOIBAADjAQAA5AEAAOUBAADmAQAA5wEAAOoBAADrAQAAAQAAAAEAQcGMBgsFFQoAABUAQdiMBgvVARUQDBMcHgMNHyAhIiMbGhEZGRkZGRkZGRkZFhICDgsPHBgYGBgYGBYWFhYWFhYWFhYWFhYWFhYWFhYWFBwEHBYcGBgYGBgYFhYWFhYWFhYWFhYWFhYWFhYWFhYcJBwcHAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQYGBgYGBgYGBgYGBgYGBgYHBwcHBwBBto4GC2sBAewBAADtAQAA7gEAAO8BAADwAQAA7gEAAPEBAADyAQAA8wEAANoBAADbAQAA3AEAAN0BAADeAQAA3wEAAOABAADhAQAA4gEAAOMBAADkAQAA5QEAAOYBAADnAQAA6gEAAOsBAAABAAAAAQBBrY8GCwUVCgAAFQBBxI8GC9UBFRAMExweAw0fICEiIxsaERkZGRkZGRkZGRkXEgIOCw8cGBgYGBgYFhYWFhYWFhYWFhYWFhYWFhYWFhYUHAQcFhwYGBgYGBgWFhYWFhYWFhYWFhYWFhYWFhYWFhwkHBwcCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAUFBQUFBQUF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AFZhbHVlIHRvbyBsYXJnZSBmb3IgZGF0YSB0eXBlAE5vIHNwYWNlIGxlZnQgb24gZGV2aWNlAE91dCBvZiBtZW1vcnkAUmVzb3VyY2UgYnVzeQBJbnRlcnJ1cHRlZCBzeXN0ZW0gY2FsbABSZXNvdXJjZSB0ZW1wb3JhcmlseSB1bmF2YWlsYWJsZQBJbnZhbGlkIHNlZWsAQ3Jvc3MtZGV2aWNlIGxpbmsAUmVhZC1vbmx5IGZpbGUgc3lzdGVtAERpcmVjdG9yeSBub3QgZW1wdHkAQ29ubmVjdGlvbiByZXNldCBieSBwZWVyAE9wZXJhdGlvbiB0aW1lZCBvdXQAQ29ubmVjdGlvbiByZWZ1c2VkAEhvc3QgaXMgZG93bgBIb3N0IGlzIHVucmVhY2hhYmxlAEFkZHJlc3MgaW4gdXNlAEJyb2tlbiBwaXBlAEkvTyBlcnJvcgBObyBzdWNoIGRldmljZSBvciBhZGRyZXNzAEJsb2NrIGRldmljZSByZXF1aXJlZABObyBzdWNoIGRldmljZQBOb3QgYSBkaXJlY3RvcnkASXMgYSBkaXJlY3RvcnkAVGV4dCBmaWxlIGJ1c3kARXhlYyBmb3JtYXQgZXJyb3IASW52YWxpZCBhcmd1bWVudABBcmd1bWVudCBsaXN0IHRvbyBsb25nAFN5bWJvbGljIGxpbmsgbG9vcABGaWxlbmFtZSB0b28gbG9uZwBUb28gbWFueSBvcGVuIGZpbGVzIGluIHN5c3RlbQBObyBmaWxlIGRlc2NyaXB0b3JzIGF2YWlsYWJsZQBCYWQgZmlsZSBkZXNjcmlwdG9yAE5vIGNoaWxkIHByb2Nlc3MAQmFkIGFkZHJlc3MARmlsZSB0b28gbGFyZ2UAVG9vIG1hbnkgbGlua3MATm8gbG9ja3MgYXZhaWxhYmxlAFJlc291cmNlIGRlYWRsb2NrIHdvdWxkIG9jY3VyAFN0YXRlIG5vdCByZWNvdmVyYWJsZQBQcmV2aW91cyBvd25lciBkaWVkAE9wZXJhdGlvbiBjYW5jZWxlZABGdW5jdGlvbiBub3QgaW1wbGVtZW50ZWQATm8gbWVzc2FnZSBvZiBkZXNpcmVkIHR5cGUASWRlbnRpZmllciByZW1vdmVkAERldmljZSBub3QgYSBzdHJlYW0ATm8gZGF0YSBhdmFpbGFibGUARGV2aWNlIHRpbWVvdXQAT3V0IG9mIHN0cmVhbXMgcmVzb3VyY2VzAExpbmsgaGFzIGJlZW4gc2V2ZXJlZABQcm90b2NvbCBlcnJvcgBCYWQgbWVzc2FnZQBGaWxlIGRlc2NyaXB0b3IgaW4gYmFkIHN0YXRlAE5vdCBhIHNvY2tldABEZXN0aW5hdGlvbiBhZGRyZXNzIHJlcXVpcmVkAE1lc3NhZ2UgdG9vIGxhcmdlAFByb3RvY29sIHdyb25nIHR5cGUgZm9yIHNvY2tldABQcm90b2NvbCBub3QgYXZhaWxhYmxlAFByb3RvY29sIG5vdCBzdXBwb3J0ZWQAU29ja2V0IHR5cGUgbm90IHN1cHBvcnRlZABOb3Qgc3VwcG9ydGVkAFByb3RvY29sIGZhbWlseSBub3Qgc3VwcG9ydGVkAEFkZHJlc3MgZmFtaWx5IG5vdCBzdXBwb3J0ZWQgYnkgcHJvdG9jb2wAQWRkcmVzcyBub3QgYXZhaWxhYmxlAE5ldHdvcmsgaXMgZG93bgBOZXR3b3JrIHVucmVhY2hhYmxlAENvbm5lY3Rpb24gcmVzZXQgYnkgbmV0d29yawBDb25uZWN0aW9uIGFib3J0ZWQATm8gYnVmZmVyIHNwYWNlIGF2YWlsYWJsZQBTb2NrZXQgaXMgY29ubmVjdGVkAFNvY2tldCBub3QgY29ubmVjdGVkAENhbm5vdCBzZW5kIGFmdGVyIHNvY2tldCBzaHV0ZG93bgBPcGVyYXRpb24gYWxyZWFkeSBpbiBwcm9ncmVzcwBPcGVyYXRpb24gaW4gcHJvZ3Jlc3MAU3RhbGUgZmlsZSBoYW5kbGUAUmVtb3RlIEkvTyBlcnJvcgBRdW90YSBleGNlZWRlZABObyBtZWRpdW0gZm91bmQAV3JvbmcgbWVkaXVtIHR5cGUATXVsdGlob3AgYXR0ZW1wdGVkAFJlcXVpcmVkIGtleSBub3QgYXZhaWxhYmxlAEtleSBoYXMgZXhwaXJlZABLZXkgaGFzIGJlZW4gcmV2b2tlZABLZXkgd2FzIHJlamVjdGVkIGJ5IHNlcnZpY2UAAAAAAKUCWwDwAbUFjAUlAYMGHQOUBP8AxwMxAwsGvAGPAX8DygQrANoGrwBCA04D3AEOBBUAoQYNAZQCCwI4BmQCvAL/Al0D5wQLB88CywXvBdsF4QIeBkUChQCCAmwDbwTxAPMDGAXZANoDTAZUAnsBnQO9BAAAUQAVArsAswNtAP8BhQQvBfkEOABlAUYBnwC3BqgBcwJTAQBB6OwGCwwhBAAAAAAAAAAALwIAQYjtBgsGNQRHBFYEAEGe7QYLAqAEAEGy7QYLIkYFYAVuBWEGAADPAQAAAAAAAAAAyQbpBvkGHgc5B0kHXgcAQeDtBguRAdF0ngBXnb0qgHBSD///PicKAAAAZAAAAOgDAAAQJwAAoIYBAEBCDwCAlpgAAOH1BRgAAAA1AAAAcQAAAGv////O+///kr///wAAAAAAAAAAGQAKABkZGQAAAAAFAAAAAAAACQAAAAALAAAAAAAAAAAZABEKGRkZAwoHAAEACQsYAAAJBgsAAAsABhkAAAAZGRkAQYHvBgshDgAAAAAAAAAAGQAKDRkZGQANAAACAAkOAAAACQAOAAAOAEG77wYLAQwAQcfvBgsVEwAAAAATAAAAAAkMAAAAAAAMAAAMAEH17wYLARAAQYHwBgsVDwAAAAQPAAAAAAkQAAAAAAAQAAAQAEGv8AYLARIAQbvwBgseEQAAAAARAAAAAAkSAAAAAAASAAASAAAaAAAAGhoaAEHy8AYLDhoAAAAaGhoAAAAAAAAJAEGj8QYLARQAQa/xBgsVFwAAAAAXAAAAAAkUAAAAAAAUAAAUAEHd8QYLARYAQenxBgsnFQAAAAAVAAAAAAkWAAAAAAAWAAAWAAAwMTIzNDU2Nzg5QUJDREVGAEG08gYLAh4CAEHc8gYLCP//////////AEGg8wYL+wj/////////////////////////////////////////////////////////////////AAECAwQFBgcICf////////8KCwwNDg8QERITFBUWFxgZGhscHR4fICEiI////////woLDA0ODxAREhMUFRYXGBkaGxwdHh8gISIj/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////wABAgQHAwYFAAAAAAAAAAIAAMADAADABAAAwAUAAMAGAADABwAAwAgAAMAJAADACgAAwAsAAMAMAADADQAAwA4AAMAPAADAEAAAwBEAAMASAADAEwAAwBQAAMAVAADAFgAAwBcAAMAYAADAGQAAwBoAAMAbAADAHAAAwB0AAMAeAADAHwAAwAAAALMBAADDAgAAwwMAAMMEAADDBQAAwwYAAMMHAADDCAAAwwkAAMMKAADDCwAAwwwAAMMNAADTDgAAww8AAMMAAAy7AQAMwwIADMMDAAzDBAAM2wAAAACYvAEAIAIAACECAAAiAgAAIwIAACQCAAAlAgAAJgIAACcCAAAoAgAAKQIAACoCAAArAgAALAIAAC0CAAAEAAAAAAAAANC8AQAuAgAALwIAAPz////8////0LwBADACAAAxAgAAyLsBANy7AQAAAAAALL0BADICAAAzAgAAIgIAACMCAAA0AgAANQIAACYCAAAnAgAAKAIAADYCAAAqAgAANwIAACwCAAA4AgAATlN0M19fMjliYXNpY19pb3NJY05TXzExY2hhcl90cmFpdHNJY0VFRUUAAACY5gEALLwBABC+AQBOU3QzX18yMTViYXNpY19zdHJlYW1idWZJY05TXzExY2hhcl90cmFpdHNJY0VFRUUAAAAAcOYBAGS8AQBOU3QzX18yMTNiYXNpY19vc3RyZWFtSWNOU18xMWNoYXJfdHJhaXRzSWNFRUVFAAD05gEAoLwBAAAAAAABAAAAWLwBAAP0//9OU3QzX18yMTViYXNpY19zdHJpbmdidWZJY05TXzExY2hhcl90cmFpdHNJY0VFTlNfOWFsbG9jYXRvckljRUVFRQAAAJjmAQDovAEAmLwBADgAAAAAAAAA4L0BADkCAAA6AgAAyP///8j////gvQEAOwIAADwCAABEvQEAfL0BAJC9AQBYvQEAOAAAAAAAAADQvAEALgIAAC8CAADI////yP///9C8AQAwAgAAMQIAAE5TdDNfXzIxOWJhc2ljX29zdHJpbmdzdHJlYW1JY05TXzExY2hhcl90cmFpdHNJY0VFTlNfOWFsbG9jYXRvckljRUVFRQAAAJjmAQCYvQEA0LwBAAAAAAAQvgEAPQIAAD4CAABOU3QzX18yOGlvc19iYXNlRQAAAHDmAQD8vQEAIMABAEGkgAcL+QMBAAAAAgAAAAMAAAAEAAAABQAAAAYAAAAHAAAA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";
function M() {
  const A2 = atob(G), I2 = new Uint8Array(A2.length);
  for (let g2 = 0; g2 < A2.length; g2++)
    I2[g2] = A2.charCodeAt(g2);
  return I2.buffer;
}
function K() {
  return A({ wasm: M() }).then((A2) => new o(A2));
}

// src/utils/meshoptimizer.js
var Module2 = (() => {
  var _scriptDir = import.meta.url;
  return function(Module3) {
    Module3 = Module3 || {};
    var Module3 = typeof Module3 != "undefined" ? Module3 : {};
    var readyPromiseResolve, readyPromiseReject;
    Module3["ready"] = new Promise(function(resolve, reject) {
      readyPromiseResolve = resolve;
      readyPromiseReject = reject;
    });
    ["_malloc", "_meshopt_buildMeshletsBound", "_meshopt_buildMeshlets", "_meshopt_buildMeshletsScan", "_meshopt_simplify", "_meshopt_generateVertexRemap", "_meshopt_remapIndexBuffer", "_meshopt_remapVertexBuffer", "_fflush", "onRuntimeInitialized"].forEach((prop) => {
      if (!Object.getOwnPropertyDescriptor(Module3["ready"], prop)) {
        Object.defineProperty(Module3["ready"], prop, { get: () => abort("You are getting " + prop + " on the Promise object, instead of the instance. Use .then() to get called back with the instance, see the MODULARIZE docs in src/settings.js"), set: () => abort("You are setting " + prop + " on the Promise object, instead of the instance. Use .then() to get called back with the instance, see the MODULARIZE docs in src/settings.js") });
      }
    });
    var moduleOverrides = Object.assign({}, Module3);
    var arguments_ = [];
    var thisProgram = "./this.program";
    var quit_ = (status, toThrow) => {
      throw toThrow;
    };
    var ENVIRONMENT_IS_WEB = true;
    var ENVIRONMENT_IS_WORKER2 = false;
    var ENVIRONMENT_IS_NODE = false;
    var ENVIRONMENT_IS_SHELL = false;
    if (Module3["ENVIRONMENT"]) {
      throw new Error("Module.ENVIRONMENT has been deprecated. To force the environment, use the ENVIRONMENT compile-time option (for example, -sENVIRONMENT=web or -sENVIRONMENT=node)");
    }
    var scriptDirectory = "";
    function locateFile(path) {
      if (Module3["locateFile"]) {
        return Module3["locateFile"](path, scriptDirectory);
      }
      return scriptDirectory + path;
    }
    var read_2, readAsync2, readBinary, setWindowTitle;
    function logExceptionOnExit(e) {
      if (e instanceof ExitStatus)
        return;
      let toLog = e;
      if (e && typeof e == "object" && e.stack) {
        toLog = [e, e.stack];
      }
      err("exiting due to exception: " + toLog);
    }
    if (ENVIRONMENT_IS_SHELL) {
      if (typeof process == "object" && typeof __require === "function" || typeof window == "object" || typeof importScripts == "function")
        throw new Error("not compiled for this environment (did you build to HTML and try to run it not on the web, or set ENVIRONMENT to something - like node - and run it someplace else - like on the web?)");
      if (typeof read != "undefined") {
        read_2 = function shell_read(f) {
          return read(f);
        };
      }
      readBinary = function readBinary2(f) {
        let data;
        if (typeof readbuffer == "function") {
          return new Uint8Array(readbuffer(f));
        }
        data = read(f, "binary");
        assert2(typeof data == "object");
        return data;
      };
      readAsync2 = function readAsync3(f, onload, onerror) {
        setTimeout(() => onload(readBinary(f)), 0);
      };
      if (typeof scriptArgs != "undefined") {
        arguments_ = scriptArgs;
      } else if (typeof arguments != "undefined") {
        arguments_ = arguments;
      }
      if (typeof quit == "function") {
        quit_ = (status, toThrow) => {
          logExceptionOnExit(toThrow);
          quit(status);
        };
      }
      if (typeof print != "undefined") {
        if (typeof console == "undefined")
          console = {};
        console.log = print;
        console.warn = console.error = typeof printErr != "undefined" ? printErr : print;
      }
    } else if (ENVIRONMENT_IS_WEB || ENVIRONMENT_IS_WORKER2) {
      if (ENVIRONMENT_IS_WORKER2) {
        scriptDirectory = self.location.href;
      } else if (typeof document != "undefined" && document.currentScript) {
        scriptDirectory = document.currentScript.src;
      }
      if (_scriptDir) {
        scriptDirectory = _scriptDir;
      }
      if (scriptDirectory.indexOf("blob:") !== 0) {
        scriptDirectory = scriptDirectory.substr(0, scriptDirectory.replace(/[?#].*/, "").lastIndexOf("/") + 1);
      } else {
        scriptDirectory = "";
      }
      if (!(typeof window == "object" || typeof importScripts == "function"))
        throw new Error("not compiled for this environment (did you build to HTML and try to run it not on the web, or set ENVIRONMENT to something - like node - and run it someplace else - like on the web?)");
      {
        read_2 = (url) => {
          var xhr = new XMLHttpRequest();
          xhr.open("GET", url, false);
          xhr.send(null);
          return xhr.responseText;
        };
        if (ENVIRONMENT_IS_WORKER2) {
          readBinary = (url) => {
            var xhr = new XMLHttpRequest();
            xhr.open("GET", url, false);
            xhr.responseType = "arraybuffer";
            xhr.send(null);
            return new Uint8Array(xhr.response);
          };
        }
        readAsync2 = (url, onload, onerror) => {
          var xhr = new XMLHttpRequest();
          xhr.open("GET", url, true);
          xhr.responseType = "arraybuffer";
          xhr.onload = () => {
            if (xhr.status == 200 || xhr.status == 0 && xhr.response) {
              onload(xhr.response);
              return;
            }
            onerror();
          };
          xhr.onerror = onerror;
          xhr.send(null);
        };
      }
      setWindowTitle = (title) => document.title = title;
    } else {
      throw new Error("environment detection error");
    }
    var out = Module3["print"] || console.log.bind(console);
    var err = Module3["printErr"] || console.warn.bind(console);
    Object.assign(Module3, moduleOverrides);
    moduleOverrides = null;
    checkIncomingModuleAPI();
    if (Module3["arguments"])
      arguments_ = Module3["arguments"];
    legacyModuleProp("arguments", "arguments_");
    if (Module3["thisProgram"])
      thisProgram = Module3["thisProgram"];
    legacyModuleProp("thisProgram", "thisProgram");
    if (Module3["quit"])
      quit_ = Module3["quit"];
    legacyModuleProp("quit", "quit_");
    assert2(typeof Module3["memoryInitializerPrefixURL"] == "undefined", "Module.memoryInitializerPrefixURL option was removed, use Module.locateFile instead");
    assert2(typeof Module3["pthreadMainPrefixURL"] == "undefined", "Module.pthreadMainPrefixURL option was removed, use Module.locateFile instead");
    assert2(typeof Module3["cdInitializerPrefixURL"] == "undefined", "Module.cdInitializerPrefixURL option was removed, use Module.locateFile instead");
    assert2(typeof Module3["filePackagePrefixURL"] == "undefined", "Module.filePackagePrefixURL option was removed, use Module.locateFile instead");
    assert2(typeof Module3["read"] == "undefined", "Module.read option was removed (modify read_ in JS)");
    assert2(typeof Module3["readAsync"] == "undefined", "Module.readAsync option was removed (modify readAsync in JS)");
    assert2(typeof Module3["readBinary"] == "undefined", "Module.readBinary option was removed (modify readBinary in JS)");
    assert2(typeof Module3["setWindowTitle"] == "undefined", "Module.setWindowTitle option was removed (modify setWindowTitle in JS)");
    assert2(typeof Module3["TOTAL_MEMORY"] == "undefined", "Module.TOTAL_MEMORY has been renamed Module.INITIAL_MEMORY");
    legacyModuleProp("read", "read_");
    legacyModuleProp("readAsync", "readAsync");
    legacyModuleProp("readBinary", "readBinary");
    legacyModuleProp("setWindowTitle", "setWindowTitle");
    assert2(!ENVIRONMENT_IS_WORKER2, "worker environment detected but not enabled at build time.  Add 'worker' to `-sENVIRONMENT` to enable.");
    assert2(!ENVIRONMENT_IS_NODE, "node environment detected but not enabled at build time.  Add 'node' to `-sENVIRONMENT` to enable.");
    assert2(!ENVIRONMENT_IS_SHELL, "shell environment detected but not enabled at build time.  Add 'shell' to `-sENVIRONMENT` to enable.");
    var POINTER_SIZE = 4;
    function legacyModuleProp(prop, newName) {
      if (!Object.getOwnPropertyDescriptor(Module3, prop)) {
        Object.defineProperty(Module3, prop, { configurable: true, get: function() {
          abort("Module." + prop + " has been replaced with plain " + newName + " (the initial value can be provided on Module, but after startup the value is only looked for on a local variable of that name)");
        } });
      }
    }
    function ignoredModuleProp(prop) {
      if (Object.getOwnPropertyDescriptor(Module3, prop)) {
        abort("`Module." + prop + "` was supplied but `" + prop + "` not included in INCOMING_MODULE_JS_API");
      }
    }
    function isExportedByForceFilesystem(name) {
      return name === "FS_createPath" || name === "FS_createDataFile" || name === "FS_createPreloadedFile" || name === "FS_unlink" || name === "addRunDependency" || name === "FS_createLazyFile" || name === "FS_createDevice" || name === "removeRunDependency";
    }
    function missingLibrarySymbol(sym) {
      if (typeof globalThis !== "undefined" && !Object.getOwnPropertyDescriptor(globalThis, sym)) {
        Object.defineProperty(globalThis, sym, { configurable: true, get: function() {
          var msg = "`" + sym + "` is a library symbol and not included by default; add it to your library.js __deps or to DEFAULT_LIBRARY_FUNCS_TO_INCLUDE on the command line";
          if (isExportedByForceFilesystem(sym)) {
            msg += ". Alternatively, forcing filesystem support (-sFORCE_FILESYSTEM) can export this for you";
          }
          warnOnce(msg);
          return void 0;
        } });
      }
    }
    function unexportedRuntimeSymbol(sym) {
      if (!Object.getOwnPropertyDescriptor(Module3, sym)) {
        Object.defineProperty(Module3, sym, { configurable: true, get: function() {
          var msg = "'" + sym + "' was not exported. add it to EXPORTED_RUNTIME_METHODS (see the FAQ)";
          if (isExportedByForceFilesystem(sym)) {
            msg += ". Alternatively, forcing filesystem support (-sFORCE_FILESYSTEM) can export this for you";
          }
          abort(msg);
        } });
      }
    }
    var wasmBinary;
    if (Module3["wasmBinary"])
      wasmBinary = Module3["wasmBinary"];
    legacyModuleProp("wasmBinary", "wasmBinary");
    var noExitRuntime = Module3["noExitRuntime"] || true;
    legacyModuleProp("noExitRuntime", "noExitRuntime");
    if (typeof WebAssembly != "object") {
      abort("no native wasm support detected");
    }
    var wasmMemory;
    var ABORT = false;
    var EXITSTATUS;
    function assert2(condition, text) {
      if (!condition) {
        abort("Assertion failed" + (text ? ": " + text : ""));
      }
    }
    var UTF8Decoder = typeof TextDecoder != "undefined" ? new TextDecoder("utf8") : void 0;
    function UTF8ArrayToString(heapOrArray, idx, maxBytesToRead) {
      var endIdx = idx + maxBytesToRead;
      var endPtr = idx;
      while (heapOrArray[endPtr] && !(endPtr >= endIdx))
        ++endPtr;
      if (endPtr - idx > 16 && heapOrArray.buffer && UTF8Decoder) {
        return UTF8Decoder.decode(heapOrArray.subarray(idx, endPtr));
      }
      var str = "";
      while (idx < endPtr) {
        var u0 = heapOrArray[idx++];
        if (!(u0 & 128)) {
          str += String.fromCharCode(u0);
          continue;
        }
        var u1 = heapOrArray[idx++] & 63;
        if ((u0 & 224) == 192) {
          str += String.fromCharCode((u0 & 31) << 6 | u1);
          continue;
        }
        var u2 = heapOrArray[idx++] & 63;
        if ((u0 & 240) == 224) {
          u0 = (u0 & 15) << 12 | u1 << 6 | u2;
        } else {
          if ((u0 & 248) != 240)
            warnOnce("Invalid UTF-8 leading byte 0x" + u0.toString(16) + " encountered when deserializing a UTF-8 string in wasm memory to a JS string!");
          u0 = (u0 & 7) << 18 | u1 << 12 | u2 << 6 | heapOrArray[idx++] & 63;
        }
        if (u0 < 65536) {
          str += String.fromCharCode(u0);
        } else {
          var ch = u0 - 65536;
          str += String.fromCharCode(55296 | ch >> 10, 56320 | ch & 1023);
        }
      }
      return str;
    }
    function UTF8ToString(ptr, maxBytesToRead) {
      return ptr ? UTF8ArrayToString(HEAPU8, ptr, maxBytesToRead) : "";
    }
    function stringToUTF8Array(str, heap, outIdx, maxBytesToWrite) {
      if (!(maxBytesToWrite > 0))
        return 0;
      var startIdx = outIdx;
      var endIdx = outIdx + maxBytesToWrite - 1;
      for (var i2 = 0; i2 < str.length; ++i2) {
        var u = str.charCodeAt(i2);
        if (u >= 55296 && u <= 57343) {
          var u1 = str.charCodeAt(++i2);
          u = 65536 + ((u & 1023) << 10) | u1 & 1023;
        }
        if (u <= 127) {
          if (outIdx >= endIdx)
            break;
          heap[outIdx++] = u;
        } else if (u <= 2047) {
          if (outIdx + 1 >= endIdx)
            break;
          heap[outIdx++] = 192 | u >> 6;
          heap[outIdx++] = 128 | u & 63;
        } else if (u <= 65535) {
          if (outIdx + 2 >= endIdx)
            break;
          heap[outIdx++] = 224 | u >> 12;
          heap[outIdx++] = 128 | u >> 6 & 63;
          heap[outIdx++] = 128 | u & 63;
        } else {
          if (outIdx + 3 >= endIdx)
            break;
          if (u > 1114111)
            warnOnce("Invalid Unicode code point 0x" + u.toString(16) + " encountered when serializing a JS string to a UTF-8 string in wasm memory! (Valid unicode code points should be in range 0-0x10FFFF).");
          heap[outIdx++] = 240 | u >> 18;
          heap[outIdx++] = 128 | u >> 12 & 63;
          heap[outIdx++] = 128 | u >> 6 & 63;
          heap[outIdx++] = 128 | u & 63;
        }
      }
      heap[outIdx] = 0;
      return outIdx - startIdx;
    }
    function stringToUTF8(str, outPtr, maxBytesToWrite) {
      assert2(typeof maxBytesToWrite == "number", "stringToUTF8(str, outPtr, maxBytesToWrite) is missing the third parameter that specifies the length of the output buffer!");
      return stringToUTF8Array(str, HEAPU8, outPtr, maxBytesToWrite);
    }
    var buffer, HEAP8, HEAPU8, HEAP16, HEAPU16, HEAP32, HEAPU32, HEAPF32, HEAPF64;
    function updateGlobalBufferAndViews(buf) {
      buffer = buf;
      Module3["HEAP8"] = HEAP8 = new Int8Array(buf);
      Module3["HEAP16"] = HEAP16 = new Int16Array(buf);
      Module3["HEAP32"] = HEAP32 = new Int32Array(buf);
      Module3["HEAPU8"] = HEAPU8 = new Uint8Array(buf);
      Module3["HEAPU16"] = HEAPU16 = new Uint16Array(buf);
      Module3["HEAPU32"] = HEAPU32 = new Uint32Array(buf);
      Module3["HEAPF32"] = HEAPF32 = new Float32Array(buf);
      Module3["HEAPF64"] = HEAPF64 = new Float64Array(buf);
    }
    var TOTAL_STACK = 5242880;
    if (Module3["TOTAL_STACK"])
      assert2(TOTAL_STACK === Module3["TOTAL_STACK"], "the stack size can no longer be determined at runtime");
    var INITIAL_MEMORY = Module3["INITIAL_MEMORY"] || 16777216;
    legacyModuleProp("INITIAL_MEMORY", "INITIAL_MEMORY");
    assert2(INITIAL_MEMORY >= TOTAL_STACK, "INITIAL_MEMORY should be larger than TOTAL_STACK, was " + INITIAL_MEMORY + "! (TOTAL_STACK=" + TOTAL_STACK + ")");
    assert2(typeof Int32Array != "undefined" && typeof Float64Array !== "undefined" && Int32Array.prototype.subarray != void 0 && Int32Array.prototype.set != void 0, "JS engine does not provide full typed array support");
    assert2(!Module3["wasmMemory"], "Use of `wasmMemory` detected.  Use -sIMPORTED_MEMORY to define wasmMemory externally");
    assert2(INITIAL_MEMORY == 16777216, "Detected runtime INITIAL_MEMORY setting.  Use -sIMPORTED_MEMORY to define wasmMemory dynamically");
    var wasmTable;
    function writeStackCookie() {
      var max = _emscripten_stack_get_end();
      assert2((max & 3) == 0);
      HEAPU32[max >> 2] = 34821223;
      HEAPU32[max + 4 >> 2] = 2310721022;
      HEAPU32[0] = 1668509029;
    }
    function checkStackCookie() {
      if (ABORT)
        return;
      var max = _emscripten_stack_get_end();
      var cookie1 = HEAPU32[max >> 2];
      var cookie2 = HEAPU32[max + 4 >> 2];
      if (cookie1 != 34821223 || cookie2 != 2310721022) {
        abort("Stack overflow! Stack cookie has been overwritten at 0x" + max.toString(16) + ", expected hex dwords 0x89BACDFE and 0x2135467, but received 0x" + cookie2.toString(16) + " 0x" + cookie1.toString(16));
      }
      if (HEAPU32[0] !== 1668509029)
        abort("Runtime error: The application has corrupted its heap memory area (address zero)!");
    }
    (function() {
      var h16 = new Int16Array(1);
      var h8 = new Int8Array(h16.buffer);
      h16[0] = 25459;
      if (h8[0] !== 115 || h8[1] !== 99)
        throw "Runtime error: expected the system to be little-endian! (Run with -sSUPPORT_BIG_ENDIAN to bypass)";
    })();
    var __ATPRERUN__ = [];
    var __ATINIT__ = [];
    var __ATPOSTRUN__ = [];
    var runtimeInitialized = false;
    function preRun() {
      if (Module3["preRun"]) {
        if (typeof Module3["preRun"] == "function")
          Module3["preRun"] = [Module3["preRun"]];
        while (Module3["preRun"].length) {
          addOnPreRun(Module3["preRun"].shift());
        }
      }
      callRuntimeCallbacks(__ATPRERUN__);
    }
    function initRuntime() {
      assert2(!runtimeInitialized);
      runtimeInitialized = true;
      checkStackCookie();
      callRuntimeCallbacks(__ATINIT__);
    }
    function postRun() {
      checkStackCookie();
      if (Module3["postRun"]) {
        if (typeof Module3["postRun"] == "function")
          Module3["postRun"] = [Module3["postRun"]];
        while (Module3["postRun"].length) {
          addOnPostRun(Module3["postRun"].shift());
        }
      }
      callRuntimeCallbacks(__ATPOSTRUN__);
    }
    function addOnPreRun(cb) {
      __ATPRERUN__.unshift(cb);
    }
    function addOnInit(cb) {
      __ATINIT__.unshift(cb);
    }
    function addOnPostRun(cb) {
      __ATPOSTRUN__.unshift(cb);
    }
    assert2(Math.imul, "This browser does not support Math.imul(), build with LEGACY_VM_SUPPORT or POLYFILL_OLD_MATH_FUNCTIONS to add in a polyfill");
    assert2(Math.fround, "This browser does not support Math.fround(), build with LEGACY_VM_SUPPORT or POLYFILL_OLD_MATH_FUNCTIONS to add in a polyfill");
    assert2(Math.clz32, "This browser does not support Math.clz32(), build with LEGACY_VM_SUPPORT or POLYFILL_OLD_MATH_FUNCTIONS to add in a polyfill");
    assert2(Math.trunc, "This browser does not support Math.trunc(), build with LEGACY_VM_SUPPORT or POLYFILL_OLD_MATH_FUNCTIONS to add in a polyfill");
    var runDependencies = 0;
    var runDependencyWatcher = null;
    var dependenciesFulfilled = null;
    var runDependencyTracking = {};
    function addRunDependency2(id) {
      runDependencies++;
      if (Module3["monitorRunDependencies"]) {
        Module3["monitorRunDependencies"](runDependencies);
      }
      if (id) {
        assert2(!runDependencyTracking[id]);
        runDependencyTracking[id] = 1;
        if (runDependencyWatcher === null && typeof setInterval != "undefined") {
          runDependencyWatcher = setInterval(function() {
            if (ABORT) {
              clearInterval(runDependencyWatcher);
              runDependencyWatcher = null;
              return;
            }
            var shown = false;
            for (var dep in runDependencyTracking) {
              if (!shown) {
                shown = true;
                err("still waiting on run dependencies:");
              }
              err("dependency: " + dep);
            }
            if (shown) {
              err("(end of list)");
            }
          }, 1e4);
        }
      } else {
        err("warning: run dependency added without ID");
      }
    }
    function removeRunDependency2(id) {
      runDependencies--;
      if (Module3["monitorRunDependencies"]) {
        Module3["monitorRunDependencies"](runDependencies);
      }
      if (id) {
        assert2(runDependencyTracking[id]);
        delete runDependencyTracking[id];
      } else {
        err("warning: run dependency removed without ID");
      }
      if (runDependencies == 0) {
        if (runDependencyWatcher !== null) {
          clearInterval(runDependencyWatcher);
          runDependencyWatcher = null;
        }
        if (dependenciesFulfilled) {
          var callback = dependenciesFulfilled;
          dependenciesFulfilled = null;
          callback();
        }
      }
    }
    function abort(what) {
      {
        if (Module3["onAbort"]) {
          Module3["onAbort"](what);
        }
      }
      what = "Aborted(" + what + ")";
      err(what);
      ABORT = true;
      EXITSTATUS = 1;
      var e = new WebAssembly.RuntimeError(what);
      readyPromiseReject(e);
      throw e;
    }
    var FS = { error: function() {
      abort("Filesystem support (FS) was not included. The problem is that you are using files from JS, but files were not used from C/C++, so filesystem support was not auto-included. You can force-include filesystem support with -sFORCE_FILESYSTEM");
    }, init: function() {
      FS.error();
    }, createDataFile: function() {
      FS.error();
    }, createPreloadedFile: function() {
      FS.error();
    }, createLazyFile: function() {
      FS.error();
    }, open: function() {
      FS.error();
    }, mkdev: function() {
      FS.error();
    }, registerDevice: function() {
      FS.error();
    }, analyzePath: function() {
      FS.error();
    }, loadFilesFromDB: function() {
      FS.error();
    }, ErrnoError: function ErrnoError() {
      FS.error();
    } };
    Module3["FS_createDataFile"] = FS.createDataFile;
    Module3["FS_createPreloadedFile"] = FS.createPreloadedFile;
    var dataURIPrefix = "data:application/octet-stream;base64,";
    function isDataURI(filename) {
      return filename.startsWith(dataURIPrefix);
    }
    function isFileURI(filename) {
      return filename.startsWith("file://");
    }
    function createExportWrapper(name, fixedasm) {
      return function() {
        var displayName = name;
        var asm2 = fixedasm;
        if (!fixedasm) {
          asm2 = Module3["asm"];
        }
        assert2(runtimeInitialized, "native function `" + displayName + "` called before runtime initialization");
        if (!asm2[name]) {
          assert2(asm2[name], "exported native function `" + displayName + "` not found");
        }
        return asm2[name].apply(null, arguments);
      };
    }
    var wasmBinaryFile;
    if (Module3["locateFile"]) {
      wasmBinaryFile = "meshoptimizer.wasm";
      if (!isDataURI(wasmBinaryFile)) {
        wasmBinaryFile = locateFile(wasmBinaryFile);
      }
    } else {
      wasmBinaryFile = new URL("meshoptimizer.wasm", import.meta.url).toString();
    }
    function getBinary(file) {
      try {
        if (file == wasmBinaryFile && wasmBinary) {
          return new Uint8Array(wasmBinary);
        }
        if (readBinary) {
          return readBinary(file);
        }
        throw "both async and sync fetching of the wasm failed";
      } catch (err2) {
        abort(err2);
      }
    }
    function getBinaryPromise() {
      if (!wasmBinary && (ENVIRONMENT_IS_WEB || ENVIRONMENT_IS_WORKER2)) {
        if (typeof fetch == "function") {
          return fetch(wasmBinaryFile, { credentials: "same-origin" }).then(function(response) {
            if (!response["ok"]) {
              throw "failed to load wasm binary file at '" + wasmBinaryFile + "'";
            }
            return response["arrayBuffer"]();
          }).catch(function() {
            return getBinary(wasmBinaryFile);
          });
        }
      }
      return Promise.resolve().then(function() {
        return getBinary(wasmBinaryFile);
      });
    }
    function createWasm() {
      var info = { "env": asmLibraryArg, "wasi_snapshot_preview1": asmLibraryArg };
      function receiveInstance(instance, module) {
        var exports2 = instance.exports;
        Module3["asm"] = exports2;
        wasmMemory = Module3["asm"]["memory"];
        assert2(wasmMemory, "memory not found in wasm exports");
        updateGlobalBufferAndViews(wasmMemory.buffer);
        wasmTable = Module3["asm"]["__indirect_function_table"];
        assert2(wasmTable, "table not found in wasm exports");
        addOnInit(Module3["asm"]["__wasm_call_ctors"]);
        removeRunDependency2("wasm-instantiate");
      }
      addRunDependency2("wasm-instantiate");
      var trueModule = Module3;
      function receiveInstantiationResult(result) {
        assert2(Module3 === trueModule, "the Module object should not be replaced during async compilation - perhaps the order of HTML elements is wrong?");
        trueModule = null;
        receiveInstance(result["instance"]);
      }
      function instantiateArrayBuffer(receiver) {
        return getBinaryPromise().then(function(binary) {
          return WebAssembly.instantiate(binary, info);
        }).then(function(instance) {
          return instance;
        }).then(receiver, function(reason) {
          err("failed to asynchronously prepare wasm: " + reason);
          if (isFileURI(wasmBinaryFile)) {
            err("warning: Loading from a file URI (" + wasmBinaryFile + ") is not supported in most browsers. See https://emscripten.org/docs/getting_started/FAQ.html#how-do-i-run-a-local-webserver-for-testing-why-does-my-program-stall-in-downloading-or-preparing");
          }
          abort(reason);
        });
      }
      function instantiateAsync() {
        if (!wasmBinary && typeof WebAssembly.instantiateStreaming == "function" && !isDataURI(wasmBinaryFile) && typeof fetch == "function") {
          return fetch(wasmBinaryFile, { credentials: "same-origin" }).then(function(response) {
            var result = WebAssembly.instantiateStreaming(response, info);
            return result.then(receiveInstantiationResult, function(reason) {
              err("wasm streaming compile failed: " + reason);
              err("falling back to ArrayBuffer instantiation");
              return instantiateArrayBuffer(receiveInstantiationResult);
            });
          });
        } else {
          return instantiateArrayBuffer(receiveInstantiationResult);
        }
      }
      if (Module3["instantiateWasm"]) {
        try {
          var exports = Module3["instantiateWasm"](info, receiveInstance);
          return exports;
        } catch (e) {
          err("Module.instantiateWasm callback failed with error: " + e);
          readyPromiseReject(e);
        }
      }
      instantiateAsync().catch(readyPromiseReject);
      return {};
    }
    var tempDouble;
    var tempI64;
    function ExitStatus(status) {
      this.name = "ExitStatus";
      this.message = "Program terminated with exit(" + status + ")";
      this.status = status;
    }
    function callRuntimeCallbacks(callbacks) {
      while (callbacks.length > 0) {
        callbacks.shift()(Module3);
      }
    }
    function demangle(func) {
      warnOnce("warning: build with -sDEMANGLE_SUPPORT to link in libcxxabi demangling");
      return func;
    }
    function demangleAll(text) {
      var regex = /\b_Z[\w\d_]+/g;
      return text.replace(regex, function(x) {
        var y = demangle(x);
        return x === y ? x : y + " [" + x + "]";
      });
    }
    function jsStackTrace() {
      var error = new Error();
      if (!error.stack) {
        try {
          throw new Error();
        } catch (e) {
          error = e;
        }
        if (!error.stack) {
          return "(no stack trace available)";
        }
      }
      return error.stack.toString();
    }
    function warnOnce(text) {
      if (!warnOnce.shown)
        warnOnce.shown = {};
      if (!warnOnce.shown[text]) {
        warnOnce.shown[text] = 1;
        err(text);
      }
    }
    function writeArrayToMemory(array, buffer2) {
      assert2(array.length >= 0, "writeArrayToMemory array must have a length (should be an array or typed array)");
      HEAP8.set(array, buffer2);
    }
    function ___assert_fail(condition, filename, line, func) {
      abort("Assertion failed: " + UTF8ToString(condition) + ", at: " + [filename ? UTF8ToString(filename) : "unknown filename", line, func ? UTF8ToString(func) : "unknown function"]);
    }
    function _abort() {
      abort("native code called abort()");
    }
    function _emscripten_memcpy_big(dest, src, num) {
      HEAPU8.copyWithin(dest, src, src + num);
    }
    function getHeapMax() {
      return 2147483648;
    }
    function emscripten_realloc_buffer(size) {
      try {
        wasmMemory.grow(size - buffer.byteLength + 65535 >>> 16);
        updateGlobalBufferAndViews(wasmMemory.buffer);
        return 1;
      } catch (e) {
        err("emscripten_realloc_buffer: Attempted to grow heap from " + buffer.byteLength + " bytes to " + size + " bytes, but got error: " + e);
      }
    }
    function _emscripten_resize_heap(requestedSize) {
      var oldSize = HEAPU8.length;
      requestedSize = requestedSize >>> 0;
      assert2(requestedSize > oldSize);
      var maxHeapSize = getHeapMax();
      if (requestedSize > maxHeapSize) {
        err("Cannot enlarge memory, asked to go up to " + requestedSize + " bytes, but the limit is " + maxHeapSize + " bytes!");
        return false;
      }
      let alignUp = (x, multiple) => x + (multiple - x % multiple) % multiple;
      for (var cutDown = 1; cutDown <= 4; cutDown *= 2) {
        var overGrownHeapSize = oldSize * (1 + 0.2 / cutDown);
        overGrownHeapSize = Math.min(overGrownHeapSize, requestedSize + 100663296);
        var newSize = Math.min(maxHeapSize, alignUp(Math.max(requestedSize, overGrownHeapSize), 65536));
        var replacement = emscripten_realloc_buffer(newSize);
        if (replacement) {
          return true;
        }
      }
      err("Failed to grow the heap from " + oldSize + " bytes to " + newSize + " bytes, not enough memory!");
      return false;
    }
    function getCFunc(ident) {
      var func = Module3["_" + ident];
      assert2(func, "Cannot call unknown function " + ident + ", make sure it is exported");
      return func;
    }
    function ccall(ident, returnType, argTypes, args, opts) {
      var toC = { "string": (str) => {
        var ret2 = 0;
        if (str !== null && str !== void 0 && str !== 0) {
          var len = (str.length << 2) + 1;
          ret2 = stackAlloc(len);
          stringToUTF8(str, ret2, len);
        }
        return ret2;
      }, "array": (arr) => {
        var ret2 = stackAlloc(arr.length);
        writeArrayToMemory(arr, ret2);
        return ret2;
      } };
      function convertReturnValue(ret2) {
        if (returnType === "string") {
          return UTF8ToString(ret2);
        }
        if (returnType === "boolean")
          return Boolean(ret2);
        return ret2;
      }
      var func = getCFunc(ident);
      var cArgs = [];
      var stack = 0;
      assert2(returnType !== "array", 'Return type should not be "array".');
      if (args) {
        for (var i2 = 0; i2 < args.length; i2++) {
          var converter = toC[argTypes[i2]];
          if (converter) {
            if (stack === 0)
              stack = stackSave();
            cArgs[i2] = converter(args[i2]);
          } else {
            cArgs[i2] = args[i2];
          }
        }
      }
      var ret = func.apply(null, cArgs);
      function onDone(ret2) {
        if (stack !== 0)
          stackRestore(stack);
        return convertReturnValue(ret2);
      }
      ret = onDone(ret);
      return ret;
    }
    function cwrap(ident, returnType, argTypes, opts) {
      return function() {
        return ccall(ident, returnType, argTypes, arguments, opts);
      };
    }
    function checkIncomingModuleAPI() {
      ignoredModuleProp("fetchSettings");
    }
    var asmLibraryArg = { "__assert_fail": ___assert_fail, "abort": _abort, "emscripten_memcpy_big": _emscripten_memcpy_big, "emscripten_resize_heap": _emscripten_resize_heap };
    var asm = createWasm();
    var ___wasm_call_ctors = Module3["___wasm_call_ctors"] = createExportWrapper("__wasm_call_ctors");
    var _meshopt_buildMeshletsBound = Module3["_meshopt_buildMeshletsBound"] = createExportWrapper("meshopt_buildMeshletsBound");
    var _meshopt_buildMeshlets = Module3["_meshopt_buildMeshlets"] = createExportWrapper("meshopt_buildMeshlets");
    var _meshopt_buildMeshletsScan = Module3["_meshopt_buildMeshletsScan"] = createExportWrapper("meshopt_buildMeshletsScan");
    var _meshopt_simplify = Module3["_meshopt_simplify"] = createExportWrapper("meshopt_simplify");
    var _meshopt_generateVertexRemap = Module3["_meshopt_generateVertexRemap"] = createExportWrapper("meshopt_generateVertexRemap");
    var _meshopt_remapVertexBuffer = Module3["_meshopt_remapVertexBuffer"] = createExportWrapper("meshopt_remapVertexBuffer");
    var _meshopt_remapIndexBuffer = Module3["_meshopt_remapIndexBuffer"] = createExportWrapper("meshopt_remapIndexBuffer");
    var ___errno_location = Module3["___errno_location"] = createExportWrapper("__errno_location");
    var _fflush = Module3["_fflush"] = createExportWrapper("fflush");
    var _malloc = Module3["_malloc"] = createExportWrapper("malloc");
    var _emscripten_stack_init = Module3["_emscripten_stack_init"] = function() {
      return (_emscripten_stack_init = Module3["_emscripten_stack_init"] = Module3["asm"]["emscripten_stack_init"]).apply(null, arguments);
    };
    var _emscripten_stack_get_free = Module3["_emscripten_stack_get_free"] = function() {
      return (_emscripten_stack_get_free = Module3["_emscripten_stack_get_free"] = Module3["asm"]["emscripten_stack_get_free"]).apply(null, arguments);
    };
    var _emscripten_stack_get_base = Module3["_emscripten_stack_get_base"] = function() {
      return (_emscripten_stack_get_base = Module3["_emscripten_stack_get_base"] = Module3["asm"]["emscripten_stack_get_base"]).apply(null, arguments);
    };
    var _emscripten_stack_get_end = Module3["_emscripten_stack_get_end"] = function() {
      return (_emscripten_stack_get_end = Module3["_emscripten_stack_get_end"] = Module3["asm"]["emscripten_stack_get_end"]).apply(null, arguments);
    };
    var stackSave = Module3["stackSave"] = createExportWrapper("stackSave");
    var stackRestore = Module3["stackRestore"] = createExportWrapper("stackRestore");
    var stackAlloc = Module3["stackAlloc"] = createExportWrapper("stackAlloc");
    Module3["ccall"] = ccall;
    Module3["cwrap"] = cwrap;
    var unexportedRuntimeSymbols = ["run", "UTF8ArrayToString", "UTF8ToString", "stringToUTF8Array", "stringToUTF8", "lengthBytesUTF8", "addOnPreRun", "addOnInit", "addOnPreMain", "addOnExit", "addOnPostRun", "addRunDependency", "removeRunDependency", "FS_createFolder", "FS_createPath", "FS_createDataFile", "FS_createPreloadedFile", "FS_createLazyFile", "FS_createLink", "FS_createDevice", "FS_unlink", "getLEB", "getFunctionTables", "alignFunctionTables", "registerFunctions", "prettyPrint", "getCompilerSetting", "print", "printErr", "callMain", "abort", "keepRuntimeAlive", "wasmMemory", "stackAlloc", "stackSave", "stackRestore", "getTempRet0", "setTempRet0", "writeStackCookie", "checkStackCookie", "ptrToString", "zeroMemory", "stringToNewUTF8", "exitJS", "getHeapMax", "emscripten_realloc_buffer", "ENV", "ERRNO_CODES", "ERRNO_MESSAGES", "setErrNo", "inetPton4", "inetNtop4", "inetPton6", "inetNtop6", "readSockaddr", "writeSockaddr", "DNS", "getHostByName", "Protocols", "Sockets", "getRandomDevice", "warnOnce", "traverseStack", "UNWIND_CACHE", "convertPCtoSourceLocation", "readAsmConstArgsArray", "readAsmConstArgs", "mainThreadEM_ASM", "jstoi_q", "jstoi_s", "getExecutableName", "listenOnce", "autoResumeAudioContext", "dynCallLegacy", "getDynCaller", "dynCall", "handleException", "runtimeKeepalivePush", "runtimeKeepalivePop", "callUserCallback", "maybeExit", "safeSetTimeout", "asmjsMangle", "asyncLoad", "alignMemory", "mmapAlloc", "writeI53ToI64", "writeI53ToI64Clamped", "writeI53ToI64Signaling", "writeI53ToU64Clamped", "writeI53ToU64Signaling", "readI53FromI64", "readI53FromU64", "convertI32PairToI53", "convertI32PairToI53Checked", "convertU32PairToI53", "getCFunc", "uleb128Encode", "sigToWasmTypes", "generateFuncType", "convertJsFunctionToWasm", "freeTableIndexes", "functionsInTableMap", "getEmptyTableSlot", "updateTableMap", "addFunction", "removeFunction", "reallyNegative", "unSign", "strLen", "reSign", "formatString", "setValue", "getValue", "PATH", "PATH_FS", "intArrayFromString", "intArrayToString", "AsciiToString", "stringToAscii", "UTF16Decoder", "UTF16ToString", "stringToUTF16", "lengthBytesUTF16", "UTF32ToString", "stringToUTF32", "lengthBytesUTF32", "allocateUTF8", "allocateUTF8OnStack", "writeStringToMemory", "writeArrayToMemory", "writeAsciiToMemory", "SYSCALLS", "getSocketFromFD", "getSocketAddress", "JSEvents", "registerKeyEventCallback", "specialHTMLTargets", "maybeCStringToJsString", "findEventTarget", "findCanvasEventTarget", "getBoundingClientRect", "fillMouseEventData", "registerMouseEventCallback", "registerWheelEventCallback", "registerUiEventCallback", "registerFocusEventCallback", "fillDeviceOrientationEventData", "registerDeviceOrientationEventCallback", "fillDeviceMotionEventData", "registerDeviceMotionEventCallback", "screenOrientation", "fillOrientationChangeEventData", "registerOrientationChangeEventCallback", "fillFullscreenChangeEventData", "registerFullscreenChangeEventCallback", "JSEvents_requestFullscreen", "JSEvents_resizeCanvasForFullscreen", "registerRestoreOldStyle", "hideEverythingExceptGivenElement", "restoreHiddenElements", "setLetterbox", "currentFullscreenStrategy", "restoreOldWindowedStyle", "softFullscreenResizeWebGLRenderTarget", "doRequestFullscreen", "fillPointerlockChangeEventData", "registerPointerlockChangeEventCallback", "registerPointerlockErrorEventCallback", "requestPointerLock", "fillVisibilityChangeEventData", "registerVisibilityChangeEventCallback", "registerTouchEventCallback", "fillGamepadEventData", "registerGamepadEventCallback", "registerBeforeUnloadEventCallback", "fillBatteryEventData", "battery", "registerBatteryEventCallback", "setCanvasElementSize", "getCanvasElementSize", "demangle", "demangleAll", "jsStackTrace", "stackTrace", "ExitStatus", "getEnvStrings", "checkWasiClock", "flush_NO_FILESYSTEM", "dlopenMissingError", "createDyncallWrapper", "setImmediateWrapped", "clearImmediateWrapped", "polyfillSetImmediate", "uncaughtExceptionCount", "exceptionLast", "exceptionCaught", "ExceptionInfo", "exception_addRef", "exception_decRef", "Browser", "setMainLoop", "wget", "FS", "MEMFS", "TTY", "PIPEFS", "SOCKFS", "_setNetworkCallback", "tempFixedLengthArray", "miniTempWebGLFloatBuffers", "heapObjectForWebGLType", "heapAccessShiftForWebGLHeap", "GL", "emscriptenWebGLGet", "computeUnpackAlignedImageSize", "emscriptenWebGLGetTexPixelData", "emscriptenWebGLGetUniform", "webglGetUniformLocation", "webglPrepareUniformLocationsBeforeFirstUse", "webglGetLeftBracePos", "emscriptenWebGLGetVertexAttrib", "writeGLArray", "AL", "SDL_unicode", "SDL_ttfContext", "SDL_audio", "SDL", "SDL_gfx", "GLUT", "EGL", "GLFW_Window", "GLFW", "GLEW", "IDBStore", "runAndAbortIfError", "ALLOC_NORMAL", "ALLOC_STACK", "allocate"];
    unexportedRuntimeSymbols.forEach(unexportedRuntimeSymbol);
    var missingLibrarySymbols = ["ptrToString", "zeroMemory", "stringToNewUTF8", "exitJS", "setErrNo", "inetPton4", "inetNtop4", "inetPton6", "inetNtop6", "readSockaddr", "writeSockaddr", "getHostByName", "getRandomDevice", "traverseStack", "convertPCtoSourceLocation", "readAsmConstArgs", "mainThreadEM_ASM", "jstoi_q", "jstoi_s", "getExecutableName", "listenOnce", "autoResumeAudioContext", "dynCallLegacy", "getDynCaller", "dynCall", "runtimeKeepalivePush", "runtimeKeepalivePop", "callUserCallback", "maybeExit", "safeSetTimeout", "asmjsMangle", "asyncLoad", "alignMemory", "mmapAlloc", "writeI53ToI64", "writeI53ToI64Clamped", "writeI53ToI64Signaling", "writeI53ToU64Clamped", "writeI53ToU64Signaling", "readI53FromI64", "readI53FromU64", "convertI32PairToI53", "convertI32PairToI53Checked", "convertU32PairToI53", "uleb128Encode", "sigToWasmTypes", "generateFuncType", "convertJsFunctionToWasm", "getEmptyTableSlot", "updateTableMap", "addFunction", "removeFunction", "reallyNegative", "unSign", "strLen", "reSign", "formatString", "intArrayFromString", "intArrayToString", "AsciiToString", "stringToAscii", "UTF16ToString", "stringToUTF16", "lengthBytesUTF16", "UTF32ToString", "stringToUTF32", "lengthBytesUTF32", "allocateUTF8", "allocateUTF8OnStack", "writeStringToMemory", "writeAsciiToMemory", "getSocketFromFD", "getSocketAddress", "registerKeyEventCallback", "maybeCStringToJsString", "findEventTarget", "findCanvasEventTarget", "getBoundingClientRect", "fillMouseEventData", "registerMouseEventCallback", "registerWheelEventCallback", "registerUiEventCallback", "registerFocusEventCallback", "fillDeviceOrientationEventData", "registerDeviceOrientationEventCallback", "fillDeviceMotionEventData", "registerDeviceMotionEventCallback", "screenOrientation", "fillOrientationChangeEventData", "registerOrientationChangeEventCallback", "fillFullscreenChangeEventData", "registerFullscreenChangeEventCallback", "JSEvents_requestFullscreen", "JSEvents_resizeCanvasForFullscreen", "registerRestoreOldStyle", "hideEverythingExceptGivenElement", "restoreHiddenElements", "setLetterbox", "softFullscreenResizeWebGLRenderTarget", "doRequestFullscreen", "fillPointerlockChangeEventData", "registerPointerlockChangeEventCallback", "registerPointerlockErrorEventCallback", "requestPointerLock", "fillVisibilityChangeEventData", "registerVisibilityChangeEventCallback", "registerTouchEventCallback", "fillGamepadEventData", "registerGamepadEventCallback", "registerBeforeUnloadEventCallback", "fillBatteryEventData", "battery", "registerBatteryEventCallback", "setCanvasElementSize", "getCanvasElementSize", "getEnvStrings", "checkWasiClock", "flush_NO_FILESYSTEM", "createDyncallWrapper", "setImmediateWrapped", "clearImmediateWrapped", "polyfillSetImmediate", "ExceptionInfo", "exception_addRef", "exception_decRef", "setMainLoop", "_setNetworkCallback", "heapObjectForWebGLType", "heapAccessShiftForWebGLHeap", "emscriptenWebGLGet", "computeUnpackAlignedImageSize", "emscriptenWebGLGetTexPixelData", "emscriptenWebGLGetUniform", "webglGetUniformLocation", "webglPrepareUniformLocationsBeforeFirstUse", "webglGetLeftBracePos", "emscriptenWebGLGetVertexAttrib", "writeGLArray", "SDL_unicode", "SDL_ttfContext", "SDL_audio", "GLFW_Window", "runAndAbortIfError", "ALLOC_NORMAL", "ALLOC_STACK", "allocate"];
    missingLibrarySymbols.forEach(missingLibrarySymbol);
    var calledRun;
    dependenciesFulfilled = function runCaller() {
      if (!calledRun)
        run();
      if (!calledRun)
        dependenciesFulfilled = runCaller;
    };
    function stackCheckInit() {
      _emscripten_stack_init();
      writeStackCookie();
    }
    function run(args) {
      args = args || arguments_;
      if (runDependencies > 0) {
        return;
      }
      stackCheckInit();
      preRun();
      if (runDependencies > 0) {
        return;
      }
      function doRun() {
        if (calledRun)
          return;
        calledRun = true;
        Module3["calledRun"] = true;
        if (ABORT)
          return;
        initRuntime();
        readyPromiseResolve(Module3);
        if (Module3["onRuntimeInitialized"])
          Module3["onRuntimeInitialized"]();
        assert2(!Module3["_main"], 'compiled without a main, but one is present. if you added it from JS, use Module["onRuntimeInitialized"]');
        postRun();
      }
      if (Module3["setStatus"]) {
        Module3["setStatus"]("Running...");
        setTimeout(function() {
          setTimeout(function() {
            Module3["setStatus"]("");
          }, 1);
          doRun();
        }, 1);
      } else {
        doRun();
      }
      checkStackCookie();
    }
    if (Module3["preInit"]) {
      if (typeof Module3["preInit"] == "function")
        Module3["preInit"] = [Module3["preInit"]];
      while (Module3["preInit"].length > 0) {
        Module3["preInit"].pop()();
      }
    }
    run();
    return Module3.ready;
  };
})();
var meshoptimizer_default = Module2;

// src/utils/MeshletSimplifier_wasm.ts
var MeshletSimplifier_wasm = class {
  static async load() {
    if (!MeshletSimplifier_wasm.meshoptimizer_clusterize) {
      MeshletSimplifier_wasm.meshoptimizer_clusterize = await meshoptimizer_default();
    }
  }
  static async simplify(meshlet, target_count) {
    await MeshletSimplifier_wasm.load();
    const MeshOptmizer = MeshletSimplifier_wasm.meshoptimizer_clusterize;
    const destination = new WASMPointer(new Uint32Array(meshlet.indices_raw.length), "out");
    const simplified_index_count = WASMHelper.call(
      MeshOptmizer,
      "meshopt_simplify",
      "number",
      destination,
      new WASMPointer(new Uint32Array(meshlet.indices_raw)),
      meshlet.indices_raw.length,
      new WASMPointer(new Float32Array(meshlet.vertices_raw)),
      meshlet.vertices_raw.length,
      3 * Float32Array.BYTES_PER_ELEMENT,
      target_count,
      0.1,
      1,
      0
    );
    const destination_resized = destination.data.slice(0, simplified_index_count);
    return new Meshlet(meshlet.vertices_raw, destination_resized);
  }
};

// src/utils/MeshletCleaner.ts
var MeshletCleaner = class {
  static async load() {
    if (!MeshletCleaner.meshoptimizer) {
      MeshletCleaner.meshoptimizer = await meshoptimizer_default();
    }
  }
  static async clean(meshlet) {
    await MeshletCleaner.load();
    const MeshOptmizer = MeshletCleaner.meshoptimizer;
    const remap = new WASMPointer(new Uint32Array(meshlet.indices_raw.length * 3), "out");
    const indices = new WASMPointer(new Uint32Array(meshlet.indices_raw), "in");
    const vertices = new WASMPointer(new Float32Array(meshlet.vertices_raw), "in");
    const vertex_count = WASMHelper.call(
      MeshOptmizer,
      "meshopt_generateVertexRemap",
      "number",
      remap,
      indices,
      meshlet.indices_raw.length,
      vertices,
      meshlet.vertices_raw.length,
      3 * Float32Array.BYTES_PER_ELEMENT
    );
    const indices_remapped = new WASMPointer(new Uint32Array(meshlet.indices_raw.length), "out");
    WASMHelper.call(
      MeshOptmizer,
      "meshopt_remapIndexBuffer",
      "number",
      indices_remapped,
      indices,
      meshlet.indices_raw.length,
      remap
    );
    const vertices_remapped = new WASMPointer(new Float32Array(vertex_count * 3), "out");
    WASMHelper.call(
      MeshOptmizer,
      "meshopt_remapVertexBuffer",
      "number",
      vertices_remapped,
      vertices,
      meshlet.vertices_raw.length,
      3 * Float32Array.BYTES_PER_ELEMENT,
      remap
    );
    const m = new Meshlet(vertices_remapped.data, indices_remapped.data);
    return m;
  }
};

// src/App.ts
var App = class {
  constructor(canvas) {
    this.canvas = canvas;
    this.renderer = new WebGLRenderer({ canvas: this.canvas });
    this.scene = new Scene();
    this.camera = new PerspectiveCamera(32, this.canvas.width / this.canvas.height, 0.01, 1e4);
    this.camera.position.z = 1;
    this.controls = new OrbitControls(this.camera, this.renderer.domElement);
    this.stats = new BetterStats(this.renderer);
    document.body.appendChild(this.stats.domElement);
    this.render();
  }
  static rand(co) {
    function fract(n) {
      return n % 1;
    }
    return fract(Math.sin((co + 1) * 12.9898) * 43758.5453);
  }
  createSphere(radius, color, x, y, z) {
    let g2 = new SphereGeometry(radius);
    const m = new MeshBasicMaterial({
      wireframe: false,
      side: 0,
      color
    });
    const mesh = new Mesh(g2, m);
    mesh.position.set(x, y, z);
    this.scene.add(mesh);
  }
  createMesh(vertices, indices, params) {
    let g2 = new BufferGeometry();
    g2.setAttribute("position", new Float32BufferAttribute(vertices, 3));
    g2.setIndex(new Uint16BufferAttribute(indices, 1));
    const m = new MeshBasicMaterial({
      wireframe: false,
      color: params.color ? params.color : 16777215,
      transparent: params.opacity ? true : false,
      opacity: params.opacity ? params.opacity : 0
    });
    const mesh = new Mesh(g2, m);
    if (params.position) {
      mesh.position.set(params.position[0], params.position[1], params.position[2]);
    }
    if (params.scale) {
      mesh.scale.set(params.scale[0], params.scale[1], params.scale[2]);
    }
    this.scene.add(mesh);
  }
  showMeshlets(meshlets, position, scale, color) {
    for (let i2 = 0; i2 < meshlets.length; i2++) {
      const meshlet_color = color ? color : App.rand(i2) * 16777215;
      this.createMesh(meshlets[i2].vertices_raw, meshlets[i2].indices_raw, { color: meshlet_color, position, scale });
    }
  }
  async processObj(objURL) {
    OBJLoaderIndexed.load(objURL, async (objMesh) => {
      const objVertices = objMesh.vertices;
      const objIndices = objMesh.indices;
      this.createMesh(objVertices, objIndices, { opacity: 0.2, position: [-0.3, 0, 0] });
      const dag4 = new DAG();
      function addToDAG(fromMeshlets, toMeshlets, lod) {
        for (let fromMeshlet of fromMeshlets) {
          for (let toMeshlet of toMeshlets) {
            dag4.add(
              { id: `${toMeshlet.id}`, data: toMeshlet, tag: `LOD${lod}` },
              { id: `${fromMeshlet.id}`, data: fromMeshlet, tag: `LOD${lod - 1}` }
            );
          }
        }
      }
      function indexCounter(meshlets) {
        let count = 0;
        for (let i2 = 0; i2 < meshlets.length; i2++) {
          if (meshlets[i2] && meshlets[i2].length) {
            for (let j = 0; j < meshlets[i2].length; j++) {
              count += meshlets[i2][j].indices.length;
            }
          } else {
            count += meshlets[i2].indices_raw.length;
          }
        }
        return count;
      }
      async function step1_cluster_metis(vertices, indices, parts) {
        const faces = MeshletGrouper.buildFacesFromIndices(indices);
        const adjacencyMatrixList = MeshletGrouper.buildFaceAdjacencyMatrix(faces);
        const groupPartitions = await METISWrapper.partition(adjacencyMatrixList, parts);
        const groupedMeshlets = MeshletGrouper.rebuildMeshletsFromGroupIndices(vertices, faces, groupPartitions);
        const meshletsV32 = [];
        for (let i2 = 0; i2 < groupedMeshlets.length; i2++) {
          const meshlet = new Meshlet(groupedMeshlets[i2].vertices_raw, groupedMeshlets[i2].indices_raw);
          meshletsV32.push(meshlet);
        }
        return meshletsV32;
      }
      function adjacencyList(meshlets) {
        let vertexHashToMeshletMap = /* @__PURE__ */ new Map();
        for (let i2 = 0; i2 < meshlets.length; i2++) {
          const meshlet = meshlets[i2];
          for (let j = 0; j < meshlet.boundaryEdges.length; j++) {
            const boundaryEdge = meshlet.boundaryEdges[j];
            const edgeHash = meshlet.getEdgeHash(boundaryEdge);
            let meshletList = vertexHashToMeshletMap.get(edgeHash);
            if (!meshletList)
              meshletList = [];
            meshletList.push(i2);
            vertexHashToMeshletMap.set(edgeHash, meshletList);
          }
        }
        const adjacencyList2 = /* @__PURE__ */ new Map();
        for (let [_, indices] of vertexHashToMeshletMap) {
          if (indices.length === 1)
            continue;
          for (let index of indices) {
            if (!adjacencyList2.has(index)) {
              adjacencyList2.set(index, /* @__PURE__ */ new Set());
            }
            for (let otherIndex of indices) {
              if (otherIndex !== index) {
                adjacencyList2.get(index).add(otherIndex);
              }
            }
          }
        }
        let adjacencyListArray = [];
        for (let [key, adjacents] of adjacencyList2) {
          if (!adjacencyListArray[key])
            adjacencyListArray[key] = [];
          adjacencyListArray[key].push(...Array.from(adjacents));
        }
        return adjacencyListArray;
      }
      function rebuildMeshletsFromGroupIndicesV3(meshlets, groups) {
        let groupedMeshlets = [];
        for (let i2 = 0; i2 < groups.length; i2++) {
          if (!groupedMeshlets[i2])
            groupedMeshlets[i2] = [];
          for (let j = 0; j < groups[i2].length; j++) {
            const meshletId = groups[i2][j];
            const meshlet = meshlets[meshletId];
            groupedMeshlets[i2].push(meshlet);
          }
        }
        return groupedMeshlets;
      }
      const step = async (meshlets, y2, scale = [1, 1, 1]) => {
        this.showMeshlets(meshlets, [0, y2, 0], scale);
        const adj = adjacencyList(meshlets);
        const MinPartitionSize = 8;
        const MaxPartitionSize = 32;
        const TargetPartitionSize = (MinPartitionSize + MaxPartitionSize) / 2;
        const TargetNumPartitions = Math.ceil(adj.flat().length / TargetPartitionSize);
        let grouped = [meshlets];
        if (TargetNumPartitions > 1) {
          const groups = await METISWrapper.partition(adj, TargetNumPartitions);
          grouped = rebuildMeshletsFromGroupIndicesV3(meshlets, groups);
        }
        for (let i2 = 0; i2 < grouped.length; i2++) {
          this.showMeshlets(grouped[i2], [0.3, y2, 0], scale, App.rand(i2) * 16777215);
        }
        async function step3_merge_v3(meshlets2) {
          const mergedMeshlet = MeshletMerger.merge(meshlets2);
          const cleanedMeshlet = await MeshletCleaner.clean(mergedMeshlet);
          return cleanedMeshlet;
        }
        let merged = [];
        for (let i2 = 0; i2 < grouped.length; i2++) {
          merged.push(await step3_merge_v3(grouped[i2]));
        }
        this.showMeshlets(merged, [0.6, y2, 0], scale);
        let simplified = [];
        for (let i2 = 0; i2 < merged.length; i2++) {
          const d = Math.max(merged[i2].indices_raw.length * 0.5, 128 * 3);
          const simplifiedMeshlet = await MeshletSimplifier_wasm.simplify(merged[i2], d);
          simplified.push(simplifiedMeshlet);
        }
        this.showMeshlets(simplified, [0.9, y2, 0], scale);
        const splitMeshlets = [];
        for (let i2 = 0; i2 < simplified.length; i2++) {
          const parts = Math.ceil(simplified[i2].indices_raw.length / 3 / 128);
          if (parts <= 1) {
            splitMeshlets.push(simplified[i2]);
            continue;
          }
          const split = await step1_cluster_metis(simplified[i2].vertices_raw, simplified[i2].indices_raw, parts);
          splitMeshlets.push(...split);
        }
        this.showMeshlets(splitMeshlets, [1.2, y2, 0], scale);
        return splitMeshlets;
      };
      const meshletsV3 = await step1_cluster_metis(objVertices, objIndices, objIndices.length / 3 / 128);
      let input = meshletsV3;
      let y = 0;
      for (let i2 = 0; i2 < 10; i2++) {
        const output = await step(input, y);
        console.log(input.length, output.length);
        console.log(indexCounter(input) / 3, indexCounter(output) / 3);
        console.log("\n");
        addToDAG(input, output, i2 + 1);
        if (output.length === 1) {
          break;
        }
        input = output;
        y -= 0.3;
      }
      K().then((viz) => {
        const diagram = dag4.toDot();
        document.body.appendChild(viz.renderSVGElement(diagram));
        const canvas = document.createElement("canvas");
        canvas.width = 500;
        canvas.height = 500;
        const ctx = canvas.getContext("2d");
        ;
        console.log(dag4);
        let y2 = 200;
        for (let lod of Object.keys(dag4.tagToNode)) {
          const nodes = dag4.tagToNode[lod];
          let x = canvas.width * 0.5 - nodes.length * 7.5;
          for (let i2 = 0; i2 < nodes.length; i2++) {
            ctx.beginPath();
            ctx.arc(x + i2 * 5, y2, 5, 0, 180 / Math.PI);
            ctx.closePath();
            ctx.stroke();
            x += 10;
            console.log(x, y2);
          }
          y2 += 15;
        }
        document.body.appendChild(canvas);
        console.log(dag4);
      });
    });
  }
  render() {
    this.stats.update();
    this.renderer.render(this.scene, this.camera);
    requestAnimationFrame(() => {
      this.render();
    });
  }
};
export {
  App
};
/*!
Viz.js 3.4.0
Copyright (c) 2023 Michael Daines

This distribution contains other software in object code form:
Graphviz https://www.graphviz.org
Expat https://libexpat.github.io
*/
/**
 * @license
 * Copyright 2010-2022 Three.js Authors
 * SPDX-License-Identifier: MIT
 */
